// Code generated by derivingbind for package integrationtest. DO NOT EDIT.

package integrationtest

import (
	"errors"
	"github.com/podhmo/go-scan/examples/derivingbind/binding"
	"github.com/podhmo/go-scan/examples/derivingbind/parser"
	"net/http"
)

func (s *TestBindStringQueryOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (string) from query:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Query, "value", parser.String, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (string) from query:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Query, "value", parser.String, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrStringQueryOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*string) from query:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Query, "value", parser.String, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrStringQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*string) from query:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Query, "value", parser.String, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringHeaderOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (string) from header:"X-Value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Header, "X-Value", parser.String, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (string) from header:"X-Value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Header, "X-Value", parser.String, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrStringHeaderOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*string) from header:"X-Value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Header, "X-Value", parser.String, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrStringHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*string) from header:"X-Value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Header, "X-Value", parser.String, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringCookieOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (string) from cookie:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Cookie, "value", parser.String, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (string) from cookie:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Cookie, "value", parser.String, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrStringCookieOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*string) from cookie:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Cookie, "value", parser.String, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrStringCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*string) from cookie:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Cookie, "value", parser.String, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPathOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (string) from path:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Path, "value", parser.String, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (string) from path:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Path, "value", parser.String, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrStringPathOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*string) from path:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Path, "value", parser.String, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrStringPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*string) from path:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Path, "value", parser.String, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntQueryOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (int) from query:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Query, "value", parser.Int, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (int) from query:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Query, "value", parser.Int, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrIntQueryOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*int) from query:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Query, "value", parser.Int, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrIntQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*int) from query:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Query, "value", parser.Int, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntHeaderOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (int) from header:"X-Value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Header, "X-Value", parser.Int, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (int) from header:"X-Value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Header, "X-Value", parser.Int, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrIntHeaderOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*int) from header:"X-Value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Header, "X-Value", parser.Int, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrIntHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*int) from header:"X-Value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Header, "X-Value", parser.Int, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntCookieOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (int) from cookie:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Cookie, "value", parser.Int, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (int) from cookie:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Cookie, "value", parser.Int, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrIntCookieOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*int) from cookie:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Cookie, "value", parser.Int, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrIntCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*int) from cookie:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Cookie, "value", parser.Int, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPathOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (int) from path:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Path, "value", parser.Int, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (int) from path:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Path, "value", parser.Int, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrIntPathOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*int) from path:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Path, "value", parser.Int, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrIntPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*int) from path:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Path, "value", parser.Int, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolQueryOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (bool) from query:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Query, "value", parser.Bool, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (bool) from query:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Query, "value", parser.Bool, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrBoolQueryOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*bool) from query:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Query, "value", parser.Bool, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrBoolQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*bool) from query:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Query, "value", parser.Bool, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolHeaderOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (bool) from header:"X-Value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Header, "X-Value", parser.Bool, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (bool) from header:"X-Value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Header, "X-Value", parser.Bool, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrBoolHeaderOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*bool) from header:"X-Value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Header, "X-Value", parser.Bool, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrBoolHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*bool) from header:"X-Value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Header, "X-Value", parser.Bool, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolCookieOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (bool) from cookie:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Cookie, "value", parser.Bool, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (bool) from cookie:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Cookie, "value", parser.Bool, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrBoolCookieOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*bool) from cookie:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Cookie, "value", parser.Bool, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrBoolCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*bool) from cookie:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Cookie, "value", parser.Bool, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPathOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (bool) from path:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Path, "value", parser.Bool, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (bool) from path:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Path, "value", parser.Bool, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrBoolPathOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*bool) from path:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Path, "value", parser.Bool, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrBoolPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*bool) from path:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Path, "value", parser.Bool, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindInt64QueryOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (int64) from query:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Query, "value", parser.Int64, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrInt64PathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*int64) from path:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Path, "value", parser.Int64, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32HeaderOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (uint32) from header:"X-Value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Header, "X-Value", parser.Uint32, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrUint32CookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*uint32) from cookie:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Cookie, "value", parser.Uint32, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64QueryOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (float64) from query:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Query, "value", parser.Float64, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrFloat64HeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*float64) from header:"X-Value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Header, "X-Value", parser.Float64, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128CookieOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (complex128) from cookie:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Cookie, "value", parser.Complex128, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrComplex128PathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*complex128) from path:"value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Path, "value", parser.Complex128, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrQueryOptional) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (uintptr) from query:"value"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Value, binding.Query, "value", parser.Uintptr, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindPtrUintptrHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Value (*uintptr) from header:"X-Value"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Value, binding.Header, "X-Value", parser.Uintptr, binding.Required); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindMixedFields) Bind(req *http.Request, pathVar func(string) string) error {
	b := binding.New(req, pathVar)
	var errs []error

	// Binding for field Name (string) from query:"name"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Name, binding.Query, "name", parser.String, binding.Required); err != nil {
		errs = append(errs, err)
	}

	// Binding for field Age (*int) from query:"age"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.Age, binding.Query, "age", parser.Int, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	// Binding for field SessionID (string) from cookie:"session_id"

	// Value, e.g., int, string
	if err := binding.One(b, &s.SessionID, binding.Cookie, "session_id", parser.String, binding.Required); err != nil {
		errs = append(errs, err)
	}

	// Binding for field AuthToken (*string) from header:"X-Auth-Token"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.AuthToken, binding.Header, "X-Auth-Token", parser.String, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	// Binding for field UserID (string) from path:"userID"

	// Value, e.g., int, string
	if err := binding.One(b, &s.UserID, binding.Path, "userID", parser.String, binding.Required); err != nil {
		errs = append(errs, err)
	}

	// Binding for field IsEnabled (*bool) from query:"enabled"

	// Pointer to a value, e.g., *int, *string (but not a slice)
	if err := binding.OnePtr(b, &s.IsEnabled, binding.Query, "enabled", parser.Bool, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	// Binding for field Factor (float64) from header:"X-Factor"

	// Value, e.g., int, string
	if err := binding.One(b, &s.Factor, binding.Header, "X-Factor", parser.Float64, binding.Optional); err != nil {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}
