// Code generated by derivingjson for package models. DO NOT EDIT.

package models

import (
	"encoding/json"
	"fmt"
)

func (s *APIResponse) UnmarshalJSON(data []byte) error {
	// Define an alias type to prevent infinite recursion with UnmarshalJSON.
	type Alias APIResponse
	aux := &struct {
		// The Data field will be parsed manually later, so initially capture it as json.RawMessage.
		Data json.RawMessage `json:"data"`
		// All other fields will be handled by the standard unmarshaler via the Alias.
		*Alias
	}{
		Alias: (*Alias)(s),
	}

	if err := json.Unmarshal(data, &aux); err != nil {
		return fmt.Errorf("failed to unmarshal into aux struct for APIResponse: %w", err)
	}

	// If the Data field is null or empty, do nothing further with it.
	if aux.Data == nil || string(aux.Data) == "null" {
		s.Data = nil // Explicitly set to nil, or follow specific logic if a non-nil zero value is required.
		return nil
	}

	// Read only the "type" field from the Data content to determine the concrete type.
	// NOTE: This assumes the discriminator field is named "type".
	// If the generator can determine the actual discriminator field name, it should be used here.
	var discriminatorDoc struct {
		Type string `json:"type"` // TODO: Make this discriminator field name configurable if not always "type".
	}
	if err := json.Unmarshal(aux.Data, &discriminatorDoc); err != nil {
		// Including aux content in the error can be helpful for debugging, but may make logs verbose for large JSON.
		return fmt.Errorf("could not detect type from field 'data' (content: %s): %w", string(aux.Data), err)
	}

	// Decode into the appropriate struct based on the value of the 'type' field.
	switch discriminatorDoc.Type {

	case "userprofile":
		var content UserProfile
		if err := json.Unmarshal(aux.Data, &content); err != nil {
			return fmt.Errorf("failed to unmarshal 'data' as UserProfile for type 'userprofile' (content: %s): %w", string(aux.Data), err)
		}
		s.Data = &content // Assuming the field is a pointer to the concrete type. Adjust if it's an interface holding value types.

	case "productinfo":
		var content ProductInfo
		if err := json.Unmarshal(aux.Data, &content); err != nil {
			return fmt.Errorf("failed to unmarshal 'data' as ProductInfo for type 'productinfo' (content: %s): %w", string(aux.Data), err)
		}
		s.Data = &content // Assuming the field is a pointer to the concrete type. Adjust if it's an interface holding value types.

	default:
		// The error message for an empty discriminatorDoc.Type could be more specific.
		// (e.g., "discriminator field 'type' is missing or not a string in 'data'")
		if discriminatorDoc.Type == "" {
			return fmt.Errorf("discriminator field 'type' missing or empty in 'data' (content: %s)", string(aux.Data))
		}
		return fmt.Errorf("unknown data type '%s' for field 'data' (content: %s)", discriminatorDoc.Type, string(aux.Data))
	}

	return nil
}
