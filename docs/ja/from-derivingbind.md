# `derivngbind` の実装から学ぶ `go-scan` の活用と改善点

`examples/derivngbind` は、`go-scan` を利用して、HTTPリクエストの様々な要素（パスパラメータ、クエリパラメータ、ヘッダー、クッキー、リクエストボディ(JSON)）からGoの構造体のフィールドに値をバインドする `Bind(req *http.Request) error` メソッドを自動生成するツールです。

このツールの実装は、`go-scan` がコードジェネレータ開発、特にHTTPリクエスト処理に関連する定型コードの自動生成において、どのように役立つかを示す良い例となります。同時に、`derivingjson` の経験も踏まえつつ、`go-scan` がさらに進化するためのポイントも見えてきます。

## `derivngbind` における `go-scan` の活用ポイント

1.  **アノテーションによる対象構造体の特定**:
    *   `derivngbind` は、構造体のDocコメントに含まれる `@derivng:binding` というアノテーションを検知することで、`Bind` メソッドを生成すべき対象の構造体を特定します。これは `go-scan` の `TypeInfo.Doc` を調べることで実現されます。

2.  **フィールドタグ (`in струк`) の解析**:
    *   各フィールドに付与された `in` タグ（例: `in:"query:user_id"`, `in:"header:X-API-Key"`, `in:"body"`）を解析し、どのリクエスト要素から、どの名前で値を取得し、どのフィールドにバインドするかを決定します。`go-scan` の `FieldInfo.Tag` を `reflect.StructTag` を使ってパースすることで情報を抽出しています。

3.  **フィールドの型情報の取得**:
    *   `FieldInfo.Type.Name` （例: `string`, `int`, `bool`）を利用して、取得した値を適切な型に変換するコード（例: `strconv.Atoi`, `strconv.ParseBool`）を生成します。

4.  **インポート管理**:
    *   生成コードが必要とするパッケージ（`net/http`, `strconv`, `fmt`, `encoding/json`, `io` など）を、処理中に検出し、最終的な出力ファイルに `import` 文を生成します。

## `derivngbind` の開発経験から `derivingjson` の学びを再確認・強調

`derivngbind` の実装は、`derivingjson` ([`docs/ja/from-derivngjson.md`](from-derivngjson.md) 参照) で得られた `go-scan` への改善提案の多くが、ここでも同様に有効であることを示しています。特に以下の点は、`derivngbind` のようなツールにとっても非常に有益です。

*   **アノテーション/コメントベースの型フィルタリング (提案1)**:
    `@derivng:binding` を持つ構造体を `go-scan` レベルでフィルタリングできれば、ジェネレータ側のコードはよりシンプルになります。

*   **フィールドタグの高度な解析とクエリ (提案2)**:
    `in:"query" query:"user_id"` のようなタグから `"query"` (種別) と `"user_id"` (名前) を簡単に抽出するために、`scanner.FieldInfo` に `TagValue(tagName string) string` メソッドが追加されました。これを利用して、ジェネレータ側で `bindFrom := field.TagValue("in")` および `bindName := field.TagValue(bindFrom)` のようにして必要な情報を取得できます。これにより、以前の自前のタグ解析ロジックが大幅に簡略化されます。
    構造体Docコメントの `in:"body"` のようなアノテーションは、`TypeInfo.Annotation(name string) (value string, ok bool)` メソッドで取得した値を解析することで対応可能です。

*   **型名の正規化/変換支援 (提案4)**:
    今回は直接的なニーズは少なかったものの、例えばOpenAPIスキーマ名との連携などを考えると、Goのフィールド名を `camelCase` や `snake_case` のパラメータ名に変換するユーティリティは役立ちます。

*   **フィールド型解決の強化と詳細情報 (提案5)**:
    *   **型が属するパッケージの完全なインポートパスの直接取得**: `derivngbind` では主に基本型を扱いましたが、リクエストボディの型が外部パッケージで定義されている場合などに、この機能は不可欠です。
    *   **ポインタ型、スライス、マップ等の複合型の判別と要素型へのアクセス**: `derivngbind` は現在、`string`, `int`, `bool` に加えて、`int8` から `int64`, `uint` から `uint64`, `uintptr`, `float32`, `float64`, `complex64`, `complex128` およびこれらのポインタ型、さらにこれらのスライス型（例: `[]string`, `[]*int`, `[]complex128`）をサポートしています。これらの型情報を `go-scan` から容易に取得できることで、ジェネレータの実装が大幅に簡略化されています。特に `FieldType.IsPointer`, `FieldType.IsSlice`, `FieldType.Elem` (要素型) といった情報が役立ちます。
    *   `FieldType.String()` や `QualifiedName()`: 型名を正確にコード生成に反映させるために重要です。

*   **生成コードのインポート管理の支援 (提案6)**:
    `derivngbind` でも必要なインポートを手動で管理しています。`go-scan` が使用された型に基づいて必要なインポートセットを提供してくれれば、ジェネレータの負担は大きく減ります。

## `derivngbind` 特有の課題と `go-scan` への期待

`derivngbind` はHTTPリクエストを扱うため、特有の課題も存在します。

1.  **Path パラメータの扱い**:
    *   Path パラメータの抽出は、使用するルーティングライブラリ（例: `chi`, `gorilla/mux`, `gin`）に依存します。ジェネレータが特定のライブラリに強く結合するのを避けるには工夫が必要です。
    *   **`go-scan` への期待**: 直接的な解決策を `go-scan` に求めるのは難しいかもしれませんが、例えば「特定のインターフェースを実装した型をコンテキストから取得するコード片」のような、より高度なコードスニペット生成の支援や、ASTノードレベルでの操作を容易にするユーティリティがあれば、ジェネレータ側でアダプタコードを生成する際の助けになるかもしれません。現状の `derivngbind` では、Pathパラメータのバインディング部分はTODOとしてコメントアウトしています。

2.  **リクエストボディの多様な扱い**:
    *   リクエストボディ全体を構造体にマッピングする場合 (`@derivng:binding in:"body"` のように構造体自体に指定) と、構造体の一フィールドにリクエストボディをマッピングする場合 (`Payload MyStruct \`in:"body"\``) があります。
    *   **`go-scan` への期待**: 構造体レベルのアノテーション（Docコメント内）とフィールドレベルのタグの情報を統合的に扱いやすくするAPIがあると良いでしょう。例えば、`TypeInfo` が自身のDocコメントから解析されたアノテーション情報（`TagValue("in")`のような形で）を保持し、フィールド処理時にそれを参照できると、ジェネレータはよりスマートな判断ができます。

## `derivingjson` と `derivngbind` の比較から見るツールの価値

*   **`derivingjson`**: JSONのシリアライズ/デシリアライズ、特に `oneOf` のようなポリモーフィックな型構造の扱いに特化しています。データ構造の内部的な整合性や変換ロジックの自動生成が主眼です。
*   **`derivngbind`**: HTTPリクエストという外部入力からデータ構造へのマッピングに特化しています。バリデーションや型変換、多様な入力ソース（Path, Query, Header, Cookie, Body）の取り扱いが焦点です。

どちらのツールも、手作業で行うと冗長で間違いやすい定型コードの生成を自動化し、開発者がより本質的なビジネスロジックに集中できるようにするという共通の価値を提供します。

`go-scan` は、これらのような多様なコード生成タスクの「型情報の静的解析」という共通基盤を提供することで、それぞれのジェネレータが自身のドメイン特有のロジック構築に注力できるように支援します。今回 `derivngbind` を実装してみて、`go-scan` が提供する型情報がなければ、これらのタグベースのコード生成は遥かに困難であったことを改めて実感しました。

`go-scan` が本稿や `from-derivngjson.md` で提案されたような改善を取り入れていくことで、Goにおけるコード生成文化がさらに発展するための強力な基盤となることを期待します。

## `errors.Join` 導入とテンプレート実装の課題

最近の更新で、`derivingbind` のエラー処理は、Go 1.20で導入された `errors.Join` を使用するように変更されました。これにより、複数のバインディングエラーを効率的に集約し、標準的なエラーインターフェースを通じて扱えるようになりました。

この変更は主に `bind_method.tmpl` テンプレートに影響を与えました。当初は `var errs []error` スライスと `append` を使用していましたが、これを `errors.Join` の直接呼び出しに置き換える過程で、Goテンプレートのいくつかの課題が浮き彫りになりました。

1.  **カンマ区切り引数の生成**:
    `errors.Join` は可変長引数を取ります。テンプレート内で、各バインディング処理（それぞれがエラーを返す可能性がある）を `errors.Join` の引数として正しく並べる必要がありました。特に、引数間のカンマ `,` の配置が問題となりました。
    *   最初の引数の前にはカンマは不要。
    *   中間引数の後（または次の引数の前）にはカンマが必要。
    *   最後の引数の後にはカンマは不要（ただし、Goの慣習としてスライスリテラル等では許容され `gofmt` が整形する）。

2.  **空白と改行の制御**:
    Goテンプレートでは、デリミタ `{{ }}` 内のロジックと、それが出力するテキスト、そしてテンプレート自体の改行や空白が複雑に絡み合います。意図しない改行が原因で、生成されたGoコードが構文エラー（例: `missing ',' before newline in argument list`）になることが頻繁にありました。
    `{{- ... -}}` のような空白制御文字を駆使することで、ある程度の制御は可能ですが、テンプレートの可読性を著しく損なう可能性があり、また完璧な制御は非常に困難です。

3.  **最終的なアプローチ**:
    数々の試行錯誤（フラグを使ったカンマ制御、空白制御文字の調整など）の結果、最もシンプルで堅牢なアプローチとして、**各バインディング処理（エラーを返す可能性のある関数呼び出しや式）の直後に常にカンマ `,` を出力する**という方法を採用しました。
    ```go
    errors.Join(
        binding.One(...),       // カンマ
        binding.Another(...),   // カンマ
        processBody(...),     // カンマ (もしこれが最後でも)
    )
    ```
    Goの可変長引数を取る関数呼び出しでは、最後の引数の後にカンマがあっても、多くの場合 `gofmt` が適切に処理（通常は除去）してくれます。これにより、テンプレート側での複雑な「最後の引数かどうかの判定ロジック」が不要になり、テンプレートの可読性と保守性が大幅に向上しました。このアプローチは、Goのスライスやマップリテラルの末尾カンマの扱いに似ています。

この経験は、Goテンプレートを使用したコード生成において、完璧なフォーマットをテンプレートのみで追求することの難しさを示しています。時には、`gofmt` のような標準ツールとの連携を前提とした、よりシンプルなテンプレート設計が有効であるという教訓を与えてくれます。

## `derivingbind` のさらなる改善点

`derivingbind` の現在の実装は堅実ですが、さらなる改善の余地もいくつか見られます。

1.  **ジェネレータ (`main.go`) の可読性向上**:
    *   型情報やタグの解析ロジック（特に `Generate` 関数内の `FieldBindingInfo` 構築部分）が長大化しています。これを例えば `buildFieldBindingInfo(field scanner.Field) (FieldBindingInfo, error)` のような責務に応じたヘルパー関数に分割することで、見通しと保守性が向上するでしょう。

2.  **エラーメッセージの具体性**:
    *   `binding/binding.go` や `parser/parsers.go` でエラーが発生した際、エンドユーザー（このライブラリを使う開発者）がデバッグしやすいように、エラーメッセージに「どのフィールドで」「どの値のパースに失敗したか」といった具体的なコンテキスト情報を含めると、より親切になります。

3.  **パーサーの挙動の一貫性**:
    *   `parser/parsers.go` の `Complex64` および `Complex128` パーサーは、空文字列を受け取った場合にエラーではなく `complex(0,0)` を返します。他の数値型パーサー（例: `Int`）が空文字列でエラーを返す挙動と一貫性がありません。これが意図的な仕様であればドキュメントに明記し、そうでなければ挙動を統一することを検討できます。

4.  **テストカバレッジの拡充**:
    *   現状でも多くのテストケースがありますが、特にスライス型のバインディングに関して、ヘッダーやクッキーでのカンマ区切り値のパースにおけるエッジケース（例: 空要素 `val1,,val3`、値の前後の空白 ` val1 , val2 ` など）のテストを増やすことで、より堅牢性を高めることができます。

5.  **ドキュメントの拡充 (`README.md`)**:
    *   **エラー時の挙動**: バインディングエラーが発生した場合に、エラーオブジェクトからどのような情報が取得できるのか（例: `errors.Unwrap` で個々のエラーにアクセス可能かなど）を明記すると有用です。
    *   **型の拡張性**: ユーザー定義の型をバインディング対象にする方法（カスタムパーサーの登録方法、`json.Unmarshaler` 等の標準インターフェースへの対応状況など）についての説明を追加すると、ライブラリの適用範囲が広がります。
    *   **Goバージョンの依存性**: パスパラメータに関するGo 1.22依存について、古いバージョンでは具体的にどのような動作になるのか（該当フィールドは無視されるのか、エラーになるのか等）を明確にすると良いでしょう。
