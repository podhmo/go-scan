# Troubleshooting: `symgo`'s Stateless Design vs. Stateful Algorithms

This document details the investigation of an issue where the `find-orphans` tool, powered by the `symgo` engine, fails to analyze the `examples/convert` project.

The root cause is not a bug in the traditional sense, but a fundamental **design mismatch**: `symgo`, as a stateless symbolic tracer, is not designed to analyze algorithms that rely on stateful memoization for termination.

## 1. The Core Issue: A Tale of Two Designs

To understand the problem, it's best to think of `symgo` as a special kind of building inspector and the code it analyzes (`parser.go`) as a special kind of building.

**1. `symgo`'s Method (Stateless Symbolic Execution):**
The `symgo` inspector's job is to create a report of every possible path in a building. It doesn't walk the hallways; it uses the building's blueprint (`source code`) to "teleport" from room to room, listing all connections. It intentionally ignores the state of doors (e.g., whether they are locked or unlocked) because its goal is to map out all *potential* paths, not to simulate one person's journey. This is a core design principle of `symgo`, allowing it to analyze complex code without getting stuck.

**2. The `parser.go` Building (A Stateful Algorithm):**
The `parser.go` code is like a building with a time-lock security system. To prevent getting lost in circles in parts of the building that loop back on themselves (i.e., circular package dependencies), the building is designed so that once a room is entered, a master logbook (`info.ProcessedPackages` map) is updated. The system is designed to never allow anyone to re-enter a room that's already in the logbook. This stateful logbook is essential for the building's own logic to terminate correctly.

**3. The Mismatch:**
The problem occurs because the inspector's stateless "teleportation" method is incompatible with the building's state-dependent security system.

- The `symgo` inspector teleports into a room (e.g., `processPackage("A")`).
- It sees the instruction to "update the logbook" (`info.ProcessedPackages["A"] = true`), but because its job is only to read the blueprint, it just notes the instruction exists and **does not actually update the logbook**. The state of the logbook is never changed.
- Later, the inspection plan requires teleporting to `processPackage("A")` again.
- Because `symgo`'s view of the logbook is that it's permanently empty, it happily re-enters the room. This creates an infinite loop *in the inspection process itself*.
- `symgo`'s own safety system (its recursion detector) notices the inspector is stuck in a loop visiting the same room with the same instructions and correctly halts the entire inspection.

## 2. Conclusion: A Design Limitation, Not a Bug

The `symgo` recursion detector is not "too aggressive"; it is working correctly by stopping a real infinite loop generated by its own analysis method. The `parser.go` code is also not "buggy"; its stateful algorithm is sound.

The issue is that `symgo`'s stateless design makes it fundamentally unsuited to analyzing algorithms whose termination relies on state changes that `symgo` does not model.

## 3. Next Steps: A Strategic Decision

This is not a simple bug fix. It requires a decision about `symgo`'s future design:

-   **Option A: Make `symgo` More Stateful.** Enhance the evaluator to correctly model state changes for common patterns like map assignments. This would make `symgo` more powerful but also more complex, and represents a departure from its core stateless philosophy.
-   **Option B: Keep `symgo` Stateless.** Accept this as a known limitation. The tool works as designed, and the documentation should state that it cannot be used on code with state-dependent termination logic.

The `TODO.md` will be updated to reflect this required design decision.
