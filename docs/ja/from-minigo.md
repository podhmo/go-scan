# `examples/minigo` から見る `go-scan` への期待

`examples/minigo` は、`github.com/podhmo/go-scan` ライブラリの能力を実証しテストするために設計された、小規模なGoインタープリタです。この `minigo` の実装や将来的な拡張を考察する中で、`go-scan` パッケージに期待される機能や、現状の `go-scan` がどのように役立ちうるか、またどのような点が補強されるとより便利になるかが見えてきます。

## `go-scan` に期待される便利な機能（`minigo` のコンテキストより）

`minigo` のようなツールを開発する際、`go-scan` が以下のような機能を提供することで、開発が大幅に効率化されると考えられます。

1.  **ASTノードとソースコード位置情報の詳細なマッピングとリッチなAPI提供**:
    *   **現状**: `minigo` の `interpreter.go` 内 `formatErrorWithContext` 関数では、エラー発生箇所のファイル名、行番号、列番号、該当行のソースコードを取得し、ユーザーフレンドリーなエラーメッセージを生成しようとしています。これは `go/token.FileSet` を直接操作することで実現されています。
    *   **期待**: `go-scan` がASTノード（または `token.Pos`）と、それに対応するファイル名、行番号、列番号、さらには該当行や周辺のソーススニペットを簡単に取得できる高レベルAPIを提供することで、エラーレポート処理の実装が簡潔かつ堅牢になります。例えば、`scanner.NodeInfo(node ast.Node)` のような形で詳細情報オブジェクトを取得できると便利です。

2.  **型情報の高度な解決と検証支援**:
    *   **現状**: `minigo` は独自の動的型システム (`object.go` の `Object` インターフェースと各種具象型) を持ちますが、これはGo言語の型システムとは独立しています。
    *   **期待**: `minigo` が将来的にGoの型システム（特にユーザー定義型やインターフェース、パッケージ外部の型など）をより深く理解し、静的解析に近いチェックを行おうとする場合、`go-scan` の型情報抽出・解決能力が重要になります。`README.md` で言及されている `scanner.FieldType.Resolve()` や `PackageResolver` のような、パッケージを跨いだ型定義の遅延読み込みと解決メカニズムは、`minigo` が外部のGoコードや他の `minigo` モジュールで定義された「型」や「関数シグネチャ」を理解する際に非常に強力な基盤となり得ます。

3.  **シンボルテーブル構築とスコープ解析の支援**:
    *   **現状**: `minigo` の `environment.go` では、変数や（将来的には）関数のスコープを管理するための `Environment` 構造体を定義し、手動でシンボルの登録と検索を行っています。
    *   **期待**: `go-scan` がソースコードから識別子（変数名、関数名、型名など）の定義箇所 (declaration) と参照箇所 (usage) を効率的に抽出し、それらの間のスコープ関係（例: この識別子はこのブロックで定義されている、この識別子は見つからない、など）を分析する機能を提供すれば、インタープリタの変数解決ロジック、未定義変数エラーの検出、シャドーイングの警告などが容易に実装できます。

4.  **組み込み関数・外部パッケージ関数のシグネチャ分析**:
    *   **現状**: `builtin_fmt.go` や `builtin_strings.go` では、Goの標準パッケージ `fmt` や `strings` の一部関数を模倣し、`minigo` のオブジェクトシステムに手動でマッピングしています。引数の数や型のチェックも手動です。
    *   **期待**: `go-scan` を利用して、実際のGoの `fmt` や `strings` パッケージ（あるいは他の任意のGoパッケージ）の関数シグネチャ（引数の数、型、名前、可変長引数か否か、戻り値の型など）を正確に解析できると、`minigo` 側の組み込み関数の定義、呼び出し時の引数チェック、型変換ロジックなどを半自動的に生成したり、検証したりするツールを構築できます。これにより、組み込み関数の実装漏れやシグネチャの不一致といったバグを減らせます。

5.  **ASTの探索、解析、変換ユーティリティ**:
    *   **現状**: `minigo` のインタープリタは、`ast.Node` の型スイッチを多用してASTを再帰的にトラバースし、各ノードを評価しています。
    *   **期待**: `go-scan` が、ASTに対するより高度なクエリ言語や探索ユーティリティ（例: XPath for AST、CSSセレクタライクなクエリ、特定の条件を満たすノードをvisitorパターンよりも簡潔に抽出する機能）、あるいはAST変換を支援する機能（例: 特定パターンのノードを別のノードに安全に置換するヘルパー）を提供すると、インタープリタや静的解析ツールのロジック記述が大幅に簡略化され、可読性も向上します。

## `minigo` の現状から見る `go-scan` の潜在的な使用感

`minigo` は現在、`go/parser` を直接利用してASTを構築しており、`go-scan` の機能は間接的な示唆に留まっています。しかし、`minigo` の `README.md` で強調されている `go-scan` のコア機能（ASTベース解析、型情報抽出、ドキュメンテーション解析、クロスパッケージ型解決、パッケージロケータ）は、`minigo` が以下のようなより高度な機能を志向する際に、その価値を発揮するでしょう。

*   **より洗練されたエラー報告**: 現在の `formatErrorWithContext` は良い出発点ですが、`go-scan` の詳細な位置情報や型情報を活用することで、エラーメッセージをさらに具体的かつ有用なものにできます（例: 「型 'int' と 'string' の間で演算子 '+' は定義されていません (file.go:10:5)」）。
*   **限定的な静的解析機能**: 変数の未定義チェック、型チェック（可能な範囲で）、到達不能コードの検出など。
*   **モジュールシステム**: 複数の `minigo` ファイルや外部ライブラリ（に見立てたGoコード）を組み合わせて解釈実行する際の依存関係解決やシンボル管理。

## `minigo` の開発を通じて `go-scan` に求められるかもしれない機能（不足部分・強化点）

`minigo` のようなプロジェクトをさらに発展させることを考えると、`go-scan` には以下のような機能や改善があると、より強力なサポートツールとなり得ます。

1.  **トークンレベルでの精密なエラー位置特定と関連情報**:
    *   行単位だけでなく、式の中のどのトークン（またはトークン範囲）が問題の原因であるかを特定できると、エラーメッセージの質が向上します。例えば、`a + b * c` という式で型エラーがある場合、`+` なのか `*` なのか、あるいは特定の変数なのかを指し示せると理想的です。

2.  **スコープ解決とシンボル解決の高度なユーティリティ**:
    *   識別子がどのスコープで定義され、どこから可視であるか、シャドーイングが発生しているかなどの情報を、AST（またはファイルセット）から直接解決してくれるユーティリティ。これにより、`minigo` の `Environment` のような機構のロジックを一部肩代わりできます。

3.  **制御フローグラフ (CFG) / データフロー分析 (DFA) の基礎情報提供**:
    *   より高度な静的解析（未使用変数、到達不能コードなど）や最適化を行うためには、基本的なCFGやDFAの情報が必要になります。`go-scan` がこれらを構築するための部品や情報を提供できると、応用範囲が広がります。

4.  **インクリメンタルスキャン / パーシャルスキャンへの対応**:
    *   特にREPL環境や大規模プロジェクトでの利用を考えると、変更があったファイルや部分だけを効率的に再スキャンし、既存のスキャン結果とマージする機能は非常に価値があります。これにより、フィードバックループを高速化できます。

5.  **GoDocコメントの構造化された解析**:
    *   型定義、関数定義、フィールド定義などに付随するGoDocコメントを、単なる文字列としてだけでなく、構造化された情報（例: `@param`, `@return` タグの解析、説明文本体の抽出）としてアクセスできるAPIがあると、ドキュメント生成ツールや、コメントベースのメタプログラミング支援に役立ちます。

6.  **`go:generate` やビルドタグのようなディレクティブの認識**:
    *   Goのソースコードに含まれる特別なコメントディレクティブ（`//go:generate ...` や `// +build ...`）を認識し、それらの情報をスキャン結果に含めることで、コード生成プロセスや条件付きコンパイルのシミュレーションに利用できる可能性があります。

`minigo` は `go-scan` の可能性を示す一例に過ぎませんが、このような具体的なアプリケーションの視点から `go-scan` の機能セットを拡充していくことで、より多くの開発者にとって価値のあるライブラリへと成長していくことが期待されます。

## `minigo` における `go-scan` 導入の具体的な検討（移行計画案）

このセクションでは、`examples/minigo` プロジェクトが `go-scan` パッケージを利用してソースコード解析処理を改善するための具体的な移行計画案を記述します。これは、上記の `minigo` の視点から `go-scan` に期待される機能と関連しつつ、より実践的な導入ステップと課題を整理するものです。

### はじめに (移行の目的)

`minigo` が `go-scan` を導入する主な目的は以下の通りです。

*   **コード解析処理の共通化:** `go-scan` という共通基盤の利用。
*   **メンテナンス性の向上:** `go-scan` の進化による恩恵。
*   **潜在的な機能拡張:** `go-scan` の型情報や依存関係解決機能の活用。

### 現状の `minigo` のパース処理

`minigo` は現在、`go/parser.ParseFile()` を使用してソースファイルをパースし `*ast.File` を取得、その `Decls` を走査して関数宣言やグローバル変数宣言を処理しています。インタプリタのコアロジックである `eval` 関数群は `ast.Node` の各種具象型を直接処理します。エラー報告には `*token.FileSet` と `token.Pos` を利用しています。

### `go-scan` の概要

`go-scan` はGoソースコードから型情報、関数シグネチャ、パッケージ構造などを抽出するユーティリティです。`scanner.Scanner` を中心に、`scanner.PackageInfo`（パッケージ全体情報）、`scanner.FunctionInfo`（関数シグネチャ）、`scanner.TypeInfo`（型定義詳細）などを提供します。重要なのは、`go-scan` が `*token.FileSet` を保持し、各情報構造体が元のASTノードやファイルパスへの参照を持つ点です。

ただし、`go-scan` は主に型やシグネチャ情報の収集に重点を置き、`minigo` のように式レベルでコードを実行するための詳細なAST構造を直接提供するものではありません。

### 統合にあたっての課題

#### `minigo` に不足しているもの (変更が必要な点)

*   **パーサーインターフェースへの対応:** `go/parser` 直接呼び出しから `go-scan` の `Scanner.ScanFiles` 等への変更。
*   **`eval` 関数の入力ソース変更:** `go-scan` から得られる情報 (`FunctionInfo` 等) から `eval` が処理できる `*ast.BlockStmt` 等を取り出す仕組み。
*   **エラーハンドリング調整:** `go-scan` のエラーと `minigo` の評価エラーの統合的扱い。

#### `go-scan` に期待される機能 (推奨される改善点)

`minigo` が効率的に `go-scan` を利用するため、`go-scan` 側に以下の改善が強く推奨されます。

1.  **`PackageInfo` による `*ast.File` の保持:**
    *   `scanner.PackageInfo` がスキャン対象となった各ファイルの `*ast.File` のスライスやマップ（例: `AstFiles map[string]*ast.File`）を保持する。
    *   これにより、`minigo` は必要なASTノード（関数本体、グローバル変数宣言など）に直接アクセスでき、統合が大幅に簡素化されます。これは **非常に推奨される改善点** です。
2.  **関数本体 (AST) へのアクセス (上記1が未対応の場合の代替案):**
    *   `scanner.FunctionInfo` が対応する `*ast.FuncDecl` ノードへの参照（例: `Node *ast.FuncDecl` フィールド）を含む。
3.  **グローバル変数宣言 (AST) へのアクセス (上記1が未対応の場合の代替案):**
    *   `scanner.PackageInfo` がファイル内のトップレベル `var` 宣言 (`*ast.GenDecl`) のリストを含む。

これらの情報が `go-scan` から提供されない場合、`minigo` 側で代替手段（ファイルパスを元にした再パース等）が必要となり、処理の重複や複雑化が生じる可能性があります。

#### インターフェースの不整合

*   **情報粒度の違い:** `minigo` の `eval` は詳細なASTノードに依存するのに対し、`go-scan` はより上位の構造情報を提供します。
*   **具体的なデータ構造の違い:** `minigo` が `ast.FuncDecl` から `Body` を取得するのに対し、`go-scan` からは `FunctionInfo` が得られます。これらを繋ぐ方法が鍵となります。

### 提案される統合方針: ハイブリッドアプローチ

`go-scan` を `minigo` の主要な**パッケージ/ファイル構造解析フェーズ**で利用し、`minigo` のコアとなる**評価フェーズ** (`eval` 関数群) は引き続き `go/ast` ノードを直接扱う形を維持する**ハイブリッドアプローチ**を提案します。

#### 具体的なステップ

1.  **初期化:** `minigo` の `Interpreter` は `go-scan` の `Scanner` インスタンスを生成し、`FileSet` を共有。
2.  **スキャン:** `LoadAndRun` 時に `Scanner.ScanFiles()` 等を呼び出し `PackageInfo` を取得。
3.  **関数とグローバル変数の登録:**
    *   **関数:** `PackageInfo.Functions` を処理。
        *   **理想 (`go-scan`改善時):** `PackageInfo` が保持する `*ast.File` (または `FunctionInfo.Node` が `*ast.FuncDecl` を指す場合) から関数名、パラメータ、本体(`Body`)を取得し登録。
        *   **代替 (現状の`go-scan`):** `FunctionInfo.FilePath` 等を使い `minigo` が再パースして `*ast.FuncDecl` を特定。
    *   **グローバル変数:**
        *   **理想 (`go-scan`改善時):** `PackageInfo` が提供するグローバル変数リスト (または `*ast.File` から抽出) を処理し `eval` で評価・登録。
        *   **代替 (現状の`go-scan`):** `minigo` が `PackageInfo.Files` の各ファイルを再パースして `ast.GenDecl` (VAR) を抽出。
4.  **エントリーポイント実行:** `PackageInfo` からエントリーポイント関数に対応する `FunctionInfo` を見つけ、上記方法で取得した関数本体で評価を開始。
5.  **評価:** `eval` 関数群は従来通り `ast.Node` を処理。
6.  **エラー報告:** `go-scan` の `FileSet` と位置情報を `minigo` のエラー報告と連携。

#### `go-scan` への期待 (推奨される改善点)

このハイブリッドアプローチを最も効果的にするためには、前述の「`go-scan` に期待される機能 (推奨される改善点)」で述べた、特に **`scanner.PackageInfo` がスキャンした各ファイルの `*ast.File` を保持する**という改善が強く望まれます。

#### 将来的な考慮事項: Lazy Import

`go-scan` の `PackageResolver` インターフェースは、パッケージ境界を越えた型の遅延読み込み・解決能力を示唆しています。`minigo` は将来的にこの機能を活用し、複数ファイルや（擬似的な）外部パッケージにまたがるコードベースを解釈できる可能性があります。これは初期統合の範囲外ですが、価値ある将来の方向性です。

### 期待される効果

*   **解析処理の責務分離:** `go-scan` が構造解析、`minigo` が評価に集中。
*   **一貫した位置情報:** `go-scan` の `FileSet` 利用によるエラー報告の一貫性。
*   **将来の拡張性:** `go-scan` の進化を取り込みやすくなる。

### 今後の課題 / 未解決点

*   **`go-scan` の改善に関する議論:** `go-scan` チーム/コントリビュータと協力し、推奨される改善点（`PackageInfo` による `*ast.File` 保持など）の実現可能性を議論・検討する。
*   **パフォーマンス評価:** `go-scan` 導入、特に代替アプローチ（再パース等）採用時の影響評価。
*   **インタプリタ機能の強化:** `go-scan` の型情報を活用した型チェック等の機能強化。
*   **複数ファイルプロジェクトのためのLazy Import実装:** `PackageResolver` を利用したインポート解釈の実装検討。
