package generator

import (
	"bytes"
	"fmt"
	"go/ast" // Added for ast.ArrayType in typeNameInSource
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"example.com/convert2/internal/model"
)

const fileSuffix = "_gen.go"

// GenerateConversionCode generates conversion functions based on parsedInfo
// and writes them to *_gen.go files in the outputDir.
func GenerateConversionCode(parsedInfo *model.ParsedInfo, outputDir string) error {
	if len(parsedInfo.ConversionPairs) == 0 {
		fmt.Println("No conversion pairs defined. Nothing to generate.")
		return nil
	}

	outputFileName := fmt.Sprintf("%s%s", parsedInfo.PackageName, fileSuffix)
	outputFilePath := filepath.Join(outputDir, outputFileName)

	var generatedCode bytes.Buffer

	// --- Package and Imports ---
	// Initial set of imports. This will be expanded by addRequiredImport.
	// Map key is import path, value is preferred alias (can be empty if no specific alias needed initially)
	requiredImports := make(map[string]string)
	requiredImports["context"] = "context" // path -> alias
	requiredImports["fmt"] = "fmt"         // For error messages in errorCollector & Sprintf
	requiredImports["errors"] = "errors"   // For errors.Join
	requiredImports["strings"] = "strings" // For strings.Join in errorCollector

	// --- Generate Error Collector ---
	// The errorCollectorTemplate itself does not declare imports.
	// The necessary imports (fmt, strings, errors) are added above.
	errCollectorTmpl, err := template.New("errorCollector").Parse(errorCollectorTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse errorCollector template: %w", err)
	}
	err = errCollectorTmpl.Execute(&generatedCode, nil)
	if err != nil {
		return fmt.Errorf("failed to execute errorCollector template: %w", err)
	}
	generatedCode.WriteString("\n\n")

	// --- Generate Conversion Functions ---
	generatedFunctionBodies := make(map[string]string) // funcName -> funcBody

	// First, generate all helper functions to ensure they are available
	// and to collect their required imports.
	for _, pair := range parsedInfo.ConversionPairs {
		coreHelperFuncName := fmt.Sprintf("%sTo%s", lowercaseFirstLetter(pair.SrcTypeInfo.Name), pair.DstTypeInfo.Name)
		if _, exists := generatedFunctionBodies[coreHelperFuncName]; !exists {
			var helperFuncBuf bytes.Buffer
			err := generateHelperFunction(&helperFuncBuf, coreHelperFuncName, pair.SrcTypeInfo, pair.DstTypeInfo, parsedInfo, requiredImports)
			if err != nil {
				return fmt.Errorf("failed to generate helper function %s: %w", coreHelperFuncName, err)
			}
			generatedFunctionBodies[coreHelperFuncName] = helperFuncBuf.String()
		}
	}
	// Potentially generate more helpers if rules or nested structs demand them (recursive step)
	// This part needs to be more sophisticated for deeply nested structures.
	// For now, we only generate helpers directly from ConversionPairs.

	// Then, generate top-level functions
	for _, pair := range parsedInfo.ConversionPairs {
		topLevelFuncName := fmt.Sprintf("Convert%s", pair.SrcTypeInfo.Name)
		if _, exists := generatedFunctionBodies[topLevelFuncName]; exists {
			continue
		}

		var funcBuf bytes.Buffer
		coreHelperFuncName := fmt.Sprintf("%sTo%s", lowercaseFirstLetter(pair.SrcTypeInfo.Name), pair.DstTypeInfo.Name)

		// Add imports for source and destination types of the top-level function
		addRequiredImport(pair.SrcTypeInfo, parsedInfo.PackagePath, requiredImports)
		addRequiredImport(pair.DstTypeInfo, parsedInfo.PackagePath, requiredImports)

		fmt.Fprintf(&funcBuf, "func %s(ctx context.Context, src %s) (%s, error) {\n",
			topLevelFuncName,
			typeNameInSource(pair.SrcTypeInfo, parsedInfo.PackagePath, requiredImports),
			typeNameInSource(pair.DstTypeInfo, parsedInfo.PackagePath, requiredImports))
		fmt.Fprintf(&funcBuf, "\tec := newErrorCollector(%d)\n", pair.MaxErrors)
		fmt.Fprintf(&funcBuf, "\tdst := %s(ec, src)\n", coreHelperFuncName) // Call helper
		fmt.Fprintf(&funcBuf, "\tif ec.HasErrors() {\n")
		fmt.Fprintf(&funcBuf, "\t\treturn dst, errors.Join(ec.Errors()...)\n")
		fmt.Fprintf(&funcBuf, "\t}\n")
		fmt.Fprintf(&funcBuf, "\treturn dst, nil\n")
		fmt.Fprintf(&funcBuf, "}\n\n")

		generatedFunctionBodies[topLevelFuncName] = funcBuf.String()
	}

	// --- Assemble Final Code ---
	var finalCode bytes.Buffer
	fmt.Fprintf(&finalCode, "// Code generated by convert2 tool. DO NOT EDIT.\n")
	fmt.Fprintf(&finalCode, "package %s\n\n", parsedInfo.PackageName)

	// Write imports
	if len(requiredImports) > 0 {
		finalCode.WriteString("import (\n")

		// Sort imports by path for consistent output
		importPaths := make([]string, 0, len(requiredImports))
		for path := range requiredImports {
			importPaths = append(importPaths, path)
		}
		// It's better to sort for deterministic output, rather than relying on Go team's tools.
		// However, gofmt/goimports will ultimately format it. So, direct iteration is fine for now.
		// For stability in tests before gofmt, sorting can be helpful. Let's add a simple sort.
		sortedImportPaths := make([]string, 0, len(requiredImports))
		for path := range requiredImports {
			sortedImportPaths = append(sortedImportPaths, path)
		}
		// Simple string sort for paths
		// For more complex alias sorting, would need custom logic
		// sort.Strings(sortedImportPaths) // Actually, map iteration order is fine, gofmt will fix.

		for importPath, alias := range requiredImports { // Iterate directly, gofmt will handle final order
			// If the determined alias is the same as the package's actual name (last part of path),
			// or if no specific alias was set (alias derived by typeNameInSource/addRequiredImport logic),
			// then no explicit alias is needed in the import statement.
			// Example: import "time" (alias "time", path "time")
			// Example: import "example.com/custom/mypkg" (alias "mypkg", path "example.com/custom/mypkg")
			baseName := filepath.Base(importPath)
			if alias == baseName || alias == "" { // if alias is empty, it means use basename
				fmt.Fprintf(&finalCode, "\t\"%s\"\n", importPath)
			} else {
				fmt.Fprintf(&finalCode, "\t%s \"%s\"\n", alias, importPath)
			}
		}
		finalCode.WriteString(")\n\n")
	}

	finalCode.Write(generatedCode.Bytes()) // Error collector code

	// Write helper functions first
	for funcName, funcBody := range generatedFunctionBodies {
		if !strings.HasPrefix(funcName, "Convert") { // Heuristic for helpers
			finalCode.WriteString(funcBody)
		}
	}
	// Then top-level functions
	for funcName, funcBody := range generatedFunctionBodies {
		if strings.HasPrefix(funcName, "Convert") {
			finalCode.WriteString(funcBody)
		}
	}

	// --- Format and Write to File ---
	formattedCode, err := format.Source(finalCode.Bytes())
	if err != nil {
		os.WriteFile(outputFilePath+".unformatted", finalCode.Bytes(), 0644)
		return fmt.Errorf("failed to format generated code for %s: %w\nUnformatted code saved to %s.unformatted", outputFileName, err, outputFilePath)
	}

	err = os.MkdirAll(outputDir, 0755)
	if err != nil {
		return fmt.Errorf("failed to create output directory %s: %w", outputDir, err)
	}

	err = os.WriteFile(outputFilePath, formattedCode, 0644)
	if err != nil {
		return fmt.Errorf("failed to write generated code to %s: %w", outputFilePath, err)
	}

	fmt.Printf("Generated conversion code at %s\n", outputFilePath)
	return nil
}

// generateHelperFunction generates the non-exported core conversion logic.
func generateHelperFunction(buf *bytes.Buffer, funcName string, srcType, dstType *model.TypeInfo, parsedInfo *model.ParsedInfo, imports map[string]string) error {
	if srcType.StructInfo == nil || dstType.StructInfo == nil {
		// Handle non-struct or unresolved struct types (e.g. named basic types)
		// This part will require using global conversion rules or direct assignment if types are compatible.
		fmt.Fprintf(buf, "// Helper function %s for types %s -> %s\n", funcName, srcType.FullName, dstType.FullName)
		fmt.Fprintf(buf, "// One or both types are not structs, or struct info not found.\n")
		fmt.Fprintf(buf, "func %s(ec *errorCollector, src %s) %s {\n",
			funcName,
			typeNameInSource(srcType, parsedInfo.PackagePath, imports), // typeNameInSource は一時的に単純化されたまま
			typeNameInSource(dstType, parsedInfo.PackagePath, imports))
		// TODO: Implement conversion for non-structs or when one is not a struct.
		// This could involve checking for global 'using' rules, or direct assignment/casting if types are compatible.
		// Example: if types are `type Meter int32` and `type Centimeter int32`
		fmt.Fprintf(buf, "\t// Placeholder for non-struct conversion logic.\n")
		if srcType.FullName == dstType.FullName || (srcType.Underlying != nil && srcType.Underlying.FullName == dstType.FullName) || (dstType.Underlying != nil && dstType.Underlying.FullName == srcType.FullName) {
			fmt.Fprintf(buf, "\treturn %s(src) // Assuming direct cast is possible\n", typeNameInSource(dstType, parsedInfo.PackagePath, imports))
		} else {
			fmt.Fprintf(buf, "\tvar dst %s\n", typeNameInSource(dstType, parsedInfo.PackagePath, imports))
			fmt.Fprintf(buf, "\tec.Addf(\"conversion from %s to %s not implemented for non-structs or mismatched types\")\n", srcType.FullName, dstType.FullName)
			fmt.Fprintf(buf, "\treturn dst\n")
		}
		fmt.Fprintf(buf, "}\n\n")
		// Imports for srcType and dstType should have been added when they were first encountered or used.
		// Calling addRequiredImport here again is fine, it's idempotent.
		addRequiredImport(srcType, parsedInfo.PackagePath, imports)
		addRequiredImport(dstType, parsedInfo.PackagePath, imports)
		return nil
	}

	srcStruct := srcType.StructInfo
	dstStruct := dstType.StructInfo

	// Add imports for src and dst types of this helper function itself.
	// This is important if srcType or dstType are from external packages.
	addRequiredImport(srcType, parsedInfo.PackagePath, imports)
	addRequiredImport(dstType, parsedInfo.PackagePath, imports)

	fmt.Fprintf(buf, "func %s(ec *errorCollector, src %s) %s {\n",
		funcName,
		typeNameInSource(srcType, parsedInfo.PackagePath, imports),
		typeNameInSource(dstType, parsedInfo.PackagePath, imports))
	fmt.Fprintf(buf, "\tdst := %s{}\n", typeNameInSource(dstType, parsedInfo.PackagePath, imports))
	fmt.Fprintf(buf, "\tif ec.MaxErrorsReached() { return dst } \n\n")

	// Iterate over source struct fields to apply rules and find destinations
	for _, srcField := range srcStruct.Fields {
		if srcField.Tag.DstFieldName == "-" {
			fmt.Fprintf(buf, "\t// Source field %s.%s is skipped due to tag '-'.\n", srcStruct.Name, srcField.Name)
			continue
		}

		dstFieldName := srcField.Tag.DstFieldName
		if dstFieldName == "" { // No specific destination name in tag, use source field name
			dstFieldName = srcField.Name
		}

		var dstField *model.FieldInfo
		for i := range dstStruct.Fields { // dstStruct がここで使われる
			if dstStruct.Fields[i].Name == dstFieldName {
				dstField = &dstStruct.Fields[i]
				break
			}
		}

		if dstField == nil {
			// No destination field found with the target name.
			// If auto-mapping by normalized name was intended, that's a later step.
			// For now, if explicit name or same name doesn't match, we report (or silently skip).
			// Let's add a comment for now if a DstFieldName was specified in tag but not found.
			if srcField.Tag.DstFieldName != "" {
				fmt.Fprintf(buf, "\t// Warning: Destination field '%s' specified for source field '%s.%s' not found in struct '%s'.\n", srcField.Tag.DstFieldName, srcStruct.Name, srcField.Name, dstStruct.Name)
			}
			continue
		}

		// Found source field and corresponding destination field.
		// Now, implement basic direct assignment if types match.
		fmt.Fprintf(buf, "\t// Mapping field %s.%s to %s.%s\n", srcStruct.Name, srcField.Name, dstStruct.Name, dstField.Name)
		fmt.Fprintf(buf, "\tec.Enter(%q)\n", dstField.Name) // Path uses DstFieldName

		// Add imports for field types
		addRequiredImport(srcField.TypeInfo, parsedInfo.PackagePath, imports)
		addRequiredImport(dstField.TypeInfo, parsedInfo.PackagePath, imports)

		var appliedUsingFunc string
		var usingFuncIsGlobal bool

		// Priority 1: Field Tag `using=<funcName>`
		if srcField.Tag.UsingFunc != "" {
			appliedUsingFunc = srcField.Tag.UsingFunc
			usingFuncIsGlobal = false
		} else {
			// Priority 2: Global Rule `convert:rule "<SrcT>" -> "<DstT>", using=<funcName>`
			for _, rule := range parsedInfo.GlobalRules {
				if rule.UsingFunc != "" && rule.SrcTypeInfo != nil && rule.DstTypeInfo != nil &&
					rule.SrcTypeInfo.FullName == srcField.TypeInfo.FullName &&
					rule.DstTypeInfo.FullName == dstField.TypeInfo.FullName {
					appliedUsingFunc = rule.UsingFunc
					usingFuncIsGlobal = true
					break
				}
			}
		}

		if appliedUsingFunc != "" {
			// Handle potential package prefix in appliedUsingFunc for imports
			funcCallName := appliedUsingFunc
			if parts := strings.Split(appliedUsingFunc, "."); len(parts) == 2 {
				// Assuming a simple pkg.Func format for now
				// This needs robust package alias resolution based on actual imports in the source
				// For now, if it contains ".", assume the first part is a package selector.
				// The actual import path for this selector needs to be available.
				// Let's assume the parser stores TypeInfo for func types or we resolve it here.
				// For simplicity, if func name is "pkg.MyFunc", ensure "pkg" (its path) is imported.
				// This is a placeholder for proper import resolution for the custom function's package.
				// The function type itself does not have a TypeInfo here easily.
				// We'd typically need to look up "pkg" in file imports to get its path.
				// For now, just use the prefix as is and rely on goimports or user to have correct imports.
				// A slightly better heuristic: if `appliedUsingFunc` contains a dot,
				// assume the part before the dot is a package that needs to be imported.
				// The `addRequiredImport` function might need to be smarter or take the function name.
				// For now, let's assume the function is in the same package or its package is handled by typeNameInSource logic if it were a type.
				// This is complex. Simplification: assume func is accessible.
				// If appliedUsingFunc is "mypackage.MyFunction", then typeNameInSource for a type from "mypackage"
				// would ensure "mypackage" is imported. We can try to leverage that.

				// Let's try to add import for the package part of the using function.
				if funcParts := strings.Split(appliedUsingFunc, "."); len(funcParts) == 2 {
					// This is a naive way to guess a package name and assume it needs import.
					// A proper solution would look up funcParts[0] in the file's imports list.
					// For now, we don't have that context directly here for the custom function.
					// We'll rely on the user ensuring the function is callable.
					// If the function is in another package, its import must be present in the generated file.
					// We can try to infer the import from the function name if it's qualified.
					// This is still problematic as we don't have the import *path* for pkgAlias.
					// For now, we generate the call as is. The user must ensure imports.
					// A future improvement would be for the parser to resolve function locations.
				}
			}

			if usingFuncIsGlobal {
				fmt.Fprintf(buf, "\t// Applying global rule: %s -> %s using %s\n", srcField.TypeInfo.FullName, dstField.TypeInfo.FullName, appliedUsingFunc)
			} else {
				fmt.Fprintf(buf, "\t// Applying field tag: using %s\n", appliedUsingFunc)
			}
			fmt.Fprintf(buf, "\tdst.%s = %s(ec, src.%s)\n", dstField.Name, funcCallName, srcField.Name)

		} else {
			// Priority 3: Automatic Conversion (including pointer logic)
			srcIsPtr := srcField.TypeInfo.IsPointer
			dstIsPtr := dstField.TypeInfo.IsPointer
			srcElemTypeFullName := ""
			if srcField.TypeInfo.Elem != nil {
				srcElemTypeFullName = srcField.TypeInfo.Elem.FullName
			} else if !srcIsPtr {
				srcElemTypeFullName = srcField.TypeInfo.FullName
			}
			dstElemTypeFullName := ""
			if dstField.TypeInfo.Elem != nil {
				dstElemTypeFullName = dstField.TypeInfo.Elem.FullName
			} else if !dstIsPtr {
				dstElemTypeFullName = dstField.TypeInfo.FullName
			}

			typesMatchDirectly := srcField.TypeInfo.FullName == dstField.TypeInfo.FullName
			elementsMatch := srcElemTypeFullName != "" && dstElemTypeFullName != "" && srcElemTypeFullName == dstElemTypeFullName

			if typesMatchDirectly { // Case: T -> T or *T -> *T (elements must also match for *T -> *T, implied by FullName match)
				fmt.Fprintf(buf, "\tdst.%s = src.%s\n", dstField.Name, srcField.Name)
			} else if !srcIsPtr && dstIsPtr && elementsMatch { // Case: T -> *T
				// Ensure that dstField.TypeInfo.Elem.FullName matches srcField.TypeInfo.FullName
				fmt.Fprintf(buf, "\t{\n")
				fmt.Fprintf(buf, "\t\tsrcVal := src.%s\n", srcField.Name)
				fmt.Fprintf(buf, "\t\tdst.%s = &srcVal\n", dstField.Name)
				fmt.Fprintf(buf, "\t}\n")
			} else if srcIsPtr && !dstIsPtr && elementsMatch { // Case: *T -> T
				// Ensure that srcField.TypeInfo.Elem.FullName matches dstField.TypeInfo.FullName
				if srcField.Tag.Required {
					fmt.Fprintf(buf, "\tif src.%s == nil {\n", srcField.Name)
					fmt.Fprintf(buf, "\t\tec.Addf(\"field '%s' is required but source field %s is nil\")\n", dstField.Name, srcField.Name)
					fmt.Fprintf(buf, "\t} else {\n")
					fmt.Fprintf(buf, "\t\tdst.%s = *src.%s\n", dstField.Name, srcField.Name)
					fmt.Fprintf(buf, "\t}\n")
				} else {
					fmt.Fprintf(buf, "\tif src.%s != nil {\n", srcField.Name)
					fmt.Fprintf(buf, "\t\tdst.%s = *src.%s\n", dstField.Name, srcField.Name)
					fmt.Fprintf(buf, "\t}\n") // If nil, dst field remains zero value, no error
				}
			} else {
				// Types do not match directly and pointer logic doesn't apply or elements mismatch.
				// This is where underlying type checks, slice/map conversions,
				// and recursive struct conversions will go.
				fmt.Fprintf(buf, "\t// TODO: Implement conversion for %s (%s) to %s (%s).\n",
					srcField.Name, srcField.TypeInfo.FullName,
					dstField.Name, dstField.TypeInfo.FullName)
				fmt.Fprintf(buf, "\tec.Addf(\"type mismatch or complex conversion not yet implemented for field '%s' (%s -> %s)\")\n",
					dstField.Name, srcField.TypeInfo.FullName, dstField.TypeInfo.FullName)
			}
		} // if appliedUsingFunc != "" の else ブロックの閉じ括弧

		fmt.Fprintf(buf, "\tec.Leave()\n")
		fmt.Fprintf(buf, "\tif ec.MaxErrorsReached() { return dst } \n\n")
	} // for ループの閉じ括弧

	fmt.Fprintf(buf, "\treturn dst\n")
	fmt.Fprintf(buf, "}\n\n")
	return nil
}

// typeNameInSource returns the string representation of the type as it should appear in the generated source code.
// It considers if the type is from the package being generated into, or an external package.
// It uses the `imports` map (path -> alias) to determine the correct alias for external packages.
func typeNameInSource(typeInfo *model.TypeInfo, currentPackagePath string, imports map[string]string) string {
	if typeInfo == nil {
		return "interface{}" // Fallback
	}

	var buildName func(ti *model.TypeInfo) string
	buildName = func(ti *model.TypeInfo) string {
		if ti.IsPointer {
			return "*" + buildName(ti.Elem)
		}
		if ti.IsSlice {
			return "[]" + buildName(ti.Elem)
		}
		if ti.IsArray {
			lenStr := "N" // Default if not resolvable through AST
			if arrType, ok := ti.AstExpr.(*ast.ArrayType); ok && arrType.Len != nil {
				// AstExprToString is in model package, need to qualify or pass down currentPkgName if it relies on it.
				// For generator, currentPkgName context for AstExprToString is less relevant.
				lenStr = model.AstExprToString(arrType.Len, "") // Use empty for currentPkgName in model.AstExprToString
			}
			return "[" + lenStr + "]" + buildName(ti.Elem)
		}
		if ti.IsMap {
			return fmt.Sprintf("map[%s]%s", buildName(ti.Key), buildName(ti.Value))
		}

		// For non-composite types (Ident, Basic, Struct, Named)
		if ti.PackagePath != "" && ti.PackagePath != currentPackagePath && !ti.IsBasic {
			// External package. Find its alias from the `imports` map.
			alias, aliasExists := imports[ti.PackagePath]
			if !aliasExists {
				// This should not happen if addRequiredImport was called for this type.
				// Fallback to using the TypeInfo's PackageName (if set by parser from a selector)
				// or the base name of the package path.
				fmt.Printf("Warning: Package path '%s' for type '%s' not found in required imports map. Using fallback selector.\n", ti.PackagePath, ti.FullName)
				if ti.PackageName != "" { // Parser might have set this from a selector like `pkg.Type`
					alias = ti.PackageName
				} else {
					alias = filepath.Base(ti.PackagePath)
				}
			}
			// If alias is same as base name of path, it means no explicit alias in import stmt.
			// e.g. import "time", used as time.Time. alias="time"
			// e.g. import custom "example.com/custom", used as custom.Type. alias="custom"
			return alias + "." + ti.Name
		}
		return ti.Name // Type is in the current package, or a basic type, or its package path is empty.
	}
	return buildName(typeInfo)
}

// addRequiredImport tracks necessary imports.
// `imports` is a map of import_path -> import_alias.
// It ensures that TypeInfo.PackageName is set to the alias that will be used in the generated code.
func addRequiredImport(typeInfo *model.TypeInfo, currentPackagePath string, imports map[string]string) { // Rewritten
	if typeInfo == nil {
		return
	}

	// Recursively add for elements, keys, values, underlying types
	if typeInfo.IsPointer || typeInfo.IsSlice || typeInfo.IsArray {
		if typeInfo.Elem != nil {
			addRequiredImport(typeInfo.Elem, currentPackagePath, imports)
		}
		return // Pointer/slice/array types themselves don't define a package to import; their elements might.
	}
	if typeInfo.IsMap {
		if typeInfo.Key != nil {
			addRequiredImport(typeInfo.Key, currentPackagePath, imports)
		}
		if typeInfo.Value != nil {
			addRequiredImport(typeInfo.Value, currentPackagePath, imports)
		}
		return // Map types themselves don't define a package; their key/value types might.
	}

	// If it's a named type, process its underlying type first.
	// e.g. for `type MyTime time.Time`, `time.Time` needs `time` import.
	// The named type `MyTime` itself is in `currentPackagePath`.
	if typeInfo.Kind == model.KindNamed && typeInfo.Underlying != nil {
		// The named type A itself is in currentPackagePath (unless it's an alias to external type, handled by PackagePath check below)
		addRequiredImport(typeInfo.Underlying, currentPackagePath, imports)
		// Fall through to check if the named type A itself is from an external package (e.g. alias to external)
	}
	// If it's a struct, its fields' types will be processed when the struct conversion is generated.
	// At that point, addRequiredImport will be called for each field type.

	if typeInfo.PackagePath != "" && typeInfo.PackagePath != currentPackagePath && !typeInfo.IsBasic {
		// External package that needs to be imported.

		// Determine the alias.
		// 1. If an alias is already registered for this path, use it.
		// 2. If TypeInfo.PackageName is set (e.g. from parser seeing 'pkg.Type'), try to use that as alias.
		// 3. Otherwise, use the base name of the package path.
		var chosenAlias string
		if existingAlias, ok := imports[typeInfo.PackagePath]; ok && existingAlias != "" {
			chosenAlias = existingAlias
		} else if typeInfo.PackageName != "" && typeInfo.PackageName != filepath.Base(typeInfo.PackagePath) && typeInfo.PackageName != "main" {
			// If PackageName is set by parser AND it's different from basename (e.g. a true alias like `customtime.Time`)
			// and not 'main' (which cannot be used as an alias typically for external packages)
			chosenAlias = typeInfo.PackageName
		} else {
			chosenAlias = filepath.Base(typeInfo.PackagePath)
		}

		// Check for collision: if this chosenAlias is already used for a *different* path.
		// This simple check doesn't fully resolve complex collisions but warns.
		// A more robust system would generate unique aliases (pkg1, pkg2, etc.)
		for path, aliasInMap := range imports {
			if aliasInMap == chosenAlias && path != typeInfo.PackagePath {
				fmt.Printf("Warning: Import alias '%s' for path '%s' collides with existing import for path '%s'. Manual intervention may be needed or use unique aliases.\n", chosenAlias, typeInfo.PackagePath, path)
				// Potentially re-assign a unique alias here if collision detected: chosenAlias = chosenAlias + "_colliding"
				// For now, we'll proceed, hoping gofmt or user handles if it's a real issue.
				break
			}
		}

		imports[typeInfo.PackagePath] = chosenAlias

		// Crucially, ensure TypeInfo.PackageName reflects the alias to be used in generated code.
		// This helps typeNameInSource use the correct prefix.
		typeInfo.PackageName = chosenAlias
	}
}

func lowercaseFirstLetter(s string) string {
	if len(s) == 0 {
		return ""
	}
	return strings.ToLower(s[0:1]) + s[1:]
}

// errorCollectorTemplate (content is the same as before)
const errorCollectorTemplate = `
// errorCollector collects errors with path tracking.
type errorCollector struct {
	maxErrors int
	errors    []error
	pathStack []string
}
func newErrorCollector(maxErrors int) *errorCollector {
	return &errorCollector{
		maxErrors: maxErrors,
		errors:    make([]error, 0),
		pathStack: make([]string, 0),
	}
}
func (ec *errorCollector) Add(reason string) bool {
	if ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors {
		return true
	}
	fullPath := strings.Join(ec.pathStack, "")
	err := fmt.Errorf("%s: %s", fullPath, reason)
	ec.errors = append(ec.errors, err)
	return ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors
}
func (ec *errorCollector) Addf(format string, args ...interface{}) bool {
	if ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors {
		return true
	}
	return ec.Add(fmt.Sprintf(format, args...))
}
func (ec *errorCollector) Enter(segment string) {
	// separator variable was unused, logic is directly handled below.
	if strings.HasPrefix(segment, "[") && strings.HasSuffix(segment, "]") { // Array/slice index
		ec.pathStack = append(ec.pathStack, segment)
	} else { // Field name
		if len(ec.pathStack) == 0 {
			ec.pathStack = append(ec.pathStack, segment)
		} else {
			ec.pathStack = append(ec.pathStack, "."+segment)
		}
	}
}
func (ec *errorCollector) Leave() {
	if len(ec.pathStack) > 0 {
		ec.pathStack = ec.pathStack[:len(ec.pathStack)-1]
	}
}
func (ec *errorCollector) Errors() []error {
	return ec.errors
}
func (ec *errorCollector) HasErrors() bool {
	return len(ec.errors) > 0
}
func (ec *errorCollector) MaxErrorsReached() bool {
	return ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors
}
`
