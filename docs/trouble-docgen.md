# `symgo` エンジンのデバッグと `docgen` 実装のブロック解除

`docgen` の M3 タスク（スキーマとパラメータの解析）を進めるにあたり、`symgo` シンボリック実行エンジンの根本的なバグ修正が必要となりました。このセクションでは、そのデバッグプロセスと、後任者への引き継ぎ事項を記録します。

### 目標

`symgo` が `net/http` ハンドラ内のメソッド呼び出し（例: `json.Decode`, `json.Encode`）を正しく解析できるように修正し、`docgen` がリクエスト/レスポンスのスキーマを生成できるようにする。

### 実施したこと（進捗）

前任者の作業（このファイルの古いバージョン）を引き継ぎ、`symgo` のテストが失敗する問題から調査を開始しました。

1.  **テスト基盤のアーキテクチャ修正**:
    *   **問題**: `symgo` の既存テストは、関数の `*ast.BlockStmt`（ボディ部分）を直接 `Eval` に渡していました。これは、関数の引数やレシーバがセットアップされるスコープをバイパスするため、実際の関数呼び出しをシミュレートできていませんでした。
    *   **修正**: 全てのテストをリファクタリングし、まず `*object.Function` を環境から取得し、`applyFunction` メソッド（実際の関数呼び出しロジック）を呼び出すパターンに統一しました。これにより、テストの信頼性が大幅に向上しました。

2.  **パッケージレベル関数のイントリンシック解決**:
    *   信頼できるようになったテストを実行した結果、`fmt.Println` のようなインポートされたパッケージの関数が、テスト用に登録したイントリンシック（モック）に正しく解決されないバグが明らかになりました。
    *   `evalSelectorExpr`（`a.b`のような式を評価する部分）のロジックを修正し、パッケージ、インスタンス、変数を正しく型でスイッチして処理するようにしました。これにより、パッケージレベルの関数呼び出しは正しくイントリンシックに解決されるようになりました。

3.  **`docgen` 分析ロジックのリファクタリング**:
    *   `symgo` のテストで確立した `applyFunction` パターンを `docgen` の分析ロジックにも適用しました。これにより、`docgen` は HTTP ハンドラをより正確にシミュレート実行できるようになり、アーキテクチャが健全化されました。

### 未解決の問題（後任者への引き継ぎ）

上記の改善にもかかわらず、`symgo` には依然として致命的なバグが残っており、`docgen` のタスク完了を阻んでいます。

*   **根本原因**: **インスタンスメソッド呼び出しのイントリンシックが解決できない**
    *   `TestEvalCallExprOnInstanceMethod` テストが依然として失敗します。これは `mux.HandleFunc(...)` のような、シンボリックなインスタンス (`mux`) に対するメソッド呼び出しをテストするものです。
    *   このバグにより、`docgen` も `decoder.Decode(...)` や `encoder.Encode(...)` のようなメソッド呼び出しを捕捉できず、リクエスト/レスポンスのスキーマを生成できません。

### 重要な調査の経緯（後任者向け）

このバグの調査において、後任者が同じ轍を踏まないように、特に重要だった点を共有します。

*   **オブジェクトのキャプチャは成功している**:
    *   `mux := http.NewServeMux()` のような代入文の評価後、環境内に `mux` が `*object.Instance` として正しく格納されていることは、診断テストを追加して確認済みです。したがって、問題はオブジェクトの生成や代入処理にはありません。

*   **AST の構造は想定通りだった**:
    *   メソッド呼び出しの AST (`*ast.SelectorExpr`) の構造が特殊で、自分の想定と異なっているのではないか、という仮説を立てました。
    *   これを検証するため、ユーザーからのアドバイスに従い、テストを一時的に修正して `go/printer` を使い `mux.HandleFunc` の AST ノードを文字列としてダンプしました。
    *   結果、ダンプされた文字列は `mux.HandleFunc` であり、AST の構造（`X` が `mux`、`Sel` が `HandleFunc`）は完全に想定通りであることが確認できました。**これにより、AST の解釈ミスという可能性を完全に排除できました。** この切り分けは非常に重要でした。

### 次のステップへの推奨事項

AST の構造も、オブジェクトの生成も正しいとすると、問題は `evalSelectorExpr` が `*object.Instance` を受け取った際の、**状態（特にイントリンシックレジストリ）の参照、あるいは環境（スコープ）の管理**といった、より繊細な部分にある可能性が極めて高いです。

後任の方は、`evalSelectorExpr` が `case *object.Instance:` に入る際の `e.intrinsics.Get(key)` の呼び出しがなぜ `false` を返すのか、あるいはその前の `e.Eval(n.X, ...)` が本当に期待通りのオブジェクトを返しているのか（関数呼び出しのネストした環境下で）、さらにデバッグを進める必要があります。

このドキュメントが、問題解決の一助となることを願っています。

### 解決編：根本原因の特定

更なる調査の結果、`symgo` エンジン自体にはバグが**存在しない**ことが判明しました。問題の根本原因は、`TestEvalCallExprOnInstanceMethod` テストケースの実装そのものにありました。

*   **問題点**: テストに記述された `HandleFunc` メソッドのイントリンシック（モック）が、受け取る引数を誤って解釈していました。
    *   インスタンスメソッド (`instance.Method()`) のイントリンシックが受け取る引数リストの最初の要素 (`args[0]`) は、レシーバインスタンス (`instance`) 自身です。
    *   しかし、テストでは `args[0]` を `HandleFunc` の第一引数（パスパターン文字列）であると期待してチェックしていました。
    *   実際には、パスパターンは `args[1]` に存在するため、テストは常に失敗し、`gotPattern` 変数が空のままになっていました。

*   **修正**: `TestEvalCallExprOnInstanceMethod` テスト内のイントリンシックの実装を修正し、`args[1]` からパスパターンを取得するように変更しました。この修正により、テストは正常に成功しました。

*   **結論**: `symgo` エンジンは、インスタンスメソッド呼び出しを正しくハンドリングできていました。この一件は、複雑なシステムをデバッグする際に、テストコード自体の正当性を疑うことの重要性を示す良い教訓となりました。`docgen` の開発をブロックしていた問題は、このテストの修正によって完全に解決されました。
