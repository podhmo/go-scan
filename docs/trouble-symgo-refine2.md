# `symgo` Refinement Plan 2: Addressing Infinite Recursion and Timeout

This document outlines a new plan to improve the `symgo` symbolic execution engine. It is based on a re-run of the `find-orphans` end-to-end test, as specified in `docs/plan-symgo-refine.md`. The analysis revealed a critical timeout issue caused by infinite recursion, as well as other significant errors that need to be addressed.

## Summary of Findings

The `find-orphans` e2e test was executed with a 30-second timeout. The process was terminated by the timeout, confirming the user's suspicion that the analysis was hanging. The generated log file, `find-orphans.out`, was incomplete but contained enough information to diagnose several critical issues. The previous fixes have resolved some problems, but new, more severe issues have been uncovered.

## Error and Warning Analysis

### 1. Critical: Infinite Recursion and Timeout

- **Log Messages**:
    - `level=WARN msg="infinite recursion detected, aborting" in_func=TypeInfoFromExpr`
    - `level=ERROR msg="infinite recursion detected: TypeInfoFromExpr"`
- **Analysis**: The log is flooded with these messages, all originating from `scanner/scanner.go` in the `TypeInfoFromExpr` function. This is the most critical issue and the undeniable cause of the timeout. The scanner is entering an unbounded recursive loop while trying to resolve type information, which prevents the symbolic execution from making any meaningful progress. This must be fixed before any other analysis can be reliably performed.

### 2. Invalid Dereference of Unresolved Functions

- **Error Message**: `invalid indirect of <Unresolved Function: ...> (type *object.UnresolvedFunction)`
- **Example Context**: This error occurs for standard library types like `log/slog.Logger`, `go/token.FileSet`, and `go/ast.File`.
- **Analysis**: This is a new and severe bug. The `symgo` engine appears to be incorrectly identifying a type as an `UnresolvedFunction` object. Subsequently, when the code attempts to use this type (e.g., as a pointer to a struct), the engine tries to perform an indirect memory access (`*p`) on the function object, which is an invalid operation. This indicates a fundamental flaw in the type resolution or object representation logic for external or built-in types.

### 3. Cascading "Identifier Not Found" Errors

- **Error Messages**:
    - `identifier not found: PackageInfo`
    - `identifier not found: elemType`
    - `identifier not found: genericType`
- **Analysis**: These errors appear frequently within the same function (`TypeInfoFromExpr`) that is suffering from infinite recursion. It is highly likely that these are a direct symptom of the recursion bug. The recursive calls are likely failing to maintain or propagate the correct scope, leading to a state where expected variables are not defined.

### 4. Persistent Multi-Return Value Warnings

- **Warning Message**: `expected multi-return value on RHS of assignment`
- **Analysis**: This warning, noted in the original plan, is still present. While the previous fix may have addressed some cases, it is not comprehensive. This suggests that the symbolic representation of un-analyzable function calls is still not robust enough to handle all multi-value assignment scenarios.

## Troubleshooting and Resolution Journey

The "Infinite Recursion" bug proved to be complex to diagnose and resolve. The initial `e2e` test timed out, pointing to a hang, but the exact trigger was unclear.

1.  **Initial Hypothesis (Incorrect): Interpreter Bug**: The first line of investigation focused on the `symgo` interpreter. The theory was that a self-referential variable initialization (e.g., `var V = F()`, where `F` uses `V`) was causing the interpreter to loop. This led to a fix in the evaluator's `evalGenDecl` function to correctly handle this pattern. While this was a valid improvement to the evaluator, it did not solve the hang, proving the root cause was elsewhere.

2.  **Second Hypothesis (Partially Correct): Scanner Recursion**: The focus then shifted to the `scanner`, as indicated by the logs. A unit test was created with a self-referential generic interface (`type I[P any] interface { Foo() G[I[P]] }`). This test did not hang but failed, returning `false` from `goscan.Implements` instead of `true`. This was a critical insight: the bug wasn't just a hang, but a logic error in the recursion handling.

3.  **First Fix Attempt (Insufficient)**: A recursion guard was added to `scanner.TypeInfoFromExpr` using a cache keyed by the AST node's position (`expr.Pos()`). This was insufficient because the same conceptual type can be represented by different AST nodes at different positions in the source code, so the cache failed to detect the cycle.

4.  **Second Fix Attempt (Correct but Incomplete)**: The recursion guard was improved by replacing the position-based key with a canonical string key generated by a new `buildKey` helper function. This function traversed the `ast.Expr` to create a unique string for the type. This fix passed the unit test. However, the `e2e` test, which was previously timing out, now started panicking with a `nil` pointer dereference inside `buildKey`.

5.  **Third Fix Attempt (Final Solution)**: The panic was traced to the `buildKey` function not handling all possible `ast.Expr` types that can appear in a type definition (e.g., `*ast.FuncType` with no return values). The `buildKey` function was made more robust with additional `nil` checks and handlers for more expression types. With this final change, the panic was resolved, and the `find-orphans` e2e test completed successfully without timing out. The core fix was the robust, cache-based recursion guard in the scanner, keyed by a canonical representation of the type expression.

## Proposed Task List for `symgo` Improvement

- [x] **Task 1: Fix Infinite Recursion in `scanner.TypeInfoFromExpr`.**
    - **Goal**: Identify and fix the cause of the unbounded recursion in `TypeInfoFromExpr`.
    - **Details**: This required a deep dive into the type resolution logic. The final fix involved adding a mechanism to track visited nodes during recursive traversal using a canonical key for the type expression, preventing the scanner from re-entering the same analysis loop.
    - **Acceptance Test**: The `find-orphans` e2e test now runs to completion without timing out. (Note: This is not fully resolved, see "Post-Fix Analysis".)

- [ ] **Task 2: Correctly Resolve and Handle External Types.**
    - **Goal**: Prevent the "invalid indirect" error by ensuring external and built-in types are resolved as type objects, not function objects.
    - **Details**: Investigate how types from packages like `log/slog` are being resolved. The evaluator should create a symbolic type placeholder, not an `UnresolvedFunction` object. This may require changes to the `scanner` or the `symgo` evaluator's handling of package lookups.

- [ ] **Task 3: Add a Debug Timeout Option to `find-orphans`.**
    - **Goal**: Make the tool easier to debug by adding a CLI flag for a timeout.
    - **Details**: The user suggested a 30s timeout is sufficient. Implement a `--timeout` flag (e.g., `--timeout 30s`) in `find-orphans` that uses a `context.WithTimeout` to gracefully terminate the analysis. This will make debugging long-running or hanging analyses much more manageable.

- [ ] **Task 4: Re-evaluate Entry Point Analysis.**
    - **Goal**: Once the critical bugs are fixed, re-run the e2e test and address any remaining errors that cause the analysis of `main` entry points to fail.
    - **Details**: This task is carried over from the previous plan. With the timeout and recursion issues resolved, it will be possible to get a complete and accurate log, which can be used to identify and fix any further bugs preventing a full analysis.

## Reproduction Steps

The reproduction steps remain the same.

1.  **Ensure Makefile exists:** The file `examples/find-orphans/Makefile` should contain:
    ```makefile
    e2e:
	@echo "Running end-to-end test for find-orphans..."
	go run . --workspace-root ../.. ./... > find-orphans.out 2>&1
	@echo "Output written to examples/find-orphans/find-orphans.out"
    ```

2.  **Run the analysis:**
    Execute the make target from the repository root. A `timeout` is recommended to prevent a hung process.
    ```sh
    timeout 60s make -C examples/find-orphans e2e
    ```

3.  **Inspect the output:**
    The results, including logs, will be in `examples/find-orphans/find-orphans.out`.

## Re-investigation of E2E Timeout (2025-09-03)

### Summary

The `find-orphans` e2e test continued to time out even after the scanner-level recursion guard was implemented. A deeper investigation was launched to identify the true root cause of the hang. The investigation confirmed that the hang is not caused by a simple infinite recursion in the scanner, but by a more fundamental issue in the `symgo` interpreter's handling of types from packages outside its primary analysis scope.

The key finding is that `symgo` incorrectly creates symbolic placeholders for these external types, leading to critical errors (e.g., `invalid indirect of <Unresolved Function>`) that destabilize the interpreter and cause it to hang in complex scenarios.

### Debugging Process

The investigation used a methodical approach by leveraging the `--primary-analysis-scope` flag in the `find-orphans` tool to incrementally expand the set of packages being analyzed.

1.  **Baseline Confirmation**: The full e2e test (`go run . --workspace-root ../.. ./...`) was run and confirmed to time out after 60 seconds, reproducing the original problem.

2.  **Isolating `minigo`**: Based on the user's hint that the issue was related to `minigo`, the first test was scoped exclusively to the `minigo` package:
    ```sh
    go run ./examples/find-orphans --workspace-root . --primary-analysis-scope github.com/podhmo/go-scan/minigo
    ```
    This command completed successfully in a few seconds, proving that the `minigo` package in isolation is not the cause of the hang.

3.  **Adding `symgo` to the Scope**: The scope was expanded to include `symgo` alongside `minigo`:
    ```sh
    go run ./examples/find-orphans --workspace-root . --primary-analysis-scope github.com/podhmo/go-scan/minigo,github.com/podhmo/go-scan/symgo
    ```
    This also completed successfully, indicating that the interaction between the two core libraries was not the direct cause.

4.  **Reproducing the "Invalid Indirect" Error**: The breakthrough came when the `examples/minigo` package was added to the scope. This package contains code that uses the `minigo` and `symgo` libraries to perform real tasks, such as generating stdlib bindings.
    ```sh
    go run ./examples/find-orphans --workspace-root . --primary-analysis-scope github.com/podhmo/go-scan/minigo,github.com/podhmo/go-scan/symgo,github.com/podhmo/go-scan/examples/minigo
    ```
    This command, while not hanging, produced a series of critical `ERROR` logs, most notably:
    ```
    level=ERROR msg="invalid indirect of <Unresolved Function: github.com/podhmo/go-scan.Scanner> (type *object.UnresolvedFunction)"
    ```
    This error is the same one identified in the initial analysis (`Error and Warning Analysis`, Section 2) and points directly to the root cause.

### Conclusion

The timeout is not a simple bug in a single function but a systemic failure of the `symgo` interpreter.

-   **Root Cause**: The `symgo` engine fails to create correct symbolic placeholders for types that are referenced from within the primary analysis scope but are defined in packages *outside* of it.
-   **Symptom**: It incorrectly represents these types as `*object.UnresolvedFunction` instead of a symbolic struct or interface. When the analyzed code attempts to use a pointer to such a type (e.g., `*goscan.Scanner`), the interpreter tries to dereference a function pointer, leading to the "invalid indirect" error.
-   **Hypothesis for Hang**: While the minimal test case produced a recoverable error, it is hypothesized that in the full e2e test (with `./...`), a similar type resolution failure occurs with a more complex type (perhaps involving generics or interfaces) that sends the interpreter into an unrecoverable state, such as a non-terminating loop, resulting in the timeout.

The investigation successfully confirmed the cause of the instability that leads to the timeout. The next step is not to chase the timeout itself, but to fix the underlying bug in `symgo`'s external type resolution logic.

---

## Update (2025-09-03): Partial Fix and Further Findings

A fix was implemented based on the conclusion above. The `evalSelectorExpr` function in the `symgo` evaluator was modified to create a proper `*object.Type` placeholder for unresolved identifiers from external packages, instead of a generic placeholder that could be misinterpreted.

### Verification Results

1.  **Unit Test**: A new unit test, `TestInterpreter_MethodCallOnExternalPointerType`, was created to specifically reproduce the bug by having the interpreter execute a function that calls a method on a pointer to an external type (`*locator.Locator`). After the fix, this test and all other unit tests passed successfully.
2.  **Limited-Scope E2E Test**: The `find-orphans` command was run with the scope limited to `minigo`, `symgo`, and `examples/minigo`. The `invalid indirect of <Unresolved Function: ...>` error, which was previously observed in this scenario, was successfully eliminated.
3.  **Full E2E Test**: The full `find-orphans` e2e test (`make -C examples/find-orphans e2e`) was run again with the fix in place.

**The test still timed out.**

### Revised Conclusion

The investigation and subsequent fix have been partially successful. A significant bug in the symbolic type resolution for external packages has been identified and fixed, improving the overall stability of the interpreter.

However, this bug was not the root cause of the e2e test timeout. The timeout is caused by a separate, deeper issue that only manifests when analyzing the entire workspace. The initial hypothesis was incorrect; while the "invalid indirect" error was a real problem, it was a symptom of the general instability, not the direct cause of the hang.

The next step in resolving the timeout will require a new investigation focused on performance profiling or identifying a different kind of recursive loop that is not related to the external type representation issue.

---

## Final Investigation (2025-09-03): Combinatorial Explosion

### Summary
Following the user's direction, a new investigation was launched without using a traditional profiler. Instead, detailed timing instrumentation was added directly to the `symgo` evaluator's main `Eval` function. This allowed for precise measurement of the time spent evaluating each AST node during the `find-orphans` e2e test. The results were definitive and pinpointed the exact source of the performance bottleneck.

### Findings
The timeout is not caused by an infinite loop, but by a **combinatorial explosion** of symbolic execution paths.

1.  **Location of Slowness:** The performance logs show that all significant delays (evaluations taking >10ms and growing to >300ms) occur when analyzing a single file: `scanner/scanner.go`.
2.  **The Bottleneck:** The primary bottleneck is the evaluation of a large `*ast.TypeSwitchStmt` within the `scanner.buildKey` function. This function is used recursively to generate a canonical string representation of a type.
3.  **The Cause:** This is a classic symbolic execution problem. When the `symgo` engine analyzes its own code (a form of meta-analysis), it encounters the complex `switch n := expr.(type)` statement in its own type-key-generation logic. Because the symbolic evaluator cannot know which branch the code will actually take for a given symbolic input, it must trace the execution of *all possible case branches*. Each of these branches contains further recursive calls to `buildKey`, which in turn contains its own `switch`. This creates a massive, branching tree of possible execution paths that the evaluator must explore, leading to exponential growth in workload and causing the timeout.

### Conclusion
The investigation successfully identified the root cause. The problem is not a simple bug but a fundamental performance limitation of the symbolic execution engine when analyzing code with highly complex, recursive, and branching control flow, which is characteristic of type resolvers and interpreters. The next step is to decide on a mitigation strategy, such as applying a targeted fix (e.g., a native intrinsic to short-circuit the analysis of `buildKey`) or a workaround (e.g., excluding `scanner.go` from the analysis scope in tests).
