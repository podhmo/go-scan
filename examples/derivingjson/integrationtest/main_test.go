package integrationtest

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings" // Added for strings.Contains
	"testing"
)

// TestUnmarshalAPIResponse tests the custom UnmarshalJSON functionality
// for APIResponse, which should be generated by the derivingjson generator.
func TestUnmarshalAPIResponse(t *testing.T) {
	fmt.Println("--- Unmarshaling Demo ---")

	// NOTE: The JSON samples have been slightly modified from the initial user request.
	// The "type" field values ("userprofile", "productinfo") match what the current
	// generator.go is expected to produce as discriminator values (lowercase of type name).
	// The original samples used "user_profile" and "product_info".
	// To make the generator use the original values, its discriminator detection logic
	// would need to be enhanced (e.g., by reading a struct tag or calling a method).
	jsonSamples := map[string]struct {
		jsonString       string
		wantErr          bool
		expectedStatus   string
		expectedDataType reflect.Type
		// We can add more specific checks for Data content if needed
	}{
		"Case 1: UserProfile": {
			jsonString:       `{"status":"ok","data":{"type":"userprofile","userId":"u-abc","userName":"Jiro"}}`,
			wantErr:          false,
			expectedStatus:   "ok",
			expectedDataType: reflect.TypeOf(&UserProfile{}),
		},
		"Case 2: ProductInfo": {
			jsonString:       `{"status":"ok","data":{"type":"productinfo","productId":"p-xyz","productName":"Mouse","price":5000}}`,
			wantErr:          false,
			expectedStatus:   "ok",
			expectedDataType: reflect.TypeOf(&ProductInfo{}),
		},
		"Case 3: Unknown Type": {
			// This will cause an error because "billing_info" is not a known type discriminator.
			jsonString: `{"status":"error","data":{"type":"billing_info","invoiceId":"i-123"}}`,
			wantErr:    true,
		},
		"Case 4: Invalid JSON in Data (missing type)": {
			// This will cause an error because the "type" field is missing in the data object.
			jsonString: `{"status":"error","data":{"invoiceId":"i-123"}}`,
			wantErr:    true,
		},
		"Case 5: Null Data": {
			jsonString:       `{"status":"ok","data":null}`,
			wantErr:          false,
			expectedStatus:   "ok",
			expectedDataType: nil, // Expect Data to be nil
		},
		"Case 6: Empty Data Object": {
			// This should also result in an error because 'type' field is missing.
			// The generated code's behavior for `aux.Data == "{}"` might lead to discriminator detection error.
			jsonString: `{"status":"error","data":{}}`,
			wantErr:    true,
		},
		"Case 7: Data field completely missing": {
			// This is valid if Data is omitempty or not required.
			// The current APIResponse struct does not use omitempty for Data.
			// Standard unmarshaling would leave Data as nil.
			// Our custom unmarshaler should behave similarly if aux.Data is not found (though json.RawMessage would be nil).
			// The Alias part handles this; aux.Data would be nil.
			jsonString:       `{"status":"ok_no_data"}`,
			wantErr:          false,
			expectedStatus:   "ok_no_data",
			expectedDataType: nil,
		},
	}

	for name, tc := range jsonSamples {
		t.Run(name, func(t *testing.T) {
			fmt.Printf("\n[%s]\n", name)
			fmt.Printf("Input JSON: %s\n", tc.jsonString)

			var response APIResponse
			// The UnmarshalJSON method for APIResponse is expected to be generated
			// in a file like models_deriving.go by the generator.
			err := json.Unmarshal([]byte(tc.jsonString), &response)

			if (err != nil) != tc.wantErr {
				t.Errorf("json.Unmarshal() error = %v, wantErr %v", err, tc.wantErr)
				return
			}

			if err != nil {
				fmt.Printf("Result: Unmarshal failed as expected! Error: %v\n", err)
			} else {
				fmt.Printf("Result: Unmarshal successful.\n")
				fmt.Printf("  - Response.Status: %s\n", response.Status)
				if response.Data != nil {
					fmt.Printf("  - Type of Response.Data: %T\n", response.Data)
					fmt.Printf("  - Value of Response.Data: %+v\n", response.Data)
				} else {
					fmt.Printf("  - Response.Data is nil\n")
				}

				if response.Status != tc.expectedStatus {
					t.Errorf("Expected Status %s, got %s", tc.expectedStatus, response.Status)
				}

				var currentDataType reflect.Type
				if response.Data != nil {
					currentDataType = reflect.TypeOf(response.Data)
				}

				if currentDataType != tc.expectedDataType {
					t.Errorf("Expected Response.Data type %v, got %v", tc.expectedDataType, currentDataType)
				}

				// Specific checks for UserProfile data
				if tc.expectedDataType == reflect.TypeOf(&UserProfile{}) && response.Data != nil {
					userProfile, ok := response.Data.(*UserProfile)
					if !ok {
						t.Errorf("Expected response.Data to be *UserProfile, but it's not")
					} else {
						if userProfile.UserID == "" || userProfile.UserName == "" {
							t.Errorf("UserProfile fields are not correctly unmarshaled: %+v", userProfile)
						}
					}
				}
				// Specific checks for ProductInfo data
				if tc.expectedDataType == reflect.TypeOf(&ProductInfo{}) && response.Data != nil {
					productInfo, ok := response.Data.(*ProductInfo)
					if !ok {
						t.Errorf("Expected response.Data to be *ProductInfo, but it's not")
					} else {
						if productInfo.ProductID == "" || productInfo.ProductName == "" || productInfo.Price == 0 {
							t.Errorf("ProductInfo fields are not correctly unmarshaled: %+v", productInfo)
						}
					}
				}
			}
		})
	}
}

func TestUnmarshalMultiOneOfStructs(t *testing.T) {
	// Import testify/assert
	// import "github.com/stretchr/testify/assert"
	// No, Go style is to have all imports at the top. I'll assume it's added or add it manually if needed after this block.
	// For now, let's write the test logic. If `assert` is not found by the linter, I'll add the import.
	// It's better to modify the imports separately if needed.

	t.Run("Scene: multiple different oneOf fields", func(t *testing.T) {
		sceneJSON := `
		{
			"name": "Park Scene",
			"main_animal": {"type": "dog", "breed": "Labrador", "noise": "Woof"},
			"main_vehicle": {"type": "bicycle", "gears": 5, "has_bell": true},
			"description": "A sunny day in the park."
		}`
		var scene Scene
		err := json.Unmarshal([]byte(sceneJSON), &scene)
		if err != nil {
			t.Fatalf("Scene unmarshal failed: %v", err)
		}

		if scene.Name != "Park Scene" {
			t.Errorf("Expected scene name 'Park Scene', got '%s'", scene.Name)
		}
		if scene.Description != "A sunny day in the park." {
			t.Errorf("Expected scene desc, got '%s'", scene.Description)
		}

		if scene.MainAnimal == nil {
			t.Fatal("scene.MainAnimal is nil")
		}
		dog, ok := scene.MainAnimal.(*Dog)
		if !ok {
			t.Fatalf("MainAnimal is not *Dog, it's %T", scene.MainAnimal)
		}
		if dog.Breed != "Labrador" {
			t.Errorf("Expected dog breed 'Labrador', got '%s'", dog.Breed)
		}
		if dog.Noise != "Woof" {
			t.Errorf("Expected dog noise 'Woof', got '%s'", dog.Noise)
		}

		if scene.MainVehicle == nil {
			t.Fatal("scene.MainVehicle is nil")
		}
		bicycle, ok := scene.MainVehicle.(*Bicycle)
		if !ok {
			t.Fatalf("MainVehicle is not *Bicycle, it's %T", scene.MainVehicle)
		}
		if bicycle.Gears != 5 {
			t.Errorf("Expected bicycle gears 5, got %d", bicycle.Gears)
		}
		if !bicycle.HasBell {
			t.Error("Expected bicycle to have a bell")
		}
	})

	t.Run("Scene: one field nil, other present", func(t *testing.T) {
		sceneJSONPartial := `
		{
			"name": "Quiet Morning",
			"main_animal": {"type": "cat", "color": "Black", "purr": true},
			"main_vehicle": null
		}`
		var scenePartial Scene
		err := json.Unmarshal([]byte(sceneJSONPartial), &scenePartial)
		if err != nil {
			t.Fatalf("Scene partial unmarshal failed: %v", err)
		}
		if scenePartial.Name != "Quiet Morning" {
			t.Errorf("Expected name 'Quiet Morning', got %s", scenePartial.Name)
		}
		if scenePartial.MainAnimal == nil {
			t.Fatal("scenePartial.MainAnimal is nil")
		}
		cat, ok := scenePartial.MainAnimal.(*Cat)
		if !ok {
			t.Fatalf("MainAnimal is not *Cat, it's %T", scenePartial.MainAnimal)
		}
		if cat.Color != "Black" {
			t.Errorf("Expected cat color 'Black', got %s", cat.Color)
		}
		if !cat.Purr {
			t.Error("Expected cat to purr")
		}
		if scenePartial.MainVehicle != nil {
			t.Errorf("Expected MainVehicle to be nil, got %T", scenePartial.MainVehicle)
		}
	})

	t.Run("Scene: both oneOf fields nil", func(t *testing.T) {
		sceneJSONBothNil := `
		{
			"name": "Empty Stage",
			"main_animal": null,
			"main_vehicle": null,
			"description": "Waiting for actors"
		}`
		var sceneBothNil Scene
		err := json.Unmarshal([]byte(sceneJSONBothNil), &sceneBothNil)
		if err != nil {
			t.Fatalf("Scene both nil unmarshal failed: %v", err)
		}
		if sceneBothNil.Name != "Empty Stage" {
			t.Errorf("Expected name 'Empty Stage', got %s", sceneBothNil.Name)
		}
		if sceneBothNil.MainAnimal != nil {
			t.Errorf("Expected MainAnimal to be nil, got %T", sceneBothNil.MainAnimal)
		}
		if sceneBothNil.MainVehicle != nil {
			t.Errorf("Expected MainVehicle to be nil, got %T", sceneBothNil.MainVehicle)
		}
	})

	t.Run("Parade: multiple oneOf fields of the same interface type", func(t *testing.T) {
		paradeJSON := `
		{
			"event_name": "Animal Parade",
			"lead_animal": {"type": "cat", "color": "Tabby", "purr": false},
			"trailing_animal": {"type": "dog", "breed": "Poodle", "noise": "Yip"},
			"floats": 3
		}`
		var parade Parade
		err := json.Unmarshal([]byte(paradeJSON), &parade)
		if err != nil {
			t.Fatalf("Parade unmarshal failed: %v", err)
		}
		if parade.EventName != "Animal Parade" {
			t.Errorf("Expected event name 'Animal Parade', got %s", parade.EventName)
		}
		if parade.Floats != 3 {
			t.Errorf("Expected 3 floats, got %d", parade.Floats)
		}

		if parade.LeadAnimal == nil {
			t.Fatal("parade.LeadAnimal is nil")
		}
		leadCat, ok := parade.LeadAnimal.(*Cat)
		if !ok {
			t.Fatalf("LeadAnimal not *Cat, is %T", parade.LeadAnimal)
		}
		if leadCat.Color != "Tabby" {
			t.Errorf("Expected lead cat color 'Tabby', got %s", leadCat.Color)
		}

		if parade.TrailingAnimal == nil {
			t.Fatal("parade.TrailingAnimal is nil")
		}
		trailingDog, ok := parade.TrailingAnimal.(*Dog)
		if !ok {
			t.Fatalf("TrailingAnimal not *Dog, is %T", parade.TrailingAnimal)
		}
		if trailingDog.Breed != "Poodle" {
			t.Errorf("Expected trailing dog breed 'Poodle', got %s", trailingDog.Breed)
		}
	})

	t.Run("PetOwner: two different oneOf fields", func(t *testing.T) {
		petOwnerJSON := `
		{
			"owner_name": "Alice",
			"pet_data": {"type": "goldfish", "name": "Finny", "bowl_shape": "round"},
			"accessory": {"type": "car", "make": "ToyCar", "wheels": 4}
		}`
		var owner PetOwner
		err := json.Unmarshal([]byte(petOwnerJSON), &owner)
		if err != nil {
			t.Fatalf("PetOwner unmarshal failed: %v", err)
		}
		if owner.OwnerName != "Alice" {
			t.Errorf("Expected owner name 'Alice', got %s", owner.OwnerName)
		}

		if owner.Pet == nil {
			t.Fatal("owner.Pet is nil")
		}
		goldfish, ok := owner.Pet.(*Goldfish)
		if !ok {
			t.Fatalf("Pet not *Goldfish, is %T", owner.Pet)
		}
		if goldfish.Name != "Finny" {
			t.Errorf("Expected goldfish name 'Finny', got %s", goldfish.Name)
		}

		if owner.Accessory == nil {
			t.Fatal("owner.Accessory is nil")
		}
		carAccessory, ok := owner.Accessory.(*Car)
		if !ok {
			t.Fatalf("Accessory not *Car, is %T", owner.Accessory)
		}
		if carAccessory.Make != "ToyCar" {
			t.Errorf("Expected car make 'ToyCar', got %s", carAccessory.Make)
		}
	})

	t.Run("PetOwner: valid pet, nil accessory", func(t *testing.T) {
		petOwnerValidPetNilAccessory := `
		{
			"owner_name": "Charlie",
			"pet_data": {"type": "goldfish", "name": "Bubbles", "bowl_shape": "square"},
			"accessory": null
		}`
		var ownerValidPet PetOwner
		err := json.Unmarshal([]byte(petOwnerValidPetNilAccessory), &ownerValidPet)
		if err != nil {
			t.Fatalf("PetOwner valid pet nil accessory unmarshal failed: %v", err)
		}
		if ownerValidPet.OwnerName != "Charlie" {
			t.Errorf("Expected name 'Charlie', got %s", ownerValidPet.OwnerName)
		}
		if ownerValidPet.Pet == nil {
			t.Fatal("ownerValidPet.Pet is nil")
		}
		bubbles, ok := ownerValidPet.Pet.(*Goldfish)
		if !ok {
			t.Fatalf("Pet not *Goldfish, is %T", ownerValidPet.Pet)
		}
		if bubbles.Name != "Bubbles" {
			t.Errorf("Expected pet name 'Bubbles', got %s", bubbles.Name)
		}
		if ownerValidPet.Accessory != nil {
			t.Errorf("Expected Accessory to be nil, got %T", ownerValidPet.Accessory)
		}
	})

	t.Run("Error Case: Scene with unknown animal type", func(t *testing.T) {
		sceneInvalidAnimalJSON := `
		{
			"name": "Error Scene",
			"main_animal": {"type": "dragon", "size": "large"},
			"main_vehicle": {"type": "car", "make": "Sedan", "wheels": 4}
		}`
		var sceneErrorStruct Scene
		err := json.Unmarshal([]byte(sceneInvalidAnimalJSON), &sceneErrorStruct)
		if err == nil {
			t.Errorf("Expected error for unknown animal type in Scene, but got nil")
		} else {
			fmt.Printf("Error for Scene with unknown animal (expected): %v\n", err)
			// Check if error message contains relevant info
			expectedErrorMsgPart := "unknown data type 'dragon' for field 'main_animal'"
			if !strings.Contains(err.Error(), expectedErrorMsgPart) {
				t.Errorf("Error message '%s' does not contain expected part '%s'", err.Error(), expectedErrorMsgPart)
			}
		}
	})

	t.Run("Error Case: Parade with one valid, one unknown animal type", func(t *testing.T) {
		paradeInvalidAnimalJSON := `
		{
			"event_name": "Mixed Parade",
			"lead_animal": {"type": "cat", "color": "Siamese"},
			"trailing_animal": {"type": "unicorn", "horn_length": 12}
		}`
		var paradeErrorStruct Parade
		err := json.Unmarshal([]byte(paradeInvalidAnimalJSON), &paradeErrorStruct)
		if err == nil {
			t.Errorf("Expected error for unknown trailing_animal type in Parade, but got nil")
		} else {
			fmt.Printf("Error for Parade with unknown animal (expected): %v\n", err)
			expectedErrorMsgPart := "unknown data type 'unicorn' for field 'trailing_animal'"
			if !strings.Contains(err.Error(), expectedErrorMsgPart) {
				t.Errorf("Error message '%s' does not contain expected part '%s'", err.Error(), expectedErrorMsgPart)
			}
		}
	})
}

// TestMarshalAPIResponse tests the custom MarshalJSON functionality.
func TestMarshalAPIResponse(t *testing.T) {
	t.Run("UserProfile", func(t *testing.T) {
		response := APIResponse{
			Status: "ok",
			Data: &UserProfile{
				UserID:   "u-123",
				UserName: "Taro",
			},
		}

		b, err := json.Marshal(response)
		if err != nil {
			t.Fatalf("json.Marshal() error = %v", err)
		}

		jsonString := string(b)
		fmt.Printf("Marshaled JSON (UserProfile): %s\n", jsonString)

		// Check for discriminator and other fields.
		if !strings.Contains(jsonString, `"type":"userprofile"`) {
			t.Errorf("marshaled JSON does not contain type discriminator for UserProfile")
		}
		if !strings.Contains(jsonString, `"userId":"u-123"`) {
			t.Errorf("marshaled JSON does not contain userId field")
		}
	})

	t.Run("ProductInfo", func(t *testing.T) {
		response := APIResponse{
			Status: "ok",
			Data: &ProductInfo{
				ProductID:   "p-456",
				ProductName: "Book",
				Price:       1500,
			},
		}

		b, err := json.Marshal(response)
		if err != nil {
			t.Fatalf("json.Marshal() error = %v", err)
		}

		jsonString := string(b)
		fmt.Printf("Marshaled JSON (ProductInfo): %s\n", jsonString)

		if !strings.Contains(jsonString, `"type":"productinfo"`) {
			t.Errorf("marshaled JSON does not contain type discriminator for ProductInfo")
		}
		if !strings.Contains(jsonString, `"productId":"p-456"`) {
			t.Errorf("marshaled JSON does not contain productId field")
		}
	})

	t.Run("NilData", func(t *testing.T) {
		response := APIResponse{
			Status: "ok",
			Data:   nil,
		}

		b, err := json.Marshal(response)
		if err != nil {
			t.Fatalf("json.Marshal() error = %v", err)
		}

		jsonString := string(b)
		fmt.Printf("Marshaled JSON (NilData): %s\n", jsonString)

		if !strings.Contains(jsonString, `"data":null`) {
			t.Errorf("marshaled JSON should have null for data field")
		}
	})
}

func TestMarshalMultiOneOfStructs(t *testing.T) {
	t.Run("Scene: with dog and bicycle", func(t *testing.T) {
		scene := Scene{
			Name: "Park Life",
			MainAnimal: &Dog{
				Breed: "Golden Retriever",
				Noise: "Bark",
			},
			MainVehicle: &Bicycle{
				Gears:   18,
				HasBell: true,
			},
		}

		b, err := json.Marshal(scene)
		if err != nil {
			t.Fatalf("json.Marshal() error = %v", err)
		}

		jsonString := string(b)
		fmt.Printf("Marshaled JSON (Scene): %s\n", jsonString)

		if !strings.Contains(jsonString, `"type":"dog"`) {
			t.Errorf("marshaled JSON does not contain type discriminator for Dog")
		}
		if !strings.Contains(jsonString, `"type":"bicycle"`) {
			t.Errorf("marshaled JSON does not contain type discriminator for Bicycle")
		}
		if !strings.Contains(jsonString, `"breed":"Golden Retriever"`) {
			t.Errorf("marshaled JSON does not contain breed")
		}
		if !strings.Contains(jsonString, `"gears":18`) {
			t.Errorf("marshaled JSON does not contain gears")
		}
	})

	t.Run("Parade: with cat and dog", func(t *testing.T) {
		parade := Parade{
			EventName: "Pet Parade",
			LeadAnimal: &Cat{
				Color: "black",
				Purr:  true,
			},
			TrailingAnimal: &Dog{
				Breed: "Poodle",
				Noise: "Yap",
			},
		}

		b, err := json.Marshal(parade)
		if err != nil {
			t.Fatalf("json.Marshal() error = %v", err)
		}

		jsonString := string(b)
		fmt.Printf("Marshaled JSON (Parade): %s\n", jsonString)

		if !strings.Contains(jsonString, `"type":"cat"`) {
			t.Errorf("marshaled JSON does not contain type discriminator for Cat")
		}
		if !strings.Contains(jsonString, `"type":"dog"`) {
			t.Errorf("marshaled JSON does not contain type discriminator for Dog")
		}
	})
}
