// Code generated by convert2 tool. DO NOT EDIT.
package gen

import (
	"context"
	"errors"
	"example.com/convert2/testdata/complex"
	"fmt"
	"strings"
)

// errorCollector collects errors with path tracking.
type errorCollector struct {
	maxErrors int
	errors    []error
	pathStack []string
}

func newErrorCollector(maxErrors int) *errorCollector {
	return &errorCollector{
		maxErrors: maxErrors,
		errors:    make([]error, 0),
		pathStack: make([]string, 0),
	}
}
func (ec *errorCollector) Add(reason string) bool {
	if ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors {
		return true
	}
	fullPath := strings.Join(ec.pathStack, "")
	err := fmt.Errorf("%s: %s", fullPath, reason)
	ec.errors = append(ec.errors, err)
	return ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors
}
func (ec *errorCollector) Addf(format string, args ...interface{}) bool {
	if ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors {
		return true
	}
	return ec.Add(fmt.Sprintf(format, args...))
}
func (ec *errorCollector) Enter(segment string) {
	// separator variable was unused, logic is directly handled below.
	if strings.HasPrefix(segment, "[") && strings.HasSuffix(segment, "]") { // Array/slice index
		ec.pathStack = append(ec.pathStack, segment)
	} else { // Field name
		if len(ec.pathStack) == 0 {
			ec.pathStack = append(ec.pathStack, segment)
		} else {
			ec.pathStack = append(ec.pathStack, "."+segment)
		}
	}
}
func (ec *errorCollector) Leave() {
	if len(ec.pathStack) > 0 {
		ec.pathStack = ec.pathStack[:len(ec.pathStack)-1]
	}
}
func (ec *errorCollector) Errors() []error {
	return ec.errors
}
func (ec *errorCollector) HasErrors() bool {
	return len(ec.errors) > 0
}
func (ec *errorCollector) MaxErrorsReached() bool {
	return ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors
}

func sourceUsingStructToDestUsingStruct(ctx context.Context, ec *errorCollector, src complex.SourceUsingStruct) complex.DestUsingStruct {
	dst := complex.DestUsingStruct{}
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

func validatedInputToValidatedInput(ctx context.Context, ec *errorCollector, src complex.ValidatedInput) complex.ValidatedInput {
	dst := complex.ValidatedInput{}
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field ValidatedInput.Name (string) to ValidatedInput.Name (string)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("Name")
	dst.Name = src.Name
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field ValidatedInput.Value (int) to ValidatedInput.Value (int)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("Value")
	dst.Value = src.Value
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Applying global validator rule: ValidateMyInput for type example.com/convert2/testdata/complex.ValidatedInput
	complex.ValidateMyInput(ec, &dst)
	if ec.MaxErrorsReached() {
		return dst
	}
	return dst
}

func addressRequestToAddress(ctx context.Context, ec *errorCollector, src complex.AddressRequest) complex.Address {
	dst := complex.Address{}
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

func userRequestToUser(ctx context.Context, ec *errorCollector, src complex.UserRequest) complex.User {
	dst := complex.User{}
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field UserRequest.ID (string) to User.ID (example.com/convert2/testdata/complex.UserID)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("ID")
	// No specific conversion rule or type match found for field ID (string) to ID (example.com/convert2/testdata/complex.UserID).
	ec.Addf("type mismatch or complex conversion not implemented for field 'ID' (string -> example.com/convert2/testdata/complex.UserID)")
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field UserRequest.Email (string) to User.UserEmail (string)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("UserEmail")
	dst.UserEmail = src.Email
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field UserRequest.Nicknames ([]string) to User.Nicknames ([]string)
	// Src: Ptr=false, ElemFull=string | Dst: Ptr=false, ElemFull=string
	ec.Enter("Nicknames")
	dst.Nicknames = src.Nicknames
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

func orderItemRequestToOrderItem(ctx context.Context, ec *errorCollector, src complex.OrderItemRequest) complex.OrderItem {
	dst := complex.OrderItem{}
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

func orderRequestToOrder(ctx context.Context, ec *errorCollector, src complex.OrderRequest) complex.Order {
	dst := complex.Order{}
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field OrderRequest.CustomerEmail (string) to Order.CustomerEmail (string)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("CustomerEmail")
	dst.CustomerEmail = src.CustomerEmail
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

func ConvertUserRequestToUser(ctx context.Context, src complex.UserRequest) (complex.User, error) {
	ec := newErrorCollector(0)
	dst := userRequestToUser(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

func ConvertValidatedInputToValidatedInput(ctx context.Context, src complex.ValidatedInput) (complex.ValidatedInput, error) {
	ec := newErrorCollector(0)
	dst := validatedInputToValidatedInput(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

func ConvertAddressRequestToAddress(ctx context.Context, src complex.AddressRequest) (complex.Address, error) {
	ec := newErrorCollector(0)
	dst := addressRequestToAddress(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

func ConvertOrderItemRequestToOrderItem(ctx context.Context, src complex.OrderItemRequest) (complex.OrderItem, error) {
	ec := newErrorCollector(0)
	dst := orderItemRequestToOrderItem(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

func ConvertOrderRequestToOrder(ctx context.Context, src complex.OrderRequest) (complex.Order, error) {
	ec := newErrorCollector(0)
	dst := orderRequestToOrder(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

func ConvertSourceUsingStructToDestUsingStruct(ctx context.Context, src complex.SourceUsingStruct) (complex.DestUsingStruct, error) {
	ec := newErrorCollector(0)
	dst := sourceUsingStructToDestUsingStruct(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
