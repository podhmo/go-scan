package generator

import (
	"bytes"
	"context"
	"fmt"
	"go/format"
	"reflect"
	"strings"
	"text/template"

	"example.com/convert/parser"
	"github.com/podhmo/go-scan"
	"github.com/podhmo/go-scan/scanner"
)

const codeTemplate = `
import (
	"context"
	{{- range $path, $alias := .Imports }}
	{{ $alias }} "{{ $path }}"
	{{- end }}
)

{{ range .Pairs }}
// {{ .ExportedFuncName }} converts {{ .SrcType.Name }} to {{ .DstType.Name }}.
func {{ .ExportedFuncName }}(ctx context.Context, src {{ .SrcType.Qualifier }}) ({{ .DstType.Qualifier }}, error) {
	dst := {{ .InternalFuncName }}(ctx, src)
	return dst, nil
}

// {{ .InternalFuncName }} is the internal conversion function.
func {{ .InternalFuncName }}(ctx context.Context, src {{ .SrcType.Qualifier }}) {{ .DstType.Qualifier }} {
	dst := {{ .DstType.Qualifier }}{}
	{{- range .Fields }}
	{{ getAssignment . "src" "dst" }}
	{{- end }}
	return dst
}
{{ end }}
`

type TemplateData struct {
	PackageName string
	Imports     map[string]string
	Pairs       []TemplatePair
}

type TemplatePair struct {
	ExportedFuncName string
	InternalFuncName string
	SrcType          QualifiedType
	DstType          QualifiedType
	Fields           []FieldMap
	im               *goscan.ImportManager
}

type FieldMap struct {
	SrcName     string
	DstName     string
	SrcField    *scanner.FieldInfo
	DstField    *scanner.FieldInfo
	IsSlice     bool
	IsMap       bool
	NeedsHelper bool
	UsingFunc   string
	im          *goscan.ImportManager
	SrcDef      *scanner.TypeInfo
	DstDef      *scanner.TypeInfo
}

type QualifiedType struct {
	Name      string
	Qualifier string
}

func Generate(s *goscan.Scanner, pkgname string, pairs []parser.ConversionPair, genPkgInfo *scanner.PackageInfo) ([]byte, error) {
	im := goscan.NewImportManager(genPkgInfo)
	im.Add("context", "context")

	worklist := make(map[string]bool)
	allPairs := make([]parser.ConversionPair, len(pairs))
	copy(allPairs, pairs)

	for _, pair := range pairs {
		key := fmt.Sprintf("%s_to_%s", pair.SrcTypeName, pair.DstTypeName)
		worklist[key] = true
	}

	i := 0
	for i < len(allPairs) {
		pair := allPairs[i]
		i++

		if pair.SrcInfo == nil || pair.SrcInfo.Struct == nil || pair.DstInfo == nil || pair.DstInfo.Struct == nil {
			continue
		}

		for _, field := range createFieldMaps(s, pair.SrcInfo, pair.DstInfo, im) {
			if field.NeedsHelper {
				var srcElem, dstElem *scanner.FieldType
				if field.IsSlice {
					srcElem = field.SrcField.Type.Elem
					dstElem = field.DstField.Type.Elem
				} else if field.IsMap {
					srcElem = field.SrcField.Type.Elem
					dstElem = field.DstField.Type.Elem
				} else {
					srcElem = field.SrcField.Type
					dstElem = field.DstField.Type
				}

				if srcElem == nil || dstElem == nil {
					continue
				}

				srcBase, dstBase := srcElem.GetBaseType(), dstElem.GetBaseType()
				if srcBase == nil || dstBase == nil {
					continue
				}

				helperKey := fmt.Sprintf("%s_to_%s", srcBase.Name, dstBase.Name)
				if !worklist[helperKey] {
					if field.SrcDef != nil && field.DstDef != nil {
						allPairs = append(allPairs, parser.ConversionPair{
							SrcTypeName: field.SrcDef.Name,
							DstTypeName: field.DstDef.Name,
							SrcInfo:     field.SrcDef,
							DstInfo:     field.DstDef,
						})
						worklist[helperKey] = true
					}
				}
			}
		}
	}

	templatePairs := make([]TemplatePair, 0, len(allPairs))
	for _, pair := range allPairs {
		if pair.SrcInfo == nil || pair.DstInfo == nil {
			continue
		}

		srcQualifier := im.Qualify(pair.SrcPkgImportPath, pair.SrcInfo.Name)
		dstQualifier := im.Qualify(pair.DstPkgImportPath, pair.DstInfo.Name)

		fieldMaps := createFieldMaps(s, pair.SrcInfo, pair.DstInfo, im)

		templatePairs = append(templatePairs, TemplatePair{
			ExportedFuncName: fmt.Sprintf("Convert%sTo%s", pair.SrcTypeName, pair.DstTypeName),
			InternalFuncName: fmt.Sprintf("convert%sTo%s", pair.SrcTypeName, pair.DstTypeName),
			SrcType:          QualifiedType{Name: pair.SrcTypeName, Qualifier: srcQualifier},
			DstType:          QualifiedType{Name: pair.DstTypeName, Qualifier: dstQualifier},
			Fields:           fieldMaps,
			im:               im,
		})
	}

	imports := im.Imports()
	delete(imports, "context")

	templateData := TemplateData{
		PackageName: pkgname,
		Imports:     imports,
		Pairs:       templatePairs,
	}

	funcMap := template.FuncMap{
		"getAssignment": getAssignment,
	}

	tmpl, err := template.New("converter").Funcs(funcMap).Parse(codeTemplate)
	if err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	header := fmt.Sprintf("// Code generated by go-scan. DO NOT EDIT.\n\npackage %s\n\n", pkgname)
	finalCode := append([]byte(header), buf.Bytes()...)

	formatted, err := format.Source(finalCode)
	if err != nil {
		return nil, fmt.Errorf("failed to format generated code: %w\n---\n%s\n---", err, string(finalCode))
	}

	return formatted, nil
}

func getAssignment(field FieldMap, srcVar, dstVar string) string {
	src := fmt.Sprintf("%s.%s", srcVar, field.SrcName)
	dst := fmt.Sprintf("%s.%s", dstVar, field.DstName)

	if field.UsingFunc != "" {
		// TODO: Handle error collector if needed
		return fmt.Sprintf("%s = %s(%s)", dst, field.UsingFunc, src)
	}

	if field.DstField.Type.FullImportPath() != "" {
		field.im.Add(field.DstField.Type.FullImportPath(), "")
	}

	if field.IsSlice {
		return generateSliceConversion(src, dst, field.SrcField.Type, field.DstField.Type, field)
	}
	if field.IsMap {
		return generateMapConversion(src, dst, field.SrcField.Type, field.DstField.Type, field)
	}
	return generatePointerValueConversion(src, dst, field.SrcField.Type, field.DstField.Type, field)
}

func generateSliceConversion(src, dst string, srcType, dstType *scanner.FieldType, field FieldMap) string {
	srcElem := srcType.Elem
	dstElem := dstType.Elem
	if srcElem == nil || dstElem == nil {
		return fmt.Sprintf("// TODO: Cannot determine slice element types for %s", src)
	}

	helperFuncName := ""
	if field.NeedsHelper && field.SrcDef != nil && field.DstDef != nil {
		helperFuncName = fmt.Sprintf("convert%sTo%s", field.SrcDef.Name, field.DstDef.Name)
	}

	dstSliceTypeQualifier := getQualifiedSliceType(dstType, field.im)

	var conversionLogic string
	if helperFuncName != "" {
		call := fmt.Sprintf("%s(ctx, elem)", helperFuncName)
		if srcElem.IsPointer {
			call = fmt.Sprintf("%s(ctx, *elem)", helperFuncName)
		}

		if dstElem.IsPointer {
			if srcElem.IsPointer {
				conversionLogic = fmt.Sprintf("if elem != nil {\n\t\t\ttmp := %s\n\t\t\tnewSlice = append(newSlice, &tmp)\n\t\t}", call)
			} else {
				conversionLogic = fmt.Sprintf("tmp := %s\n\t\tnewSlice = append(newSlice, &tmp)", call)
			}
		} else {
			if srcElem.IsPointer {
				conversionLogic = fmt.Sprintf("if elem != nil {\n\t\t\tnewSlice = append(newSlice, %s)\n\t\t}", call)
			} else {
				conversionLogic = fmt.Sprintf("newSlice = append(newSlice, %s)", call)
			}
		}
	} else {
		assign := "elem"
		if srcElem.IsPointer {
			assign = "*elem"
		}

		if dstElem.IsPointer {
			if srcElem.IsPointer {
				conversionLogic = fmt.Sprintf("if elem != nil { tmp := %s; newSlice = append(newSlice, &tmp) }", assign)
			} else {
				conversionLogic = fmt.Sprintf("tmp := %s\n\t\tnewSlice = append(newSlice, &tmp)", assign)
			}
		} else {
			if srcElem.IsPointer {
				conversionLogic = fmt.Sprintf("if elem != nil { newSlice = append(newSlice, %s) }", assign)
			} else {
				conversionLogic = fmt.Sprintf("newSlice = append(newSlice, %s)", assign)
			}
		}
	}

	return fmt.Sprintf(`if %s != nil {
		newSlice := make(%s, 0, len(%s))
		for _, elem := range %s {
			%s
		}
		%s = newSlice
	}`, src, dstSliceTypeQualifier, src, src, conversionLogic, dst)
}

func generateMapConversion(src, dst string, srcType, dstType *scanner.FieldType, field FieldMap) string {
	srcKey := srcType.MapKey
	srcValue := srcType.Elem
	dstKey := dstType.MapKey
	dstValue := dstType.Elem

	if srcKey == nil || srcValue == nil || dstKey == nil || dstValue == nil {
		return fmt.Sprintf("// TODO: Cannot determine map key/value types for %s", src)
	}

	keyConversion := "key"
	helperFuncName := ""
	if field.NeedsHelper && field.SrcDef != nil && field.DstDef != nil {
		helperFuncName = fmt.Sprintf("convert%sTo%s", field.SrcDef.Name, field.DstDef.Name)
	}

	var valueConversion string
	if helperFuncName != "" {
		call := fmt.Sprintf("%s(ctx, value)", helperFuncName)
		if srcValue.IsPointer {
			call = fmt.Sprintf("%s(ctx, *value)", helperFuncName)
		}

		if dstValue.IsPointer {
			if srcValue.IsPointer {
				valueConversion = fmt.Sprintf("if value != nil { tmp := %s; newMap[%s] = &tmp }", call, keyConversion)
			} else {
				valueConversion = fmt.Sprintf("tmp := %s; newMap[%s] = &tmp", call, keyConversion)
			}
		} else {
			if srcValue.IsPointer {
				valueConversion = fmt.Sprintf("if value != nil { newMap[%s] = %s }", keyConversion, call)
			} else {
				valueConversion = fmt.Sprintf("newMap[%s] = %s", keyConversion, call)
			}
		}
	} else {
		assign := "value"
		if srcValue.IsPointer {
			assign = "*value"
		}

		if dstValue.IsPointer {
			if srcValue.IsPointer {
				valueConversion = fmt.Sprintf("if value != nil { tmp := %s; newMap[%s] = &tmp }", assign, keyConversion)
			} else {
				valueConversion = fmt.Sprintf("tmp := %s; newMap[%s] = &tmp", assign, keyConversion)
			}
		} else {
			if srcValue.IsPointer {
				valueConversion = fmt.Sprintf("if value != nil { newMap[%s] = %s }", keyConversion, assign)
			} else {
				valueConversion = fmt.Sprintf("newMap[%s] = %s", keyConversion, assign)
			}
		}
	}

	dstMapTypeQualifier := getQualifiedMapType(dstType, field.im)

	return fmt.Sprintf(`if %s != nil {
		newMap := make(%s, len(%s))
		for key, value := range %s {
			%s
		}
		%s = newMap
	}`, src, dstMapTypeQualifier, src, src, valueConversion, dst)
}

func getQualifiedSliceType(sliceType *scanner.FieldType, im *goscan.ImportManager) string {
	elemQualifier := im.Qualify(sliceType.Elem.FullImportPath(), sliceType.Elem.Name)
	if sliceType.Elem.IsPointer {
		elemQualifier = "*" + elemQualifier
	}
	return fmt.Sprintf("[]%s", elemQualifier)
}

func getQualifiedMapType(mapType *scanner.FieldType, im *goscan.ImportManager) string {
	keyQualifier := im.Qualify(mapType.MapKey.FullImportPath(), mapType.MapKey.Name)
	if mapType.MapKey.IsPointer {
		keyQualifier = "*" + keyQualifier
	}
	valueQualifier := im.Qualify(mapType.Elem.FullImportPath(), mapType.Elem.Name)
	if mapType.Elem.IsPointer {
		valueQualifier = "*" + valueQualifier
	}
	return fmt.Sprintf("map[%s]%s", keyQualifier, valueQualifier)
}

func generatePointerValueConversion(src, dst string, srcType, dstType *scanner.FieldType, field FieldMap) string {
	srcIsPtr := srcType.IsPointer
	dstIsPtr := dstType.IsPointer

	helperFunc := ""
	if field.NeedsHelper {
		srcBaseType := srcType.GetBaseType()
		dstBaseType := dstType.GetBaseType()
		if srcBaseType != nil && dstBaseType != nil {
			helperFunc = fmt.Sprintf("convert%sTo%s", srcBaseType.Name, dstBaseType.Name)
		}
	}

	if !srcIsPtr && !dstIsPtr { // value -> value
		if helperFunc != "" {
			return fmt.Sprintf("%s = %s(ctx, %s)", dst, helperFunc, src)
		}
		return fmt.Sprintf("%s = %s", dst, src)
	}
	if srcIsPtr && !dstIsPtr { // *value -> value
		if helperFunc != "" {
			return fmt.Sprintf("if %s != nil {\n\t\t%s = %s(ctx, *%s)\n\t}", src, dst, helperFunc, src)
		}
		return fmt.Sprintf("if %s != nil {\n\t\t%s = *%s\n\t}", src, dst, src)
	}
	if !srcIsPtr && dstIsPtr { // value -> *value
		if helperFunc != "" {
			return fmt.Sprintf("{\n\t\ttmp := %s(ctx, %s)\n\t\t%s = &tmp\n\t}", helperFunc, src, dst)
		}
		return fmt.Sprintf("{\n\t\ttmp := %s\n\t\t%s = &tmp\n\t}", src, dst)
	}
	if srcIsPtr && dstIsPtr { // *value -> *value
		if helperFunc != "" {
			return fmt.Sprintf("if %s != nil {\n\t\ttmp := %s(ctx, *%s)\n\t\t%s = &tmp\n\t}", src, helperFunc, src, dst)
		}
		return fmt.Sprintf("if %s != nil {\n\t\ttmp := *%s\n\t\t%s = &tmp\n\t}", src, src, dst)
	}
	return fmt.Sprintf("// TODO: Conversion not implemented for %s -> %s", srcType.Name, dstType.Name)
}


func parseConvertTag(tag reflect.StructTag) (parser.ConvertTag, error) {
	raw := tag.Get("convert")
	if raw == "" {
		return parser.ConvertTag{}, nil
	}

	parts := strings.Split(raw, ",")
	result := parser.ConvertTag{
		DstFieldName: parts[0],
		RawValue:     raw,
	}

	for _, part := range parts[1:] {
		switch {
		case strings.HasPrefix(part, "using="):
			result.UsingFunc = strings.TrimPrefix(part, "using=")
		case part == "required":
			result.Required = true
		default:
			return parser.ConvertTag{}, fmt.Errorf("unknown convert tag option: %q", part)
		}
	}
	return result, nil
}

func createFieldMaps(s *goscan.Scanner, srcStruct, dstStruct *scanner.TypeInfo, im *goscan.ImportManager) []FieldMap {
	var fieldMaps []FieldMap
	if srcStruct.Struct == nil || dstStruct.Struct == nil {
		return nil
	}

	dstFields := make(map[string]*scanner.FieldInfo)
	for _, field := range dstStruct.Struct.Fields {
		dstFields[field.Name] = field
	}

	for _, srcFieldInfo := range srcStruct.Struct.Fields {
		tag, _ := parseConvertTag(reflect.StructTag(srcFieldInfo.Tag))
		if tag.DstFieldName == "-" {
			continue // Skip field
		}

		dstFieldName := tag.DstFieldName
		if dstFieldName == "" {
			dstFieldName = srcFieldInfo.Name
		}

		srcScannerField := srcFieldInfo
		dstScannerField, ok := dstFields[dstFieldName]
		if !ok || srcScannerField == nil || dstScannerField == nil {
			continue // No corresponding destination field or field info is nil
		}

		srcType := srcScannerField.Type
		dstType := dstScannerField.Type
		var needsHelper bool
		var srcDef, dstDef *scanner.TypeInfo

		if srcType != nil && dstType != nil {
			checkTypeSrc, checkTypeDst := srcType.GetBaseTypeForCheck(), dstType.GetBaseTypeForCheck()
			if checkTypeSrc != nil && checkTypeDst != nil {
				checkTypeSrc.SetResolver(s)
				checkTypeDst.SetResolver(s)
				srcDef, _ = checkTypeSrc.Resolve(context.Background(), make(map[string]struct{}))
				dstDef, _ = checkTypeDst.Resolve(context.Background(), make(map[string]struct{}))
				needsHelper = (srcDef != nil && srcDef.Struct != nil) && (dstDef != nil && dstDef.Struct != nil)
			}
		}

		fieldMaps = append(fieldMaps, FieldMap{
			SrcName:     srcFieldInfo.Name,
			DstName:     dstFieldName,
			SrcField:    srcScannerField,
			DstField:    dstScannerField,
			IsSlice:     srcType != nil && srcType.IsSlice,
			IsMap:       srcType != nil && srcType.IsMap,
			NeedsHelper: needsHelper && tag.UsingFunc == "", // using overrides helper
			UsingFunc:   tag.UsingFunc,
			im:          im,
			SrcDef:      srcDef,
			DstDef:      dstDef,
		})
	}

	return fieldMaps
}
