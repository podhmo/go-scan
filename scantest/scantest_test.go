package scantest

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"

	scan "github.com/podhmo/go-scan"
)

func TestWriteFiles(t *testing.T) {
	files := map[string]string{
		"go.mod":  "module example.com/me",
		"main.go": `package main`,
	}

	dir, cleanup := WriteFiles(t, files)
	defer cleanup()

	for name, content := range files {
		path := filepath.Join(dir, name)
		data, err := os.ReadFile(path)
		if err != nil {
			t.Errorf("ReadFile(%q): %v", path, err)
			continue
		}
		if string(data) != content {
			t.Errorf("expected content of %q is %q, but got %q", name, content, string(data))
		}
	}
}

func TestRun_PureCheck(t *testing.T) {
	dir, cleanup := WriteFiles(t, map[string]string{
		"go.mod":    "module example.com/me",
		"person.go": `package main; type Person struct { Name string }`,
	})
	defer cleanup()

	action := func(ctx context.Context, s *scan.Scanner, pkgs []*scan.Package) error {
		if len(pkgs) == 0 {
			return fmt.Errorf("no packages found")
		}
		if pkgs[0].Name != "main" {
			return fmt.Errorf("package name is not main, got %s", pkgs[0].Name)
		}
		personType := pkgs[0].Lookup("Person")
		if personType == nil {
			return fmt.Errorf("type Person not found")
		}
		return nil
	}

	result, err := Run(t, dir, []string{"."}, action)
	if err != nil {
		t.Fatal(err)
	}
	if result != nil {
		t.Errorf("expected a nil result for a pure check, but got %+v", result)
	}
}

func TestRun_GenerateFile(t *testing.T) {
	dir, cleanup := WriteFiles(t, map[string]string{
		"go.mod":  "module example.com/me",
		"main.go": "package main",
	})
	defer cleanup()

	generateAction := func(ctx context.Context, s *scan.Scanner, pkgs []*scan.Package) error {
		// This uses the context-aware scan.WriteFile via SaveGoFile
		pd := scan.NewPackageDirectory(dir, "main")
		gf := scan.GoFile{
			CodeSet: "// Code generated by test",
		}
		return pd.SaveGoFile(ctx, gf, "main_gen.go")
	}

	result, err := Run(t, dir, []string{"."}, generateAction)
	if err != nil {
		t.Fatal(err)
	}

	if result == nil {
		t.Fatal("expected a non-nil result for a file generation action")
	}
	if len(result.Outputs) != 1 {
		t.Fatalf("expected 1 generated file, but got %d", len(result.Outputs))
	}

	content, ok := result.Outputs["main_gen.go"]
	if !ok {
		t.Fatal("expected file 'main_gen.go' was not in the result")
	}
	if !strings.Contains(string(content), "Code generated by test") {
		t.Errorf("generated file content is not what was expected")
	}
}

func TestRun_WithReplaceDirective(t *testing.T) {
	// Create a temporary directory structure that requires a `replace` directive.
	// root/
	//   - go.mod (module example.com/me)
	//   - project/
	//     - go.mod (module example.com/project, replace example.com/lib => ../lib)
	//     - main.go (imports example.com/lib)
	//   - lib/
	//     - go.mod (module example.com/lib)
	//     - lib.go (defines type Thing)

	tmpDir := t.TempDir()

	// Create lib module
	libDir := filepath.Join(tmpDir, "lib")
	if err := os.Mkdir(libDir, 0755); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(filepath.Join(libDir, "go.mod"), []byte("module example.com/lib"), 0644); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(filepath.Join(libDir, "lib.go"), []byte("package lib; type Thing struct { Name string }"), 0644); err != nil {
		t.Fatal(err)
	}

	// Create project module
	projectDir := filepath.Join(tmpDir, "project")
	if err := os.Mkdir(projectDir, 0755); err != nil {
		t.Fatal(err)
	}
	projectGoMod := `
module example.com/project
go 1.18
replace example.com/lib => ../lib
`
	if err := os.WriteFile(filepath.Join(projectDir, "go.mod"), []byte(projectGoMod), 0644); err != nil {
		t.Fatal(err)
	}
	projectMainGo := `
package main
import "example.com/lib"
type Model struct {
    Thing lib.Thing
}
`
	if err := os.WriteFile(filepath.Join(projectDir, "main.go"), []byte(projectMainGo), 0644); err != nil {
		t.Fatal(err)
	}

	// Action to verify that the type from the replaced module is resolved
	action := func(ctx context.Context, s *scan.Scanner, pkgs []*scan.Package) error {
		if len(pkgs) == 0 {
			return fmt.Errorf("no packages found")
		}
		pkg := pkgs[0]
		modelType := pkg.Lookup("Model")
		if modelType == nil {
			return fmt.Errorf("type Model not found")
		}
		if modelType.Struct == nil || len(modelType.Struct.Fields) == 0 {
			return fmt.Errorf("Model struct is empty")
		}
		thingField := modelType.Struct.Fields[0]
		if thingField.Type.Name != "lib.Thing" {
			return fmt.Errorf("expected field type name to be 'lib.Thing', got %q", thingField.Type.Name)
		}

		// Try to resolve the field type
		resolvedType, err := s.ResolveType(ctx, thingField.Type)
		if err != nil {
			return fmt.Errorf("failed to resolve lib.Thing: %w", err)
		}
		if resolvedType == nil {
			return fmt.Errorf("resolved lib.Thing is nil")
		}
		if resolvedType.Name != "Thing" {
			return fmt.Errorf("expected resolved type name to be 'Thing', got %q", resolvedType.Name)
		}
		if resolvedType.PkgPath != "example.com/lib" {
			return fmt.Errorf("expected resolved type package path to be 'example.com/lib', got %q", resolvedType.PkgPath)
		}
		return nil
	}

	// Run the test on the project directory
	_, err := Run(t, projectDir, []string{"."}, action)
	if err != nil {
		t.Fatalf("Run failed: %v", err)
	}
}
