# `symgo`における "not a function: NIL" エラーの調査と解決

## 1. 当初の問題

`make -C examples/find-orphans` を実行すると、`find-orphans.out` に `level=ERROR msg="not a function: NIL"` というエラーが記録される。このエラーは `examples/minigo/main_test.go` の解析中に発生していた。

## 2. 調査の経緯と誤った仮説

### 仮説1: if文の評価ロジックの欠陥

当初、`if f != nil { f() }` のようなコードで、条件式 `f != nil` が `false` と評価されても、`symgo` が `if` の `then` ブロックを探索してしまうことが問題だと考えた。

この仮説に基づき、`evalIfStmt` と `evalBinaryExpr` を修正し、条件が具体的な真偽値に解決される場合は、到達不可能な分岐を評価しないように変更した。

しかし、このアプローチはリポジトリ全体のテストスイートを失敗させた。`symgo` はシンボリック実行エンジン（トレーサー）であり、**意図的に両方の分岐を探索するのが正しい設計**であったため、この修正は `symgo` の基本設計に反していた。

### 仮説2: 関数呼び出し間の状態汚染

`helper(myFunc1)` -> `helper(nil)` -> `helper(myFunc2)` のような一連の呼び出しで、`helper(nil)` の引数が後続の `helper(myFunc2)` の呼び出しに影響を与えている（状態を汚染している）のではないかと考えた。

しかし、詳細なデバッグの結果、呼び出し間で環境（スコープ）は正しく分離されており、状態の汚染は発生していないことが確認された。

## 3. 真の根本原因

`symgo` がシンボリックトレーサーとして、到達不可能なパス（`f` が `nil` のときの `f()` 呼び出し）を探索すること自体は、仕様通りの正しい挙動である。

真の問題は、その**到達不可能なパスを探索した結果、`nil` を関数として呼び出そうとした際に、解析全体を停止させてしまう致命的なエラーを発生させていた**点にある。シンボリック実行においては、このようなケースはエラーとして処理するのではなく、そのパスの評価を穏やかに終了させるべきである。

## 4. 最終的な解決策

この問題を解決するため、最も影響範囲が狭く、かつシンボリック実行の原則に沿った修正を行う。

関数呼び出しを処理する `evalCallExpr` (`symgo/evaluator/evaluator_eval_call_expr.go`) の段階で、呼び出し対象のオブジェクトが `*object.Nil` であるかをチェックする。もし `nil` であれば、致命的なエラーを発生させる `applyFunction` を呼び出す前に、即座に評価を終了して `nil` を返すようにする。

これにより、エンジンは到達不可能なパスを探索してもエラーで停止することなく、解析全体を正常に続行できる。

### 5. 修正後の挙動の検証

この修正により、以下のようなシナリオでも `symgo` は正しく動作する。

**シナリオ:**
```go
if f != nil {
    f()
    g()
}
```

**`f` が `nil` の場合の評価フロー:**

1.  `symgo` は `if` ブロック内を探索する。
2.  最初の文 `f()` が評価される。
3.  `evalCallExpr` は `f` が `nil` であることを検知し、エラーを発生させることなく `nil` を返して評価を穏やかに終了する。
4.  ブロック内の評価は中断されず、次の文 `g()` の評価に進む。
5.  `g()` は正常に解析される。

これにより、到達不可能なパスの探索中に発生した `nil` 関数呼び出しが、後続の文の解析を妨げることがなくなり、トレーサーとしての一貫した挙動が保証される。