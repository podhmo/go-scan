package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"
	"text/template"

	"example.com/convert/parser"
	"github.com/podhmo/go-scan"
	"github.com/podhmo/go-scan/scanner"
)

const codeTemplate = `
import (
	"context"
	{{- range $path, $alias := .Imports }}
	{{ $alias }} "{{ $path }}"
	{{- end }}
)

{{ range .Pairs }}
// {{ .ExportedFuncName }} converts {{ .SrcType.Name }} to {{ .DstType.Name }}.
func {{ .ExportedFuncName }}(ctx context.Context, src {{ .SrcType.Qualifier }}) ({{ .DstType.Qualifier }}, error) {
	// In the future, this will use an error collector.
	// For now, we just call the internal function.
	dst := {{ .InternalFuncName }}(ctx, src)
	return dst, nil
}

// {{ .InternalFuncName }} is the internal conversion function.
func {{ .InternalFuncName }}(ctx context.Context, src {{ .SrcType.Qualifier }}) {{ .DstType.Qualifier }} {
	dst := {{ .DstType.Qualifier }}{}
	{{- range .Fields }}
	{{- if .IsPointer }}
	if src.{{ .SrcName }} != nil {
		dst.{{ .DstName }} = *src.{{ .SrcName }}
	}
	{{- else }}
	dst.{{ .DstName }} = src.{{ .SrcName }}
	{{- end }}
	{{- end }}
	return dst
}
{{ end }}
`

type TemplateData struct {
	PackageName string
	Imports     map[string]string
	Pairs       []TemplatePair
}

type TemplatePair struct {
	ExportedFuncName string
	InternalFuncName string
	SrcType          QualifiedType
	DstType          QualifiedType
	Fields           []FieldMap
}

type FieldMap struct {
	SrcName   string
	DstName   string
	IsPointer bool
}

type QualifiedType struct {
	Name      string
	Qualifier string
}

// Generate generates the Go code for the conversion functions.
func Generate(packageName string, pairs []parser.ConversionPair, pkgInfo *scanner.PackageInfo) ([]byte, error) {
	// The import manager should be initialized with the context of the *target* package, not the source.
	im := goscan.NewImportManager(&scanner.PackageInfo{ImportPath: "example.com/convert/" + packageName})
	im.Add("context", "context")

	templatePairs := make([]TemplatePair, 0, len(pairs))

	for _, pair := range pairs {
		if pair.SrcType.Struct == nil || pair.DstType.Struct == nil {
			continue
		}

		srcQualifier := im.Qualify(pkgInfo.ImportPath, pair.SrcType.Name)
		dstQualifier := im.Qualify(pair.DstPkgImportPath, pair.DstType.Name)

		fieldMaps := createFieldMaps(pair.SrcType.Struct, pair.DstType.Struct)

		templatePair := TemplatePair{
			ExportedFuncName: fmt.Sprintf("Convert%sTo%s", pair.SrcType.Name, pair.DstType.Name),
			InternalFuncName: fmt.Sprintf("convert%sTo%s", pair.SrcType.Name, pair.DstType.Name),
			SrcType: QualifiedType{
				Name:      pair.SrcType.Name,
				Qualifier: srcQualifier,
			},
			DstType: QualifiedType{
				Name:      pair.DstType.Name,
				Qualifier: dstQualifier,
			},
			Fields: fieldMaps,
		}
		templatePairs = append(templatePairs, templatePair)
	}

	imports := im.Imports()
	delete(imports, "context")

	templateData := TemplateData{
		PackageName: packageName,
		Imports:     imports,
		Pairs:       templatePairs,
	}

	tmpl, err := template.New("converter").Parse(strings.TrimSpace(codeTemplate))
	if err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	header := fmt.Sprintf("// Code generated by go-scan for package %s. DO NOT EDIT.\n\npackage %s\n\n", packageName, packageName)
	finalCode := append([]byte(header), buf.Bytes()...)

	formatted, err := format.Source(finalCode)
	if err != nil {
		return nil, fmt.Errorf("failed to format generated code: %w\n---\n%s\n---", err, string(finalCode))
	}

	return formatted, nil
}

func createFieldMaps(srcStruct, dstStruct *scanner.StructInfo) []FieldMap {
	var fieldMaps []FieldMap
	dstFields := make(map[string]*scanner.FieldInfo)
	for _, field := range dstStruct.Fields {
		dstFields[field.Name] = field
	}

	for _, srcField := range srcStruct.Fields {
		if dstField, ok := dstFields[srcField.Name]; ok {
			// In a real scenario, we would check for type compatibility.
			// For now, we just map by name.
			_ = dstField // dstField is currently unused but would be needed for type checks.
			fieldMaps = append(fieldMaps, FieldMap{
				SrcName:   srcField.Name,
				DstName:   srcField.Name, // Assume same name for now
				IsPointer: srcField.Type.IsPointer,
			})
		}
	}

	return fieldMaps
}
