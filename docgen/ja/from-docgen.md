# docgenとsymgoの現状分析と将来の展望

このドキュメントは、`go-scan`リポジトリの`symgo`エンジンと、それを利用する`docgen`ツールの現状を分析し、発見された課題と将来必要とされる機能についてまとめたものです。

分析は`docs/plan-symbolic-execution-like.md`で概説されている設計思想と、現在の`symgo`および`examples/docgen`の実装を比較することによって行われました。

## 1. 設計計画と実装の現状

まず、設計ドキュメントに記載されたマイルストーンと、現在の実装状況を比較します。

| 機能フェーズ | 計画内容 | 実装状況 |
| :--- | :--- | :--- |
| **フェーズ1: 基礎エンジン** | `symgo`のコア（Evaluator, Scope, Object）とintrinsicの仕組み | ✅ **実装済み** |
| **フェーズ2: 基本的なルート抽出** | `docgen`の骨格、`http.HandleFunc`からパスとメソッドを抽出 | ✅ **実装済み** |
| **フェーズ3: 詳細なハンドラ分析** | `json.Decode`/`Encode`等のパターンを分析し、リクエスト/レスポンスの型を特定 | 🟡 **部分的に実装済み** |
| **フェーズ4: 応用的な機能強化**| ヘルパー関数の追跡、`fmt.Sprintf`等のサポート | 🟡 **部分的に実装済み** |
| **フェーズ5: OpenAPI生成** | 収集した情報からOpenAPIドキュメントを生成 | ✅ **実装済み** |

全体として、`symgo`は設計思想のコア部分を実装しており、`docgen`はそれを利用して基本的なOpenAPI仕様を生成できる段階にあります。

しかし、「部分的実装」とした項目には、実用性を高める上で重要なギャップが残されています。

## 2. 発見されたギャップと不足機能

詳細な分析を通じて、以下の課題が明らかになりました。

### 2.1. 未実装および不完全な機能

計画にありながら実装されていない、あるいは実装が不完全な機能です。

*   **`fmt.Sprintf`の未サポート**:
    設計書では文字列結合の重要なパターンとして挙げられていましたが、`symgo`のintrinsicとして実装されていません。これにより、パスやレスポンスの一部が動的に生成される一般的なケースに対応できません。
*   **不完全な制御フロー分析**:
    - `if`文の評価において`else`ブロックが無視されます。これにより、エラーケースなど`else`側で定義されたレスポンスのパターンが検出されません。
    - `for`文の評価はループボディを1回実行するのみで、実質的にループ内のパターンを1度だけスキャンするだけに留まっています。

### 2.2. デバッグの難しさ（実行の不透明性）

ユーザーから指摘があった通り、現在の`symgo`および`docgen`は「なぜその結果になったのか」を追跡することが非常に困難です。

*   **限定的な実行トレース**:
    `symgo`の内部には関数呼び出しを追跡する`callStack`ログが存在しますが、これは`symgo`開発者向けのものであり、`docgen`の利用者が簡単に使えるものではありません。また、追跡できるのは関数呼び出しのみで、変数への代入や条件分岐の評価といった詳細なステップは追跡できません。
*   **エラーメッセージの位置情報欠如**:
    「識別子 `x` が見つかりません」といったエラーが発生しても、ソースコードのどのファイル・どの行でその問題が発生したのかが示されません。これにより、問題の特定と修正が著しく困難になっています。

### 2.3. モジュール境界の扱いの複雑さ

計画書では「モジュール内（Intra-Module）」と「モジュール外（Extra-Module）」の関数呼び出しを区別する戦略が明確に示されています。

*   **実装は計画に沿っている**: モジュール内の関数は再帰的に評価し、モジュール外の関数は（intrinsicがなければ）シンボリックなプレースホルダーとして扱う、というロジックは実装されています。
*   **潜在的な堅牢性の問題**: このロジックは`evalSelectorExpr`に集中しており、非常に複雑です。また、`go-scan`による型解決の正確性に完全に依存しているため、`go-scan`側の挙動が`symgo`の安定性に直接影響します。この複雑さは、将来のメンテナンスにおいて課題となる可能性があります。

### 2.4. docgenの使いにくさと拡張性の低さ

`docgen`は強力なツールですが、特定のコーディングスタイルに強く依存しており、カスタマイズが困難です。

*   **ハードコードされた分析パターン**:
    リクエスト/レスポンスの型を特定するための分析パターン（例: `json.NewDecoder(...).Decode(...)`）は、`examples/docgen/patterns/` 以下にGoのコードとしてハードコードされています。ユーザーが独自のヘルパー関数（例: `myapp.DecodeJSON(r, &req)`）を使っている場合、分析は何も検知できずに静かに失敗します。
*   **高い拡張コスト**:
    新しい分析パターンを追加するには、`symgo`の`Object`モデルを理解した上で、`docgen`のGoコードを直接修正・再コンパイルする必要があります。これは、ツールを利用したいだけのユーザーにとっては非常に高いハードルです。

## 3. 提案：今後必要とされる機能

上記の課題を解決し、`symgo`と`docgen`をより実用的なツールにするために、以下の機能追加を提案します。

### 3.1. 抜本的なデバッグ機能の強化

*   **構造化された実行ログ (Structured Execution Log)**:
    `symgo`の評価器（Evaluator）が、その実行ステップを単なるログではなく、構造化されたデータとして生成・返却する機能を設けます。
    - **ログの内容**: `[ファイル名:行:列] ASTノードの種類 -> 評価結果オブジェクト` のような形式で、すべての評価ステップを記録します。
    - **活用方法**: `docgen`に`--debug-analysis <関数名>`のようなデバッグフラグを追加し、この構造化ログを出力させることで、ユーザーは「なぜこの型が選ばれたのか」「なぜこの処理が無視されたのか」を正確に追跡できるようになります。
*   **エラー報告の改善**:
    すべてのエラーオブジェクトに、エラー発生箇所のコード位置情報（`token.Pos`）を保持させ、最終的にユーザーに提示されるエラーメッセージにファイル名・行・列を含めるようにします。

### 3.2. ユーザーによる拡張性の確保

*   **外部ファイルによるパターン設定**:
    `docgen`が分析に用いるカスタムパターンを、Goコードではなく外部の設定ファイル（例: `docgen-patterns.yml`）から読み込めるようにします。

    ```yaml
    # docgen-patterns.yml の例
    patterns:
      - key: "github.com/my-org/my-app/utils.DecodeJSON" # 追跡したい関数
        type: "requestBody"
        argIndex: 1 # 解析対象の引数インデックス
      - key: "github.com/my-org/my-app/utils.RenderJSON"
        type: "responseBody"
        argIndex: 2
    ```
    これにより、ユーザーは自分のプロジェクトの慣習に合わせて、Goのコードを触ることなく`docgen`の振る舞いを拡張できます。

### 3.3. `symgo`エンジンの機能補完

*   **不足しているintrinsicの実装**:
    `fmt.Sprintf`のような、一般的に使われる標準ライブラリ関数をintrinsicとして追加し、より多くのコードパターンに対応できるようにします。
*   **制御フロー分析の強化**:
    `if`文の`else`ブロックを評価するよう修正し、分析のカバレッジを向上させます。

これらの機能が実装されることで、`symgo`はより堅牢なシンボリック実行エンジンとなり、`docgen`は多様な実プロジェクトで活用できる、デバッグしやすく拡張性の高いドキュメント生成ツールへと進化することができるでしょう。
