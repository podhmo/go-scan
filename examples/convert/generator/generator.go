package generator

import (
	"bytes"
	"context"
	"fmt"
	"text/template"

	"example.com/convert/model"
	"github.com/podhmo/go-scan"
	"github.com/podhmo/go-scan/scanner"
)

const codeTemplate = `
// Code generated by convert. DO NOT EDIT.
package {{ .PackageName }}

import (
	"context"
	"fmt"
	{{- range $path, $alias := .Imports }}
	{{ $alias }} "{{ $path }}"
	{{- end }}
)

{{ range .Pairs -}}
// Convert{{ .SrcType.Name }}To{{ .DstType.Name }} converts {{ .SrcType.Name }} to {{ .DstType.Name }}.
func Convert{{ .SrcType.Name }}To{{ .DstType.Name }}(ctx context.Context, src *{{ .SrcType.Name }}) (*{{ .DstType.Name }}, error) {
	dst := &{{ .DstType.Name }}{}
	{{- range .Fields }}
	{{ getAssignment $.Im . "src" "dst" }}
	{{- end }}
	return dst, nil // TODO: error handling
}
{{ end }}
`

type TemplateData struct {
	PackageName string
	Imports     map[string]string
	Pairs       []TemplatePair
	Im          *goscan.ImportManager
}

type TemplatePair struct {
	SrcType *model.StructInfo
	DstType *model.StructInfo
	Fields  []FieldMap
}

type FieldMap struct {
	SrcName   string
	DstName   string
	Tag       model.ConvertTag
	SrcFieldT *scanner.FieldType
	DstFieldT *scanner.FieldType
}

func Generate(s *goscan.Scanner, info *model.ParsedInfo) ([]byte, error) {
	im := goscan.NewImportManager(&scanner.PackageInfo{ImportPath: info.PackagePath, Name: info.PackageName})
	im.Add("context", "context")
	im.Add("fmt", "fmt")

	var pairs []TemplatePair
	for _, pair := range info.ConversionPairs {
		srcStruct, ok := info.Structs[pair.SrcTypeName]
		if !ok {
			return nil, fmt.Errorf("source struct %q not found", pair.SrcTypeName)
		}
		dstStruct, ok := info.Structs[pair.DstTypeName]
		if !ok {
			return nil, fmt.Errorf("destination struct %q not found", pair.DstTypeName)
		}

		fieldMaps, err := createFieldMaps(context.Background(), s, srcStruct, dstStruct)
		if err != nil {
			return nil, fmt.Errorf("creating field maps for %s -> %s: %w", srcStruct.Name, dstStruct.Name, err)
		}

		pairs = append(pairs, TemplatePair{
			SrcType: srcStruct,
			DstType: dstStruct,
			Fields:  fieldMaps,
		})
	}

	templateData := TemplateData{
		PackageName: info.PackageName,
		Imports:     im.Imports(),
		Pairs:       pairs,
		Im:          im,
	}

	funcMap := template.FuncMap{
		"getAssignment": func(im *goscan.ImportManager, field FieldMap, srcVar, dstVar string) string {
			src := fmt.Sprintf("%s.%s", srcVar, field.SrcName)
			dst := fmt.Sprintf("%s.%s", dstVar, field.DstName)

			if field.Tag.UsingFunc != "" {
				return fmt.Sprintf("%s = %s(ctx, %s)", dst, field.Tag.UsingFunc, src)
			}
			if field.Tag.Required && field.SrcFieldT.IsPointer {
				return fmt.Sprintf("if %s == nil {\n\t\treturn nil, fmt.Errorf(\"%s is required\")\n\t}\n\ttmp := *%s\n\t%s = &tmp", src, field.SrcName, src, dst)
			}

			if field.SrcFieldT.IsPointer && !field.DstFieldT.IsPointer {
				return fmt.Sprintf("if %s != nil { %s = *%s }", src, dst, src)
			}
			if !field.SrcFieldT.IsPointer && field.DstFieldT.IsPointer {
				return fmt.Sprintf("{ tmp := %s; %s = &tmp }", src, dst)
			}
			if field.SrcFieldT.IsPointer && field.DstFieldT.IsPointer {
				return fmt.Sprintf("if %s != nil { tmp := *%s; %s = &tmp }", src, src, dst)
			}

			// Slice conversion
			if field.SrcFieldT.IsSlice && field.DstFieldT.IsSlice {
				srcElem := field.SrcFieldT.Elem
				dstElem := field.DstFieldT.Elem
				if srcElem.Definition != nil && srcElem.Definition.Kind == scanner.StructKind && dstElem.Definition != nil && dstElem.Definition.Kind == scanner.StructKind {
					return fmt.Sprintf(`{
						convertedSlice := make([]%s, len(%s))
						for i, item := range %s {
							converted, err := Convert%sTo%s(ctx, &item)
							if err != nil {
								// TODO: proper error handling
								return nil, err
							}
							convertedSlice[i] = *converted
						}
						%s = convertedSlice
					}`, dstElem.Definition.Name, src, src, srcElem.Definition.Name, dstElem.Definition.Name, dst)
				}
			}
			return fmt.Sprintf("%s = %s", dst, src)
		},
	}

	tmpl, err := template.New("converter").Funcs(funcMap).Parse(codeTemplate)
	if err != nil {
		return nil, fmt.Errorf("parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		return nil, fmt.Errorf("executing template: %w", err)
	}

	// formatted, err := format.Source(buf.Bytes())
	// if err != nil {
	// 	return nil, fmt.Errorf("formatting generated code: %w\n---\n%s", err, buf.String())
	// }
	// return formatted, nil
	return buf.Bytes(), nil
}

func createFieldMaps(ctx context.Context, s *goscan.Scanner, src, dst *model.StructInfo) ([]FieldMap, error) {
	var maps []FieldMap
	dstFields := make(map[string]model.FieldInfo)
	for _, f := range dst.Fields {
		dstFields[f.Name] = f
	}

	for _, srcField := range src.Fields {
		if err := resolveFieldType(ctx, srcField.FieldType); err != nil {
			return nil, fmt.Errorf("resolving src field %q: %w", srcField.Name, err)
		}
		if srcField.Tag.DstFieldName == "-" {
			continue
		}
		dstFieldName := srcField.Tag.DstFieldName
		if dstFieldName == "" {
			dstFieldName = srcField.Name
		}
		dstField, ok := dstFields[dstFieldName]
		if !ok {
			continue
		}
		if err := resolveFieldType(ctx, dstField.FieldType); err != nil {
			return nil, fmt.Errorf("resolving dst field %q: %w", dstField.Name, err)
		}
		maps = append(maps, FieldMap{
			SrcName:   srcField.Name,
			DstName:   dstFieldName,
			Tag:       srcField.Tag,
			SrcFieldT: srcField.FieldType,
			DstFieldT: dstField.FieldType,
		})
	}
	return maps, nil
}

func resolveFieldType(ctx context.Context, ft *scanner.FieldType) error {
	if ft == nil {
		return nil
	}
	if _, err := ft.Resolve(ctx, make(map[string]struct{})); err != nil {
		return err
	}
	if ft.Elem != nil {
		if err := resolveFieldType(ctx, ft.Elem); err != nil {
			return fmt.Errorf("resolving element type: %w", err)
		}
	}
	if ft.MapKey != nil {
		if err := resolveFieldType(ctx, ft.MapKey); err != nil {
			return fmt.Errorf("resolving map key type: %w", err)
		}
	}
	return nil
}
