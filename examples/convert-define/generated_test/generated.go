// Code generated by convert. DO NOT EDIT.

//go:build e2e
// +build e2e

package generated

import (
	"context"
	"errors"
	"fmt"

	convutil "github.com/podhmo/go-scan/examples/convert/convutil"
	"github.com/podhmo/go-scan/examples/convert/model"
	destination "github.com/podhmo/go-scan/examples/convert/sampledata/destination"
	"github.com/podhmo/go-scan/examples/convert/sampledata/funcs"
	source "github.com/podhmo/go-scan/examples/convert/sampledata/source"
)

// convertSrcUserToDstUser converts source.SrcUser to destination.DstUser.
func convertSrcUserToDstUser(ctx context.Context, ec *model.ErrorCollector, src *source.SrcUser) *destination.DstUser {
	if src == nil {
		return nil
	}
	dst := &destination.DstUser{}
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("UserID")
	dst.UserID = funcs.UserIDToString(ctx, ec, src.ID)

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("Address")
	dst.Address = *convertSrcAddressToDstAddress(ctx, ec, &src.Address)

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("Contact")
	dst.Contact = funcs.ConvertSrcContactToDstContact(ctx, ec, src.ContactInfo)

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("Details")
	{
		convertedSlice := make([]destination.DstInternalDetail, len(src.Details))
		for i, item := range src.Details {
			ec.Enter(fmt.Sprintf("[%d]", i))
			convertedSlice[i] = *convertSrcInternalDetailToDstInternalDetail(ctx, ec, &item)
			ec.Leave()
		}
		dst.Details = convertedSlice
	}

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("CreatedAt")
	dst.CreatedAt = convutil.TimeToString(ctx, ec, src.CreatedAt)

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("UpdatedAt")
	dst.UpdatedAt = convutil.PtrTimeToString(ctx, ec, src.UpdatedAt)

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("FullName")
	dst.FullName = funcs.MakeFullName(src.FirstName, src.LastName)
	ec.Leave()
	return dst
}

// ConvertSrcUserToDstUser converts source.SrcUser to destination.DstUser.
func ConvertSrcUserToDstUser(ctx context.Context, src *source.SrcUser) (*destination.DstUser, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSrcUserToDstUser(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

// convertSrcAddressToDstAddress converts source.SrcAddress to destination.DstAddress.
func convertSrcAddressToDstAddress(ctx context.Context, ec *model.ErrorCollector, src *source.SrcAddress) *destination.DstAddress {
	if src == nil {
		return nil
	}
	dst := &destination.DstAddress{}
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("FullStreet")
	dst.FullStreet = src.Street

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("CityName")
	dst.CityName = src.City

	ec.Leave()
	return dst
}

// ConvertSrcAddressToDstAddress converts source.SrcAddress to destination.DstAddress.
func ConvertSrcAddressToDstAddress(ctx context.Context, src *source.SrcAddress) (*destination.DstAddress, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSrcAddressToDstAddress(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

// convertSrcInternalDetailToDstInternalDetail converts source.SrcInternalDetail to destination.DstInternalDetail.
//
// Fields that are not populated by this converter:
//   - ItemCode
//   - LocalizedDesc
func convertSrcInternalDetailToDstInternalDetail(ctx context.Context, ec *model.ErrorCollector, src *source.SrcInternalDetail) *destination.DstInternalDetail {
	if src == nil {
		return nil
	}
	dst := &destination.DstInternalDetail{}
	return dst
}

// ConvertSrcInternalDetailToDstInternalDetail converts source.SrcInternalDetail to destination.DstInternalDetail.
//
// Fields that are not populated by this converter:
//   - ItemCode
//   - LocalizedDesc
func ConvertSrcInternalDetailToDstInternalDetail(ctx context.Context, src *source.SrcInternalDetail) (*destination.DstInternalDetail, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSrcInternalDetailToDstInternalDetail(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

// convertSrcOrderToDstOrder converts source.SrcOrder to destination.DstOrder.
//
// Fields that are not populated by this converter:
//   - LineItems
func convertSrcOrderToDstOrder(ctx context.Context, ec *model.ErrorCollector, src *source.SrcOrder) *destination.DstOrder {
	if src == nil {
		return nil
	}
	dst := &destination.DstOrder{}
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("ID")
	dst.ID = src.OrderID

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("TotalAmount")
	dst.TotalAmount = src.Amount

	ec.Leave()
	return dst
}

// ConvertSrcOrderToDstOrder converts source.SrcOrder to destination.DstOrder.
//
// Fields that are not populated by this converter:
//   - LineItems
func ConvertSrcOrderToDstOrder(ctx context.Context, src *source.SrcOrder) (*destination.DstOrder, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSrcOrderToDstOrder(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

// convertSrcItemToDstItem converts source.SrcItem to destination.DstItem.
//
// Fields that are not populated by this converter:
//   - Count
//   - ProductCode
func convertSrcItemToDstItem(ctx context.Context, ec *model.ErrorCollector, src *source.SrcItem) *destination.DstItem {
	if src == nil {
		return nil
	}
	dst := &destination.DstItem{}
	return dst
}

// ConvertSrcItemToDstItem converts source.SrcItem to destination.DstItem.
//
// Fields that are not populated by this converter:
//   - Count
//   - ProductCode
func ConvertSrcItemToDstItem(ctx context.Context, src *source.SrcItem) (*destination.DstItem, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSrcItemToDstItem(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

// convertComplexSourceToComplexTarget converts source.ComplexSource to destination.ComplexTarget.
func convertComplexSourceToComplexTarget(ctx context.Context, ec *model.ErrorCollector, src *source.ComplexSource) *destination.ComplexTarget {
	if src == nil {
		return nil
	}
	dst := &destination.ComplexTarget{}
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("Value")
	dst.Value = src.Value

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("Ptr")
	if src.Ptr != nil {
		tmp := (*src.Ptr)
		dst.Ptr = &tmp
	} else {
		dst.Ptr = nil
	}

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("Slice")
	{
		convertedSlice := make([]destination.SubTarget, len(src.Slice))
		for i, item := range src.Slice {
			ec.Enter(fmt.Sprintf("[%d]", i))
			convertedSlice[i] = *convertSubSourceToSubTarget(ctx, ec, &item)
			ec.Leave()
		}
		dst.Slice = convertedSlice
	}

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("SliceOfPtrs")
	{
		convertedSlice := make([]*destination.SubTarget, len(src.SliceOfPtrs))
		for i, item := range src.SliceOfPtrs {
			ec.Enter(fmt.Sprintf("[%d]", i))
			convertedSlice[i] = convertSubSourceToSubTarget(ctx, ec, item)
			ec.Leave()
		}
		dst.SliceOfPtrs = convertedSlice
	}

	ec.Leave()
	return dst
}

// ConvertComplexSourceToComplexTarget converts source.ComplexSource to destination.ComplexTarget.
func ConvertComplexSourceToComplexTarget(ctx context.Context, src *source.ComplexSource) (*destination.ComplexTarget, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertComplexSourceToComplexTarget(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

// convertSubSourceToSubTarget converts source.SubSource to destination.SubTarget.
func convertSubSourceToSubTarget(ctx context.Context, ec *model.ErrorCollector, src *source.SubSource) *destination.SubTarget {
	if src == nil {
		return nil
	}
	dst := &destination.SubTarget{}
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("Value")
	dst.Value = src.Value

	ec.Leave()
	return dst
}

// ConvertSubSourceToSubTarget converts source.SubSource to destination.SubTarget.
func ConvertSubSourceToSubTarget(ctx context.Context, src *source.SubSource) (*destination.SubTarget, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSubSourceToSubTarget(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

// convertSourceWithMapToTargetWithMap converts source.SourceWithMap to destination.TargetWithMap.
func convertSourceWithMapToTargetWithMap(ctx context.Context, ec *model.ErrorCollector, src *source.SourceWithMap) *destination.TargetWithMap {
	if src == nil {
		return nil
	}
	dst := &destination.TargetWithMap{}
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("ValueMap")
	{
		convertedMap := make(map[string]destination.SubTarget, len(src.ValueMap))
		for key, value := range src.ValueMap {
			ec.Enter(fmt.Sprintf("[%v]", key))
			convertedMap[key] = *convertSubSourceToSubTarget(ctx, ec, &value)
			ec.Leave()
		}
		dst.ValueMap = convertedMap
	}

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("PtrMap")
	{
		convertedMap := make(map[string]*destination.SubTarget, len(src.PtrMap))
		for key, value := range src.PtrMap {
			ec.Enter(fmt.Sprintf("[%v]", key))
			convertedMap[key] = convertSubSourceToSubTarget(ctx, ec, value)
			ec.Leave()
		}
		dst.PtrMap = convertedMap
	}

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("StringToStr")
	{
		convertedMap := make(map[string]string, len(src.StringToStr))
		for key, value := range src.StringToStr {
			ec.Enter(fmt.Sprintf("[%v]", key))
			convertedMap[key] = value
			ec.Leave()
		}
		dst.StringToStr = convertedMap
	}

	ec.Leave()
	return dst
}

// ConvertSourceWithMapToTargetWithMap converts source.SourceWithMap to destination.TargetWithMap.
func ConvertSourceWithMapToTargetWithMap(ctx context.Context, src *source.SourceWithMap) (*destination.TargetWithMap, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSourceWithMapToTargetWithMap(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
