package generator

import (
	"bytes"
	"context"
	"fmt"
	"go/format"
	"strings"
	"text/template"

	"example.com/convert/parser"
	"github.com/podhmo/go-scan"
	"github.com/podhmo/go-scan/scanner"
)

const codeTemplate = `
import (
	"context"
	{{- range $path, $alias := .Imports }}
	{{ $alias }} "{{ $path }}"
	{{- end }}
)

{{ range .Pairs }}
// {{ .ExportedFuncName }} converts {{ .SrcType.Name }} to {{ .DstType.Name }}.
func {{ .ExportedFuncName }}(ctx context.Context, src {{ .SrcType.Qualifier }}) ({{ .DstType.Qualifier }}, error) {
	dst := {{ .InternalFuncName }}(ctx, src)
	return dst, nil
}

// {{ .InternalFuncName }} is the internal conversion function.
func {{ .InternalFuncName }}(ctx context.Context, src {{ .SrcType.Qualifier }}) {{ .DstType.Qualifier }} {
	dst := {{ .DstType.Qualifier }}{}
	{{- range .Fields }}
	{{ getAssignment . "src" "dst" }}
	{{- end }}
	return dst
}
{{ end }}
`

type TemplateData struct {
	PackageName string
	Imports     map[string]string
	Pairs       []TemplatePair
}

type TemplatePair struct {
	ExportedFuncName string
	InternalFuncName string
	SrcType          QualifiedType
	DstType          QualifiedType
	Fields           []FieldMap
	im               *goscan.ImportManager
}

type FieldMap struct {
	SrcName     string
	DstName     string
	SrcField    *scanner.FieldInfo
	DstField    *scanner.FieldInfo
	IsSlice     bool
	IsMap       bool
	NeedsHelper bool
	im          *goscan.ImportManager
	SrcDef      *scanner.TypeInfo
	DstDef      *scanner.TypeInfo
}

type QualifiedType struct {
	Name      string
	Qualifier string
}

func Generate(s *goscan.Scanner, packageName string, pairs []parser.ConversionPair, pkgInfo *scanner.PackageInfo) ([]byte, error) {
	im := goscan.NewImportManager(&scanner.PackageInfo{ImportPath: "example.com/convert/" + packageName})
	im.Add("context", "context")

	worklist := make(map[string]bool)
	allPairs := make([]parser.ConversionPair, len(pairs))
	copy(allPairs, pairs)

	for _, pair := range pairs {
		key := fmt.Sprintf("%s_to_%s", pair.SrcType.Name, pair.DstType.Name)
		worklist[key] = true
	}

	i := 0
	for i < len(allPairs) {
		pair := allPairs[i]
		i++
		if pair.SrcType.Struct == nil {
			continue
		}
		for _, field := range createFieldMaps(s, pair.SrcType.Struct, pair.DstType.Struct, im) {
			if field.NeedsHelper {
				var srcElem, dstElem *scanner.FieldType
				if field.IsSlice {
					srcElem = field.SrcField.Type.Elem
					dstElem = field.DstField.Type.Elem
				} else if field.IsMap {
					srcElem = field.SrcField.Type.Elem
					dstElem = field.DstField.Type.Elem
				} else {
					srcElem = field.SrcField.Type
					dstElem = field.DstField.Type
				}

				if srcElem == nil || dstElem == nil {
					continue
				}

				// Dereference pointers to get the base type for the key
				srcBase := srcElem
				if srcBase.IsPointer {
					srcBase = srcBase.Elem
				}
				dstBase := dstElem
				if dstBase.IsPointer {
					dstBase = dstBase.Elem
				}

				helperKey := fmt.Sprintf("%s_to_%s", srcBase.Name, dstBase.Name)
				if !worklist[helperKey] {
					if srcBase.Definition != nil && dstBase.Definition != nil {
						allPairs = append(allPairs, parser.ConversionPair{
							SrcType:          srcBase.Definition,
							DstType:          dstBase.Definition,
							DstPkgImportPath: dstBase.FullImportPath(),
						})
						worklist[helperKey] = true
					}
				}
			}
		}
	}

	templatePairs := make([]TemplatePair, 0, len(allPairs))
	for _, pair := range allPairs {
		if pair.SrcType.Struct == nil || pair.DstType.Struct == nil {
			continue
		}
		srcQualifier := im.Qualify(pkgInfo.ImportPath, pair.SrcType.Name)
		dstQualifier := im.Qualify(pair.DstPkgImportPath, pair.DstType.Name)
		fieldMaps := createFieldMaps(s, pair.SrcType.Struct, pair.DstType.Struct, im)
		templatePairs = append(templatePairs, TemplatePair{
			ExportedFuncName: fmt.Sprintf("Convert%sTo%s", pair.SrcType.Name, pair.DstType.Name),
			InternalFuncName: fmt.Sprintf("convert%sTo%s", pair.SrcType.Name, pair.DstType.Name),
			SrcType:          QualifiedType{Name: pair.SrcType.Name, Qualifier: srcQualifier},
			DstType:          QualifiedType{Name: pair.DstType.Name, Qualifier: dstQualifier},
			Fields:           fieldMaps,
			im:               im,
		})
	}

	imports := im.Imports()
	delete(imports, "context")

	templateData := TemplateData{
		PackageName: packageName,
		Imports:     imports,
		Pairs:       templatePairs,
	}

	funcMap := template.FuncMap{
		"getAssignment": getAssignment,
	}

	tmpl, err := template.New("converter").Funcs(funcMap).Parse(strings.TrimSpace(codeTemplate))
	if err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	header := fmt.Sprintf("// Code generated by go-scan for package %s. DO NOT EDIT.\n\npackage %s\n\n", packageName, packageName)
	finalCode := append([]byte(header), buf.Bytes()...)

	formatted, err := format.Source(finalCode)
	if err != nil {
		return nil, fmt.Errorf("failed to format generated code: %w\n---\n%s\n---", err, string(finalCode))
	}

	return formatted, nil
}

func getAssignment(field FieldMap, srcVar, dstVar string) string {
	src := fmt.Sprintf("%s.%s", srcVar, field.SrcName)
	dst := fmt.Sprintf("%s.%s", dstVar, field.DstName)

	if field.DstField.Type.FullImportPath() != "" {
		field.im.Add(field.DstField.Type.FullImportPath(), "")
	}

	if field.IsSlice {
		return generateSliceConversion(src, dst, field.SrcField.Type, field.DstField.Type, field)
	}
	if field.IsMap {
		return generateMapConversion(src, dst, field.SrcField.Type, field.DstField.Type, field)
	}
	return generatePointerValueConversion(src, dst, field.SrcField.Type, field.DstField.Type, field)
}

func generateSliceConversion(src, dst string, srcType, dstType *scanner.FieldType, field FieldMap) string {
	srcElem := srcType.Elem
	dstElem := dstType.Elem
	if srcElem == nil || dstElem == nil {
		return fmt.Sprintf("// TODO: Cannot determine slice element types for %s", src)
	}

	helperFuncName := ""
	if field.NeedsHelper && field.SrcDef != nil && field.DstDef != nil {
		helperFuncName = fmt.Sprintf("convert%sTo%s", field.SrcDef.Name, field.DstDef.Name)
	}

	dstSliceTypeQualifier := getQualifiedSliceType(dstType, field.im)


	var conversionLogic string
	if helperFuncName != "" {
		call := fmt.Sprintf("%s(ctx, elem)", helperFuncName)
		if srcElem.IsPointer {
			call = fmt.Sprintf("%s(ctx, *elem)", helperFuncName)
		}

		if dstElem.IsPointer {
			if srcElem.IsPointer {
				conversionLogic = fmt.Sprintf("if elem != nil {\n\t\t\ttmp := %s\n\t\t\tnewSlice = append(newSlice, &tmp)\n\t\t}", call)
			} else {
				conversionLogic = fmt.Sprintf("tmp := %s\n\t\tnewSlice = append(newSlice, &tmp)", call)
			}
		} else {
			if srcElem.IsPointer {
				conversionLogic = fmt.Sprintf("if elem != nil {\n\t\t\tnewSlice = append(newSlice, %s)\n\t\t}", call)
			} else {
				conversionLogic = fmt.Sprintf("newSlice = append(newSlice, %s)", call)
			}
		}
	} else {
		// No helper function, direct assignment with pointer handling.
		assign := "elem"
		if srcElem.IsPointer {
			assign = "*elem"
		}

		if dstElem.IsPointer {
			if srcElem.IsPointer {
				conversionLogic = fmt.Sprintf("if elem != nil { tmp := %s; newSlice = append(newSlice, &tmp) }", assign)
			} else {
				conversionLogic = fmt.Sprintf("tmp := %s\n\t\tnewSlice = append(newSlice, &tmp)", assign)
			}
		} else {
			if srcElem.IsPointer {
				conversionLogic = fmt.Sprintf("if elem != nil { newSlice = append(newSlice, %s) }", assign)
			} else {
				conversionLogic = fmt.Sprintf("newSlice = append(newSlice, %s)", assign)
			}
		}
	}

	return fmt.Sprintf(`if %s != nil {
		newSlice := make(%s, 0, len(%s))
		for _, elem := range %s {
			%s
		}
		%s = newSlice
	}`, src, dstSliceTypeQualifier, src, src, conversionLogic, dst)
}

func generateMapConversion(src, dst string, srcType, dstType *scanner.FieldType, field FieldMap) string {
	srcKey := srcType.MapKey
	srcValue := srcType.Elem
	dstKey := dstType.MapKey
	dstValue := dstType.Elem

	if srcKey == nil || srcValue == nil || dstKey == nil || dstValue == nil {
		return fmt.Sprintf("// TODO: Cannot determine map key/value types for %s", src)
	}

	// Assuming keys are directly assignable
	keyConversion := "key"

	helperFuncName := ""
	if field.NeedsHelper && field.SrcDef != nil && field.DstDef != nil {
		helperFuncName = fmt.Sprintf("convert%sTo%s", field.SrcDef.Name, field.DstDef.Name)
	}

	var valueConversion string
	if helperFuncName != "" {
		call := fmt.Sprintf("%s(ctx, value)", helperFuncName)
		if srcValue.IsPointer {
			call = fmt.Sprintf("%s(ctx, *value)", helperFuncName)
		}

		if dstValue.IsPointer {
			if srcValue.IsPointer {
				valueConversion = fmt.Sprintf("if value != nil { tmp := %s; newMap[%s] = &tmp }", call, keyConversion)
			} else {
				valueConversion = fmt.Sprintf("tmp := %s; newMap[%s] = &tmp", call, keyConversion)
			}
		} else {
			if srcValue.IsPointer {
				valueConversion = fmt.Sprintf("if value != nil { newMap[%s] = %s }", keyConversion, call)
			} else {
				valueConversion = fmt.Sprintf("newMap[%s] = %s", keyConversion, call)
			}
		}
	} else {
		// No helper function, direct assignment with pointer handling.
		assign := "value"
		if srcValue.IsPointer {
			assign = "*value"
		}

		if dstValue.IsPointer {
			if srcValue.IsPointer {
				valueConversion = fmt.Sprintf("if value != nil { tmp := %s; newMap[%s] = &tmp }", assign, keyConversion)
			} else {
				valueConversion = fmt.Sprintf("tmp := %s; newMap[%s] = &tmp", assign, keyConversion)
			}
		} else {
			if srcValue.IsPointer {
				valueConversion = fmt.Sprintf("if value != nil { newMap[%s] = %s }", keyConversion, assign)
			} else {
				valueConversion = fmt.Sprintf("newMap[%s] = %s", keyConversion, assign)
			}
		}
	}

	dstMapTypeQualifier := getQualifiedMapType(dstType, field.im)

	return fmt.Sprintf(`if %s != nil {
		newMap := make(%s, len(%s))
		for key, value := range %s {
			%s
		}
		%s = newMap
	}`, src, dstMapTypeQualifier, src, src, valueConversion, dst)
}

func getQualifiedSliceType(sliceType *scanner.FieldType, im *goscan.ImportManager) string {
	elemQualifier := im.Qualify(sliceType.Elem.FullImportPath(), sliceType.Elem.Name)
	if sliceType.Elem.IsPointer {
		elemQualifier = "*" + elemQualifier
	}
	return fmt.Sprintf("[]%s", elemQualifier)
}

func getQualifiedMapType(mapType *scanner.FieldType, im *goscan.ImportManager) string {
	keyQualifier := im.Qualify(mapType.MapKey.FullImportPath(), mapType.MapKey.Name)
	if mapType.MapKey.IsPointer {
		keyQualifier = "*" + keyQualifier
	}
	valueQualifier := im.Qualify(mapType.Elem.FullImportPath(), mapType.Elem.Name)
	if mapType.Elem.IsPointer {
		valueQualifier = "*" + valueQualifier
	}
	return fmt.Sprintf("map[%s]%s", keyQualifier, valueQualifier)
}

func generatePointerValueConversion(src, dst string, srcType, dstType *scanner.FieldType, field FieldMap) string {
	srcIsPtr := srcType.IsPointer
	dstIsPtr := dstType.IsPointer

	srcBaseType := srcType
	if srcIsPtr {
		srcBaseType = srcType.Elem
	}
	dstBaseType := dstType
	if dstIsPtr {
		dstBaseType = dstType.Elem
	}

	helperFunc := ""
	if field.NeedsHelper {
		helperFunc = fmt.Sprintf("convert%sTo%s", srcBaseType.Name, dstBaseType.Name)
	}

	if !srcIsPtr && !dstIsPtr {
		if helperFunc != "" {
			return fmt.Sprintf("%s = %s(ctx, %s)", dst, helperFunc, src)
		}
		return fmt.Sprintf("%s = %s", dst, src)
	}
	if srcIsPtr && !dstIsPtr {
		if helperFunc != "" {
			return fmt.Sprintf("if %s != nil {\n\t\t%s = %s(ctx, *%s)\n\t}", src, dst, helperFunc, src)
		}
		return fmt.Sprintf("if %s != nil {\n\t\t%s = *%s\n\t}", src, dst, src)
	}
	if !srcIsPtr && dstIsPtr {
		if helperFunc != "" {
			return fmt.Sprintf("{\n\t\ttmp := %s(ctx, %s)\n\t\t%s = &tmp\n\t}", helperFunc, src, dst)
		}
		return fmt.Sprintf("{\n\t\ttmp := %s\n\t\t%s = &tmp\n\t}", src, dst)
	}
	if srcIsPtr && dstIsPtr {
		if helperFunc != "" {
			return fmt.Sprintf("if %s != nil {\n\t\ttmp := %s(ctx, *%s)\n\t\t%s = &tmp\n\t}", src, helperFunc, src, dst)
		}
		return fmt.Sprintf("if %s != nil {\n\t\ttmp := *%s\n\t\t%s = &tmp\n\t}", src, src, dst)
	}
	return fmt.Sprintf("// TODO: Conversion not implemented for %s -> %s", srcType.Name, dstType.Name)
}

func createFieldMaps(s *goscan.Scanner, srcStruct, dstStruct *scanner.StructInfo, im *goscan.ImportManager) []FieldMap {
	var fieldMaps []FieldMap
	dstFields := make(map[string]*scanner.FieldInfo)
	for _, field := range dstStruct.Fields {
		dstFields[field.Name] = field
	}

	for _, srcField := range srcStruct.Fields {
		if dstField, ok := dstFields[srcField.Name]; ok {
			srcType := srcField.Type
			dstType := dstField.Type

			var needsHelper bool
			var checkTypeSrc, checkTypeDst *scanner.FieldType

			if srcType.IsSlice && dstType.IsSlice {
				checkTypeSrc = srcType.Elem
				checkTypeDst = dstType.Elem
			} else if srcType.IsMap && dstType.IsMap {
				// We only consider converting map values, not keys.
				checkTypeSrc = srcType.Elem
				checkTypeDst = dstType.Elem
			} else {
				checkTypeSrc = srcType
				checkTypeDst = dstType
			}

			var srcDef, dstDef *scanner.TypeInfo
			if checkTypeSrc != nil && checkTypeDst != nil {
				checkTypeSrc.SetResolver(s)
				checkTypeDst.SetResolver(s)
				srcDef, _ = checkTypeSrc.Resolve(context.Background(), make(map[string]struct{}))
				dstDef, _ = checkTypeDst.Resolve(context.Background(), make(map[string]struct{}))
				needsHelper = (srcDef != nil && srcDef.Struct != nil) && (dstDef != nil && dstDef.Struct != nil)
			}

			fieldMaps = append(fieldMaps, FieldMap{
				SrcName:     srcField.Name,
				DstName:     srcField.Name,
				SrcField:    srcField,
				DstField:    dstField,
				IsSlice:     srcField.Type.IsSlice,
				IsMap:       srcField.Type.IsMap,
				NeedsHelper: needsHelper,
				im:          im,
				SrcDef:      srcDef,
				DstDef:      dstDef,
			})
		}
	}

	return fieldMaps
}
