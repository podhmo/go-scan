package generator

import (
	"bytes"
	"context"
	"fmt"
	"strings"
	"text/template"

	"example.com/convert/model"
	goscan "github.com/podhmo/go-scan"
	"github.com/podhmo/go-scan/scanner"
)

const codeTemplate = `
// Code generated by convert. DO NOT EDIT.
package {{ .PackageName }}

import (
	"context"
	"fmt"
	"strings"
	"errors"
	{{- range $path, $alias := .Imports }}
	{{ $alias }} "{{ $path }}"
	{{- end }}
)

// errorCollector collects errors with their field paths.
type errorCollector struct {
	errors []error
	path   []string
	max    int
}

func newErrorCollector(max int) *errorCollector {
	return &errorCollector{max: max}
}

func (ec *errorCollector) Add(field string, err error) {
	if ec.max > 0 && len(ec.errors) >= ec.max {
		return
	}
	path := strings.Join(append(ec.path, field), ".")
	ec.errors = append(ec.errors, fmt.Errorf("field %q: %w", path, err))
}

func (ec *errorCollector) Enter(field string) {
	ec.path = append(ec.path, field)
}

func (ec *errorCollector) Leave() {
	if len(ec.path) > 0 {
		ec.path = ec.path[:len(ec.path)-1]
	}
}

func (ec *errorCollector) Errors() []error {
	return ec.errors
}

func (ec *errorCollector) HasErrors() bool {
	return len(ec.errors) > 0
}

func (ec *errorCollector) MaxErrorsReached() bool {
	return ec.max > 0 && len(ec.errors) >= ec.max
}

{{ range .Pairs -}}
// Convert{{ .SrcType.Name }}To{{ .DstType.Name }} converts {{ .SrcType.Name }} to {{ .DstType.Name }}.
func Convert{{ .SrcType.Name }}To{{ .DstType.Name }}(ctx context.Context, src *{{ .SrcType.Name }}) (*{{ .DstType.Name }}, error) {
	if src == nil {
		return nil, nil
	}
	ec := newErrorCollector(0) // TODO: Get max_errors from annotation
	dst := convert{{ .SrcType.Name }}To{{ .DstType.Name }}(ctx, ec, src)
	if ec.HasErrors() {
		return &dst, errors.Join(ec.Errors()...)
	}
	return &dst, nil
}

// convert{{ .SrcType.Name }}To{{ .DstType.Name }} is a helper function for conversion.
func convert{{ .SrcType.Name }}To{{ .DstType.Name }}(ctx context.Context, ec *errorCollector, src *{{ .SrcType.Name }}) {{ .DstType.Name }} {
	dst := {{ .DstType.Name }}{}
	if ec.MaxErrorsReached() {
		return dst
	}

	{{- range .Fields }}
	ec.Enter("{{ .DstName }}")
	{{ getAssignment $.Im $.Info . "src" "dst" }}
	{{ getValidatorCall $.Im $.Info . "dst" }}
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	{{- end }}

	return dst
}
{{ end }}
`

type TemplateData struct {
	PackageName string
	Imports     map[string]string
	Pairs       []TemplatePair
	Im          *goscan.ImportManager
	Info        *model.ParsedInfo
}

type TemplatePair struct {
	SrcType *model.StructInfo
	DstType *model.StructInfo
	Fields  []FieldMap
}

type FieldMap struct {
	SrcName   string
	DstName   string
	Tag       model.ConvertTag
	SrcFieldT *scanner.FieldType
	DstFieldT *scanner.FieldType
}

func Generate(s *goscan.Scanner, info *model.ParsedInfo) ([]byte, error) {
	im := goscan.NewImportManager(&scanner.PackageInfo{ImportPath: info.PackagePath, Name: info.PackageName})
	im.Add("context", "context")
	im.Add("fmt", "fmt")

	var pairs []TemplatePair
	for _, pair := range info.ConversionPairs {
		srcStruct, ok := info.Structs[pair.SrcTypeName]
		if !ok {
			return nil, fmt.Errorf("source struct %q not found", pair.SrcTypeName)
		}
		dstStruct, ok := info.Structs[pair.DstTypeName]
		if !ok {
			return nil, fmt.Errorf("destination struct %q not found", pair.DstTypeName)
		}

		fieldMaps, err := createFieldMaps(context.Background(), s, srcStruct, dstStruct)
		if err != nil {
			return nil, fmt.Errorf("creating field maps for %s -> %s: %w", srcStruct.Name, dstStruct.Name, err)
		}

		pairs = append(pairs, TemplatePair{
			SrcType: srcStruct,
			DstType: dstStruct,
			Fields:  fieldMaps,
		})
	}

	templateData := TemplateData{
		PackageName: info.PackageName,
		Imports:     im.Imports(),
		Pairs:       pairs,
		Im:          im,
		Info:        info,
	}

	funcMap := template.FuncMap{
		"getAssignment": func(im *goscan.ImportManager, info *model.ParsedInfo, field FieldMap, srcVar, dstVar string) string {
			return getAssignment(im, info, field, srcVar, dstVar)
		},
		"getValidatorCall": func(im *goscan.ImportManager, info *model.ParsedInfo, field FieldMap, dstVar string) string {
			return getValidatorCall(im, info, field, dstVar)
		},
	}

	tmpl, err := template.New("converter").Funcs(funcMap).Parse(codeTemplate)
	if err != nil {
		return nil, fmt.Errorf("parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		return nil, fmt.Errorf("executing template: %w", err)
	}
	return buf.Bytes(), nil
}

func createFieldMaps(ctx context.Context, s *goscan.Scanner, src, dst *model.StructInfo) ([]FieldMap, error) {
	var maps []FieldMap
	dstFields := make(map[string]model.FieldInfo)
	for _, f := range dst.Fields {
		dstFields[f.Name] = f
	}

	for _, srcField := range src.Fields {
		_ = resolveFieldType(ctx, srcField.FieldType) // Ignore error for now
		if srcField.Tag.DstFieldName == "-" {
			continue
		}
		dstFieldName := srcField.Tag.DstFieldName
		if dstFieldName == "" {
			dstFieldName = srcField.Name
		}
		dstField, ok := dstFields[dstFieldName]
		if !ok {
			continue
		}
		_ = resolveFieldType(ctx, dstField.FieldType) // Ignore error for now
		maps = append(maps, FieldMap{
			SrcName:   srcField.Name,
			DstName:   dstFieldName,
			Tag:       srcField.Tag,
			SrcFieldT: srcField.FieldType,
			DstFieldT: dstField.FieldType,
		})
	}
	return maps, nil
}

func resolveFieldType(ctx context.Context, ft *scanner.FieldType) error {
	if ft == nil {
		return nil
	}
	if _, err := ft.Resolve(ctx, make(map[string]struct{})); err != nil {
		return err
	}
	if ft.Elem != nil {
		if err := resolveFieldType(ctx, ft.Elem); err != nil {
			return fmt.Errorf("resolving element type: %w", err)
		}
	}
	if ft.MapKey != nil {
		if err := resolveFieldType(ctx, ft.MapKey); err != nil {
			return fmt.Errorf("resolving map key type: %w", err)
		}
	}
	return nil
}

// -----------------------------------------------------------------------------
// Assignment Logic
// -----------------------------------------------------------------------------

func getValidatorCall(im *goscan.ImportManager, info *model.ParsedInfo, field FieldMap, dstVar string) string {
	dst := fmt.Sprintf("%s.%s", dstVar, field.DstName)
	dstFieldTypeName := getFullTypeNameFromFieldType(field.DstFieldT)

	for _, rule := range info.GlobalRules {
		if rule.ValidatorFunc == "" {
			continue
		}
		ruleDstName := getFullTypeNameFromTypeInfo(rule.DstTypeInfo)
		if ruleDstName == dstFieldTypeName {
			// The validator function is now expected to accept `ec`
			return fmt.Sprintf("%s(ec, %s)", rule.ValidatorFunc, dst)
		}
	}
	return ""
}

func getFullTypeNameFromFieldType(t *scanner.FieldType) string {
	if t == nil {
		return ""
	}
	if t.IsPointer || t.IsSlice || t.IsMap {
		// For now, we don't support validators on complex types
		return ""
	}
	if t.Definition != nil {
		return getFullTypeNameFromTypeInfo(t.Definition)
	}
	return t.Name // for string, int, etc.
}

func getAssignment(im *goscan.ImportManager, info *model.ParsedInfo, field FieldMap, srcVar, dstVar string) string {
	src := fmt.Sprintf("%s.%s", srcVar, field.SrcName)
	dst := fmt.Sprintf("%s.%s", dstVar, field.DstName)

	// Priority 1: Field-level using tag
	if field.Tag.UsingFunc != "" {
		// Custom conversion functions now receive the error collector
		return fmt.Sprintf("%s = %s(ec, %s)", dst, field.Tag.UsingFunc, src)
	}

	// Priority 2: Global conversion rule
	srcFieldTypeName := getFullTypeNameFromFieldType(field.SrcFieldT)
	dstFieldTypeName := getFullTypeNameFromFieldType(field.DstFieldT)

	for _, rule := range info.GlobalRules {
		if rule.UsingFunc == "" {
			continue
		}
		ruleSrcName := getFullTypeNameFromTypeInfo(rule.SrcTypeInfo)
		ruleDstName := getFullTypeNameFromTypeInfo(rule.DstTypeInfo)

		if ruleSrcName == srcFieldTypeName && ruleDstName == dstFieldTypeName {
			return fmt.Sprintf("%s = %s(ec, %s)", dst, rule.UsingFunc, src)
		}
	}

	if field.Tag.Required && field.SrcFieldT.IsPointer {
		var b strings.Builder
		b.WriteString(fmt.Sprintf("if %s == nil {\n", src))
		b.WriteString(fmt.Sprintf("\tec.Add(\"\", fmt.Errorf(\"%s is required\"))\n", field.SrcName))
		b.WriteString("} else {\n")
		b.WriteString(fmt.Sprintf("\t%s\n", generateConversion(im, src, dst, field.SrcFieldT, field.DstFieldT, 0)))
		b.WriteString("}")
		return b.String()
	}

	// Priority 3: Default conversion logic
	return generateConversion(im, src, dst, field.SrcFieldT, field.DstFieldT, 0)
}

func generateConversion(im *goscan.ImportManager, src, dst string, srcT, dstT *scanner.FieldType, depth int) string {
	if srcT == nil || dstT == nil {
		return fmt.Sprintf("// srcT or dstT is nil for %s -> %s", src, dst)
	}

	// Pointer to Pointer
	if srcT.IsPointer && dstT.IsPointer {
		if srcT.Elem == nil || dstT.Elem == nil {
			return fmt.Sprintf("%s = %s // Cannot convert pointer types, element type is nil", dst, src)
		}
		var b strings.Builder
		b.WriteString(fmt.Sprintf("if %s != nil {\n", src))
		b.WriteString(fmt.Sprintf("\ttmp := %s\n", getTypeName(im, dstT.Elem)))
		b.WriteString(fmt.Sprintf("\t%s\n", generateConversion(im, "(*"+src+")", "tmp", srcT.Elem, dstT.Elem, depth+1)))
		b.WriteString(fmt.Sprintf("\t%s = &tmp\n", dst))
		b.WriteString("} else {\n")
		b.WriteString(fmt.Sprintf("\t%s = nil\n", dst))
		b.WriteString("}")
		return b.String()
	}
	// Pointer to Value
	if srcT.IsPointer && !dstT.IsPointer {
		if srcT.Elem == nil {
			return fmt.Sprintf("// Cannot convert pointer to value, element type is nil")
		}
		return fmt.Sprintf("if %s != nil {\n\t%s\n}", src, generateConversion(im, "(*"+src+")", dst, srcT.Elem, dstT, depth+1))
	}
	// Value to Pointer
	if !srcT.IsPointer && dstT.IsPointer {
		if dstT.Elem == nil {
			return fmt.Sprintf("// Cannot convert value to pointer, element type is nil")
		}
		var b strings.Builder
		b.WriteString("{\n")
		b.WriteString(fmt.Sprintf("\ttmp := %s\n", getTypeName(im, dstT.Elem)))
		b.WriteString(fmt.Sprintf("\t%s\n", generateConversion(im, src, "tmp", srcT, dstT.Elem, depth+1)))
		b.WriteString(fmt.Sprintf("\t%s = &tmp\n", dst))
		b.WriteString("}")
		return b.String()
	}

	// Slices
	if srcT.IsSlice && dstT.IsSlice {
		return generateSliceConversion(im, src, dst, srcT, dstT, depth)
	}

	// Maps
	if srcT.IsMap && dstT.IsMap {
		return generateMapConversion(im, src, dst, srcT, dstT, depth)
	}

	// Structs
	if isStruct(srcT) && isStruct(dstT) && srcT.Name != "" && dstT.Name != "" {
		return fmt.Sprintf("%s = convert%sTo%s(ctx, ec, &%s)", dst, srcT.Name, dstT.Name, src)
	}

	// Basic assignment
	return fmt.Sprintf("%s = %s", dst, src)
}

func generateSliceConversion(im *goscan.ImportManager, src, dst string, srcT, dstT *scanner.FieldType, depth int) string {
	if srcT.Elem == nil || dstT.Elem == nil {
		return ""
	}

	var b strings.Builder
	b.WriteString(fmt.Sprintf("{\n"))
	b.WriteString(fmt.Sprintf("\tconvertedSlice := make([]%s, len(%s))\n", getTypeName(im, dstT.Elem), src))
	b.WriteString(fmt.Sprintf("\tfor i, item := range %s {\n", src))
	b.WriteString(fmt.Sprintf("\t\t%s\n", generateConversion(im, "item", "convertedSlice[i]", srcT.Elem, dstT.Elem, depth+2)))
	b.WriteString(fmt.Sprintf("\t}\n"))
	b.WriteString(fmt.Sprintf("\t%s = convertedSlice\n", dst))
	b.WriteString(fmt.Sprintf("}"))
	return b.String()
}

func generateMapConversion(im *goscan.ImportManager, src, dst string, srcT, dstT *scanner.FieldType, depth int) string {
	if srcT.MapKey == nil || srcT.Elem == nil || dstT.MapKey == nil || dstT.Elem == nil {
		return ""
	}

	var b strings.Builder
	b.WriteString(fmt.Sprintf("{\n"))
	b.WriteString(fmt.Sprintf("\tconvertedMap := make(map[%s]%s, len(%s))\n", getTypeName(im, dstT.MapKey), getTypeName(im, dstT.Elem), src))
	b.WriteString(fmt.Sprintf("\tfor key, value := range %s {\n", src))
	b.WriteString(fmt.Sprintf("\t\t%s\n", generateConversion(im, "value", "convertedMap[key]", srcT.Elem, dstT.Elem, depth+2)))
	b.WriteString(fmt.Sprintf("\t}\n"))
	b.WriteString(fmt.Sprintf("\t%s = convertedMap\n", dst))
	b.WriteString(fmt.Sprintf("}"))
	return b.String()
}

func getTypeName(im *goscan.ImportManager, t *scanner.FieldType) string {
	if t == nil {
		return "interface{}"
	}
	var sb strings.Builder
	if t.IsPointer {
		sb.WriteString("*")
		if t.Elem != nil {
			sb.WriteString(getTypeName(im, t.Elem))
		} else {
			sb.WriteString("interface{}")
		}
		return sb.String()
	}
	if t.IsSlice {
		sb.WriteString("[]")
		if t.Elem != nil {
			sb.WriteString(getTypeName(im, t.Elem))
		} else {
			sb.WriteString("interface{}")
		}
		return sb.String()
	}
	if t.IsMap {
		keyType := "interface{}"
		if t.MapKey != nil {
			keyType = getTypeName(im, t.MapKey)
		}
		valType := "interface{}"
		if t.Elem != nil {
			valType = getTypeName(im, t.Elem)
		}
		return fmt.Sprintf("map[%s]%s", keyType, valType)
	}
	return im.Qualify(t.FullImportPath(), t.Name)
}

func isStruct(t *scanner.FieldType) bool {
	if t == nil {
		return false
	}
	if t.IsPointer {
		if t.Elem == nil {
			return false
		}
		return isStruct(t.Elem)
	}
	return t.Definition != nil && t.Definition.Kind == scanner.StructKind
}

func getFullTypeNameFromTypeInfo(t *scanner.TypeInfo) string {
	if t == nil {
		return ""
	}
	if t.PkgPath != "" {
		return fmt.Sprintf("%s.%s", t.PkgPath, t.Name)
	}
	// This handles primitive types or types in the same package
	if t.Underlying != nil && t.Underlying.IsBuiltin {
		return t.Name
	}
	if t.Underlying != nil && t.Underlying.PkgName != "" {
		return fmt.Sprintf("%s.%s", t.Underlying.PkgName, t.Underlying.Name)
	}
	return t.Name
}
