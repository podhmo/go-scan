package complex

// This file contains the conversion directives for the 'complex' package.
// It's used by the convert2 tool to generate conversion functions.

//go:generate go run ../../main.go -input . -output ./gen/

// Convert UserRequest to User
// //convert:pair UserRequest -> User
// The above is commented out because we will test a global rule for UserRequest -> User with a 'using' for the whole struct first.
// Then, for more granular field tests, we might enable this and remove the global 'using'.

// Convert AddressRequest to Address
// This will be implicitly handled by the UserRequest -> User conversion if RawAddress -> HomeAddress mapping is done via a 'using' function.
// If we wanted a standalone Address converter:
// //convert:pair AddressRequest -> Address

// Convert OrderItemRequest to OrderItem
// //convert:pair OrderItemRequest -> OrderItem

// Convert OrderRequest to Order
// //convert:pair OrderRequest -> Order

// Convert ValidatedInput to itself (useful if a validator is the only thing)
// //convert:pair ValidatedInput -> ValidatedInput

// --- Global Rules ---

// Example of a global 'using' rule for a specific type pair (struct level)
// //convert:rule "complex.SourceUsingStruct" -> "complex.DestUsingStruct", using=WholeStructConversionUsingFunc

// Example using rules for specific fields/types, if not handled by field tags
// //convert:rule "complex.UserID" -> "string", using=ConvertUserIDToString
// //convert:rule "string" -> "complex.UserID", using=ConvertStringToUserID
// //convert:rule "complex.OrderStatus" -> "int", using=ConvertOrderStatusToInt
// //convert:rule "int" -> "complex.OrderStatus", using=ConvertIntToOrderStatus

// Example of a global validator
// //convert:rule "complex.ValidatedInput", validator=ValidateMyInput


// --- Test Scenarios for Generator ---

// Scenario 1: Basic struct with nested struct, slices, and different field names.
// Test: Recursive struct conversion, slice of basic types, field renaming.
// //convert:pair UserRequest -> User

// Scenario 2: Slice of structs.
// Test: Recursive conversion for elements within a slice.
// //convert:pair OrderItemRequest -> OrderItem
// //convert:pair OrderRequest -> Order

// Scenario 3: Underlying types and pointer to basic types.
// Test: Correct handling of named basic types, *string -> string, *bool -> bool.
// (Covered by OrderItemRequest -> OrderItem and OrderRequest -> Order)

// Scenario 4: Using function for a specific field.
// User.FullName should be generated by `using=CombineFullName` on a (non-existent) source field,
// or the generator should be smart enough to map UserRequest to User and allow `using` on User.FullName.
// Let's assume we'll add a tag to User.FullName: `convert:",using=CombineFullName"`
// For Address.Country: `convert:",using=ConvertAddressWithCountryCtx"`

// Scenario 5: Validator function for a destination type.
// //convert:pair ValidatedInput -> ValidatedInput // to trigger generation
// //convert:rule "complex.ValidatedInput", validator=ValidateMyInput

// Scenario 6: Whole struct conversion using a single 'using' function.
// //convert:pair SourceUsingStruct -> DestUsingStruct
// //convert:rule "complex.SourceUsingStruct" -> "complex.DestUsingStruct", using=WholeStructConversionUsingFunc


// --- CONSOLIDATED DIRECTIVES FOR TEST RUN ---
// (Uncomment and select specific scenarios by commenting/uncommenting pairs)

// Pair 1: UserRequest -> User (tests nesting, slices, field renames, field 'using' funcs)
// //convert:pair UserRequest -> User

// Pair 2: OrderRequest -> Order (tests slice of structs, *bool -> bool, underlying types)
// //convert:pair OrderItemRequest -> OrderItem
// //convert:pair OrderRequest -> Order

// Pair 3: Validation
// //convert:pair ValidatedInput -> ValidatedInput
// //convert:rule "complex.ValidatedInput", validator=ValidateMyInput

// Pair 4: Whole struct conversion with 'using'
// //convert:pair SourceUsingStruct -> DestUsingStruct
// //convert:rule "complex.SourceUsingStruct" -> "complex.DestUsingStruct", using=WholeStructConversionUsingFunc


// --- Focused test for recursive and advanced features ---
// convert:pair UserRequest -> User
// convert:pair OrderItemRequest -> OrderItem
// convert:pair OrderRequest -> Order
// convert:pair ValidatedInput -> ValidatedInput
// convert:rule "ValidatedInput", validator=ValidateMyInput
// convert:pair SourceUsingStruct -> DestUsingStruct
// convert:rule "SourceUsingStruct" -> "DestUsingStruct", using=WholeStructConversionUsingFunc

// Simpler set for initial testing of recursion and using:
// convert:pair UserRequest -> User
// convert:pair AddressRequest -> Address // For standalone test
// convert:pair OrderRequest -> Order
// convert:pair OrderItemRequest -> OrderItem

// Final set for this PR (testing primary goals)
// convert:pair UserRequest -> User
// convert:pair OrderRequest -> Order
// convert:pair OrderItemRequest -> OrderItem // Dependency for OrderRequest
// convert:pair ValidatedInput -> ValidatedInput // For validator
// convert:rule "ValidatedInput", validator=ValidateMyInput
// convert:pair SourceUsingStruct -> DestUsingStruct // For whole-struct using
// convert:rule "SourceUsingStruct" -> "DestUsingStruct", using=WholeStructConversionUsingFunc
// convert:rule "string" -> "UserID", using=ConvertStringToUserID
// convert:rule "UserID" -> "string", using=ConvertUserIDToString
// convert:rule "int" -> "OrderStatus", using=ConvertIntToOrderStatus
// convert:rule "OrderStatus" -> "int", using=ConvertOrderStatusToInt

// For UserRequest.RawAddress (*AddressRequest) to User.HomeAddress (*Address)
// the 'using' on Address.Country is ConvertAddressWithCountryCtx
// We need a global rule or field tag for *AddressRequest -> *Address
// Let's assume User.HomeAddress has `convert:"RawAddress,using=ConvertAddressWithCountryCtx"`
// No, ConvertAddressWithCountryCtx takes *AddressRequest and returns *Address.
// So, on User.HomeAddress: `convert:"RawAddress,using=ConvertAddressWithCountryCtx"` is correct.

// For User.FullName: `convert:",using=CombineFullName"` (source is UserRequest implicitly)
// For OrderItem.Comment: `convert:"Notes,using=PtrStringToString"`
// For Order.RushOrder: `convert:"IsRush,using=PtrBoolToBool"`

// For Order.Status: `convert:",using=ConvertIntToOrderStatus"` (if source was int)
// Or if source is OrderRequest and Order.Status is set from a specific field,
// e.g. OrderRequest.StatusCodeInt `convert:"StatusCodeInt,using=ConvertIntToOrderStatus"`

// Let's define the active directives for the test run:

// convert:pair UserRequest -> User
// convert:pair ValidatedInput -> ValidatedInput
// convert:rule "ValidatedInput", validator=ValidateMyInput

// convert:pair AddressRequest -> Address // For direct test of address conversion with context
// convert:pair OrderItemRequest -> OrderItem
// convert:pair OrderRequest -> Order
// convert:pair SourceUsingStruct -> DestUsingStruct
// convert:rule "SourceUsingStruct" -> "DestUsingStruct", using=WholeStructConversionUsingFunc
