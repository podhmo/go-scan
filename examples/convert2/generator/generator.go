package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"example.com/convert2/internal/model"
)

const fileSuffix = "_gen.go"

// GenerateConversionCode generates conversion functions based on parsedInfo
// and writes them to *_gen.go files in the outputDir.
func GenerateConversionCode(parsedInfo *model.ParsedInfo, outputDir string) error {
	if len(parsedInfo.ConversionPairs) == 0 {
		fmt.Println("No conversion pairs defined. Nothing to generate.")
		return nil
	}

	outputFileName := fmt.Sprintf("%s%s", parsedInfo.PackageName, fileSuffix)
	outputFilePath := filepath.Join(outputDir, outputFileName)

	var generatedCode bytes.Buffer

	// --- Package and Imports ---
	// Initial set of imports. This will be expanded by addRequiredImport.
	requiredImports := make(map[string]string) // alias -> path
	requiredImports["context"] = "context"
	requiredImports["fmt"] = "fmt"     // For error messages in errorCollector
	requiredImports["errors"] = "errors" // For errors.Join

	// --- Generate Error Collector ---
	errCollectorTmpl, err := template.New("errorCollector").Parse(errorCollectorTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse errorCollector template: %w", err)
	}
	err = errCollectorTmpl.Execute(&generatedCode, nil)
	if err != nil {
		return fmt.Errorf("failed to execute errorCollector template: %w", err)
	}
	generatedCode.WriteString("\n\n")

	// --- Generate Conversion Functions ---
	generatedFunctionBodies := make(map[string]string) // funcName -> funcBody

	// First, generate all helper functions to ensure they are available
	// and to collect their required imports.
	for _, pair := range parsedInfo.ConversionPairs {
		coreHelperFuncName := fmt.Sprintf("%sTo%s", lowercaseFirstLetter(pair.SrcTypeInfo.Name), pair.DstTypeInfo.Name)
		if _, exists := generatedFunctionBodies[coreHelperFuncName]; !exists {
			var helperFuncBuf bytes.Buffer
			err := generateHelperFunction(&helperFuncBuf, coreHelperFuncName, pair.SrcTypeInfo, pair.DstTypeInfo, parsedInfo, requiredImports)
			if err != nil {
				return fmt.Errorf("failed to generate helper function %s: %w", coreHelperFuncName, err)
			}
			generatedFunctionBodies[coreHelperFuncName] = helperFuncBuf.String()
		}
	}
	// Potentially generate more helpers if rules or nested structs demand them (recursive step)
	// This part needs to be more sophisticated for deeply nested structures.
	// For now, we only generate helpers directly from ConversionPairs.


	// Then, generate top-level functions
	for _, pair := range parsedInfo.ConversionPairs {
		topLevelFuncName := fmt.Sprintf("Convert%s", pair.SrcTypeInfo.Name)
		if _, exists := generatedFunctionBodies[topLevelFuncName]; exists {
			continue
		}

		var funcBuf bytes.Buffer
		coreHelperFuncName := fmt.Sprintf("%sTo%s", lowercaseFirstLetter(pair.SrcTypeInfo.Name), pair.DstTypeInfo.Name)

		// Add imports for source and destination types of the top-level function
		addRequiredImport(pair.SrcTypeInfo, parsedInfo.PackagePath, requiredImports)
		addRequiredImport(pair.DstTypeInfo, parsedInfo.PackagePath, requiredImports)


		fmt.Fprintf(&funcBuf, "func %s(ctx context.Context, src %s) (%s, error) {\n",
			topLevelFuncName,
			typeNameInSource(pair.SrcTypeInfo, parsedInfo.PackagePath),
			typeNameInSource(pair.DstTypeInfo, parsedInfo.PackagePath))
		fmt.Fprintf(&funcBuf, "\tec := newErrorCollector(%d)\n", pair.MaxErrors)
		fmt.Fprintf(&funcBuf, "\tdst := %s(ec, src)\n", coreHelperFuncName) // Call helper
		fmt.Fprintf(&funcBuf, "\tif ec.HasErrors() {\n")
		fmt.Fprintf(&funcBuf, "\t\treturn dst, errors.Join(ec.Errors()...)\n")
		fmt.Fprintf(&funcBuf, "\t}\n")
		fmt.Fprintf(&funcBuf, "\treturn dst, nil\n")
		fmt.Fprintf(&funcBuf, "}\n\n")

		generatedFunctionBodies[topLevelFuncName] = funcBuf.String()
	}


	// --- Assemble Final Code ---
	var finalCode bytes.Buffer
	fmt.Fprintf(&finalCode, "// Code generated by convert2 tool. DO NOT EDIT.\n")
	fmt.Fprintf(&finalCode, "package %s\n\n", parsedInfo.PackageName)

	// Write imports
	if len(requiredImports) > 0 {
		finalCode.WriteString("import (\n")
		// Sort imports for consistent output? For now, map iteration order.
		for alias, importPath := range requiredImports {
			if alias == importPath || strings.HasSuffix(importPath, "/"+alias) { // stdlib or path ends with alias
				fmt.Fprintf(&finalCode, "\t\"%s\"\n", importPath)
			} else {
				fmt.Fprintf(&finalCode, "\t%s \"%s\"\n", alias, importPath)
			}
		}
		finalCode.WriteString(")\n\n")
	}

	finalCode.Write(generatedCode.Bytes()) // Error collector code

	// Write helper functions first
	for funcName, funcBody := range generatedFunctionBodies {
		if !strings.HasPrefix(funcName, "Convert") { // Heuristic for helpers
			finalCode.WriteString(funcBody)
		}
	}
	// Then top-level functions
	for funcName, funcBody := range generatedFunctionBodies {
		if strings.HasPrefix(funcName, "Convert") {
			finalCode.WriteString(funcBody)
		}
	}

	// --- Format and Write to File ---
	formattedCode, err := format.Source(finalCode.Bytes())
	if err != nil {
		os.WriteFile(outputFilePath+".unformatted", finalCode.Bytes(), 0644)
		return fmt.Errorf("failed to format generated code for %s: %w\nUnformatted code saved to %s.unformatted", outputFileName, err, outputFilePath)
	}

	err = os.MkdirAll(outputDir, 0755)
	if err != nil {
		return fmt.Errorf("failed to create output directory %s: %w", outputDir, err)
	}

	err = os.WriteFile(outputFilePath, formattedCode, 0644)
	if err != nil {
		return fmt.Errorf("failed to write generated code to %s: %w", outputFilePath, err)
	}

	fmt.Printf("Generated conversion code at %s\n", outputFilePath)
	return nil
}

// generateHelperFunction generates the non-exported core conversion logic.
func generateHelperFunction(buf *bytes.Buffer, funcName string, srcType, dstType *model.TypeInfo, parsedInfo *model.ParsedInfo, imports map[string]string) error {
	if srcType.StructInfo == nil || dstType.StructInfo == nil {
		// Handle non-struct or unresolved struct types (e.g. named basic types)
		// This part will require using global conversion rules or direct assignment if types are compatible.
		fmt.Fprintf(buf, "// Helper function %s for types %s -> %s\n", funcName, srcType.FullName, dstType.FullName)
		fmt.Fprintf(buf, "// One or both types are not structs, or struct info not found.\n")
		fmt.Fprintf(buf, "func %s(ec *errorCollector, src %s) %s {\n",
			funcName,
			typeNameInSource(srcType, parsedInfo.PackagePath),
			typeNameInSource(dstType, parsedInfo.PackagePath))
		// TODO: Implement conversion for non-structs or when one is not a struct.
		// This could involve checking for global 'using' rules, or direct assignment/casting if types are compatible.
		// Example: if types are `type Meter int32` and `type Centimeter int32`
		fmt.Fprintf(buf, "\t// Placeholder for non-struct conversion logic.\n")
		if srcType.FullName == dstType.FullName || (srcType.Underlying != nil && srcType.Underlying.FullName == dstType.FullName) || (dstType.Underlying != nil && dstType.Underlying.FullName == srcType.FullName) {
			fmt.Fprintf(buf, "\treturn %s(src) // Assuming direct cast is possible\n", typeNameInSource(dstType, parsedInfo.PackagePath))
		} else {
			fmt.Fprintf(buf, "\tvar dst %s\n", typeNameInSource(dstType, parsedInfo.PackagePath))
			fmt.Fprintf(buf, "\tec.Addf(\"conversion from %s to %s not implemented for non-structs or mismatched types\")\n", srcType.FullName, dstType.FullName)
			fmt.Fprintf(buf, "\treturn dst\n")
		}
		fmt.Fprintf(buf, "}\n\n")
		addRequiredImport(srcType, parsedInfo.PackagePath, imports)
		addRequiredImport(dstType, parsedInfo.PackagePath, imports)
		return nil
	}

	srcStruct := srcType.StructInfo
	dstStruct := dstType.StructInfo

	// Add imports for src and dst types of this helper
	addRequiredImport(srcType, parsedInfo.PackagePath, imports)
	addRequiredImport(dstType, parsedInfo.PackagePath, imports)

	fmt.Fprintf(buf, "func %s(ec *errorCollector, src %s) %s {\n",
		funcName,
		typeNameInSource(srcType, parsedInfo.PackagePath), // Use srcStruct.Type.Name if it's simpler and resolved locally
		typeNameInSource(dstType, parsedInfo.PackagePath))
	fmt.Fprintf(buf, "\tdst := %s{}\n", typeNameInSource(dstType, parsedInfo.PackagePath))
	fmt.Fprintf(buf, "\tif ec.MaxErrorsReached() { return dst } \n\n")

	// Iterate over source struct fields to apply rules and find destinations
	for _, srcField := range srcStruct.Fields {
		if srcField.Tag.DstFieldName == "-" {
			fmt.Fprintf(buf, "\t// Source field %s.%s is skipped due to tag '-'.\n", srcStruct.Name, srcField.Name)
			continue
		}

		dstFieldName := srcField.Tag.DstFieldName
		if dstFieldName == "" { // No specific destination name in tag, use source field name
			dstFieldName = srcField.Name
		}

		var dstField *model.FieldInfo
		for i := range dstStruct.Fields {
			if dstStruct.Fields[i].Name == dstFieldName {
				dstField = &dstStruct.Fields[i]
				break
			}
		}

		if dstField == nil {
			// No destination field found with the target name.
			// If auto-mapping by normalized name was intended, that's a later step.
			// For now, if explicit name or same name doesn't match, we report (or silently skip).
			// Let's add a comment for now if a DstFieldName was specified in tag but not found.
			if srcField.Tag.DstFieldName != "" {
				 fmt.Fprintf(buf, "\t// Warning: Destination field '%s' specified for source field '%s.%s' not found in struct '%s'.\n", srcField.Tag.DstFieldName, srcStruct.Name, srcField.Name, dstStruct.Name)
			}
			continue
		}

		// Found source field and corresponding destination field.
		// Now, implement basic direct assignment if types match.
		fmt.Fprintf(buf, "\t// Mapping field %s.%s to %s.%s\n", srcStruct.Name, srcField.Name, dstStruct.Name, dstField.Name)
		fmt.Fprintf(buf, "\tec.Enter(%q)\n", dstField.Name) // Path uses DstFieldName

		// Add imports for field types
		addRequiredImport(srcField.TypeInfo, parsedInfo.PackagePath, imports)
		addRequiredImport(dstField.TypeInfo, parsedInfo.PackagePath, imports)


		// TODO: Priority 1: Field Tag `using=<funcName>`
		// TODO: Priority 2: Global Rule `convert:rule "<SrcT>" -> "<DstT>", using=<funcName>`

		// Priority 3: Automatic Conversion (Basic Direct Assignment)
		if srcField.TypeInfo.FullName == dstField.TypeInfo.FullName {
			// Direct assignment
			fmt.Fprintf(buf, "\tdst.%s = src.%s\n", dstField.Name, srcField.Name)
		} else {
			// Types do not match directly. Placeholder for more complex logic.
			// This is where underlying type checks, pointer logic, slice/map conversions,
			// and recursive struct conversions will go.
			fmt.Fprintf(buf, "\t// TODO: Implement conversion for %s (%s) to %s (%s).\n",
				srcField.Name, srcField.TypeInfo.FullName,
				dstField.Name, dstField.TypeInfo.FullName)
			fmt.Fprintf(buf, "\tec.Addf(\"type mismatch or complex conversion not yet implemented for field '%s' (%s -> %s)\")\n",
				dstField.Name, srcField.TypeInfo.FullName, dstField.TypeInfo.FullName)
		}

		fmt.Fprintf(buf, "\tec.Leave()\n")
		fmt.Fprintf(buf, "\tif ec.MaxErrorsReached() { return dst } \n\n")
	}

	fmt.Fprintf(buf, "\treturn dst\n")
	fmt.Fprintf(buf, "}\n\n")
	return nil
}

// typeNameInSource returns the string representation of the type as it should appear in the generated source code.
// It considers if the type is from the package being generated into, or an external package.
func typeNameInSource(typeInfo *model.TypeInfo, currentPackagePath string) string {
	if typeInfo == nil {
		return "interface{}" // Fallback for nil TypeInfo
	}

	var buildName func(ti *model.TypeInfo) string
	buildName = func(ti *model.TypeInfo) string {
		if ti.IsPointer {
			return "*" + buildName(ti.Elem)
		}
		if ti.IsSlice {
			return "[]" + buildName(ti.Elem)
		}
		if ti.IsArray {
			// Assuming ti.AstExpr is *ast.ArrayType for length
			lenStr := "N" // Placeholder
			if arrType, ok := ti.AstExpr.(*ast.ArrayType); ok && arrType.Len != nil {
				// This is tricky, AstExprToString might not be available here or fully resolved.
				// For now, use a placeholder or the raw string from AST if possible.
				// A simple way: model.AstExprToString(arrType.Len, "")
				// This dependency is problematic. For now, just use "N"
				// lenStr = model.AstExprToString(arrType.Len, "") // Needs package context for AstExprToString
				// Let's use a simpler name from TypeInfo if available or just N
				if arrTypeNode, ok := ti.AstExpr.(*ast.ArrayType); ok && arrTypeNode.Len != nil {
					lenStr = model.AstExprToString(arrTypeNode.Len, "") // Pass empty pkg name for simplicity
				}

			}
			return "[" + lenStr + "]" + buildName(ti.Elem)
		}
		if ti.IsMap {
			return fmt.Sprintf("map[%s]%s", buildName(ti.Key), buildName(ti.Value))
		}

		// For non-composite types (Ident, Basic, Struct, Named)
		if ti.PackagePath != "" && ti.PackagePath != currentPackagePath {
			// Type is from an external package. Need to use its imported name.
			// The import alias logic is handled by addRequiredImport and import statement generation.
			// Here, we just need the package's selector.
			// The TypeInfo.PackageName should be the alias to use if one was defined,
			// or the actual package name if no alias.
			// This requires that TypeInfo.PackageName is correctly set by the parser
			// to the alias used in the *target* generated file, which is tricky.
			// Simpler: use the actual package name (last part of PackagePath) as selector.
			// The import map (`imports` in GenerateConversionCode) will store alias -> path.
			// We need to find the alias for ti.PackagePath.
			// For now, assume ti.PackageName is the correct selector prefix.
			// This needs to be robustly linked to the import alias generation.

			// A common convention: if TypeInfo.PackageName is set by parser from selector (e.g. "pkgalias.MyType")
			// then TypeInfo.PackageName is "pkgalias", TypeInfo.Name is "MyType".
			// The generator must ensure "pkgalias" is imported correctly.
			if ti.PackageName != "" { // PackageName field of TypeInfo should be the alias/name used for import
				return ti.PackageName + "." + ti.Name
			}
			// If PackageName is empty but PackagePath is not, use last part of path as selector
			// This is a fallback.
			parts := strings.Split(ti.PackagePath, "/")
			return parts[len(parts)-1] + "." + ti.Name
		}
		return ti.Name // Type is in the current package or a basic type
	}
	return buildName(typeInfo)
}


// addRequiredImport tracks necessary imports.
// It tries to use the package name as an alias if the package path is not standard
// or if the package name conflicts with another.
// `imports` is a map of import_alias -> import_path.
func addRequiredImport(typeInfo *model.TypeInfo, currentPackagePath string, imports map[string]string) {
	if typeInfo == nil {
		return
	}

	// Recursively add for elements, keys, values, underlying types
	if typeInfo.IsPointer || typeInfo.IsSlice || typeInfo.IsArray {
		addRequiredImport(typeInfo.Elem, currentPackagePath, imports)
	}
	if typeInfo.IsMap {
		addRequiredImport(typeInfo.Key, currentPackagePath, imports)
		addRequiredImport(typeInfo.Value, currentPackagePath, imports)
	}
	if typeInfo.Underlying != nil {
		addRequiredImport(typeInfo.Underlying, currentPackagePath, imports)
	}
	// If it's a struct, iterate its fields' types too (can lead to deep recursion, handle carefully)
	// For now, direct type imports are handled. Field types will be handled when those fields are processed.

	if typeInfo.PackagePath != "" && typeInfo.PackagePath != currentPackagePath {
		// External package, needs import.
		// Use TypeInfo.PackageName as the preferred alias if available from parser (e.g. from selector)
		// Otherwise, derive an alias (e.g., last part of path).
		alias := typeInfo.PackageName // This should be the package name part of a selector if `pkg.Type`
		if alias == "" { // If not from a selector, or if TypeInfo.PackageName was not set for it
			parts := strings.Split(typeInfo.PackagePath, "/")
			alias = parts[len(parts)-1]
		}

		if existingPath, ok := imports[alias]; ok {
			if existingPath != typeInfo.PackagePath {
				// Alias collision! Need to generate a new unique alias.
				// For now, just overwrite and print warning. This needs robust handling.
				fmt.Printf("Warning: Import alias collision for '%s'. Path '%s' overwrites '%s'. Manual intervention may be needed.\n", alias, typeInfo.PackagePath, existingPath)
				imports[alias] = typeInfo.PackagePath // Or generate new_alias_1, new_alias_2 ...
			}
			// If paths are same, alias is already correctly registered.
		} else {
			imports[alias] = typeInfo.PackagePath
		}
		// Ensure TypeInfo.PackageName is updated to the alias that will be used in generated code.
		// This is important for typeNameInSource.
		if typeInfo.PackageName != alias && typeInfo.PackageName != "" {
			// This means the original selector's package part (typeInfo.PackageName) is different from the derived/chosen alias.
			// This can happen if we derive alias from path and it differs from an explicit selector prefix.
			// For generated code, the `alias` is what matters.
			// Let's assume parser sets TypeInfo.PackageName from selector if present,
			// and this function primarily ensures the import exists.
			// typeNameInSource should then use TypeInfo.PackageName (if set) or derive from TypeInfo.PackagePath's alias.
		} else if typeInfo.PackageName == "" {
			typeInfo.PackageName = alias // Set the derived alias back to TypeInfo if it was empty
		}

	}
}


func lowercaseFirstLetter(s string) string {
	if len(s) == 0 {
		return ""
	}
	return strings.ToLower(s[0:1]) + s[1:]
}

// errorCollectorTemplate (content is the same as before)
const errorCollectorTemplate = `
// errorCollector collects errors with path tracking.
type errorCollector struct {
	maxErrors int
	errors    []error
	pathStack []string
}
func newErrorCollector(maxErrors int) *errorCollector {
	return &errorCollector{
		maxErrors: maxErrors,
		errors:    make([]error, 0),
		pathStack: make([]string, 0),
	}
}
func (ec *errorCollector) Add(reason string) bool {
	if ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors {
		return true
	}
	fullPath := strings.Join(ec.pathStack, "")
	err := fmt.Errorf("%s: %s", fullPath, reason)
	ec.errors = append(ec.errors, err)
	return ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors
}
func (ec *errorCollector) Addf(format string, args ...interface{}) bool {
	if ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors {
		return true
	}
	return ec.Add(fmt.Sprintf(format, args...))
}
func (ec *errorCollector) Enter(segment string) {
	separator := "."
	if len(ec.pathStack) == 0 {
		separator = ""
	} else {
		// Check if previous segment is an indexer, if so, no dot.
		// This logic needs to be robust: A.B[0].C
		// Current pathStack is like ["A", ".B", "[0]"]
		// If adding "C", it should be ".C".
		// If pathStack is empty, or ends with non-alphanumeric (like "[0]"), no leading dot for next field.
		// This is simpler: always dot for fields unless it's the first element.
		// Indices are handled by not having a dot.
	}
	if strings.HasPrefix(segment, "[") && strings.HasSuffix(segment, "]") { // Array/slice index
		ec.pathStack = append(ec.pathStack, segment)
	} else { // Field name
		if len(ec.pathStack) == 0 {
			ec.pathStack = append(ec.pathStack, segment)
		} else {
			ec.pathStack = append(ec.pathStack, "."+segment)
		}
	}
}
func (ec *errorCollector) Leave() {
	if len(ec.pathStack) > 0 {
		ec.pathStack = ec.pathStack[:len(ec.pathStack)-1]
	}
}
func (ec *errorCollector) Errors() []error {
	return ec.errors
}
func (ec *errorCollector) HasErrors() bool {
	return len(ec.errors) > 0
}
func (ec *errorCollector) MaxErrorsReached() bool {
	return ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors
}
`
