package goscan

import (
	"bytes"
	"context"
	"fmt"
	"go/format"
	"log/slog"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// GoFile represents a Go source file to be generated.
type GoFile struct {
	PackageName string // PackageName is the name of the package (e.g., "main", "models").
	// Imports is a map of import path to alias.
	// If an alias is not needed, the alias should be an empty string.
	// Example:
	//   Imports = map[string]string{
	//     "fmt": "", // for `import "fmt"`
	//     "custom_errors": "errors", // for `import errors "custom_errors"`
	//     "github.com/pkg/errors": "", // for `import "github.com/pkg/errors"`
	//   }
	Imports map[string]string
	CodeSet string // CodeSet is the body of the Go code to be generated.
}

// PackageDirectory represents a directory where Go files will be saved.
type PackageDirectory struct {
	Path               string // Path is the directory path of the package.
	DefaultPackageName string // DefaultPackageName is used if GoFile.PackageName is empty.
	Overwrite          bool   // Overwrite specifies if existing files should be overwritten. Defaults to true.
}

// NewPackageDirectory creates a new PackageDirectory with default Overwrite behavior (true).
func NewPackageDirectory(path string, defaultPackageName string) *PackageDirectory {
	return &PackageDirectory{
		Path:               path,
		DefaultPackageName: defaultPackageName,
		Overwrite:          true, // Default to true
	}
}

// SaveGoFile generates and saves a Go source file.
// It formats the source code and handles imports.
// filename is the complete name of the file to be saved (e.g., "models_deriving.go").
func (pd *PackageDirectory) SaveGoFile(ctx context.Context, gf GoFile, filename string) error {
	pkgName := gf.PackageName
	if pkgName == "" {
		pkgName = pd.DefaultPackageName
	}
	if pkgName == "" {
		return fmt.Errorf("package name is empty and no default package name is set in PackageDirectory")
	}

	if filename == "" {
		return fmt.Errorf("filename cannot be empty")
	}
	if !strings.HasSuffix(filename, ".go") {
		return fmt.Errorf("filename must end with .go: %s", filename)
	}
	if strings.HasPrefix(filename, "_") { // Conventionally, files starting with _ or . are ignored by go build
		slog.WarnContext(ctx, "Generated filename starts with an underscore, which might be ignored by go tools", slog.String("filename", filename))
	}

	fullOutputPath := filepath.Join(pd.Path, filename)

	// Check if file exists and if overwrite is allowed
	if !pd.Overwrite {
		if _, err := os.Stat(fullOutputPath); err == nil {
			return fmt.Errorf("file %s already exists and overwrite is disabled", fullOutputPath)
		} else if !os.IsNotExist(err) {
			return fmt.Errorf("failed to check if file %s exists: %w", fullOutputPath, err)
		}
	}

	var finalOutput bytes.Buffer
	finalOutput.WriteString(fmt.Sprintf("// Code generated by go-scan for package %s. DO NOT EDIT.\n\n", pkgName))
	finalOutput.WriteString(fmt.Sprintf("package %s\n\n", pkgName))

	if len(gf.Imports) > 0 {
		finalOutput.WriteString("import (\n")
		// Sort imports by path for consistent output
		importPaths := make([]string, 0, len(gf.Imports))
		for path := range gf.Imports {
			importPaths = append(importPaths, path)
		}
		sort.Strings(importPaths)

		for _, importPath := range importPaths {
			alias := gf.Imports[importPath]
			if alias != "" {
				finalOutput.WriteString(fmt.Sprintf("\t%s \"%s\"\n", alias, importPath))
			} else {
				finalOutput.WriteString(fmt.Sprintf("\t\"%s\"\n", importPath))
			}
		}
		finalOutput.WriteString(")\n\n")
	}

	finalOutput.WriteString(gf.CodeSet)

	formattedCode, err := format.Source(finalOutput.Bytes())
	if err != nil {
		// Log the unformatted code for debugging if formatting fails
		slog.ErrorContext(ctx, "Failed to format generated code",
			slog.String("package", pkgName),
			slog.String("path", fullOutputPath),
			slog.Any("error", err),
			slog.String("unformatted_code", finalOutput.String()), // Be cautious with large code strings
		)
		return fmt.Errorf("failed to format generated code for package %s (file: %s): %w. Unformatted code logged", pkgName, filename, err)
	}

	// Ensure the directory exists
	if err := os.MkdirAll(pd.Path, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", pd.Path, err)
	}

	// Remove existing file before writing if Overwrite is true
	if pd.Overwrite {
		if _, statErr := os.Stat(fullOutputPath); statErr == nil { // File exists
			if removeErr := os.Remove(fullOutputPath); removeErr != nil {
				slog.WarnContext(ctx, "Failed to remove existing generated file before writing", slog.String("path", fullOutputPath), slog.Any("error", removeErr))
				// Continue, as WriteFile will likely truncate or overwrite.
			}
		}
	}

	if err := WriteFile(ctx, fullOutputPath, formattedCode, 0644); err != nil {
		return fmt.Errorf("failed to write generated code to %s: %w", fullOutputPath, err)
	}
	slog.InfoContext(ctx, "Generated code written", slog.String("path", fullOutputPath))
	return nil
}

// ContextKey is a private type for context keys to avoid collisions.
type ContextKey string

const (
	// FileWriterKey is the context key for the file writer interceptor.
	FileWriterKey = ContextKey("fileWriter")
)

// FileWriter is an interface for writing files, allowing for interception during tests.
type FileWriter interface {
	WriteFile(ctx context.Context, path string, data []byte, perm os.FileMode) error
}

// WriteFile is a context-aware file writing function.
// It checks the context for a FileWriter and uses it if available.
// Otherwise, it falls back to os.WriteFile.
func WriteFile(ctx context.Context, path string, data []byte, perm os.FileMode) error {
	if writer, ok := ctx.Value(FileWriterKey).(FileWriter); ok {
		return writer.WriteFile(ctx, path, data, perm)
	}
	return os.WriteFile(path, data, perm)
}
