package generator

import (
	"context"
	"go/format"
	"path/filepath"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/podhmo/go-scan"
	"github.com/podhmo/go-scan/parser"
	"github.com/podhmo/go-scan/scantest"
)

func TestGenerate_CrossPackage_WithSlices(t *testing.T) {
	files := map[string]string{
		"go.mod": `
module github.com/podhmo/go-scan
go 1.24
`,
		"models/source/source.go": `
package source
import "time"

// @derivingconvert("github.com/podhmo/go-scan/models/destination.DstUser")
type SrcUser struct {
	ID   int64
	Name string
}

// @derivingconvert("github.com/podhmo/go-scan/models/destination.DstOrder")
type SrcOrder struct {
	OrderID string
	Items   []SrcItem
}

type SrcItem struct {
	SKU      string
	Quantity int
}
`,
		"models/destination/destination.go": `
package destination

type DstUser struct {
	ID   int64
	Name string
}

type DstOrder struct {
	OrderID string
	Items   []DstItem
}

type DstItem struct {
	SKU      string
	Quantity int
}
`,
	}

	tmpdir, cleanup := scantest.WriteFiles(t, files)
	defer cleanup()

	ctx := context.Background()
	s, err := goscan.New(goscan.WithWorkDir(tmpdir))
	if err != nil {
		t.Fatalf("goscan.New failed: %+v", err)
	}

	pkg, err := s.ScanPackage(ctx, filepath.Join(tmpdir, "models/source"))
	if err != nil {
		t.Fatalf("s.ScanPackage failed: %+v", err)
	}

	pairs, err := parser.Parse(ctx, pkg, s)
	if err != nil {
		t.Fatalf("parser.Parse failed: %+v", err)
	}

	got, err := Generate("converter", pairs, pkg)
	if err != nil {
		t.Fatalf("Generate failed: %+v", err)
	}

	want := `// Code generated by go-scan for package converter. DO NOT EDIT.

package converter

import (
	"context"
	destination "github.com/podhmo/go-scan/models/destination"
	source "github.com/podhmo/go-scan/models/source"
)

// ConvertSrcUserToDstUser converts SrcUser to DstUser.
func ConvertSrcUserToDstUser(ctx context.Context, src source.SrcUser) (destination.DstUser, error) {
	dst := convertSrcUserToDstUser(ctx, src)
	return dst, nil
}

// convertSrcUserToDstUser is the internal conversion function.
func convertSrcUserToDstUser(ctx context.Context, src source.SrcUser) destination.DstUser {
	dst := destination.DstUser{}
	dst.ID = src.ID
	dst.Name = src.Name
	return dst
}

// ConvertSrcOrderToDstOrder converts SrcOrder to DstOrder.
func ConvertSrcOrderToDstOrder(ctx context.Context, src source.SrcOrder) (destination.DstOrder, error) {
	dst := convertSrcOrderToDstOrder(ctx, src)
	return dst, nil
}

// convertSrcOrderToDstOrder is the internal conversion function.
func convertSrcOrderToDstOrder(ctx context.Context, src source.SrcOrder) destination.DstOrder {
	dst := destination.DstOrder{}
	dst.OrderID = src.OrderID
	if src.Items != nil {
		newSlice := make([]destination.DstItem, 0, len(src.Items))
		for _, elem := range src.Items {
			newSlice = append(newSlice, convertSrcItemToDstItem(ctx, elem))
		}
		dst.Items = newSlice
	}
	return dst
}

// convertSrcItemToDstItem is the internal conversion function.
func convertSrcItemToDstItem(ctx context.Context, src source.SrcItem) destination.DstItem {
	dst := destination.DstItem{}
	dst.SKU = src.SKU
	dst.Quantity = src.Quantity
	return dst
}
`

	formattedGot, err := format.Source(got)
	if err != nil {
		t.Logf("failed to format generated code: %+v\n--- raw output ---\n%s", err, string(got))
		formattedGot = got
	}

	formattedWant, err := format.Source([]byte(want))
	if err != nil {
		t.Fatalf("failed to format want code: %+v\n--- raw output ---\n%s", err, want)
	}

	if diff := cmp.Diff(strings.TrimSpace(string(formattedWant)), strings.TrimSpace(string(formattedGot))); diff != "" {
		t.Errorf("generated code mismatch (-want +got):\n%s", diff)
	}
}
