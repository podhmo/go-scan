# `find-orphans`における孤児（Orphan）の定義

このドキュメントでは、`find-orphans`ツールが検出する「孤児（Orphan）」の技術的な定義について詳述します。

## 基本的な定義

孤児とは、**分析スコープ内において、定義された一連の開始点から到達不可能な関数またはメソッド**を指します。

言い換えると、プログラムの実行開始点から呼び出しグラフをたどっていったときに、一度も呼び出されることのない関数やメソッドが孤児と見なされます。

## 分析の構成要素

孤児の定義は、以下の3つの重要な要素に依存します。

1.  **分析スコープ (Analysis Scope)**
    -   これは、ツールが関数の使用状況を分析するためにスキャンするコードの「全体集合」です。
    -   通常、ワークスペース（`--workspace-root`で指定）または単一のGoモジュール全体が含まれます。このスコープ内のすべての関数呼び出しが、使用状況の判断材料となります。

2.  **ターゲットスコープ (Target Scope)**
    -   これは、ツールが孤児を**報告する**対象となるパッケージの集合です。
    -   コマンドライン引数で与えられるパッケージパターン（例: `./...`）によって定義されます。
    -   分析スコープ内のコードから呼び出しがあったとしても、その関数がターゲットスコープ内に存在しなければ、孤児としては報告されません。

3.  **分析モードと探索の起点**
    -   分析は、`--mode`フラグで指定されたモードに基づいて行われます。モードによって、どの関数から呼び出しグラフの探索を始めるか、そして何を「孤児」と判断するかの基準が異なります。
    -   **アプリケーションモード (`app`)**:
        -   **探索の起点**: `main.main` 関数のみ。
        -   **孤児の判定**: `main.main`から到達不可能な全ての関数・メソッドが孤児となります。`main.main`自体は、定義上「使用済み」と見なされ、孤児にはなりません。
        -   **用途**: 実行可能バイナリ内のデッドコード検出に適しています。
    -   **ライブラリモード (`lib`)**:
        -   **探索の起点**: 分析スコープ内の**すべてのエクスポートされた（publicな）関数・メソッド、すべての`init`関数、そして`main.main`関数**。
        -   **孤児の判定**: ライブラリモードの目的は、公開APIの中で実際に使われていないものを発見することです。そのため、探索の起点となるエクスポートされた関数自体も、**他のどのコードからも呼び出されていなければ「孤児」として報告されます**。つまり、エクスポートされた関数は、呼び出しグラフをたどるための起点にはなりますが、それだけで自動的に「使用済み」とは見なされません。
        -   **用途**: ライブラリとして提供されるAPIのうち、利用されていないものを検出するのに適しています。
    -   **自動モード (`auto`, デフォルト)**:
        -   分析スコープ内に `main.main` 関数が存在すればアプリケーションモード、存在しなければライブラリモードが自動的に選択されます。

## 孤児と判定されるプロセスの要約

1.  ツールはまず、分析スコープとターゲットスコープを決定します。
2.  **アプリケーションモードの場合**: `main.main` を「使用済み」としてマークします。
3.  シンボリック実行エンジン（`symgo`）が、分析の開始点（アプリケーションモードでは `main.main`、ライブラリモードでは全てのエクスポートされた関数・メソッド）から呼び出しグラフを再帰的にたどります。
4.  この過程で呼び出された全ての関数とメソッドが「使用済み」としてマークされます。
    -   ある開始点（例: `exported`な関数A）から到達可能な関数（例: `unexported`な関数f）があり、その関数fが別の関数（例: `exported`な関数H）を呼び出している場合、Hも「使用済み」と見なされます。つまり、同じパッケージ内での呼び出しもすべて考慮されます。
    -   インターフェースのメソッド呼び出しについては、そのメソッドを実装するすべての具象型のメソッドが「使用済み」と見なされる保守的な分析が行われます。
    -   **エラーハンドリング**: ライブラリモードで多数の関数を分析する際、特定の関数の解析でエラーが発生しても、ツールは全体を停止させません。エラーをログに出力し、残りの関数の分析を続行します。
5.  分析完了後、「使用済み」とマークされなかった関数のうち、**ターゲットスコープ**に属するものが孤児として報告されます。結果として、ライブラリモードでは、他のどの関数・メソッドからも呼び出されない `exported` な関数・メソッドも孤児として報告され得ます。

## symgoの評価対象と分析スコープ

`find-orphans` は内部的に `symgo` というシンボリック実行エンジンを利用して、関数の利用状況を解析します。`symgo` がどの範囲のコードを評価対象とするかを理解することは、ツールの挙動を把握する上で重要です。

-   **分析スコープ (Analysis Scope)**
    -   `--workspace-root` フラグ（または、指定がない場合はカレントモジュール）によって定義される、`symgo`がソースコードレベルで解析するGoパッケージの集合を「分析スコープ」と呼びます。
    -   **スコープ内の関数・メソッド**: `symgo`は、これらの関数やメソッドの内部実装をすべて評価します。つまり、関数Aが関数Bを呼び出していれば、その呼び出しを正確にトレースし、Bが「使用済み」であることを記録します。

-   **分析スコープ外の関数・メソッド**
    -   外部の依存ライブラリ（例: `gopkg.in/yaml.v3`）など、分析スコープに含まれないパッケージの関数がこれに該当します。
    -   `symgo`はこれらの関数のソースコードを持たないため、関数シグネチャ（引数や返り値の型）は認識できますが、その**内部の動作をトレースすることはできません**。
    -   例えば、分析スコープ内のコードが外部ライブラリの関数を呼び出した場合、`symgo`はその呼び出しを認識しますが、その外部関数が内部でさらにどの関数を呼び出しているかまでは追跡しません。分析の連鎖はそこで停止します。

> **実装上の注意点**
> 上記の挙動を実現するため、`find-orphans`ツールは、`symgo`エンジンに渡すパッケージ群を、あらかじめ定義された分析スコープ内に限定する責務を持ちます。もしこの絞り込みに失敗し、分析スコープ外のシンボル情報が`symgo`に渡されると、予期せぬエラーを引き起こす可能性があります。

### 除外されるケース

以下の関数は、孤児として報告されることはありません。

-   `main.main` 関数および `init` 関数（これらは言語仕様上の特別なエントリーポイントです）。
-   `//go:scan:ignore` アノテーションが付与された関数。
-   `_test.go` ファイル内に存在する、テスト実行の起点となる関数（`TestXxx`, `BenchmarkXxx`など）。これらは分析の開始点として扱われる場合がありますが、それ自体が孤児として報告されることはありません。

---

関連ドキュメント:
-   `symgo` エンジンの仕様: [`docs/plan-symbolic-execution-like.md`](../../docs/plan-symbolic-execution-like.md)
