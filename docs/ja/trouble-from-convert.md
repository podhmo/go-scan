# `generated` パッケージの変換関数生成に関する問題

## 概要

`examples/convert/sampledata/generated` パッケージを作成し、`source` パッケージから `destination` パッケージへの変換関数を自動生成しようとしましたが、生成されたコードにコンパイルエラーが残り、テストをパスさせることができませんでした。

## 目標

`examples/convert/main.go` を実行し、`examples/convert/sampledata/source` に定義された型から `examples/convert/sampledata/destination` に定義された型への変換関数を、`examples/convert/sampledata/generated` パッケージに `generated.go` として出力する。

## 実行したこと

1.  **`generated` パッケージの作成:**
    *   `examples/convert/sampledata/generated` ディレクトリを作成しました。

2.  **`source.go` へのアノテーション追加:**
    *   `examples/convert/sampledata/source/source.go` の `SrcInternalDetail` と `SubSource` に `@derivingconvert` アノテーションを追加し、これらの型に対応する変換関数が生成されるようにしました。

3.  **`main.go` の修正:**
    *   当初、`go-scan` が `source` パッケージしかスキャンしないため、`destination` パッケージの型情報が見つけられないという問題がありました。
    *   これを解決するため、`main.go` の `run` 関数を修正し、`source` と `destination` の両方のパッケージを `goscan.Scanner.ScanPackage` でスキャンし、その結果（`scanner.PackageInfo`）をマージしてから `parser.Parse` に渡すように試みました。

4.  **`parser/parser.go` の修正:**
    *   `main.go` の修正に伴い、`parser.Parse` がマージされた `PackageInfo` を正しく解釈できるように、`parser.Parse` とその内部で呼び出される関数を修正しました。
    *   具体的には、`dstTypeName` からパッケージパスと型名を分割し、マージされた `PackageInfo.Types` の中から目的の型を探すように変更しました。

5.  **`generator/generator.go` の修正:**
    *   生成されるコードの型名が、パッケージプレフィックスなしで出力される問題があったため、`getTypeName` 関数を修正し、`ImportManager` を使って正しくパッケージ名を修飾するようにしました。
    *   `time.Time` から `string` への変換が定義されていなかったため、`generateConversion` 関数に変換ロジックを追加しました。
    *   ポインタ、スライス、マップの変換ロジックを修正し、より堅牢にしました。

## 残っている課題 (TODO)

*   **`main.go` の `-pkg` オプションで複数パッケージを扱えるようにする:**
    *   現状、`-pkg` オプションは単一のパッケージしか受け付けません。`go-scan` が複数のパッケージをスキャンできるように、`-pkg` オプションをカンマ区切りなどで複数指定できるように修正する必要があります。

*   **`parser.Parse` で、`@derivingconvert` に指定された外部パッケージを自動的にスキャンする:**
    *   `main.go` で明示的に `destination` パッケージをスキャンするのではなく、`parser.Parse` が `@derivingconvert` アノテーションを解析し、必要に応じて `goscan.Scanner.ScanPackageByImport` を呼び出して外部パッケージをスキャンするように修正するのが、よりクリーンな解決策です。

*   **`generator.go` の型名解決の改善:**
    *   `getTypeName` 関数が、異なるパッケージの型名を正しく解決できていません。`ImportManager` の使い方を見直すか、あるいは `ImportManager` に頼らない方法で型名を解決する必要があります。

*   **`generator.go` の変換ロジックの改善:**
    *   `generateConversion` 関数が、ポインタ、スライス、マップなどの複雑な型を正しく変換できていません。特に、`time.Time` から `string` への変換など、型が異なる場合の変換ロジックを拡充する必要があります。

*   **`main_test.go` のインテグレーションテストの修正:**
    *   インテグレーションテストが、一時的なディレクトリで実行されるために `go.mod` の情報を正しく読み込めていません。テスト実行時に `go.mod` の情報を正しく渡すか、あるいはテストの前提条件を見直す必要があります。

## 当初の見通しとの差異と実装の不備

当初は、`go-scan` が `@derivingconvert` アノテーションに書かれたインポートパスを自動的に解決し、必要なパッケージをスキャンしてくれるものと想定していました。しかし、実際には `-pkg` オプションで指定されたパッケージしかスキャンせず、これが問題の根本原因でした。

`main.go` で複数のパッケージをスキャンしてマージするというアプローチは、この問題を回避するための場当たり的な対応であり、`go-scan` の設計思想とは異なっていた可能性があります。その結果、`parser` や `generator` で、マージされた `PackageInfo` を正しく扱いきれず、多数のコンパイルエラーを引き起こしました。

`go-scan` のコアな機能を修正するのではなく、`go-scan` の使い方を工夫するか、あるいは `go-scan` の機能拡張として、複数のパッケージをスキャンする仕組みを正式に導入する、といったアプローチの方が、よりクリーンな解決に繋がるかもしれません。

## はじめからやり直す場合のTODO

1.  **`go-scan` の設計思想の再確認:**
    *   `go-scan` がどのようにパッケージを解決し、型情報を保持するのかを、ドキュメントやコードから再確認します。特に、複数のパッケージをまたがる型解決の仕組みを重点的に調査します。

2.  **`main.go` の `-pkg` オプションの拡張:**
    *   `-pkg` オプションで複数のパッケージをカンマ区切りなどで指定できるように修正します。
    *   `run` 関数の中で、指定されたすべてのパッケージを `goscan.Scanner.ScanPackage` でスキャンし、その結果を一つの `scanner.PackageInfo` にマージします。

3.  **`parser.Parse` の修正:**
    *   `@derivingconvert` アノテーションに書かれた型が、スキャン済みのパッケージに含まれていない場合、`goscan.Scanner.ScanPackageByImport` を呼び出して動的にパッケージをスキャンし、型情報を取得するように修正します。

4.  **`generator.go` の段階的な実装とテスト:**
    *   まずは、`string` や `int` などの基本的な型変換のみをサポートした状態で、ビルド可能なコードが生成されることを確認します。
    *   次に、ポインタ、スライス、マップ、と段階的に対応する型を増やし、その都度テストを実行して、生成されたコードがビルド可能であり、かつ期待通りに動作することを確認します。
    *   `time.Time` から `string` への変換など、特殊な変換ロジックは、基本的な型変換が安定してから追加します。

5.  **インテグレーションテストの整備:**
    *   `main_test.go` のインテグレーションテストが、一時的なディレクトリでも正しく動作するように修正します。`go.mod` の情報をテスト実行時に渡す方法を確立するか、あるいは `go-scan` のテスト用APIを拡張して、モジュールルートを柔軟に設定できるようにします。
    *   テストケースを細分化し、1つのテストでは1つの機能のみを検証するようにします。これにより、問題が発生した際の切り分けが容易になります。

## go-scan にあると嬉しい機能（`scantest` や `overlay` との関連性を踏まえて）

`scantest` や `overlay` は、テスト時にファイルシステムを模倣するための非常に強力な機能ですが、今回のタスクで直面した問題は、`go-scan` のコア機能、特に**複数パッケージにまたがる型情報の解決と管理**に関するものが中心でした。これらの既存機能だけでは解決が難しかった点を踏まえ、以下の機能があると、より複雑なコード生成タスクに対応できると考えられます。

1.  **統合されたパッケージ解決機構:**
    *   **現状の課題:** `goscan.Scanner` は `-pkg` で指定された単一のパッケージしかスキャンしません。`@derivingconvert` で外部パッケージが指定されていても、それを自動で解決・スキャンする機能がありません。`main.go` で手動で複数パッケージをスキャンしてマージする方法を試みましたが、これは場当たり的で、`PackageInfo` の一貫性を損なう可能性がありました。
    *   **欲しい機能:** `goscan.Scanner` が、スキャン対象のパッケージからインポートされているパッケージ、あるいはアノテーションなどで明示的に指定されたパッケージを**再帰的にスキャン**し、すべての型情報を**単一のコンテキスト（リポジトリのようなもの）で管理**する機能。これにより、`parser` や `generator` は、どのパッケージの型であっても、そのコンテキストに問い合わせるだけで型情報を取得できるようになります。`scantest` はこのコンテキストをテスト時に提供する役割を担うべきです。

2.  **リッチな型情報:**
    *   **現状の課題:** `scanner.TypeInfo` は、型がどのパッケージに属しているか（`PkgPath`）という情報は持っていますが、そのパッケージが `source` なのか `destination` なのか、といった文脈的な情報を持っていません。そのため、`generator` で型名を生成する際に、どの型をパッケージプレフィックス付きで修飾すべきかの判断が複雑になっています。
    *   **欲しい機能:** `TypeInfo` に、その型が属する `PackageInfo` への参照や、パッケージのエイリアス情報を持たせる機能。これにより、`generator` は、現在の生成対象パッケージと比較して、外部パッケージの型であれば自動的にパッケージ名を修飾する、といった判断が容易になります。

3.  **より柔軟なテストユーティリティ:**
    *   **現状の課題:** `main_test.go` のインテグレーションテストは、一時ディレクトリで実行されるため、リポジトリルートにある `go.mod` を見つけられずに失敗します。`scantest` はファイルシステムの模倣はできますが、モジュール解決のコンテキストまでを完全に模倣するのは難しいようです。
    *   **欲しい機能:** `scantest` に、テスト用の `go.mod` の内容をインメモリで指定したり、モジュールルートを動的に設定したりする機能。これにより、ファイルシステムに依存しない、より完結したインテグレーションテストが書けるようになります。

4.  **マーカーコメントのフック機構:**
    *   **現状の課題:** `parser.Parse` は、`@derivingconvert` という特定のアノテーションをハードコードで探しています。新しいアノテーションを追加するには、`parser.Parse` を直接修正する必要があります。
    *   **欲しい機能:** `goscan.Scanner` に、スキャン中に特定のコメント（マーカー）を見つけた場合に呼び出されるコールバック関数（フック）を登録できる機能。例えば、`s.RegisterHook("@derivingconvert", myConvertHook)` のように登録すると、`go-scan` は `@derivingconvert` を見つけるたびに `myConvertHook` を呼び出します。
    *   **`lazy` なパッケージ読み込みとの連携:** このフック機構と、前述の「統合されたパッケージ解決機構」を組み合わせることで、真に `lazy` なパッケージ読み込みが実現できます。フック関数の中で、アノテーションに記述された外部パッケージの型情報が必要になった場合に、初めてそのパッケージをスキャンする、という実装が可能になります。これは、すべてのパッケージを最初に一括でスキャンするよりも効率的であり、`go-scan` のコア機能を汚すことなく、拡張性を高めることができます。

これらの機能は、`overlay` がファイル内容をインメモリで提供するように、`go-scan` の型解決のプロセスそのものを、より柔軟に制御・拡張するためのものです。現状の `scantest` や `overlay` の機能を補完し、より複雑なコード生成シナリオに対応できるようにするために、これらの機能が必要だと考えます。
