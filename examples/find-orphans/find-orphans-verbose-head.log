time=2025-09-18T09:43:10.966Z level=DEBUG source=/app/examples/find-orphans/main.go:109 msg="no go.work file found, falling back to go.mod scan" root=/app
time=2025-09-18T09:43:10.968Z level=DEBUG source=/app/examples/find-orphans/main.go:175 msg="creating locators for workspace" count=9 modules="[/app/examples/convert /app/examples/convert-define /app/examples/deriving-all /app/examples/derivingbind /app/examples/derivingjson /app/examples/docgen /app/examples/minigo /app /app/integration_test]"
time=2025-09-18T09:43:11.071Z level=INFO source=/app/examples/find-orphans/main.go:197 msg="* scan module" module=github.com/podhmo/go-scan/examples/convert
time=2025-09-18T09:43:11.071Z level=INFO source=/app/examples/find-orphans/main.go:197 msg="* scan module" module=github.com/podhmo/go-scan/examples/convert-define
time=2025-09-18T09:43:11.071Z level=INFO source=/app/examples/find-orphans/main.go:197 msg="* scan module" module=github.com/podhmo/go-scan/examples/deriving-all
time=2025-09-18T09:43:11.071Z level=INFO source=/app/examples/find-orphans/main.go:197 msg="* scan module" module=github.com/podhmo/go-scan/examples/derivingbind
time=2025-09-18T09:43:11.071Z level=INFO source=/app/examples/find-orphans/main.go:197 msg="* scan module" module=github.com/podhmo/go-scan/examples/derivingjson
time=2025-09-18T09:43:11.071Z level=INFO source=/app/examples/find-orphans/main.go:197 msg="* scan module" module=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.071Z level=INFO source=/app/examples/find-orphans/main.go:197 msg="* scan module" module=github.com/podhmo/go-scan/examples/minigo
time=2025-09-18T09:43:11.071Z level=INFO source=/app/examples/find-orphans/main.go:197 msg="* scan module" module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.071Z level=INFO source=/app/examples/find-orphans/main.go:197 msg="* scan module" module=github.com/podhmo/go-scan/integration_test
time=2025-09-18T09:43:11.090Z level=DEBUG source=/app/examples/find-orphans/main.go:205 msg="resolved target packages for reporting" count=72 packages="[github.com/podhmo/go-scan/examples/convert/sampledata/source github.com/podhmo/go-scan/examples/convert-define github.com/podhmo/go-scan/examples/derivingbind/binding github.com/podhmo/go-scan/minigo/stdlib/bytes github.com/podhmo/go-scan/symgo github.com/podhmo/go-scan/examples/convert/convutil github.com/podhmo/go-scan/examples/docgen/openapi github.com/podhmo/go-scan/examples/convert/model github.com/podhmo/go-scan/examples/convert/sampledata/funcs github.com/podhmo/go-scan/examples/deriving-all github.com/podhmo/go-scan/examples/derivingbind github.com/podhmo/go-scan/examples/docgen/patterns github.com/podhmo/go-scan/minigo/stdlib/bufio github.com/podhmo/go-scan/minigo/stdlib/container/list github.com/podhmo/go-scan/minigo/stdlib/fmt github.com/podhmo/go-scan/minigo/stdlib/io github.com/podhmo/go-scan/minigo/stdlib/path github.com/podhmo/go-scan/examples/derivingbind/anotherpkg github.com/podhmo/go-scan/examples/minigo github.com/podhmo/go-scan/integration_test github.com/podhmo/go-scan/minigo github.com/podhmo/go-scan/examples/convert/generator github.com/podhmo/go-scan/examples/convert/sampledata/generated github.com/podhmo/go-scan/examples/deriving-all/integrationtest github.com/podhmo/go-scan/examples/derivingbind/parser github.com/podhmo/go-scan/examples/derivingjson/gen github.com/podhmo/go-scan/minigo/stdlib/os github.com/podhmo/go-scan/examples/convert/parser github.com/podhmo/go-scan/examples/derivingjson/integrationtest github.com/podhmo/go-scan/minigo/stdlib/net/url github.com/podhmo/go-scan/symgo/object github.com/podhmo/go-scan/examples/convert github.com/podhmo/go-scan/examples/derivingjson github.com/podhmo/go-scan/symgo/evaluator github.com/podhmo/go-scan/symgo/integration_test github.com/podhmo/go-scan/astwalk github.com/podhmo/go-scan/examples/convert/sampledata/destination github.com/podhmo/go-scan/examples/convert/sampledata/tags github.com/podhmo/go-scan/minigo/stdlib/errors github.com/podhmo/go-scan/minigo/stdlib/net/http github.com/podhmo/go-scan/minigo/stdlib/time github.com/podhmo/go-scan github.com/podhmo/go-scan/examples/convert-define/define github.com/podhmo/go-scan/examples/derivingbind/gen github.com/podhmo/go-scan/minigo/stdlib/crypto/md5 github.com/podhmo/go-scan/scantest github.com/podhmo/go-scan/examples/convert-define/internal github.com/podhmo/go-scan/locator github.com/podhmo/go-scan/minigo/stdlib/strconv github.com/podhmo/go-scan/scanner github.com/podhmo/go-scan/symgo/intrinsics github.com/podhmo/go-scan/symgotest github.com/podhmo/go-scan/minigo/object github.com/podhmo/go-scan/minigo/stdlib/context github.com/podhmo/go-scan/minigo/stdlib/regexp github.com/podhmo/go-scan/examples/derivingbind/integrationtest github.com/podhmo/go-scan/examples/find-orphans github.com/podhmo/go-scan/minigo/stdlib/encoding/json github.com/podhmo/go-scan/minigo/stdlib/strings github.com/podhmo/go-scan/minigo/stdlib/text/scanner github.com/podhmo/go-scan/examples/convert/generated_test github.com/podhmo/go-scan/examples/docgen github.com/podhmo/go-scan/minigo/stdlib/math/rand github.com/podhmo/go-scan/minigo/stdlib/sort github.com/podhmo/go-scan/examples/deps-walk github.com/podhmo/go-scan/examples/docgen/sampleapi github.com/podhmo/go-scan/minigo/evaluator github.com/podhmo/go-scan/minigo/stdlib/path/filepath github.com/podhmo/go-scan/minigo/stdlib/text/template github.com/podhmo/go-scan/examples/convert/sampledata/converter github.com/podhmo/go-scan/examples/convert-define/e2e_test github.com/podhmo/go-scan/minigo/ffibridge]"
time=2025-09-18T09:43:11.109Z level=DEBUG source=/app/examples/find-orphans/main.go:217 msg="resolved scan packages for analysis" count=72 packages="[github.com/podhmo/go-scan/examples/convert/generator github.com/podhmo/go-scan/examples/convert/sampledata/source github.com/podhmo/go-scan/examples/deps-walk github.com/podhmo/go-scan/minigo/ffibridge github.com/podhmo/go-scan/minigo/stdlib/io github.com/podhmo/go-scan/minigo/stdlib/text/template github.com/podhmo/go-scan/examples/convert/sampledata/funcs github.com/podhmo/go-scan/examples/derivingjson/gen github.com/podhmo/go-scan/integration_test github.com/podhmo/go-scan/minigo/evaluator github.com/podhmo/go-scan/minigo/stdlib/encoding/json github.com/podhmo/go-scan/minigo/stdlib/math/rand github.com/podhmo/go-scan/minigo/stdlib/text/scanner github.com/podhmo/go-scan/symgo/object github.com/podhmo/go-scan/examples/convert/parser github.com/podhmo/go-scan/minigo/stdlib/net/url github.com/podhmo/go-scan/examples/derivingjson/integrationtest github.com/podhmo/go-scan/examples/find-orphans github.com/podhmo/go-scan/examples/derivingbind/anotherpkg github.com/podhmo/go-scan/astwalk github.com/podhmo/go-scan/minigo/stdlib/regexp github.com/podhmo/go-scan/minigo/stdlib/strconv github.com/podhmo/go-scan/examples/derivingbind/integrationtest github.com/podhmo/go-scan/examples/docgen/openapi github.com/podhmo/go-scan/minigo/stdlib/errors github.com/podhmo/go-scan/minigo/stdlib/net/http github.com/podhmo/go-scan/examples/convert/convutil github.com/podhmo/go-scan/examples/convert-define github.com/podhmo/go-scan/examples/docgen github.com/podhmo/go-scan/minigo/stdlib/bufio github.com/podhmo/go-scan/minigo/stdlib/fmt github.com/podhmo/go-scan/minigo/stdlib/path/filepath github.com/podhmo/go-scan/examples/derivingbind/binding github.com/podhmo/go-scan/examples/convert/sampledata/generated github.com/podhmo/go-scan/locator github.com/podhmo/go-scan/minigo/stdlib/os github.com/podhmo/go-scan/minigo/stdlib/path github.com/podhmo/go-scan/scantest github.com/podhmo/go-scan/examples/convert github.com/podhmo/go-scan/examples/deriving-all/integrationtest github.com/podhmo/go-scan/examples/derivingbind github.com/podhmo/go-scan/minigo/stdlib/bytes github.com/podhmo/go-scan/minigo/object github.com/podhmo/go-scan/symgo github.com/podhmo/go-scan/symgo/evaluator github.com/podhmo/go-scan/symgo/intrinsics github.com/podhmo/go-scan/symgotest github.com/podhmo/go-scan/examples/convert/sampledata/tags github.com/podhmo/go-scan/examples/convert/sampledata/destination github.com/podhmo/go-scan/examples/derivingjson github.com/podhmo/go-scan/examples/minigo github.com/podhmo/go-scan/minigo/stdlib/context github.com/podhmo/go-scan/minigo/stdlib/time github.com/podhmo/go-scan/examples/derivingbind/parser github.com/podhmo/go-scan github.com/podhmo/go-scan/examples/convert-define/define github.com/podhmo/go-scan/examples/convert-define/e2e_test github.com/podhmo/go-scan/examples/convert-define/internal github.com/podhmo/go-scan/examples/deriving-all github.com/podhmo/go-scan/minigo/stdlib/crypto/md5 github.com/podhmo/go-scan/symgo/integration_test github.com/podhmo/go-scan/examples/convert/generated_test github.com/podhmo/go-scan/examples/convert/model github.com/podhmo/go-scan/examples/convert/sampledata/converter github.com/podhmo/go-scan/examples/docgen/patterns github.com/podhmo/go-scan/scanner github.com/podhmo/go-scan/examples/derivingbind/gen github.com/podhmo/go-scan/examples/docgen/sampleapi github.com/podhmo/go-scan/minigo/stdlib/container/list github.com/podhmo/go-scan/minigo/stdlib/sort github.com/podhmo/go-scan/minigo/stdlib/strings github.com/podhmo/go-scan/minigo]"
time=2025-09-18T09:43:11.183Z level=DEBUG source=/app/examples/find-orphans/main.go:440 msg="walking with patterns" patterns="[github.com/podhmo/go-scan/symgo github.com/podhmo/go-scan/symgo/evaluator github.com/podhmo/go-scan/symgo/intrinsics github.com/podhmo/go-scan/symgotest github.com/podhmo/go-scan/examples/convert/sampledata/tags github.com/podhmo/go-scan/examples/convert/sampledata/destination github.com/podhmo/go-scan/examples/derivingjson github.com/podhmo/go-scan/examples/minigo github.com/podhmo/go-scan/minigo/stdlib/context github.com/podhmo/go-scan/minigo/stdlib/time github.com/podhmo/go-scan/examples/derivingbind/parser github.com/podhmo/go-scan github.com/podhmo/go-scan/examples/convert-define/define github.com/podhmo/go-scan/examples/convert-define/e2e_test github.com/podhmo/go-scan/examples/convert-define/internal github.com/podhmo/go-scan/examples/deriving-all github.com/podhmo/go-scan/minigo/stdlib/crypto/md5 github.com/podhmo/go-scan/symgo/integration_test github.com/podhmo/go-scan/examples/convert/generated_test github.com/podhmo/go-scan/examples/convert/model github.com/podhmo/go-scan/examples/convert/sampledata/converter github.com/podhmo/go-scan/examples/docgen/patterns github.com/podhmo/go-scan/scanner github.com/podhmo/go-scan/examples/derivingbind/gen github.com/podhmo/go-scan/examples/docgen/sampleapi github.com/podhmo/go-scan/minigo/stdlib/container/list github.com/podhmo/go-scan/minigo/stdlib/sort github.com/podhmo/go-scan/minigo/stdlib/strings github.com/podhmo/go-scan/minigo github.com/podhmo/go-scan/examples/convert/generator github.com/podhmo/go-scan/examples/convert/sampledata/source github.com/podhmo/go-scan/examples/deps-walk github.com/podhmo/go-scan/minigo/ffibridge github.com/podhmo/go-scan/minigo/stdlib/io github.com/podhmo/go-scan/minigo/stdlib/text/template github.com/podhmo/go-scan/examples/convert/sampledata/funcs github.com/podhmo/go-scan/examples/derivingjson/gen github.com/podhmo/go-scan/integration_test github.com/podhmo/go-scan/minigo/evaluator github.com/podhmo/go-scan/minigo/stdlib/encoding/json github.com/podhmo/go-scan/minigo/stdlib/math/rand github.com/podhmo/go-scan/minigo/stdlib/text/scanner github.com/podhmo/go-scan/symgo/object github.com/podhmo/go-scan/examples/convert/parser github.com/podhmo/go-scan/minigo/stdlib/net/url github.com/podhmo/go-scan/examples/derivingjson/integrationtest github.com/podhmo/go-scan/examples/find-orphans github.com/podhmo/go-scan/examples/derivingbind/anotherpkg github.com/podhmo/go-scan/astwalk github.com/podhmo/go-scan/minigo/stdlib/regexp github.com/podhmo/go-scan/minigo/stdlib/strconv github.com/podhmo/go-scan/examples/derivingbind/integrationtest github.com/podhmo/go-scan/examples/docgen/openapi github.com/podhmo/go-scan/minigo/stdlib/errors github.com/podhmo/go-scan/minigo/stdlib/net/http github.com/podhmo/go-scan/examples/convert/convutil github.com/podhmo/go-scan/examples/convert-define github.com/podhmo/go-scan/examples/docgen github.com/podhmo/go-scan/minigo/stdlib/bufio github.com/podhmo/go-scan/minigo/stdlib/fmt github.com/podhmo/go-scan/minigo/stdlib/path/filepath github.com/podhmo/go-scan/examples/derivingbind/binding github.com/podhmo/go-scan/examples/convert/sampledata/generated github.com/podhmo/go-scan/locator github.com/podhmo/go-scan/minigo/stdlib/os github.com/podhmo/go-scan/minigo/stdlib/path github.com/podhmo/go-scan/scantest github.com/podhmo/go-scan/examples/convert github.com/podhmo/go-scan/examples/deriving-all/integrationtest github.com/podhmo/go-scan/examples/derivingbind github.com/podhmo/go-scan/minigo/stdlib/bytes github.com/podhmo/go-scan/minigo/object]"
time=2025-09-18T09:43:11.183Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.184Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.184Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan pkgDirAbs=/app module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.184Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=6 pkgDirAbs=/app files="[/app/cache.go /app/goscan.go /app/importmanager.go /app/modulewalker.go /app/type_relation.go /app/writer.go]"
time=2025-09-18T09:43:11.184Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan enabled=false
time=2025-09-18T09:43:11.196Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/astwalk
time=2025-09-18T09:43:11.196Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/astwalk
time=2025-09-18T09:43:11.196Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/astwalk pkgDirAbs=/app/astwalk module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.196Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/astwalk files=[/app/astwalk/astwalk.go]
time=2025-09-18T09:43:11.196Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/astwalk enabled=false
time=2025-09-18T09:43:11.196Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert
time=2025-09-18T09:43:11.196Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert
time=2025-09-18T09:43:11.196Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/convert pkgDirAbs=/app/examples/convert module=github.com/podhmo/go-scan/examples/convert
time=2025-09-18T09:43:11.196Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/convert files=[/app/examples/convert/main.go]
time=2025-09-18T09:43:11.196Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/convert enabled=false
time=2025-09-18T09:43:11.197Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert-define
time=2025-09-18T09:43:11.197Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert-define
time=2025-09-18T09:43:11.197Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/convert-define pkgDirAbs=/app/examples/convert-define module=github.com/podhmo/go-scan/examples/convert-define
time=2025-09-18T09:43:11.198Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/convert-define files=[/app/examples/convert-define/main.go]
time=2025-09-18T09:43:11.198Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/convert-define enabled=false
time=2025-09-18T09:43:11.199Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert-define/define
time=2025-09-18T09:43:11.199Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert-define/define
time=2025-09-18T09:43:11.199Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/convert-define/define pkgDirAbs=/app/examples/convert-define/define module=github.com/podhmo/go-scan/examples/convert-define
time=2025-09-18T09:43:11.200Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/convert-define/define files=[/app/examples/convert-define/define/define.go]
time=2025-09-18T09:43:11.200Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/convert-define/define enabled=false
time=2025-09-18T09:43:11.201Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert-define/e2e_test
time=2025-09-18T09:43:11.201Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert-define/e2e_test
time=2025-09-18T09:43:11.201Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/convert-define/e2e_test pkgDirAbs=/app/examples/convert-define/e2e_test module=github.com/podhmo/go-scan/examples/convert-define
time=2025-09-18T09:43:11.201Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=2 pkgDirAbs=/app/examples/convert-define/e2e_test files="[/app/examples/convert-define/e2e_test/generated.go /app/examples/convert-define/e2e_test/mappings.go]"
time=2025-09-18T09:43:11.201Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/convert-define/e2e_test enabled=false
time=2025-09-18T09:43:11.203Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert-define/internal
time=2025-09-18T09:43:11.203Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert-define/internal
time=2025-09-18T09:43:11.203Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/convert-define/internal pkgDirAbs=/app/examples/convert-define/internal module=github.com/podhmo/go-scan/examples/convert-define
time=2025-09-18T09:43:11.203Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/convert-define/internal files=[/app/examples/convert-define/internal/interpreter.go]
time=2025-09-18T09:43:11.203Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/convert-define/internal enabled=false
time=2025-09-18T09:43:11.205Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/convutil
time=2025-09-18T09:43:11.205Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/convutil
time=2025-09-18T09:43:11.205Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/convert/convutil pkgDirAbs=/app/examples/convert/convutil module=github.com/podhmo/go-scan/examples/convert
time=2025-09-18T09:43:11.205Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/convert/convutil files=[/app/examples/convert/convutil/util.go]
time=2025-09-18T09:43:11.205Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/convert/convutil enabled=false
time=2025-09-18T09:43:11.205Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/generated_test
time=2025-09-18T09:43:11.205Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/generated_test
time=2025-09-18T09:43:11.205Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/convert/generated_test pkgDirAbs=/app/examples/convert/generated_test module=github.com/podhmo/go-scan/examples/convert
time=2025-09-18T09:43:11.205Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=0 pkgDirAbs=/app/examples/convert/generated_test files=[]
time=2025-09-18T09:43:11.205Z level=DEBUG source=/app/goscan.go:998 msg="ScanPackageByImport found no .go files. Caching empty PackageInfo." pkgDirAbs=/app/examples/convert/generated_test
time=2025-09-18T09:43:11.205Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/generator
time=2025-09-18T09:43:11.206Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/generator
time=2025-09-18T09:43:11.206Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/convert/generator pkgDirAbs=/app/examples/convert/generator module=github.com/podhmo/go-scan/examples/convert
time=2025-09-18T09:43:11.206Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/convert/generator files=[/app/examples/convert/generator/generator.go]
time=2025-09-18T09:43:11.206Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/convert/generator enabled=false
time=2025-09-18T09:43:11.208Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/model
time=2025-09-18T09:43:11.209Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/model
time=2025-09-18T09:43:11.209Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/convert/model pkgDirAbs=/app/examples/convert/model module=github.com/podhmo/go-scan/examples/convert
time=2025-09-18T09:43:11.209Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/convert/model files=[/app/examples/convert/model/model.go]
time=2025-09-18T09:43:11.209Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/convert/model enabled=false
time=2025-09-18T09:43:11.209Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/parser
time=2025-09-18T09:43:11.210Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/parser
time=2025-09-18T09:43:11.210Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/convert/parser pkgDirAbs=/app/examples/convert/parser module=github.com/podhmo/go-scan/examples/convert
time=2025-09-18T09:43:11.210Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/convert/parser files=[/app/examples/convert/parser/parser.go]
time=2025-09-18T09:43:11.210Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/convert/parser enabled=false
time=2025-09-18T09:43:11.212Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/converter
time=2025-09-18T09:43:11.212Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/converter
time=2025-09-18T09:43:11.212Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/converter pkgDirAbs=/app/examples/convert/sampledata/converter module=github.com/podhmo/go-scan/examples/convert
time=2025-09-18T09:43:11.212Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/convert/sampledata/converter files=[/app/examples/convert/sampledata/converter/converter.go]
time=2025-09-18T09:43:11.212Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/converter enabled=false
time=2025-09-18T09:43:11.212Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/destination
time=2025-09-18T09:43:11.213Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/destination
time=2025-09-18T09:43:11.213Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/destination pkgDirAbs=/app/examples/convert/sampledata/destination module=github.com/podhmo/go-scan/examples/convert
time=2025-09-18T09:43:11.213Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/convert/sampledata/destination files=[/app/examples/convert/sampledata/destination/destination.go]
time=2025-09-18T09:43:11.213Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/destination enabled=false
time=2025-09-18T09:43:11.213Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/funcs
time=2025-09-18T09:43:11.213Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/funcs
time=2025-09-18T09:43:11.213Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/funcs pkgDirAbs=/app/examples/convert/sampledata/funcs module=github.com/podhmo/go-scan/examples/convert
time=2025-09-18T09:43:11.213Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/convert/sampledata/funcs files=[/app/examples/convert/sampledata/funcs/funcs.go]
time=2025-09-18T09:43:11.213Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/funcs enabled=false
time=2025-09-18T09:43:11.213Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.214Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.214Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/generated pkgDirAbs=/app/examples/convert/sampledata/generated module=github.com/podhmo/go-scan/examples/convert
time=2025-09-18T09:43:11.214Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/convert/sampledata/generated files=[/app/examples/convert/sampledata/generated/generated.go]
time=2025-09-18T09:43:11.214Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/generated enabled=false
time=2025-09-18T09:43:11.216Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/source
time=2025-09-18T09:43:11.216Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/source
time=2025-09-18T09:43:11.216Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/source pkgDirAbs=/app/examples/convert/sampledata/source module=github.com/podhmo/go-scan/examples/convert
time=2025-09-18T09:43:11.216Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/convert/sampledata/source files=[/app/examples/convert/sampledata/source/source.go]
time=2025-09-18T09:43:11.216Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/source enabled=false
time=2025-09-18T09:43:11.216Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/tags
time=2025-09-18T09:43:11.216Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/tags
time=2025-09-18T09:43:11.216Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/tags pkgDirAbs=/app/examples/convert/sampledata/tags module=github.com/podhmo/go-scan/examples/convert
time=2025-09-18T09:43:11.216Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=2 pkgDirAbs=/app/examples/convert/sampledata/tags files="[/app/examples/convert/sampledata/tags/generated.go /app/examples/convert/sampledata/tags/tags.go]"
time=2025-09-18T09:43:11.216Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/tags enabled=false
time=2025-09-18T09:43:11.218Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/deps-walk
time=2025-09-18T09:43:11.218Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/deps-walk
time=2025-09-18T09:43:11.218Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/deps-walk pkgDirAbs=/app/examples/deps-walk module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.218Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/deps-walk files=[/app/examples/deps-walk/main.go]
time=2025-09-18T09:43:11.218Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/deps-walk enabled=false
time=2025-09-18T09:43:11.221Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/deriving-all
time=2025-09-18T09:43:11.221Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/deriving-all
time=2025-09-18T09:43:11.221Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/deriving-all pkgDirAbs=/app/examples/deriving-all module=github.com/podhmo/go-scan/examples/deriving-all
time=2025-09-18T09:43:11.221Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/deriving-all files=[/app/examples/deriving-all/main.go]
time=2025-09-18T09:43:11.221Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/deriving-all enabled=false
time=2025-09-18T09:43:11.222Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/deriving-all/integrationtest
time=2025-09-18T09:43:11.222Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/deriving-all/integrationtest
time=2025-09-18T09:43:11.222Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/deriving-all/integrationtest pkgDirAbs=/app/examples/deriving-all/integrationtest module=github.com/podhmo/go-scan/examples/deriving-all
time=2025-09-18T09:43:11.222Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=0 pkgDirAbs=/app/examples/deriving-all/integrationtest files=[]
time=2025-09-18T09:43:11.222Z level=DEBUG source=/app/goscan.go:998 msg="ScanPackageByImport found no .go files. Caching empty PackageInfo." pkgDirAbs=/app/examples/deriving-all/integrationtest
time=2025-09-18T09:43:11.222Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/derivingbind
time=2025-09-18T09:43:11.222Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/derivingbind
time=2025-09-18T09:43:11.222Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/derivingbind pkgDirAbs=/app/examples/derivingbind module=github.com/podhmo/go-scan/examples/derivingbind
time=2025-09-18T09:43:11.222Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/derivingbind files=[/app/examples/derivingbind/main.go]
time=2025-09-18T09:43:11.222Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/derivingbind enabled=false
time=2025-09-18T09:43:11.223Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/derivingbind/anotherpkg
time=2025-09-18T09:43:11.223Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/derivingbind/anotherpkg
time=2025-09-18T09:43:11.223Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/derivingbind/anotherpkg pkgDirAbs=/app/examples/derivingbind/anotherpkg module=github.com/podhmo/go-scan/examples/derivingbind
time=2025-09-18T09:43:11.223Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=2 pkgDirAbs=/app/examples/derivingbind/anotherpkg files="[/app/examples/derivingbind/anotherpkg/anotherpkg_deriving.go /app/examples/derivingbind/anotherpkg/models_another.go]"
time=2025-09-18T09:43:11.223Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/derivingbind/anotherpkg enabled=false
time=2025-09-18T09:43:11.224Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/derivingbind/binding
time=2025-09-18T09:43:11.224Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/derivingbind/binding
time=2025-09-18T09:43:11.224Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/derivingbind/binding pkgDirAbs=/app/examples/derivingbind/binding module=github.com/podhmo/go-scan/examples/derivingbind
time=2025-09-18T09:43:11.224Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/derivingbind/binding files=[/app/examples/derivingbind/binding/binding.go]
time=2025-09-18T09:43:11.224Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/derivingbind/binding enabled=false
time=2025-09-18T09:43:11.225Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/derivingbind/gen
time=2025-09-18T09:43:11.225Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/derivingbind/gen
time=2025-09-18T09:43:11.225Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/derivingbind/gen pkgDirAbs=/app/examples/derivingbind/gen module=github.com/podhmo/go-scan/examples/derivingbind
time=2025-09-18T09:43:11.225Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/derivingbind/gen files=[/app/examples/derivingbind/gen/generate.go]
time=2025-09-18T09:43:11.225Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/derivingbind/gen enabled=false
time=2025-09-18T09:43:11.226Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/derivingbind/integrationtest
time=2025-09-18T09:43:11.226Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/derivingbind/integrationtest
time=2025-09-18T09:43:11.226Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/derivingbind/integrationtest pkgDirAbs=/app/examples/derivingbind/integrationtest module=github.com/podhmo/go-scan/examples/derivingbind
time=2025-09-18T09:43:11.226Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=3 pkgDirAbs=/app/examples/derivingbind/integrationtest files="[/app/examples/derivingbind/integrationtest/helper.go /app/examples/derivingbind/integrationtest/integrationtest_deriving.go /app/examples/derivingbind/integrationtest/models.go]"
time=2025-09-18T09:43:11.226Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/derivingbind/integrationtest enabled=false
time=2025-09-18T09:43:11.233Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.233Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.233Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/derivingbind/parser pkgDirAbs=/app/examples/derivingbind/parser module=github.com/podhmo/go-scan/examples/derivingbind
time=2025-09-18T09:43:11.233Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/derivingbind/parser files=[/app/examples/derivingbind/parser/parsers.go]
time=2025-09-18T09:43:11.233Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/derivingbind/parser enabled=false
time=2025-09-18T09:43:11.235Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/derivingjson
time=2025-09-18T09:43:11.235Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/derivingjson
time=2025-09-18T09:43:11.235Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/derivingjson pkgDirAbs=/app/examples/derivingjson module=github.com/podhmo/go-scan/examples/derivingjson
time=2025-09-18T09:43:11.235Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/derivingjson files=[/app/examples/derivingjson/main.go]
time=2025-09-18T09:43:11.235Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/derivingjson enabled=false
time=2025-09-18T09:43:11.236Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/derivingjson/gen
time=2025-09-18T09:43:11.237Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/derivingjson/gen
time=2025-09-18T09:43:11.237Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/derivingjson/gen pkgDirAbs=/app/examples/derivingjson/gen module=github.com/podhmo/go-scan/examples/derivingjson
time=2025-09-18T09:43:11.237Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/derivingjson/gen files=[/app/examples/derivingjson/gen/generate.go]
time=2025-09-18T09:43:11.237Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/derivingjson/gen enabled=false
time=2025-09-18T09:43:11.239Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.239Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.239Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/derivingjson/integrationtest pkgDirAbs=/app/examples/derivingjson/integrationtest module=github.com/podhmo/go-scan/examples/derivingjson
time=2025-09-18T09:43:11.239Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=3 pkgDirAbs=/app/examples/derivingjson/integrationtest files="[/app/examples/derivingjson/integrationtest/integrationtest_deriving.go /app/examples/derivingjson/integrationtest/models.go /app/examples/derivingjson/integrationtest/multioneof.go]"
time=2025-09-18T09:43:11.239Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/derivingjson/integrationtest enabled=false
time=2025-09-18T09:43:11.241Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.242Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.242Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/docgen pkgDirAbs=/app/examples/docgen module=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.242Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=3 pkgDirAbs=/app/examples/docgen files="[/app/examples/docgen/analyzer.go /app/examples/docgen/loader.go /app/examples/docgen/main.go]"
time=2025-09-18T09:43:11.242Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/docgen enabled=false
time=2025-09-18T09:43:11.247Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/docgen/openapi
time=2025-09-18T09:43:11.247Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/docgen/openapi
time=2025-09-18T09:43:11.247Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/docgen/openapi pkgDirAbs=/app/examples/docgen/openapi module=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.247Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/docgen/openapi files=[/app/examples/docgen/openapi/model.go]
time=2025-09-18T09:43:11.247Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/docgen/openapi enabled=false
time=2025-09-18T09:43:11.249Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.249Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.249Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/docgen/patterns pkgDirAbs=/app/examples/docgen/patterns module=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.249Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/docgen/patterns files=[/app/examples/docgen/patterns/patterns.go]
time=2025-09-18T09:43:11.249Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/docgen/patterns enabled=false
time=2025-09-18T09:43:11.255Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/docgen/sampleapi
time=2025-09-18T09:43:11.255Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/docgen/sampleapi
time=2025-09-18T09:43:11.255Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/docgen/sampleapi pkgDirAbs=/app/examples/docgen/sampleapi module=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.255Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/docgen/sampleapi files=[/app/examples/docgen/sampleapi/api.go]
time=2025-09-18T09:43:11.255Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/docgen/sampleapi enabled=false
time=2025-09-18T09:43:11.257Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/find-orphans
time=2025-09-18T09:43:11.258Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/find-orphans
time=2025-09-18T09:43:11.258Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/find-orphans pkgDirAbs=/app/examples/find-orphans module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.258Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/examples/find-orphans files=[/app/examples/find-orphans/main.go]
time=2025-09-18T09:43:11.258Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/find-orphans enabled=false
time=2025-09-18T09:43:11.260Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/examples/minigo
time=2025-09-18T09:43:11.260Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/examples/minigo
time=2025-09-18T09:43:11.260Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/examples/minigo pkgDirAbs=/app/examples/minigo module=github.com/podhmo/go-scan/examples/minigo
time=2025-09-18T09:43:11.260Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=2 pkgDirAbs=/app/examples/minigo files="[/app/examples/minigo/gen_bindings.go /app/examples/minigo/main.go]"
time=2025-09-18T09:43:11.260Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/examples/minigo enabled=false
time=2025-09-18T09:43:11.261Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/integration_test
time=2025-09-18T09:43:11.261Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/integration_test
time=2025-09-18T09:43:11.261Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/integration_test pkgDirAbs=/app/integration_test module=github.com/podhmo/go-scan/integration_test
time=2025-09-18T09:43:11.261Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=0 pkgDirAbs=/app/integration_test files=[]
time=2025-09-18T09:43:11.261Z level=DEBUG source=/app/goscan.go:998 msg="ScanPackageByImport found no .go files. Caching empty PackageInfo." pkgDirAbs=/app/integration_test
time=2025-09-18T09:43:11.261Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.261Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.261Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/locator pkgDirAbs=/app/locator module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.262Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/locator files=[/app/locator/locator.go]
time=2025-09-18T09:43:11.262Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/locator enabled=false
time=2025-09-18T09:43:11.263Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo
time=2025-09-18T09:43:11.263Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo
time=2025-09-18T09:43:11.263Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo pkgDirAbs=/app/minigo module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.263Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo files=[/app/minigo/minigo.go]
time=2025-09-18T09:43:11.263Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo enabled=false
time=2025-09-18T09:43:11.265Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.265Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.265Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/evaluator pkgDirAbs=/app/minigo/evaluator module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.265Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/evaluator files=[/app/minigo/evaluator/evaluator.go]
time=2025-09-18T09:43:11.265Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/evaluator enabled=false
time=2025-09-18T09:43:11.286Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/ffibridge
time=2025-09-18T09:43:11.286Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/ffibridge
time=2025-09-18T09:43:11.286Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/ffibridge pkgDirAbs=/app/minigo/ffibridge module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.286Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/ffibridge files=[/app/minigo/ffibridge/bridge.go]
time=2025-09-18T09:43:11.286Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/ffibridge enabled=false
time=2025-09-18T09:43:11.287Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/object
time=2025-09-18T09:43:11.287Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/object
time=2025-09-18T09:43:11.288Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/object pkgDirAbs=/app/minigo/object module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.288Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/object files=[/app/minigo/object/object.go]
time=2025-09-18T09:43:11.288Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/object enabled=false
time=2025-09-18T09:43:11.300Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/bufio
time=2025-09-18T09:43:11.301Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/bufio
time=2025-09-18T09:43:11.301Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/bufio pkgDirAbs=/app/minigo/stdlib/bufio module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.301Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/bufio files=[/app/minigo/stdlib/bufio/install.go]
time=2025-09-18T09:43:11.301Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/bufio enabled=false
time=2025-09-18T09:43:11.301Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/bytes
time=2025-09-18T09:43:11.301Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/bytes
time=2025-09-18T09:43:11.301Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/bytes pkgDirAbs=/app/minigo/stdlib/bytes module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.301Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/bytes files=[/app/minigo/stdlib/bytes/install.go]
time=2025-09-18T09:43:11.301Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/bytes enabled=false
time=2025-09-18T09:43:11.302Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/container/list
time=2025-09-18T09:43:11.302Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/container/list
time=2025-09-18T09:43:11.302Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/container/list pkgDirAbs=/app/minigo/stdlib/container/list module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.302Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/container/list files=[/app/minigo/stdlib/container/list/install.go]
time=2025-09-18T09:43:11.302Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/container/list enabled=false
time=2025-09-18T09:43:11.302Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/context
time=2025-09-18T09:43:11.302Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/context
time=2025-09-18T09:43:11.302Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/context pkgDirAbs=/app/minigo/stdlib/context module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.302Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/context files=[/app/minigo/stdlib/context/install.go]
time=2025-09-18T09:43:11.302Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/context enabled=false
time=2025-09-18T09:43:11.303Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/crypto/md5
time=2025-09-18T09:43:11.303Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/crypto/md5
time=2025-09-18T09:43:11.303Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/crypto/md5 pkgDirAbs=/app/minigo/stdlib/crypto/md5 module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.303Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/crypto/md5 files=[/app/minigo/stdlib/crypto/md5/install.go]
time=2025-09-18T09:43:11.303Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/crypto/md5 enabled=false
time=2025-09-18T09:43:11.303Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/encoding/json
time=2025-09-18T09:43:11.303Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/encoding/json
time=2025-09-18T09:43:11.303Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/encoding/json pkgDirAbs=/app/minigo/stdlib/encoding/json module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.303Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/encoding/json files=[/app/minigo/stdlib/encoding/json/install.go]
time=2025-09-18T09:43:11.303Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/encoding/json enabled=false
time=2025-09-18T09:43:11.304Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/errors
time=2025-09-18T09:43:11.304Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/errors
time=2025-09-18T09:43:11.304Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/errors pkgDirAbs=/app/minigo/stdlib/errors module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.304Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/errors files=[/app/minigo/stdlib/errors/install.go]
time=2025-09-18T09:43:11.304Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/errors enabled=false
time=2025-09-18T09:43:11.304Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/fmt
time=2025-09-18T09:43:11.304Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/fmt
time=2025-09-18T09:43:11.304Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/fmt pkgDirAbs=/app/minigo/stdlib/fmt module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.304Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/fmt files=[/app/minigo/stdlib/fmt/install.go]
time=2025-09-18T09:43:11.305Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/fmt enabled=false
time=2025-09-18T09:43:11.305Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/io
time=2025-09-18T09:43:11.306Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/io
time=2025-09-18T09:43:11.306Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/io pkgDirAbs=/app/minigo/stdlib/io module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.306Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/io files=[/app/minigo/stdlib/io/install.go]
time=2025-09-18T09:43:11.306Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/io enabled=false
time=2025-09-18T09:43:11.307Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/math/rand
time=2025-09-18T09:43:11.307Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/math/rand
time=2025-09-18T09:43:11.307Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/math/rand pkgDirAbs=/app/minigo/stdlib/math/rand module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.307Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/math/rand files=[/app/minigo/stdlib/math/rand/install.go]
time=2025-09-18T09:43:11.307Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/math/rand enabled=false
time=2025-09-18T09:43:11.307Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/net/http
time=2025-09-18T09:43:11.307Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/net/http
time=2025-09-18T09:43:11.307Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/net/http pkgDirAbs=/app/minigo/stdlib/net/http module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.307Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/net/http files=[/app/minigo/stdlib/net/http/install.go]
time=2025-09-18T09:43:11.307Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/net/http enabled=false
time=2025-09-18T09:43:11.308Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/net/url
time=2025-09-18T09:43:11.309Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/net/url
time=2025-09-18T09:43:11.309Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/net/url pkgDirAbs=/app/minigo/stdlib/net/url module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.309Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/net/url files=[/app/minigo/stdlib/net/url/install.go]
time=2025-09-18T09:43:11.309Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/net/url enabled=false
time=2025-09-18T09:43:11.309Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/os
time=2025-09-18T09:43:11.309Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/os
time=2025-09-18T09:43:11.309Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/os pkgDirAbs=/app/minigo/stdlib/os module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.309Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/os files=[/app/minigo/stdlib/os/install.go]
time=2025-09-18T09:43:11.309Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/os enabled=false
time=2025-09-18T09:43:11.310Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/path
time=2025-09-18T09:43:11.310Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/path
time=2025-09-18T09:43:11.310Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/path pkgDirAbs=/app/minigo/stdlib/path module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.310Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/path files=[/app/minigo/stdlib/path/install.go]
time=2025-09-18T09:43:11.311Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/path enabled=false
time=2025-09-18T09:43:11.311Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/path/filepath
time=2025-09-18T09:43:11.311Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/path/filepath
time=2025-09-18T09:43:11.311Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/path/filepath pkgDirAbs=/app/minigo/stdlib/path/filepath module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.311Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/path/filepath files=[/app/minigo/stdlib/path/filepath/install.go]
time=2025-09-18T09:43:11.311Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/path/filepath enabled=false
time=2025-09-18T09:43:11.312Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/regexp
time=2025-09-18T09:43:11.312Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/regexp
time=2025-09-18T09:43:11.312Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/regexp pkgDirAbs=/app/minigo/stdlib/regexp module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.312Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/regexp files=[/app/minigo/stdlib/regexp/install.go]
time=2025-09-18T09:43:11.312Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/regexp enabled=false
time=2025-09-18T09:43:11.312Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/sort
time=2025-09-18T09:43:11.312Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/sort
time=2025-09-18T09:43:11.312Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/sort pkgDirAbs=/app/minigo/stdlib/sort module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.312Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/sort files=[/app/minigo/stdlib/sort/install.go]
time=2025-09-18T09:43:11.312Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/sort enabled=false
time=2025-09-18T09:43:11.313Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/strconv
time=2025-09-18T09:43:11.313Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/strconv
time=2025-09-18T09:43:11.313Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/strconv pkgDirAbs=/app/minigo/stdlib/strconv module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.313Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/strconv files=[/app/minigo/stdlib/strconv/install.go]
time=2025-09-18T09:43:11.313Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/strconv enabled=false
time=2025-09-18T09:43:11.313Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/strings
time=2025-09-18T09:43:11.313Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/strings
time=2025-09-18T09:43:11.314Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/strings pkgDirAbs=/app/minigo/stdlib/strings module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.314Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/strings files=[/app/minigo/stdlib/strings/install.go]
time=2025-09-18T09:43:11.314Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/strings enabled=false
time=2025-09-18T09:43:11.314Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/text/scanner
time=2025-09-18T09:43:11.314Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/text/scanner
time=2025-09-18T09:43:11.314Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/text/scanner pkgDirAbs=/app/minigo/stdlib/text/scanner module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.314Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/text/scanner files=[/app/minigo/stdlib/text/scanner/install.go]
time=2025-09-18T09:43:11.314Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/text/scanner enabled=false
time=2025-09-18T09:43:11.315Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/text/template
time=2025-09-18T09:43:11.315Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/text/template
time=2025-09-18T09:43:11.315Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/text/template pkgDirAbs=/app/minigo/stdlib/text/template module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.315Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/text/template files=[/app/minigo/stdlib/text/template/install.go]
time=2025-09-18T09:43:11.315Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/text/template enabled=false
time=2025-09-18T09:43:11.315Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/time
time=2025-09-18T09:43:11.316Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/minigo/stdlib/time
time=2025-09-18T09:43:11.316Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/minigo/stdlib/time pkgDirAbs=/app/minigo/stdlib/time module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.316Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/minigo/stdlib/time files=[/app/minigo/stdlib/time/install.go]
time=2025-09-18T09:43:11.316Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/minigo/stdlib/time enabled=false
time=2025-09-18T09:43:11.316Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/scanner
time=2025-09-18T09:43:11.317Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/scanner
time=2025-09-18T09:43:11.317Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/scanner pkgDirAbs=/app/scanner module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.317Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=2 pkgDirAbs=/app/scanner files="[/app/scanner/models.go /app/scanner/scanner.go]"
time=2025-09-18T09:43:11.317Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/scanner enabled=false
time=2025-09-18T09:43:11.325Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/scantest
time=2025-09-18T09:43:11.325Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/scantest
time=2025-09-18T09:43:11.325Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/scantest pkgDirAbs=/app/scantest module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.325Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/scantest files=[/app/scantest/scantest.go]
time=2025-09-18T09:43:11.325Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/scantest enabled=false
time=2025-09-18T09:43:11.326Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/symgo
time=2025-09-18T09:43:11.326Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/symgo
time=2025-09-18T09:43:11.326Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/symgo pkgDirAbs=/app/symgo module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.326Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/symgo files=[/app/symgo/symgo.go]
time=2025-09-18T09:43:11.326Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/symgo enabled=false
time=2025-09-18T09:43:11.328Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/symgo/evaluator
time=2025-09-18T09:43:11.328Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/symgo/evaluator
time=2025-09-18T09:43:11.328Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/symgo/evaluator pkgDirAbs=/app/symgo/evaluator module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.328Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=5 pkgDirAbs=/app/symgo/evaluator files="[/app/symgo/evaluator/accessor.go /app/symgo/evaluator/builtins.go /app/symgo/evaluator/evaluator.go /app/symgo/evaluator/resolver.go /app/symgo/evaluator/universe.go]"
time=2025-09-18T09:43:11.328Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/symgo/evaluator enabled=false
time=2025-09-18T09:43:11.339Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/symgo/integration_test
time=2025-09-18T09:43:11.339Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/symgo/integration_test
time=2025-09-18T09:43:11.339Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/symgo/integration_test pkgDirAbs=/app/symgo/integration_test module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.339Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=0 pkgDirAbs=/app/symgo/integration_test files=[]
time=2025-09-18T09:43:11.339Z level=DEBUG source=/app/goscan.go:998 msg="ScanPackageByImport found no .go files. Caching empty PackageInfo." pkgDirAbs=/app/symgo/integration_test
time=2025-09-18T09:43:11.339Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/symgo/intrinsics
time=2025-09-18T09:43:11.339Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/symgo/intrinsics
time=2025-09-18T09:43:11.339Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/symgo/intrinsics pkgDirAbs=/app/symgo/intrinsics module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.339Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=2 pkgDirAbs=/app/symgo/intrinsics files="[/app/symgo/intrinsics/builtins.go /app/symgo/intrinsics/intrinsics.go]"
time=2025-09-18T09:43:11.339Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/symgo/intrinsics enabled=false
time=2025-09-18T09:43:11.343Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/symgo/object
time=2025-09-18T09:43:11.343Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/symgo/object
time=2025-09-18T09:43:11.343Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/symgo/object pkgDirAbs=/app/symgo/object module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.343Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/symgo/object files=[/app/symgo/object/object.go]
time=2025-09-18T09:43:11.343Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/symgo/object enabled=false
time=2025-09-18T09:43:11.353Z level=DEBUG source=/app/modulewalker.go:59 msg="ScanPackageImports CACHE MISS" importPath=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.354Z level=DEBUG source=/app/goscan.go:977 msg="ScanPackageByImport CACHE MISS" importPath=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.354Z level=DEBUG source=/app/goscan.go:988 msg="ScanPackageByImport resolved import path" importPath=github.com/podhmo/go-scan/symgotest pkgDirAbs=/app/symgotest module=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.354Z level=DEBUG source=/app/goscan.go:994 msg="ScanPackageByImport found .go files" count=1 pkgDirAbs=/app/symgotest files=[/app/symgotest/symgotest.go]
time=2025-09-18T09:43:11.354Z level=DEBUG source=/app/goscan.go:1008 msg="ScanPackageByImport symbol cache status" importPath=github.com/podhmo/go-scan/symgotest enabled=false
time=2025-09-18T09:43:11.358Z level=INFO source=/app/examples/find-orphans/main.go:444 msg="analysis phase" packages=72
time=2025-09-18T09:43:11.360Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/minigo/object types=49
time=2025-09-18T09:43:11.366Z level=DEBUG source=/app/examples/find-orphans/main.go:447 msg="built interface map" interfaces=11
time=2025-09-18T09:43:11.366Z level=DEBUG source=/app/examples/find-orphans/main.go:547 msg="running symbolic execution from entry points"
time=2025-09-18T09:43:11.366Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/minigo/stdlib/encoding/json
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/minigo/stdlib/encoding/json/install.go:3:1 source="// Code generated by minigo-gen-bindings. DO NOT EDIT.\n\npackage json\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n\n\t\"github.com/podhmo/go-scan/minigo\"\n)\n\n// Install binds all exported symbols from the \"encoding/json\" package to the interpreter.\nfunc Install(interp *minigo.Interpreter) {\n\tinterp.Register(\"encoding/json\", map[string]any{\n\t\t\"Compact\":\t\t\tjson.Compact,\n\t\t\"HTMLEscape\":\t\t\tjson.HTMLEscape,\n\t\t\"Indent\":\t\t\tjson.Indent,\n\t\t\"Marshal\":\t\t\tjson.Marshal,\n\t\t\"MarshalIndent\":\t\tjson.MarshalIndent,\n\t\t\"NewDecoder\":\t\t\tjson.NewDecoder,\n\t\t\"NewEncoder\":\t\t\tjson.NewEncoder,\n\t\t\"Unmarshal\":\t\t\tjson.Unmarshal,\n\t\t\"Valid\":\t\t\tjson.Valid,\n\t\t\"Decoder\":\t\t\treflect.TypeOf((*json.Decoder)(nil)).Elem(),\n\t\t\"Delim\":\t\t\treflect.TypeOf((*json.Delim)(nil)).Elem(),\n\t\t\"Encoder\":\t\t\treflect.TypeOf((*json.Encoder)(nil)).Elem(),\n\t\t\"InvalidUTF8Error\":\t\treflect.TypeOf((*json.InvalidUTF8Error)(nil)).Elem(),\n\t\t\"InvalidUnmarshalError\":\treflect.TypeOf((*json.InvalidUnmarshalError)(nil)).Elem(),\n\t\t\"Marshaler\":\t\t\treflect.TypeOf((*json.Marshaler)(nil)).Elem(),\n\t\t\"MarshalerError\":\t\treflect.TypeOf((*json.MarshalerError)(nil)).Elem(),\n\t\t\"Number\":\t\t\treflect.TypeOf((*json.Number)(nil)).Elem(),\n\t\t\"RawMessage\":\t\t\treflect.TypeOf((*json.RawMessage)(nil)).Elem(),\n\t\t\"SyntaxError\":\t\t\treflect.TypeOf((*json.SyntaxError)(nil)).Elem(),\n\t\t\"Token\":\t\t\treflect.TypeOf((*json.Token)(nil)).Elem(),\n\t\t\"UnmarshalFieldError\":\t\treflect.TypeOf((*json.UnmarshalFieldError)(nil)).Elem(),\n\t\t\"UnmarshalTypeError\":\t\treflect.TypeOf((*json.UnmarshalTypeError)(nil)).Elem(),\n\t\t\"Unmarshaler\":\t\t\treflect.TypeOf((*json.Unmarshaler)(nil)).Elem(),\n\t\t\"UnsupportedTypeError\":\t\treflect.TypeOf((*json.UnsupportedTypeError)(nil)).Elem(),\n\t\t\"UnsupportedValueError\":\treflect.TypeOf((*json.UnsupportedValueError)(nil)).Elem(),\n\t})\n}\n"
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/encoding/json
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/minigo/stdlib/encoding/json
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/minigo/stdlib/encoding/json
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/minigo/stdlib/encoding/json types=0
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/encoding/json scanned=true
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/minigo/stdlib/encoding/json
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/encoding/json scanned=true
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/encoding/json
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/stdlib/encoding/json scanned=true
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/encoding/json scanned=true
time=2025-09-18T09:43:11.367Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/minigo/stdlib/path/filepath
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/minigo/stdlib/path/filepath/install.go:3:1 source="// Code generated by minigo-gen-bindings. DO NOT EDIT.\n\npackage filepath\n\nimport (\n\t\"path/filepath\"\n\t\"reflect\"\n\n\t\"github.com/podhmo/go-scan/minigo\"\n)\n\n// Install binds all exported symbols from the \"path/filepath\" package to the interpreter.\nfunc Install(interp *minigo.Interpreter) {\n\tinterp.Register(\"path/filepath\", map[string]any{\n\t\t\"Abs\":\t\t\tfilepath.Abs,\n\t\t\"Base\":\t\t\tfilepath.Base,\n\t\t\"Clean\":\t\tfilepath.Clean,\n\t\t\"Dir\":\t\t\tfilepath.Dir,\n\t\t\"ErrBadPattern\":\tfilepath.ErrBadPattern,\n\t\t\"EvalSymlinks\":\t\tfilepath.EvalSymlinks,\n\t\t\"Ext\":\t\t\tfilepath.Ext,\n\t\t\"FromSlash\":\t\tfilepath.FromSlash,\n\t\t\"Glob\":\t\t\tfilepath.Glob,\n\t\t\"HasPrefix\":\t\tfilepath.HasPrefix,\n\t\t\"IsAbs\":\t\tfilepath.IsAbs,\n\t\t\"IsLocal\":\t\tfilepath.IsLocal,\n\t\t\"Join\":\t\t\tfilepath.Join,\n\t\t\"ListSeparator\":\tfilepath.ListSeparator,\n\t\t\"Localize\":\t\tfilepath.Localize,\n\t\t\"Match\":\t\tfilepath.Match,\n\t\t\"Rel\":\t\t\tfilepath.Rel,\n\t\t\"Separator\":\t\tfilepath.Separator,\n\t\t\"SkipAll\":\t\tfilepath.SkipAll,\n\t\t\"SkipDir\":\t\tfilepath.SkipDir,\n\t\t\"Split\":\t\tfilepath.Split,\n\t\t\"SplitList\":\t\tfilepath.SplitList,\n\t\t\"ToSlash\":\t\tfilepath.ToSlash,\n\t\t\"VolumeName\":\t\tfilepath.VolumeName,\n\t\t\"Walk\":\t\t\tfilepath.Walk,\n\t\t\"WalkDir\":\t\tfilepath.WalkDir,\n\t\t\"WalkFunc\":\t\treflect.TypeOf((*filepath.WalkFunc)(nil)).Elem(),\n\t})\n}\n"
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/path/filepath
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/minigo/stdlib/path/filepath
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/minigo/stdlib/path/filepath
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/minigo/stdlib/path/filepath types=0
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/path/filepath scanned=true
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/minigo/stdlib/path/filepath
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/path/filepath scanned=true
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/path/filepath
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/stdlib/path/filepath scanned=true
time=2025-09-18T09:43:11.367Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/path/filepath scanned=true
time=2025-09-18T09:43:11.367Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/minigo/stdlib/strings
time=2025-09-18T09:43:11.368Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/minigo/stdlib/strings/install.go:3:1 source="// Code generated by minigo-gen-bindings. DO NOT EDIT.\n\npackage strings\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n\n\t\"github.com/podhmo/go-scan/minigo\"\n)\n\n// Install binds all exported symbols from the \"strings\" package to the interpreter.\nfunc Install(interp *minigo.Interpreter) {\n\tinterp.Register(\"strings\", map[string]any{\n\t\t\"Clone\":\t\tstrings.Clone,\n\t\t\"Compare\":\t\tstrings.Compare,\n\t\t\"Contains\":\t\tstrings.Contains,\n\t\t\"ContainsAny\":\t\tstrings.ContainsAny,\n\t\t\"ContainsFunc\":\t\tstrings.ContainsFunc,\n\t\t\"ContainsRune\":\t\tstrings.ContainsRune,\n\t\t\"Count\":\t\tstrings.Count,\n\t\t\"Cut\":\t\t\tstrings.Cut,\n\t\t\"CutPrefix\":\t\tstrings.CutPrefix,\n\t\t\"CutSuffix\":\t\tstrings.CutSuffix,\n\t\t\"EqualFold\":\t\tstrings.EqualFold,\n\t\t\"Fields\":\t\tstrings.Fields,\n\t\t\"FieldsFunc\":\t\tstrings.FieldsFunc,\n\t\t\"FieldsFuncSeq\":\tstrings.FieldsFuncSeq,\n\t\t\"FieldsSeq\":\t\tstrings.FieldsSeq,\n\t\t\"HasPrefix\":\t\tstrings.HasPrefix,\n\t\t\"HasSuffix\":\t\tstrings.HasSuffix,\n\t\t\"Index\":\t\tstrings.Index,\n\t\t\"IndexAny\":\t\tstrings.IndexAny,\n\t\t\"IndexByte\":\t\tstrings.IndexByte,\n\t\t\"IndexFunc\":\t\tstrings.IndexFunc,\n\t\t\"IndexRune\":\t\tstrings.IndexRune,\n\t\t\"Join\":\t\t\tstrings.Join,\n\t\t\"LastIndex\":\t\tstrings.LastIndex,\n\t\t\"LastIndexAny\":\t\tstrings.LastIndexAny,\n\t\t\"LastIndexByte\":\tstrings.LastIndexByte,\n\t\t\"LastIndexFunc\":\tstrings.LastIndexFunc,\n\t\t\"Lines\":\t\tstrings.Lines,\n\t\t\"Map\":\t\t\tstrings.Map,\n\t\t\"NewReader\":\t\tstrings.NewReader,\n\t\t\"NewReplacer\":\t\tstrings.NewReplacer,\n\t\t\"Repeat\":\t\tstrings.Repeat,\n\t\t\"Replace\":\t\tstrings.Replace,\n\t\t\"ReplaceAll\":\t\tstrings.ReplaceAll,\n\t\t\"Split\":\t\tstrings.Split,\n\t\t\"SplitAfter\":\t\tstrings.SplitAfter,\n\t\t\"SplitAfterN\":\t\tstrings.SplitAfterN,\n\t\t\"SplitAfterSeq\":\tstrings.SplitAfterSeq,\n\t\t\"SplitN\":\t\tstrings.SplitN,\n\t\t\"SplitSeq\":\t\tstrings.SplitSeq,\n\t\t\"Title\":\t\tstrings.Title,\n\t\t\"ToLower\":\t\tstrings.ToLower,\n\t\t\"ToLowerSpecial\":\tstrings.ToLowerSpecial,\n\t\t\"ToTitle\":\t\tstrings.ToTitle,\n\t\t\"ToTitleSpecial\":\tstrings.ToTitleSpecial,\n\t\t\"ToUpper\":\t\tstrings.ToUpper,\n\t\t\"ToUpperSpecial\":\tstrings.ToUpperSpecial,\n\t\t\"ToValidUTF8\":\t\tstrings.ToValidUTF8,\n\t\t\"Trim\":\t\t\tstrings.Trim,\n\t\t\"TrimFunc\":\t\tstrings.TrimFunc,\n\t\t\"TrimLeft\":\t\tstrings.TrimLeft,\n\t\t\"TrimLeftFunc\":\t\tstrings.TrimLeftFunc,\n\t\t\"TrimPrefix\":\t\tstrings.TrimPrefix,\n\t\t\"TrimRight\":\t\tstrings.TrimRight,\n\t\t\"TrimRightFunc\":\tstrings.TrimRightFunc,\n\t\t\"TrimSpace\":\t\tstrings.TrimSpace,\n\t\t\"TrimSuffix\":\t\tstrings.TrimSuffix,\n\t\t\"Builder\":\t\treflect.TypeOf((*strings.Builder)(nil)).Elem(),\n\t\t\"Reader\":\t\treflect.TypeOf((*strings.Reader)(nil)).Elem(),\n\t\t\"Replacer\":\t\treflect.TypeOf((*strings.Replacer)(nil)).Elem(),\n\t})\n}\n"
time=2025-09-18T09:43:11.368Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/strings
time=2025-09-18T09:43:11.368Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/minigo/stdlib/strings
time=2025-09-18T09:43:11.368Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/minigo/stdlib/strings
time=2025-09-18T09:43:11.368Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/minigo/stdlib/strings types=0
time=2025-09-18T09:43:11.368Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/strings scanned=true
time=2025-09-18T09:43:11.368Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/minigo/stdlib/strings
time=2025-09-18T09:43:11.368Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/strings scanned=true
time=2025-09-18T09:43:11.368Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/strings
time=2025-09-18T09:43:11.368Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/stdlib/strings scanned=true
time=2025-09-18T09:43:11.368Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/strings scanned=true
time=2025-09-18T09:43:11.368Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/symgotest/symgotest.go:1:1 source="package symgotest\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/parser\"\n\t\"go/printer\"\n\t\"go/token\"\n\t\"io\"\n\t\"log/slog\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\tgoscan \"github.com/podhmo/go-scan\"\n\t\"github.com/podhmo/go-scan/scantest\"\n\t\"github.com/podhmo/go-scan/symgo\"\n\t\"github.com/podhmo/go-scan/symgo/object\"\n)\n\n// Run executes a symgo test case. It handles all setup and teardown.\n// Its behavior with respect to interpreter errors depends on the `ExpectError` flag in the TestCase.\nfunc Run(t *testing.T, tc TestCase, action func(t *testing.T, r *Result)) {\n\tt.Helper()\n\tres := runLogic(t, tc)\n\n\t// If an unexpected error occurred, fail fatally.\n\tif res.Error != nil && !tc.ExpectError {\n\t\tif res.Trace != nil {\n\t\t\tt.Fatalf(\"symgotest: test failed unexpectedly: %v\\n\\n%s\", res.Error, res.Trace.Format())\n\t\t}\n\t\tt.Fatalf(\"symgotest: test failed unexpectedly: %v\", res.Error)\n\t}\n\n\t// If an error was expected but none occurred, fail fatally.\n\tif res.Error == nil && tc.ExpectError {\n\t\tt.Fatalf(\"symgotest: expected an error, but test completed successfully\")\n\t}\n\n\t// Otherwise, proceed to the action function for user assertions.\n\taction(t, res)\n}\n\n// runLogic contains the core logic of a test run. It always returns a Result,\n// with any errors (setup or runtime) populated in the Result.Error field.\nfunc runLogic(t *testing.T, tc TestCase) *Result {\n\t// 1. Setup test environment\n\tdir, cleanup := scantest.WriteFiles(t, tc.Source)\n\tdefer cleanup()\n\n\tworkDir := dir\n\tif tc.WorkDir != \"\" {\n\t\tworkDir = filepath.Join(dir, tc.WorkDir)\n\t}\n\n\t// 2. Create scanner and interpreter\n\tcfg := &config{\n\t\tTimeout:\t5 * time.Second,\t// Default timeout\n\t\tMaxSteps:\t10000,\t\t\t// Default max steps\n\t}\n\tfor _, opt := range tc.Options {\n\t\topt(cfg)\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), cfg.Timeout)\n\tdefer cancel()\n\n\tscanner, err := goscan.New(\n\t\tgoscan.WithWorkDir(workDir),\n\t\tgoscan.WithGoModuleResolver(),\n\t)\n\tif err != nil {\n\t\treturn &Result{Error: &object.Error{Message: fmt.Sprintf(\"failed to create scanner: %v\", err)}}\n\t}\n\n\t// Use provided tracer or default to internal one.\n\tvar tracer object.Tracer\n\tvar internalTracer *ExecutionTracer\n\tif cfg.Tracer != nil {\n\t\ttracer = cfg.Tracer\n\t} else {\n\t\tinternalTracer = NewExecutionTracer(scanner.Fset())\n\t\ttracer = internalTracer\n\t}\n\tres := &Result{Trace: internalTracer}\t// Initialize result early\n\n\tpkgPath, fnName := splitQualifiedName(tc.EntryPoint)\n\tif pkgPath == \"\" {\n\t\tres.Error = &object.Error{Message: fmt.Sprintf(\"invalid entry point format: %q. Expected 'path/to/package.FunctionName'\", tc.EntryPoint)}\n\t\treturn res\n\t}\n\n\tinterpreterOpts := []symgo.Option{\n\t\tsymgo.WithLogger(slog.New(slog.NewTextHandler(io.Discard, &slog.HandlerOptions{Level: slog.LevelError}))),\n\t\tsymgo.WithTracer(tracer),\n\t\tsymgo.WithMaxSteps(cfg.MaxSteps),\n\t}\n\tif cfg.ScanPolicy != nil {\n\t\tinterpreterOpts = append(interpreterOpts, symgo.WithScanPolicy(cfg.ScanPolicy))\n\t} else {\n\t\tmodules := scanner.Modules()\n\t\tif len(modules) > 0 {\n\t\t\tmodulePaths := make([]string, len(modules))\n\t\t\tfor i, mod := range modules {\n\t\t\t\tmodulePaths[i] = mod.Path\n\t\t\t}\n\t\t\tdefaultPolicy := func(pkgPath string) bool {\n\t\t\t\tfor _, modPath := range modulePaths {\n\t\t\t\t\tif strings.HasPrefix(pkgPath, modPath) {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tinterpreterOpts = append(interpreterOpts, symgo.WithScanPolicy(defaultPolicy))\n\t\t} else {\n\t\t\tinterpreterOpts = append(interpreterOpts, symgo.WithPrimaryAnalysisScope(pkgPath))\n\t\t}\n\t}\n\n\tinterpreter, err := symgo.NewInterpreter(scanner, interpreterOpts...)\n\tif err != nil {\n\t\tres.Error = &object.Error{Message: fmt.Sprintf(\"failed to create interpreter: %v\", err)}\n\t\treturn res\n\t}\n\tres.Interpreter = interpreter\n\tres.FinalEnv = interpreter.GlobalEnvForTest()\n\n\tif cfg.Intrinsics != nil {\n\t\tfor name, handler := range cfg.Intrinsics {\n\t\t\tinterpreter.RegisterIntrinsic(name, handler)\n\t\t}\n\t}\n\tif cfg.DefaultIntrinsic != nil {\n\t\tinterpreter.RegisterDefaultIntrinsic(cfg.DefaultIntrinsic)\n\t}\n\n\tif cfg.SetupFunc != nil {\n\t\tif err := cfg.SetupFunc(interpreter); err != nil {\n\t\t\tres.Error = &object.Error{Message: fmt.Sprintf(\"WithSetup function failed: %v\", err)}\n\t\t\treturn res\n\t\t}\n\t}\n\n\tpkgs, err := scanner.Scan(ctx, \"./...\")\n\tif err != nil {\n\t\tres.Error = &object.Error{Message: fmt.Sprintf(\"failed to scan module: %v\", err)}\n\t\treturn res\n\t}\n\n\tvar entryPointPkg *goscan.Package\n\tfor _, p := range pkgs {\n\t\tif p.ImportPath == pkgPath {\n\t\t\tentryPointPkg = p\n\t\t\tbreak\n\t\t}\n\t}\n\tif entryPointPkg == nil {\n\t\tres.Error = &object.Error{Message: fmt.Sprintf(\"could not find package %q after scanning module\", pkgPath)}\n\t\treturn res\n\t}\n\n\tfnObj, ok := interpreter.FindObjectInPackage(ctx, pkgPath, fnName)\n\tif !ok {\n\t\tres.Error = &object.Error{Message: fmt.Sprintf(\"entry point function %q not found in package %q\", fnName, pkgPath)}\n\t\treturn res\n\t}\n\n\trawResult := interpreter.EvaluatorForTest().Apply(ctx, fnObj, tc.Args, entryPointPkg)\n\n\tif err, ok := rawResult.(*object.Error); ok {\n\t\tres.Error = err\n\t\tres.ReturnValue = nil\n\t} else {\n\t\tfinalReturnValue := rawResult\n\t\tif ret, ok := rawResult.(*object.ReturnValue); ok {\n\t\t\tfinalReturnValue = ret.Value\n\t\t}\n\t\tres.ReturnValue = finalReturnValue\n\t}\n\n\tif ctx.Err() == context.DeadlineExceeded {\n\t\tres.Error = &object.Error{Message: fmt.Sprintf(\"timeout exceeded (%v)\", cfg.Timeout)}\n\t}\n\n\treturn res\n}\n\n// splitQualifiedName splits a name like \"pkg/path.Name\" into \"pkg/path\" and \"Name\".\nfunc splitQualifiedName(name string) (pkgPath, typeName string) {\n\tlastDot := strings.LastIndex(name, \".\")\n\tif lastDot == -1 {\n\t\treturn \"\", name\n\t}\n\treturn name[:lastDot], name[lastDot+1:]\n}\n\n// RunExpression is a convenience wrapper around Run for testing a single expression.\nfunc RunExpression(t *testing.T, expr string, action func(t *testing.T, r *Result)) {\n\tt.Helper()\n\tsource := fmt.Sprintf(\"package main\\n\\nfunc main() any {\\n\\treturn %s\\n}\", expr)\n\ttc := TestCase{\n\t\tSource: map[string]string{\n\t\t\t\"go.mod\":\t\"module example.com/main\",\n\t\t\t\"main.go\":\tsource,\n\t\t},\n\t\tEntryPoint:\t\"example.com/main.main\",\n\t}\n\tRun(t, tc, action)\n}\n\n// RunStatements is a convenience wrapper for testing a block of statements.\nfunc RunStatements(t *testing.T, stmts string, action func(t *testing.T, r *Result)) {\n\tt.Helper()\n\tsource := fmt.Sprintf(\"package main\\n\\nfunc main() {\\n%s\\n}\", stmts)\n\n\tfset := token.NewFileSet()\n\tf, err := parser.ParseFile(fset, \"main.go\", source, 0)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to parse statements: %v\", err)\n\t}\n\n\tscanner, err := goscan.New()\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create scanner: %v\", err)\n\t}\n\tinterpreter, err := symgo.NewInterpreter(scanner)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create interpreter: %v\", err)\n\t}\n\n\t// Evaluate the statements in the global environment\n\tglobalEnv := interpreter.GlobalEnvForTest()\n\tfor _, decl := range f.Decls {\n\t\tif fnDecl, ok := decl.(*ast.FuncDecl); ok && fnDecl.Name.Name == \"main\" {\n\t\t\tfor _, stmt := range fnDecl.Body.List {\n\t\t\t\t_, err := interpreter.EvalWithEnv(context.Background(), stmt, globalEnv, nil)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"statement evaluation failed: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tres := &Result{\n\t\tFinalEnv:\tglobalEnv,\n\t\tInterpreter:\tinterpreter,\n\t}\n\taction(t, res)\n}\n\n// TestCase defines the inputs for a single symgo test.\ntype TestCase struct {\n\t// Source provides the file contents for the test, mapping filename to content.\n\t// A `go.mod` file is typically required.\n\tSource\tmap[string]string\n\n\t// WorkDir specifies the working directory relative to the source root.\n\t// This is useful for multi-module workspaces. If empty, the root is used.\n\tWorkDir\tstring\n\n\t// EntryPoint is the fully qualified name of the function to execute.\n\t// e.g., \"example.com/me/main.main\"\n\tEntryPoint\tstring\n\n\t// Args are the symbolic objects to pass as arguments to the EntryPoint function.\n\tArgs\t[]object.Object\n\n\t// Options allow for customizing the test run's behavior.\n\tOptions\t[]Option\n\n\t// ExpectError, if true, treats a runtime error from the interpreter as an\n\t// expected outcome rather than a fatal test failure. The error can then be\n\t// inspected in the Result.\n\tExpectError\tbool\n}\n\n// Result contains the outcome of the symbolic execution.\ntype Result struct {\n\t// ReturnValue is the object returned from the EntryPoint function.\n\tReturnValue\tobject.Object\n\n\t// FinalEnv is the environment state after the EntryPoint function has completed.\n\t// This can be used to inspect the values of variables.\n\tFinalEnv\t*object.Environment\n\n\t// Trace is the detailed execution trace, useful for debugging.\n\t// This is only populated if the default internal tracer is used.\n\tTrace\t*ExecutionTracer\n\n\t// Error is any runtime error returned by the interpreter during execution.\n\tError\t*object.Error\n\n\t// Interpreter provides access to the configured interpreter for advanced assertions.\n\tInterpreter\t*symgo.Interpreter\n}\n\n// TraceEvent stores information about a single step in the execution trace.\ntype TraceEvent struct {\n\tStep\tint\n\tSource\tstring\n\tPos\tstring\n}\n\n// ExecutionTracer captures the execution flow of the symgo evaluator.\ntype ExecutionTracer struct {\n\tEvents\t[]TraceEvent\n\tmu\tsync.Mutex\n\tfset\t*token.FileSet\n}\n\n// NewExecutionTracer creates a new tracer.\nfunc NewExecutionTracer(fset *token.FileSet) *ExecutionTracer {\n\treturn &ExecutionTracer{\n\t\tEvents:\tmake([]TraceEvent, 0, 100),\n\t\tfset:\tfset,\n\t}\n}\n\n// Trace implements the symgo.Tracer interface.\nfunc (t *ExecutionTracer) Trace(event object.TraceEvent) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\n\tvar buf bytes.Buffer\n\tif t.fset != nil && event.Node != nil && event.Node.Pos().IsValid() {\n\t\tprinter.Fprint(&buf, t.fset, event.Node)\n\t}\n\n\tpos := \"\"\n\tif t.fset != nil && event.Node != nil && event.Node.Pos().IsValid() {\n\t\tpos = t.fset.Position(event.Node.Pos()).String()\n\t}\n\n\tt.Events = append(t.Events, TraceEvent{\n\t\tStep:\tevent.Step,\n\t\tSource:\tbuf.String(),\n\t\tPos:\tpos,\n\t})\n}\n\n// Format returns a string representation of the captured trace.\nfunc (t *ExecutionTracer) Format() string {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\n\tvar b strings.Builder\n\tb.WriteString(\"Execution Trace:\\n\")\n\tfor _, ev := range t.Events {\n\t\tfmt.Fprintf(&b, \"[Step %d] at %s\\n\\t%s\\n\", ev.Step, ev.Pos, ev.Source)\n\t}\n\treturn b.String()\n}\n\n// config holds the configuration for a test run.\ntype config struct {\n\tMaxSteps\t\tint\n\tTimeout\t\t\ttime.Duration\n\tScanPolicy\t\tsymgo.ScanPolicyFunc\n\tIntrinsics\t\tmap[string]symgo.IntrinsicFunc\n\tDefaultIntrinsic\tsymgo.IntrinsicFunc\n\tSetupFunc\t\tfunc(interp *symgo.Interpreter) error\n\tTracer\t\t\tobject.Tracer\n}\n\n// Option configures a test run.\ntype Option func(*config)\n\n// WithTracer provides a custom tracer for the symgo interpreter.\n// If this option is used, the default execution trace in the Result will not be populated.\nfunc WithTracer(tracer object.Tracer) Option {\n\treturn func(c *config) {\n\t\tc.Tracer = tracer\n\t}\n}\n\n// WithSetup provides a hook to perform arbitrary configuration on the interpreter\n// after it has been created but before analysis begins. This is useful for\n// advanced setup like `BindInterface`.\nfunc WithSetup(f func(interp *symgo.Interpreter) error) Option {\n\treturn func(c *config) {\n\t\tc.SetupFunc = f\n\t}\n}\n\n// WithMaxSteps sets a limit on the number of evaluation steps to prevent\n// infinite loops. If the limit is exceeded, the test fails.\n// Default: 10,000\nfunc WithMaxSteps(limit int) Option {\n\treturn func(c *config) {\n\t\tc.MaxSteps = limit\n\t}\n}\n\n// WithTimeout sets a time limit for the entire test run.\n// Default: 5 seconds\nfunc WithTimeout(d time.Duration) Option {\n\treturn func(c *config) {\n\t\tc.Timeout = d\n\t}\n}\n\n// WithScanPolicy defines which packages are \"in-policy\" (evaluated recursively)\n// versus \"out-of-policy\" (treated as symbolic placeholders).\nfunc WithScanPolicy(policy symgo.ScanPolicyFunc) Option {\n\treturn func(c *config) {\n\t\tc.ScanPolicy = policy\n\t}\n}\n\n// WithIntrinsic registers a custom handler for a specific function call,\n// allowing for mocking or spying. This is a cleaner alternative to\n\n// registering intrinsics on the interpreter manually.\nfunc WithIntrinsic(name string, handler symgo.IntrinsicFunc) Option {\n\treturn func(c *config) {\n\t\tif c.Intrinsics == nil {\n\t\t\tc.Intrinsics = make(map[string]symgo.IntrinsicFunc)\n\t\t}\n\t\tc.Intrinsics[name] = handler\n\t}\n}\n\n// WithDefaultIntrinsic registers a handler that is called for any function\n// that does not have a specific intrinsic registered.\nfunc WithDefaultIntrinsic(handler symgo.IntrinsicFunc) Option {\n\treturn func(c *config) {\n\t\tc.DefaultIntrinsic = handler\n\t}\n}\n\n// AssertAs unwraps the result and asserts the type of the nth return value.\n// For single return values, use index 0. It fails the test if the index is\n// out of bounds or if the type assertion fails.\nfunc AssertAs[T object.Object](r *Result, t *testing.T, index int) T {\n\tt.Helper()\n\tvar obj object.Object\n\n\tif mr, ok := r.ReturnValue.(*object.MultiReturn); ok {\n\t\tif index < 0 || index >= len(mr.Values) {\n\t\t\tt.Fatalf(\"index %d out of bounds for multi-return value with %d values\", index, len(mr.Values))\n\t\t}\n\t\tobj = mr.Values[index]\n\t} else {\n\t\tif index != 0 {\n\t\t\tt.Fatalf(\"index %d out of bounds for single return value\", index)\n\t\t}\n\t\tobj = r.ReturnValue\n\t}\n\n\tval, ok := obj.(T)\n\tif !ok {\n\t\tvar zero T\n\t\tt.Fatalf(\"type assertion failed: expected %T, got %T\", zero, obj)\n\t}\n\treturn val\n}\n"
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/symgotest types=6
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.370Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/symgotest
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/symgotest scanned=true
time=2025-09-18T09:43:11.371Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/examples/convert/sampledata/converter
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/examples/convert/sampledata/converter/converter.go:1:1 source="package converter\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/podhmo/go-scan/examples/convert/sampledata/destination\"\n\t\"github.com/podhmo/go-scan/examples/convert/sampledata/source\"\n)\n\n// This file contains manually written converter functions.\n// These would be used for complex conversions that the generator doesn't handle,\n// or as custom functions invoked by the generator via tags in the future.\n\n// translateDescription is a helper function simulating internal processing.\nfunc translateDescription(ctx context.Context, text string, targetLang string) string {\n\tif targetLang == \"jp\" {\n\t\treturn \"翻訳済み (JP): \" + text\n\t}\n\treturn text\n}\n\n// --- User Conversion Functions ---\n\n// This is a manually implemented converter. The test `TestConvertUser` verifies its behavior.\n// The generated code will produce `ConvertSrcUserToDstUser` and `convertSrcUserToDstUser` in a separate file.\n// To avoid conflicts, we could name this differently, but for the test, we rely on the test calling this specific implementation.\nfunc ConvertUser(ctx context.Context, src source.SrcUser) destination.DstUser {\n\tif ctx == nil {\n\t\tctx = context.Background()\n\t}\n\n\tdst := destination.DstUser{}\n\n\tdst.UserID = fmt.Sprintf(\"user-%d\", src.ID)\n\tdst.FullName = src.FirstName + \" \" + src.LastName\n\tdst.Address = srcAddressToDstAddress(ctx, src.Address)\n\tdst.Contact = srcContactToDstContact(ctx, src.ContactInfo)\n\n\tif src.Details != nil {\n\t\tdst.Details = make([]destination.DstInternalDetail, len(src.Details))\n\t\tfor i, sDetail := range src.Details {\n\t\t\tdst.Details[i] = srcInternalDetailToDstInternalDetail(ctx, sDetail)\n\t\t}\n\t}\n\n\tdst.CreatedAt = src.CreatedAt.Format(time.RFC3339)\n\n\tif src.UpdatedAt != nil {\n\t\tdst.UpdatedAt = src.UpdatedAt.Format(time.RFC3339)\n\t} else {\n\t\tdst.UpdatedAt = \"\"\n\t}\n\n\treturn dst\n}\n\nfunc srcAddressToDstAddress(ctx context.Context, src source.SrcAddress) destination.DstAddress {\n\treturn destination.DstAddress{\n\t\tFullStreet:\tsrc.Street,\n\t\tCityName:\tsrc.City,\n\t}\n}\n\nfunc srcContactToDstContact(ctx context.Context, src source.SrcContact) destination.DstContact {\n\tdst := destination.DstContact{\n\t\tEmailAddress: src.Email,\n\t}\n\tif src.Phone != nil {\n\t\tdst.PhoneNumber = *src.Phone\n\t} else {\n\t\tdst.PhoneNumber = \"N/A\"\n\t}\n\treturn dst\n}\n\nfunc srcInternalDetailToDstInternalDetail(ctx context.Context, src source.SrcInternalDetail) destination.DstInternalDetail {\n\tlocalizedDescription := translateDescription(ctx, src.Description, \"jp\")\n\treturn destination.DstInternalDetail{\n\t\tItemCode:\tsrc.Code,\n\t\tLocalizedDesc:\tlocalizedDescription,\n\t}\n}\n\n// --- Order Conversion Functions ---\n\nfunc ConvertOrder(ctx context.Context, src source.SrcOrder) destination.DstOrder {\n\tif ctx == nil {\n\t\tctx = context.Background()\n\t}\n\n\tdst := destination.DstOrder{\n\t\tID:\t\tsrc.OrderID,\n\t\tTotalAmount:\tsrc.Amount,\n\t}\n\n\tif src.Items != nil {\n\t\tdst.LineItems = make([]destination.DstItem, len(src.Items))\n\t\tfor i, sItem := range src.Items {\n\t\t\tdst.LineItems[i] = srcItemToDstItem(ctx, sItem)\n\t\t}\n\t}\n\treturn dst\n}\n\nfunc srcItemToDstItem(ctx context.Context, src source.SrcItem) destination.DstItem {\n\treturn destination.DstItem{\n\t\tProductCode:\tsrc.SKU,\n\t\tCount:\t\tsrc.Quantity,\n\t}\n}\n"
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/examples/convert/sampledata/converter
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/examples/convert/sampledata/converter
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/converter types=0
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/examples/convert/sampledata/converter
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter scanned=true
time=2025-09-18T09:43:11.371Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/converter scanned=true
time=2025-09-18T09:43:11.371Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/examples/convert/model
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/examples/convert/model/model.go:1:1 source="package model\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/podhmo/go-scan/scanner\"\n)\n\n// ParsedInfo holds all parsed conversion rules and type information.\ntype ParsedInfo struct {\n\tPackageName\t\tstring\n\tPackagePath\t\tstring\t// Import path of the package being parsed\n\tConversionPairs\t\t[]ConversionPair\n\tGlobalRules\t\t[]TypeRule\n\tImports\t\t\tmap[string]string\t// alias -> import path\n\tStructs\t\t\tmap[string]*StructInfo\n\tNamedTypes\t\tmap[string]*scanner.TypeInfo\n\tProcessedPackages\tmap[string]bool\t// Tracks import paths that have been parsed\n}\n\n// Variable defines a variable to be declared in the converter function.\ntype Variable struct {\n\tName\tstring\n\tType\tstring\n}\n\n// ComputedField defines a field that is computed from an expression.\ntype ComputedField struct {\n\tDstName\tstring\n\tExpr\tstring\n}\n\n// FieldMap defines a mapping between a source and destination field,\n// optionally with a custom conversion function.\ntype FieldMap struct {\n\tDstName\t\tstring\n\tSrcName\t\tstring\n\tConverter\tstring\t// e.g. \"funcs.UserIDToString\"\n}\n\n// MappingInfo holds the set of explicit mapping rules defined within a define.Mapping call.\ntype MappingInfo struct {\n\tMaps\t\t[]FieldMap\n\tComputes\t[]ComputedField\n}\n\n// ConversionPair defines a top-level conversion between two types.\ntype ConversionPair struct {\n\tSrcTypeName\tstring\n\tDstTypeName\tstring\n\tSrcTypeInfo\t*scanner.TypeInfo\n\tDstTypeInfo\t*scanner.TypeInfo\n\tMapping\t\t*MappingInfo\t// Explicit mapping rules from define.Mapping\n\tMaxErrors\tint\n\tVariables\t[]Variable\n\tComputed\t[]ComputedField\t// TODO: This might be deprecated in favor of Mapping.Computes\n}\n\n// TypeRule defines a global rule for converting between types or validating a type.\ntype TypeRule struct {\n\tSrcTypeName\tstring\n\tDstTypeName\tstring\n\tSrcTypeInfo\t*scanner.TypeInfo\n\tDstTypeInfo\t*scanner.TypeInfo\n\tUsingFunc\tstring\n\tValidatorFunc\tstring\n}\n\n// StructInfo holds information about a parsed struct.\ntype StructInfo struct {\n\tName\t\tstring\n\tFields\t\t[]FieldInfo\n\tType\t\t*scanner.TypeInfo\n\tIsAlias\t\tbool\n\tUnderlyingAlias\t*scanner.TypeInfo\n}\n\n// FieldInfo holds information about a field within a struct.\ntype FieldInfo struct {\n\tName\t\tstring\n\tOriginalName\tstring\n\tJSONTag\t\tstring\n\tTypeInfo\t*scanner.TypeInfo\t// The resolved TypeInfo for the field's type\n\tFieldType\t*scanner.FieldType\t// The detailed FieldType\n\tTag\t\tConvertTag\n\tParentStruct\t*StructInfo\n}\n\n// ConvertTag holds parsed values from a `convert` struct tag.\ntype ConvertTag struct {\n\tDstFieldName\tstring\n\tUsingFunc\tstring\n\tRequired\tbool\n\tRawValue\tstring\n}\n\ntype TypeKind int\n\nconst (\n\tKindUnknown\tTypeKind\t= iota\n\tKindBasic\n\tKindIdent\t// Identifier, could be a struct, named type, etc.\n\tKindPointer\n\tKindSlice\n\tKindArray\n\tKindMap\n\tKindInterface\n\tKindStruct\t// Specifically a struct type definition\n\tKindNamed\t// A named type (type MyInt int)\n\tKindFunc\n)\n\n// ErrorCollector accumulates errors during a conversion process.\ntype ErrorCollector struct {\n\terrors\t\t[]error\n\tMaxErrors\tint\n\tpath\t\t[]string\n}\n\n// NewErrorCollector creates a new ErrorCollector.\nfunc NewErrorCollector(maxErrors int) *ErrorCollector {\n\treturn &ErrorCollector{\n\t\tMaxErrors: maxErrors,\n\t}\n}\n\n// Add records a new error with the current field path.\nfunc (ec *ErrorCollector) Add(err error) {\n\tif ec.MaxErrorsReached() {\n\t\treturn\n\t}\n\tpath := strings.Join(ec.path, \".\")\n\tec.errors = append(ec.errors, fmt.Errorf(\"%s: %w\", path, err))\n}\n\n// Enter steps into a nested field.\nfunc (ec *ErrorCollector) Enter(field string) {\n\tec.path = append(ec.path, field)\n}\n\n// Leave steps out of a nested field.\nfunc (ec *ErrorCollector) Leave() {\n\tif len(ec.path) > 0 {\n\t\tec.path = ec.path[:len(ec.path)-1]\n\t}\n}\n\n// MaxErrorsReached returns true if the number of collected errors has reached the maximum limit.\nfunc (ec *ErrorCollector) MaxErrorsReached() bool {\n\treturn ec.MaxErrors > 0 && len(ec.errors) >= ec.MaxErrors\n}\n\n// HasErrors returns true if any errors have been collected.\nfunc (ec *ErrorCollector) HasErrors() bool {\n\treturn len(ec.errors) > 0\n}\n\n// Errors returns the collected errors.\nfunc (ec *ErrorCollector) Errors() []error {\n\treturn ec.errors\n}\n"
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/model
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/examples/convert/model
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/examples/convert/model
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/examples/convert/model types=12
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/model scanned=true
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/examples/convert/model
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/model scanned=true
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/model
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/model scanned=true
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/model scanned=true
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/model
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/model scanned=true
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/model scanned=true
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/model
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/model scanned=true
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/model scanned=true
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/model
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/model scanned=true
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/model scanned=true
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/model
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/model scanned=true
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/model scanned=true
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/model
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/model scanned=true
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/model scanned=true
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/model
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/model scanned=true
time=2025-09-18T09:43:11.372Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/model scanned=true
time=2025-09-18T09:43:11.372Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.373Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/examples/convert/sampledata/generated/generated.go:2:1 source="// Code generated by convert. DO NOT EDIT.\npackage generated\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\n\tconvutil \"github.com/podhmo/go-scan/examples/convert/convutil\"\n\t\"github.com/podhmo/go-scan/examples/convert/model\"\n\tdestination \"github.com/podhmo/go-scan/examples/convert/sampledata/destination\"\n\tfuncs \"github.com/podhmo/go-scan/examples/convert/sampledata/funcs\"\n\tsource \"github.com/podhmo/go-scan/examples/convert/sampledata/source\"\n)\n\n// convertSrcUserToDstUser converts source.SrcUser to destination.DstUser.\nfunc convertSrcUserToDstUser(ctx context.Context, ec *model.ErrorCollector, src *source.SrcUser) *destination.DstUser {\n\tif src == nil {\n\t\treturn nil\n\t}\n\tdst := &destination.DstUser{}\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"UserID\")\n\tdst.UserID = funcs.UserIDToString(ctx, ec, src.ID)\n\n\tec.Leave()\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"Address\")\n\tdst.Address = *convertSrcAddressToDstAddress(ctx, ec, &src.Address)\n\n\tec.Leave()\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"Contact\")\n\tdst.Contact = funcs.ConvertSrcContactToDstContact(ctx, ec, src.ContactInfo)\n\n\tec.Leave()\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"Details\")\n\t{\n\t\tconvertedSlice := make([]destination.DstInternalDetail, len(src.Details))\n\t\tfor i, item := range src.Details {\n\t\t\tec.Enter(fmt.Sprintf(\"[%d]\", i))\n\t\t\tconvertedSlice[i] = *convertSrcInternalDetailToDstInternalDetail(ctx, ec, &item)\n\t\t\tec.Leave()\n\t\t}\n\t\tdst.Details = convertedSlice\n\t}\n\n\tec.Leave()\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"CreatedAt\")\n\tdst.CreatedAt = convutil.TimeToString(ctx, ec, src.CreatedAt)\n\n\tec.Leave()\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"UpdatedAt\")\n\tdst.UpdatedAt = convutil.PtrTimeToString(ctx, ec, src.UpdatedAt)\n\n\tec.Leave()\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"FullName\")\n\tdst.FullName = funcs.MakeFullName(src.FirstName, src.LastName)\n\tec.Leave()\n\treturn dst\n}\n\n// ConvertSrcUserToDstUser converts source.SrcUser to destination.DstUser.\nfunc ConvertSrcUserToDstUser(ctx context.Context, src *source.SrcUser) (*destination.DstUser, error) {\n\tif src == nil {\n\t\treturn nil, nil\n\t}\n\tec := model.NewErrorCollector(0)\n\tdst := convertSrcUserToDstUser(ctx, ec, src)\n\tif ec.HasErrors() {\n\t\treturn dst, errors.Join(ec.Errors()...)\n\t}\n\treturn dst, nil\n}\n\n// convertSrcAddressToDstAddress converts source.SrcAddress to destination.DstAddress.\nfunc convertSrcAddressToDstAddress(ctx context.Context, ec *model.ErrorCollector, src *source.SrcAddress) *destination.DstAddress {\n\tif src == nil {\n\t\treturn nil\n\t}\n\tdst := &destination.DstAddress{}\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"FullStreet\")\n\tdst.FullStreet = src.Street\n\n\tec.Leave()\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"CityName\")\n\tdst.CityName = src.City\n\n\tec.Leave()\n\treturn dst\n}\n\n// ConvertSrcAddressToDstAddress converts source.SrcAddress to destination.DstAddress.\nfunc ConvertSrcAddressToDstAddress(ctx context.Context, src *source.SrcAddress) (*destination.DstAddress, error) {\n\tif src == nil {\n\t\treturn nil, nil\n\t}\n\tec := model.NewErrorCollector(0)\n\tdst := convertSrcAddressToDstAddress(ctx, ec, src)\n\tif ec.HasErrors() {\n\t\treturn dst, errors.Join(ec.Errors()...)\n\t}\n\treturn dst, nil\n}\n\n// convertSrcInternalDetailToDstInternalDetail converts source.SrcInternalDetail to destination.DstInternalDetail.\nfunc convertSrcInternalDetailToDstInternalDetail(ctx context.Context, ec *model.ErrorCollector, src *source.SrcInternalDetail) *destination.DstInternalDetail {\n\tif src == nil {\n\t\treturn nil\n\t}\n\tdst := &destination.DstInternalDetail{}\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"ItemCode\")\n\tdst.ItemCode = src.Code\n\n\tec.Leave()\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"LocalizedDesc\")\n\tdst.LocalizedDesc = funcs.Translate(ctx, ec, src.Description)\n\n\tec.Leave()\n\treturn dst\n}\n\n// ConvertSrcInternalDetailToDstInternalDetail converts source.SrcInternalDetail to destination.DstInternalDetail.\nfunc ConvertSrcInternalDetailToDstInternalDetail(ctx context.Context, src *source.SrcInternalDetail) (*destination.DstInternalDetail, error) {\n\tif src == nil {\n\t\treturn nil, nil\n\t}\n\tec := model.NewErrorCollector(0)\n\tdst := convertSrcInternalDetailToDstInternalDetail(ctx, ec, src)\n\tif ec.HasErrors() {\n\t\treturn dst, errors.Join(ec.Errors()...)\n\t}\n\treturn dst, nil\n}\n\n// convertSrcOrderToDstOrder converts source.SrcOrder to destination.DstOrder.\nfunc convertSrcOrderToDstOrder(ctx context.Context, ec *model.ErrorCollector, src *source.SrcOrder) *destination.DstOrder {\n\tif src == nil {\n\t\treturn nil\n\t}\n\tdst := &destination.DstOrder{}\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"ID\")\n\tdst.ID = src.OrderID\n\n\tec.Leave()\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"TotalAmount\")\n\tdst.TotalAmount = src.Amount\n\n\tec.Leave()\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"LineItems\")\n\t{\n\t\tconvertedSlice := make([]destination.DstItem, len(src.Items))\n\t\tfor i, item := range src.Items {\n\t\t\tec.Enter(fmt.Sprintf(\"[%d]\", i))\n\t\t\tconvertedSlice[i] = *convertSrcItemToDstItem(ctx, ec, &item)\n\t\t\tec.Leave()\n\t\t}\n\t\tdst.LineItems = convertedSlice\n\t}\n\n\tec.Leave()\n\treturn dst\n}\n\n// ConvertSrcOrderToDstOrder converts source.SrcOrder to destination.DstOrder.\nfunc ConvertSrcOrderToDstOrder(ctx context.Context, src *source.SrcOrder) (*destination.DstOrder, error) {\n\tif src == nil {\n\t\treturn nil, nil\n\t}\n\tec := model.NewErrorCollector(0)\n\tdst := convertSrcOrderToDstOrder(ctx, ec, src)\n\tif ec.HasErrors() {\n\t\treturn dst, errors.Join(ec.Errors()...)\n\t}\n\treturn dst, nil\n}\n\n// convertSrcItemToDstItem converts source.SrcItem to destination.DstItem.\nfunc convertSrcItemToDstItem(ctx context.Context, ec *model.ErrorCollector, src *source.SrcItem) *destination.DstItem {\n\tif src == nil {\n\t\treturn nil\n\t}\n\tdst := &destination.DstItem{}\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"ProductCode\")\n\tdst.ProductCode = src.SKU\n\n\tec.Leave()\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"Count\")\n\tdst.Count = src.Quantity\n\n\tec.Leave()\n\treturn dst\n}\n\n// ConvertSrcItemToDstItem converts source.SrcItem to destination.DstItem.\nfunc ConvertSrcItemToDstItem(ctx context.Context, src *source.SrcItem) (*destination.DstItem, error) {\n\tif src == nil {\n\t\treturn nil, nil\n\t}\n\tec := model.NewErrorCollector(0)\n\tdst := convertSrcItemToDstItem(ctx, ec, src)\n\tif ec.HasErrors() {\n\t\treturn dst, errors.Join(ec.Errors()...)\n\t}\n\treturn dst, nil\n}\n\n// convertComplexSourceToComplexTarget converts source.ComplexSource to destination.ComplexTarget.\nfunc convertComplexSourceToComplexTarget(ctx context.Context, ec *model.ErrorCollector, src *source.ComplexSource) *destination.ComplexTarget {\n\tif src == nil {\n\t\treturn nil\n\t}\n\tdst := &destination.ComplexTarget{}\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"Value\")\n\tdst.Value = src.Value\n\n\tec.Leave()\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"Ptr\")\n\tif src.Ptr != nil {\n\t\ttmp := (*src.Ptr)\n\t\tdst.Ptr = &tmp\n\t} else {\n\t\tdst.Ptr = nil\n\t}\n\n\tec.Leave()\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"Slice\")\n\t{\n\t\tconvertedSlice := make([]destination.SubTarget, len(src.Slice))\n\t\tfor i, item := range src.Slice {\n\t\t\tec.Enter(fmt.Sprintf(\"[%d]\", i))\n\t\t\tconvertedSlice[i] = *convertSubSourceToSubTarget(ctx, ec, &item)\n\t\t\tec.Leave()\n\t\t}\n\t\tdst.Slice = convertedSlice\n\t}\n\n\tec.Leave()\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"SliceOfPtrs\")\n\t{\n\t\tconvertedSlice := make([]*destination.SubTarget, len(src.SliceOfPtrs))\n\t\tfor i, item := range src.SliceOfPtrs {\n\t\t\tec.Enter(fmt.Sprintf(\"[%d]\", i))\n\t\t\tconvertedSlice[i] = convertSubSourceToSubTarget(ctx, ec, item)\n\t\t\tec.Leave()\n\t\t}\n\t\tdst.SliceOfPtrs = convertedSlice\n\t}\n\n\tec.Leave()\n\treturn dst\n}\n\n// ConvertComplexSourceToComplexTarget converts source.ComplexSource to destination.ComplexTarget.\nfunc ConvertComplexSourceToComplexTarget(ctx context.Context, src *source.ComplexSource) (*destination.ComplexTarget, error) {\n\tif src == nil {\n\t\treturn nil, nil\n\t}\n\tec := model.NewErrorCollector(0)\n\tdst := convertComplexSourceToComplexTarget(ctx, ec, src)\n\tif ec.HasErrors() {\n\t\treturn dst, errors.Join(ec.Errors()...)\n\t}\n\treturn dst, nil\n}\n\n// convertSourceWithMapToTargetWithMap converts source.SourceWithMap to destination.TargetWithMap.\nfunc convertSourceWithMapToTargetWithMap(ctx context.Context, ec *model.ErrorCollector, src *source.SourceWithMap) *destination.TargetWithMap {\n\tif src == nil {\n\t\treturn nil\n\t}\n\tdst := &destination.TargetWithMap{}\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"ValueMap\")\n\t{\n\t\tconvertedMap := make(map[string]destination.SubTarget, len(src.ValueMap))\n\t\tfor key, value := range src.ValueMap {\n\t\t\tec.Enter(fmt.Sprintf(\"[%v]\", key))\n\t\t\tconvertedMap[key] = *convertSubSourceToSubTarget(ctx, ec, &value)\n\t\t\tec.Leave()\n\t\t}\n\t\tdst.ValueMap = convertedMap\n\t}\n\n\tec.Leave()\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"PtrMap\")\n\t{\n\t\tconvertedMap := make(map[string]*destination.SubTarget, len(src.PtrMap))\n\t\tfor key, value := range src.PtrMap {\n\t\t\tec.Enter(fmt.Sprintf(\"[%v]\", key))\n\t\t\tconvertedMap[key] = convertSubSourceToSubTarget(ctx, ec, value)\n\t\t\tec.Leave()\n\t\t}\n\t\tdst.PtrMap = convertedMap\n\t}\n\n\tec.Leave()\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"StringToStr\")\n\t{\n\t\tconvertedMap := make(map[string]string, len(src.StringToStr))\n\t\tfor key, value := range src.StringToStr {\n\t\t\tec.Enter(fmt.Sprintf(\"[%v]\", key))\n\t\t\tconvertedMap[key] = value\n\t\t\tec.Leave()\n\t\t}\n\t\tdst.StringToStr = convertedMap\n\t}\n\n\tec.Leave()\n\treturn dst\n}\n\n// ConvertSourceWithMapToTargetWithMap converts source.SourceWithMap to destination.TargetWithMap.\nfunc ConvertSourceWithMapToTargetWithMap(ctx context.Context, src *source.SourceWithMap) (*destination.TargetWithMap, error) {\n\tif src == nil {\n\t\treturn nil, nil\n\t}\n\tec := model.NewErrorCollector(0)\n\tdst := convertSourceWithMapToTargetWithMap(ctx, ec, src)\n\tif ec.HasErrors() {\n\t\treturn dst, errors.Join(ec.Errors()...)\n\t}\n\treturn dst, nil\n}\n\n// convertSrcContactToDstContact converts source.SrcContact to destination.DstContact.\n//\n// Fields that are not populated by this converter:\n//   - EmailAddress\n//   - PhoneNumber\nfunc convertSrcContactToDstContact(ctx context.Context, ec *model.ErrorCollector, src *source.SrcContact) *destination.DstContact {\n\tif src == nil {\n\t\treturn nil\n\t}\n\tdst := &destination.DstContact{}\n\treturn dst\n}\n\n// ConvertSrcContactToDstContact converts source.SrcContact to destination.DstContact.\n//\n// Fields that are not populated by this converter:\n//   - EmailAddress\n//   - PhoneNumber\nfunc ConvertSrcContactToDstContact(ctx context.Context, src *source.SrcContact) (*destination.DstContact, error) {\n\tif src == nil {\n\t\treturn nil, nil\n\t}\n\tec := model.NewErrorCollector(0)\n\tdst := convertSrcContactToDstContact(ctx, ec, src)\n\tif ec.HasErrors() {\n\t\treturn dst, errors.Join(ec.Errors()...)\n\t}\n\treturn dst, nil\n}\n\n// convertSubSourceToSubTarget converts source.SubSource to destination.SubTarget.\nfunc convertSubSourceToSubTarget(ctx context.Context, ec *model.ErrorCollector, src *source.SubSource) *destination.SubTarget {\n\tif src == nil {\n\t\treturn nil\n\t}\n\tdst := &destination.SubTarget{}\n\tif ec.MaxErrorsReached() {\n\t\treturn dst\n\t}\n\tec.Enter(\"Value\")\n\tdst.Value = src.Value\n\n\tec.Leave()\n\treturn dst\n}\n\n// ConvertSubSourceToSubTarget converts source.SubSource to destination.SubTarget.\nfunc ConvertSubSourceToSubTarget(ctx context.Context, src *source.SubSource) (*destination.SubTarget, error) {\n\tif src == nil {\n\t\treturn nil, nil\n\t}\n\tec := model.NewErrorCollector(0)\n\tdst := convertSubSourceToSubTarget(ctx, ec, src)\n\tif ec.HasErrors() {\n\t\treturn dst, errors.Join(ec.Errors()...)\n\t}\n\treturn dst, nil\n}\n"
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/examples/convert/sampledata/generated types=0
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert/sampledata/generated scanned=true
time=2025-09-18T09:43:11.374Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/examples/derivingbind/parser/parsers.go:3:1 source="// Package parser provides a set of standard parser functions for use with\n// the binding package. These parser convert strings to common Go types.\npackage parser\n\nimport (\n\t\"strconv\"\n)\n\n// String is a parser for the string type.\n// It always succeeds and returns the input string as is.\nfunc String(s string) (string, error) {\n\treturn s, nil\n}\n\n// Int is a parser for the int type.\n// It uses strconv.Atoi for conversion.\nfunc Int(s string) (int, error) {\n\treturn strconv.Atoi(s)\n}\n\n// Bool is a parser for the bool type.\n// It uses strconv.ParseBool, which accepts \"1\", \"t\", \"T\", \"TRUE\", \"true\", \"True\",\n// \"0\", \"f\", \"F\", \"FALSE\", \"false\", \"False\".\nfunc Bool(s string) (bool, error) {\n\treturn strconv.ParseBool(s)\n}\n\n// Float64 is a parser for the float64 type.\n// It uses strconv.ParseFloat for conversion.\nfunc Float64(s string) (float64, error) {\n\treturn strconv.ParseFloat(s, 64)\n}\n\n// Int8 is a parser for the int8 type.\nfunc Int8(s string) (int8, error) {\n\tn, err := strconv.ParseInt(s, 10, 8)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn int8(n), nil\n}\n\n// Int16 is a parser for the int16 type.\nfunc Int16(s string) (int16, error) {\n\tn, err := strconv.ParseInt(s, 10, 16)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn int16(n), nil\n}\n\n// Int32 is a parser for the int32 type.\nfunc Int32(s string) (int32, error) {\n\tn, err := strconv.ParseInt(s, 10, 32)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn int32(n), nil\n}\n\n// Int64 is a parser for the int64 type.\nfunc Int64(s string) (int64, error) {\n\treturn strconv.ParseInt(s, 10, 64)\n}\n\n// Uint is a parser for the uint type.\nfunc Uint(s string) (uint, error) {\n\tn, err := strconv.ParseUint(s, 10, 0)\t// 0 means infer bit size from type\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn uint(n), nil\n}\n\n// Uint8 is a parser for the uint8 type.\nfunc Uint8(s string) (uint8, error) {\n\tn, err := strconv.ParseUint(s, 10, 8)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn uint8(n), nil\n}\n\n// Uint16 is a parser for the uint16 type.\nfunc Uint16(s string) (uint16, error) {\n\tn, err := strconv.ParseUint(s, 10, 16)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn uint16(n), nil\n}\n\n// Uint32 is a parser for the uint32 type.\nfunc Uint32(s string) (uint32, error) {\n\tn, err := strconv.ParseUint(s, 10, 32)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn uint32(n), nil\n}\n\n// Uint64 is a parser for the uint64 type.\nfunc Uint64(s string) (uint64, error) {\n\treturn strconv.ParseUint(s, 10, 64)\n}\n\n// Float32 is a parser for the float32 type.\nfunc Float32(s string) (float32, error) {\n\tn, err := strconv.ParseFloat(s, 32)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn float32(n), nil\n}\n\n// Uintptr is a parser for the uintptr type.\nfunc Uintptr(s string) (uintptr, error) {\n\tn, err := strconv.ParseUint(s, 10, 64)\t// uintptr size is architecture-dependent, parse as uint64 then cast\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn uintptr(n), nil\n}\n\n// Complex64 is a parser for the complex64 type.\n// It uses strconv.ParseComplex for conversion.\nfunc Complex64(s string) (complex64, error) {\n\tc, err := strconv.ParseComplex(s, 64)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn complex64(c), nil\n}\n\n// Complex128 is a parser for the complex128 type.\n// It uses strconv.ParseComplex for conversion.\nfunc Complex128(s string) (complex128, error) {\n\treturn strconv.ParseComplex(s, 128)\n}\n"
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/examples/derivingbind/parser types=0
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/parser
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/parser scanned=true
time=2025-09-18T09:43:11.375Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/examples/docgen/openapi
time=2025-09-18T09:43:11.376Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/examples/docgen/openapi/model.go:2:1 source="// Package openapi provides a minimal set of structs to represent an OpenAPI 3.1.0 specification.\npackage openapi\n\n// OpenAPI is the root document object of the OpenAPI specification.\ntype OpenAPI struct {\n\tOpenAPI\t\tstring\t\t\t`json:\"openapi\" yaml:\"openapi\"`\n\tInfo\t\tInfo\t\t\t`json:\"info\" yaml:\"info\"`\n\tPaths\t\tmap[string]*PathItem\t`json:\"paths,omitempty\" yaml:\"paths,omitempty\"`\n\tComponents\t*Components\t\t`json:\"components,omitempty\" yaml:\"components,omitempty\"`\n}\n\n// Components holds a set of reusable objects for different aspects of the OAS.\ntype Components struct {\n\tSchemas map[string]*Schema `json:\"schemas,omitempty\" yaml:\"schemas,omitempty\"`\n}\n\n// Info provides metadata about the API.\ntype Info struct {\n\tTitle\tstring\t`json:\"title\" yaml:\"title\"`\n\tVersion\tstring\t`json:\"version\" yaml:\"version\"`\n}\n\n// PathItem describes the operations available on a single path.\ntype PathItem struct {\n\tGet\t*Operation\t`json:\"get,omitempty\" yaml:\"get,omitempty\"`\n\tPost\t*Operation\t`json:\"post,omitempty\" yaml:\"post,omitempty\"`\n\tPut\t*Operation\t`json:\"put,omitempty\" yaml:\"put,omitempty\"`\n\tDelete\t*Operation\t`json:\"delete,omitempty\" yaml:\"delete,omitempty\"`\n\tPatch\t*Operation\t`json:\"patch,omitempty\" yaml:\"patch,omitempty\"`\n\tHead\t*Operation\t`json:\"head,omitempty\" yaml:\"head,omitempty\"`\n\tOptions\t*Operation\t`json:\"options,omitempty\" yaml:\"options,omitempty\"`\n\tTrace\t*Operation\t`json:\"trace,omitempty\" yaml:\"trace,omitempty\"`\n}\n\n// Operation describes a single API operation on a path.\ntype Operation struct {\n\tSummary\t\tstring\t\t\t`json:\"summary,omitempty\" yaml:\"summary,omitempty\"`\n\tDescription\tstring\t\t\t`json:\"description,omitempty\" yaml:\"description,omitempty\"`\n\tOperationID\tstring\t\t\t`json:\"operationId,omitempty\" yaml:\"operationId,omitempty\"`\n\tParameters\t[]*Parameter\t\t`json:\"parameters,omitempty\" yaml:\"parameters,omitempty\"`\n\tRequestBody\t*RequestBody\t\t`json:\"requestBody,omitempty\" yaml:\"requestBody,omitempty\"`\n\tResponses\tmap[string]*Response\t`json:\"responses,omitempty\" yaml:\"responses,omitempty\"`\n}\n\n// Parameter describes a single operation parameter.\ntype Parameter struct {\n\tName\t\tstring\t`json:\"name\" yaml:\"name\"`\n\tIn\t\tstring\t`json:\"in\" yaml:\"in\"`\t// \"query\", \"header\", \"path\", \"cookie\"\n\tDescription\tstring\t`json:\"description,omitempty\" yaml:\"description,omitempty\"`\n\tRequired\tbool\t`json:\"required,omitempty\" yaml:\"required,omitempty\"`\n\tSchema\t\t*Schema\t`json:\"schema\" yaml:\"schema\"`\n}\n\n// RequestBody describes a single request body.\ntype RequestBody struct {\n\tDescription\tstring\t\t\t`json:\"description,omitempty\" yaml:\"description,omitempty\"`\n\tContent\t\tmap[string]MediaType\t`json:\"content\" yaml:\"content\"`\n\tRequired\tbool\t\t\t`json:\"required,omitempty\" yaml:\"required,omitempty\"`\n}\n\n// Response describes a single response from an API Operation.\ntype Response struct {\n\tDescription\tstring\t\t\t`json:\"description\" yaml:\"description\"`\n\tContent\t\tmap[string]MediaType\t`json:\"content,omitempty\" yaml:\"content,omitempty\"`\n}\n\n// MediaType provides schema and examples for the media type.\ntype MediaType struct {\n\tSchema *Schema `json:\"schema,omitempty\" yaml:\"schema,omitempty\"`\n}\n\n// Schema defines the schema for a type.\ntype Schema struct {\n\tType\t\t\tstring\t\t\t`json:\"type,omitempty\" yaml:\"type,omitempty\"`\n\tDescription\t\tstring\t\t\t`json:\"description,omitempty\" yaml:\"description,omitempty\"`\n\tProperties\t\tmap[string]*Schema\t`json:\"properties,omitempty\" yaml:\"properties,omitempty\"`\n\tItems\t\t\t*Schema\t\t\t`json:\"items,omitempty\" yaml:\"items,omitempty\"`\n\tAdditionalProperties\t*Schema\t\t\t`json:\"additionalProperties,omitempty\" yaml:\"additionalProperties,omitempty\"`\n\tFormat\t\t\tstring\t\t\t`json:\"format,omitempty\" yaml:\"format,omitempty\"`\t// e.g., \"int32\", \"int64\"\n\tRef\t\t\tstring\t\t\t`json:\"$ref,omitempty\" yaml:\"$ref,omitempty\"`\n}\n"
time=2025-09-18T09:43:11.376Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/openapi
time=2025-09-18T09:43:11.376Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/examples/docgen/openapi
time=2025-09-18T09:43:11.376Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/examples/docgen/openapi
time=2025-09-18T09:43:11.376Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/examples/docgen/openapi types=10
time=2025-09-18T09:43:11.376Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/openapi scanned=true
time=2025-09-18T09:43:11.376Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/examples/docgen/openapi
time=2025-09-18T09:43:11.376Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/openapi scanned=true
time=2025-09-18T09:43:11.376Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/minigo/stdlib/sort
time=2025-09-18T09:43:11.376Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/minigo/stdlib/sort/install.go:3:1 source="// Code generated by minigo-gen-bindings. DO NOT EDIT.\n\npackage sort\n\nimport (\n\t\"reflect\"\n\t\"sort\"\n\n\t\"github.com/podhmo/go-scan/minigo\"\n)\n\n// Install binds all exported symbols from the \"sort\" package to the interpreter.\nfunc Install(interp *minigo.Interpreter) {\n\tinterp.Register(\"sort\", map[string]any{\n\t\t\"Find\":\t\t\tsort.Find,\n\t\t\"Float64s\":\t\tsort.Float64s,\n\t\t\"Float64sAreSorted\":\tsort.Float64sAreSorted,\n\t\t\"Ints\":\t\t\tsort.Ints,\n\t\t\"IntsAreSorted\":\tsort.IntsAreSorted,\n\t\t\"IsSorted\":\t\tsort.IsSorted,\n\t\t\"Reverse\":\t\tsort.Reverse,\n\t\t\"Search\":\t\tsort.Search,\n\t\t\"SearchFloat64s\":\tsort.SearchFloat64s,\n\t\t\"SearchInts\":\t\tsort.SearchInts,\n\t\t\"SearchStrings\":\tsort.SearchStrings,\n\t\t\"Slice\":\t\tsort.Slice,\n\t\t\"SliceIsSorted\":\tsort.SliceIsSorted,\n\t\t\"SliceStable\":\t\tsort.SliceStable,\n\t\t\"Sort\":\t\t\tsort.Sort,\n\t\t\"Stable\":\t\tsort.Stable,\n\t\t\"Strings\":\t\tsort.Strings,\n\t\t\"StringsAreSorted\":\tsort.StringsAreSorted,\n\t\t\"Float64Slice\":\t\treflect.TypeOf((*sort.Float64Slice)(nil)).Elem(),\n\t\t\"IntSlice\":\t\treflect.TypeOf((*sort.IntSlice)(nil)).Elem(),\n\t\t\"Interface\":\t\treflect.TypeOf((*sort.Interface)(nil)).Elem(),\n\t\t\"StringSlice\":\t\treflect.TypeOf((*sort.StringSlice)(nil)).Elem(),\n\t})\n}\n"
time=2025-09-18T09:43:11.376Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/sort
time=2025-09-18T09:43:11.376Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/minigo/stdlib/sort
time=2025-09-18T09:43:11.376Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/minigo/stdlib/sort
time=2025-09-18T09:43:11.376Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/minigo/stdlib/sort types=0
time=2025-09-18T09:43:11.376Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/sort scanned=true
time=2025-09-18T09:43:11.376Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/minigo/stdlib/sort
time=2025-09-18T09:43:11.376Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/sort scanned=true
time=2025-09-18T09:43:11.376Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/sort
time=2025-09-18T09:43:11.376Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/stdlib/sort scanned=true
time=2025-09-18T09:43:11.376Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/sort scanned=true
time=2025-09-18T09:43:11.376Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.379Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/locator/locator.go:1:1 source="package locator\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\n\t\"github.com/podhmo/go-scan/scanner\"\n\t\"golang.org/x/mod/module\"\n)\n\n// ReplaceDirective represents a single replace directive in a go.mod file.\ntype ReplaceDirective struct {\n\tOldPath\t\tstring\n\tOldVersion\tstring\t// Empty if not specified\n\tNewPath\t\tstring\n\tNewVersion\tstring\t// Empty if it's a local path or not specified\n\tIsLocal\t\tbool\n}\n\n// Locator helps find the module root and resolve package import paths.\ntype Locator struct {\n\tmodulePath\tstring\n\trootDir\t\tstring\n\treplaces\t[]ReplaceDirective\n\toverlay\t\tscanner.Overlay\n\n\t// Options for advanced resolution\n\tUseGoModuleResolver\tbool\n\tgoRoot\t\t\tstring\n\tgoModCache\t\tstring\n\trequires\t\tmap[string]string\t// module path -> version\n}\n\n// Option is a functional option for configuring the Locator.\ntype Option func(*Locator)\n\n// WithOverlay provides in-memory file content for go.mod.\nfunc WithOverlay(overlay scanner.Overlay) Option {\n\treturn func(l *Locator) {\n\t\tif l.overlay == nil {\n\t\t\tl.overlay = make(scanner.Overlay)\n\t\t}\n\t\tfor k, v := range overlay {\n\t\t\tl.overlay[k] = v\n\t\t}\n\t}\n}\n\n// WithGoModuleResolver enables resolving packages from GOROOT and the module cache.\nfunc WithGoModuleResolver() Option {\n\treturn func(l *Locator) {\n\t\tl.UseGoModuleResolver = true\n\t}\n}\n\n// New creates a new Locator by searching for a go.mod file.\n// It starts searching from startPath and moves up the directory tree.\nfunc New(startPath string, options ...Option) (*Locator, error) {\n\tl := &Locator{\n\t\trequires: make(map[string]string),\n\t}\n\tfor _, opt := range options {\n\t\topt(l)\n\t}\n\n\tabsPath, err := filepath.Abs(startPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get absolute path for %s: %w\", startPath, err)\n\t}\n\n\trootDir, err := findModuleRoot(absPath)\n\tif err != nil {\n\t\t// If resolver is enabled, not finding a go.mod is not a fatal error\n\t\t// as we might be resolving stdlib packages.\n\t\tif !l.UseGoModuleResolver {\n\t\t\treturn nil, err\n\t\t}\n\t\t// We can proceed without a module root, but some features will be limited.\n\t\t// Let's assign rootDir to startPath to have a reference point.\n\t\trootDir = absPath\n\t}\n\tl.rootDir = rootDir\n\n\tvar goModContent []byte\n\tif l.overlay != nil {\n\t\tif content, ok := l.overlay[\"go.mod\"]; ok {\n\t\t\tgoModContent = content\n\t\t}\n\t}\n\n\tif goModContent == nil && l.rootDir != \"\" {\n\t\tgoModFilePath := filepath.Join(l.rootDir, \"go.mod\")\n\t\t// It's okay if go.mod doesn't exist, especially if UseGoModuleResolver is true\n\t\tif content, readErr := os.ReadFile(goModFilePath); readErr == nil {\n\t\t\tgoModContent = content\n\t\t}\n\t}\n\n\tif len(goModContent) > 0 {\n\t\tmodPath, err := getModulePathFromBytes(goModContent)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to get module path from go.mod content: %w\", err)\n\t\t}\n\t\tl.modulePath = modPath\n\n\t\treplaces, err := getReplaceDirectivesFromBytes(goModContent)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"warning: could not parse replace directives in go.mod: %v\\n\", err)\n\t\t}\n\t\tl.replaces = replaces\n\n\t\tif l.UseGoModuleResolver {\n\t\t\trequires, err := getRequireDirectivesFromBytes(goModContent)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"warning: could not parse require directives in go.mod: %v\\n\", err)\n\t\t\t}\n\t\t\tl.requires = requires\n\t\t}\n\t}\n\n\tif l.UseGoModuleResolver {\n\t\tl.goRoot = runtime.GOROOT()\n\t\tcache, err := getGoModCache()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not determine go mod cache location: %w\", err)\n\t\t}\n\t\tl.goModCache = cache\n\t}\n\n\treturn l, nil\n}\n\n// RootDir returns the project's root directory (where go.mod is located).\nfunc (l *Locator) RootDir() string {\n\treturn l.rootDir\n}\n\n// ModulePath returns the module path from go.mod.\nfunc (l *Locator) ModulePath() string {\n\treturn l.modulePath\n}\n\n// FindPackageDir converts an import path to a physical directory path.\nfunc (l *Locator) FindPackageDir(importPath string) (string, error) {\n\t// 1. Check replace directives\n\tfor _, r := range l.replaces {\n\t\tif strings.HasPrefix(importPath, r.OldPath) {\n\t\t\tremainingPath := strings.TrimPrefix(importPath, r.OldPath)\n\t\t\tif remainingPath != \"\" && !strings.HasPrefix(remainingPath, \"/\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tremainingPath = strings.TrimPrefix(remainingPath, \"/\")\n\n\t\t\tif r.IsLocal {\n\t\t\t\tvar localCandidatePath string\n\t\t\t\tif filepath.IsAbs(r.NewPath) {\n\t\t\t\t\tlocalCandidatePath = filepath.Join(r.NewPath, remainingPath)\n\t\t\t\t} else {\n\t\t\t\t\tlocalCandidatePath = filepath.Join(l.rootDir, r.NewPath, remainingPath)\n\t\t\t\t}\n\t\t\t\tabsLocalCandidatePath, err := filepath.Abs(localCandidatePath)\n\t\t\t\tif err != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif stat, statErr := os.Stat(absLocalCandidatePath); statErr == nil && stat.IsDir() {\n\t\t\t\t\treturn absLocalCandidatePath, nil\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewImportPath := r.NewPath\n\t\t\t\tif remainingPath != \"\" {\n\t\t\t\t\tnewImportPath = r.NewPath + \"/\" + remainingPath\n\t\t\t\t}\n\t\t\t\t// If the replaced path points to a different module, this simple locator cannot find it\n\t\t\t\t// unless that different module's path is passed to a *new* Locator instance for that module.\n\t\t\t\t// For the current request, we can't resolve it if it's truly external.\n\t\t\t\t// We will let it fall through, and it will likely fail unless another rule matches,\n\t\t\t\t// or the original importPath itself matches the current module (which it wouldn't if a replace rule was hit).\n\t\t\t\t// This implies that module-to-module replaces that point to *other* modules are not fully supported by this iteration.\n\t\t\t\t// Let's try to resolve it within the current module context.\n\t\t\t\tif l.modulePath != \"\" && strings.HasPrefix(newImportPath, l.modulePath) {\n\t\t\t\t\trelPath := strings.TrimPrefix(newImportPath, l.modulePath)\n\t\t\t\t\tcandidatePath := filepath.Join(l.rootDir, relPath)\n\t\t\t\t\tif stat, err := os.Stat(candidatePath); err == nil && stat.IsDir() {\n\t\t\t\t\t\treturn candidatePath, nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Try with the current module context\n\tif l.modulePath != \"\" && strings.HasPrefix(importPath, l.modulePath) {\n\t\trelPath := strings.TrimPrefix(importPath, l.modulePath)\n\t\tcandidatePath := filepath.Join(l.rootDir, relPath)\n\t\tif stat, err := os.Stat(candidatePath); err == nil && stat.IsDir() {\n\t\t\treturn candidatePath, nil\n\t\t}\n\t}\n\n\t// 3. If resolver is enabled, try GOROOT and GOMODCACHE\n\tif l.UseGoModuleResolver {\n\t\t// Try standard library in GOROOT\n\t\tif l.goRoot != \"\" {\n\t\t\tcandidatePath := filepath.Join(l.goRoot, \"src\", importPath)\n\t\t\tif stat, err := os.Stat(candidatePath); err == nil && stat.IsDir() {\n\t\t\t\treturn candidatePath, nil\n\t\t\t}\n\t\t}\n\n\t\t// Try external modules in GOMODCACHE\n\t\tif l.goModCache != \"\" {\n\t\t\tfor mod, ver := range l.requires {\n\t\t\t\tif strings.HasPrefix(importPath, mod) {\n\t\t\t\t\t// Path in cache is ${GOMODCACHE}/${module}@${version}/${subpath}\n\t\t\t\t\t// Module paths with uppercase letters are encoded.\n\t\t\t\t\tescapedMod, err := module.EscapePath(mod)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t// Should not happen for valid module paths\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tbaseDir := filepath.Join(l.goModCache, escapedMod+\"@\"+ver)\n\t\t\t\t\tremainingPath := strings.TrimPrefix(importPath, mod)\n\t\t\t\t\tcandidatePath := filepath.Join(baseDir, remainingPath)\n\n\t\t\t\t\tif stat, err := os.Stat(candidatePath); err == nil && stat.IsDir() {\n\t\t\t\t\t\treturn candidatePath, nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If no resolution method succeeded, return an error.\n\tif l.modulePath != \"\" {\n\t\treturn \"\", fmt.Errorf(\"import path %q could not be resolved. Current module is %q (root: %s)\", importPath, l.modulePath, l.rootDir)\n\t}\n\treturn \"\", fmt.Errorf(\"import path %q could not be resolved\", importPath)\n}\n\n// findModuleRoot searches for any go.mod starting from a given directory and moving upwards.\nfunc findModuleRoot(dir string) (string, error) {\n\tcurrentDir := dir\n\tfor {\n\t\tgoModPath := filepath.Join(currentDir, \"go.mod\")\n\t\tif _, err := os.Stat(goModPath); err == nil {\n\t\t\treturn currentDir, nil\n\t\t}\n\n\t\tparentDir := filepath.Dir(currentDir)\n\t\tif parentDir == currentDir {\n\t\t\treturn \"\", fmt.Errorf(\"go.mod not found in or above %s\", dir)\n\t\t}\n\t\tcurrentDir = parentDir\n\t}\n}\n\n// getModulePathFromBytes reads the module path from go.mod content.\nfunc getModulePathFromBytes(content []byte) (string, error) {\n\tif len(content) == 0 {\n\t\treturn \"\", fmt.Errorf(\"go.mod content is empty\")\n\t}\n\tscanner := bufio.NewScanner(bytes.NewReader(content))\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tif strings.HasPrefix(line, \"module\") {\n\t\t\tparts := strings.Fields(line)\n\t\t\tif len(parts) == 2 {\n\t\t\t\treturn parts[1], nil\n\t\t\t}\n\t\t}\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\treturn \"\", fmt.Errorf(\"error reading go.mod content: %w\", err)\n\t}\n\n\treturn \"\", fmt.Errorf(\"module path not found in go.mod content\")\n}\n\n// getReplaceDirectivesFromBytes reads replace directives from go.mod content.\nfunc getReplaceDirectivesFromBytes(content []byte) ([]ReplaceDirective, error) {\n\tif len(content) == 0 {\n\t\treturn nil, nil\t// No directives in empty file\n\t}\n\tvar directives []ReplaceDirective\n\tscanner := bufio.NewScanner(bytes.NewReader(content))\n\tinReplaceBlock := false\n\n\tfor scanner.Scan() {\n\t\tline := strings.TrimSpace(scanner.Text())\n\n\t\tif strings.HasPrefix(line, \"//\") {\t// Skip comments\n\t\t\tcontinue\n\t\t}\n\n\t\tif line == \"\" {\t// Skip empty lines\n\t\t\tcontinue\n\t\t}\n\n\t\tif strings.HasPrefix(line, \"replace\") {\n\t\t\tif strings.Contains(line, \"(\") {\n\t\t\t\tinReplaceBlock = true\n\t\t\t\tline = strings.TrimSpace(strings.TrimPrefix(line, \"replace\"))\n\t\t\t\tline = strings.TrimSpace(strings.TrimPrefix(line, \"(\"))\n\t\t\t\t// Process first line if it's not just \"replace (\"\n\t\t\t\tif line != \"\" {\n\t\t\t\t\tdirective, err := parseReplaceLine(line)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t// TODO: Log or handle individual line parsing errors more gracefully\n\t\t\t\t\t\t// For now, skip malformed lines.\n\t\t\t\t\t\tfmt.Fprintf(os.Stderr, \"warning: skipping malformed replace directive line: %q in go.mod: %v\\n\", line, err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tdirectives = append(directives, directive)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\t// Single line replace\n\t\t\t\tcontentParts := strings.Fields(line)\t// line is \"replace old [v] => new [v]\"\n\t\t\t\tif len(contentParts) < 1 {\t\t// Should not happen if HasPrefix(\"replace\") is true and line is trimmed\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tdirectiveLine := strings.Join(contentParts[1:], \" \")\t// \"old [v] => new [v]\"\n\n\t\t\t\t// parseReplaceLine will check for \"=>\"\n\t\t\t\tdirective, err := parseReplaceLine(directiveLine)\n\t\t\t\tif err != nil {\n\t\t\t\t\t// Log the original line for better context if parsing fails\n\t\t\t\t\tfmt.Fprintf(os.Stderr, \"warning: skipping malformed single-line replace directive content: %q (from line: %q) in go.mod: %v\\n\", directiveLine, line, err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tdirectives = append(directives, directive)\n\t\t\t\t// No need for 'continue' here as it's the end of the 'if strings.HasPrefix(line, \"replace\")' block's else path\n\t\t\t}\n\t\t} else if inReplaceBlock {\t// Ensure this is 'else if' or structure appropriately\n\t\t\tif line == \")\" {\n\t\t\t\tinReplaceBlock = false\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdirective, err := parseReplaceLine(line)\n\t\t\tif err != nil {\n\t\t\t\t// fmt.Fprintf(os.Stderr, \"warning: skipping malformed replace directive line: %q in go.mod: %v\\n\", line, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdirectives = append(directives, directive)\n\t\t}\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading go.mod content: %w\", err)\n\t}\n\n\treturn directives, nil\n}\n\n// getGoModCache finds the path to the module cache directory by calling `go env GOMODCACHE`.\nfunc getGoModCache() (string, error) {\n\tcmd := exec.Command(\"go\", \"env\", \"GOMODCACHE\")\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to run 'go env GOMODCACHE': %w\", err)\n\t}\n\treturn strings.TrimSpace(string(output)), nil\n}\n\n// getRequireDirectivesFromBytes reads require directives from go.mod content.\nfunc getRequireDirectivesFromBytes(content []byte) (map[string]string, error) {\n\tif len(content) == 0 {\n\t\treturn nil, nil\n\t}\n\trequires := make(map[string]string)\n\tscanner := bufio.NewScanner(bytes.NewReader(content))\n\tinRequireBlock := false\n\n\tfor scanner.Scan() {\n\t\tline := strings.TrimSpace(scanner.Text())\n\n\t\tif strings.HasPrefix(line, \"//\") {\n\t\t\tcontinue\n\t\t}\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif strings.HasPrefix(line, \"require\") {\n\t\t\tif strings.Contains(line, \"(\") {\n\t\t\t\tinRequireBlock = true\n\t\t\t\t// Potentially a require statement on the same line as `require (`\n\t\t\t\tline = strings.TrimSpace(strings.TrimPrefix(line, \"require\"))\n\t\t\t\tline = strings.TrimSpace(strings.TrimPrefix(line, \"(\"))\n\t\t\t} else {\n\t\t\t\t// Single line require\n\t\t\t\tparts := strings.Fields(line)\n\t\t\t\tif len(parts) == 3 {\t// require <path> <version>\n\t\t\t\t\trequires[parts[1]] = parts[2]\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif inRequireBlock {\n\t\t\tif line == \")\" {\n\t\t\t\tinRequireBlock = false\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tparts := strings.Fields(line)\n\t\t\tif len(parts) >= 2 {\t// <path> <version>\n\t\t\t\t// Handle potential // indirect comments\n\t\t\t\tversion := parts[1]\n\t\t\t\tif len(parts) > 2 && parts[2] == \"//\" {\n\t\t\t\t\t// it's indirect, but we still record it\n\t\t\t\t}\n\t\t\t\trequires[parts[0]] = version\n\t\t\t}\n\t\t}\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading go.mod content for require directives: %w\", err)\n\t}\n\n\treturn requires, nil\n}\n\n// parseReplaceLine parses a single line of a replace directive.\n// Example inputs:\n// \"old.module/path => new.module/path v1.2.3\"\n// \"old.module/path v0.0.0 => new.module/path v1.2.3\"\n// \"old.module/path => ./local/path\"\n// \"old.module/path v1.0.0 => ./local/path\"\nfunc parseReplaceLine(line string) (ReplaceDirective, error) {\n\tparts := strings.Fields(line)\n\tarrowIndex := -1\n\tfor i, p := range parts {\n\t\tif p == \"=>\" {\n\t\t\tarrowIndex = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif arrowIndex == -1 || arrowIndex == 0 || arrowIndex == len(parts)-1 {\n\t\treturn ReplaceDirective{}, fmt.Errorf(\"malformed replace directive line: %q (missing or misplaced '=>')\", line)\n\t}\n\n\tvar dir ReplaceDirective\n\toldParts := parts[:arrowIndex]\n\tnewParts := parts[arrowIndex+1:]\n\n\tdir.OldPath = oldParts[0]\n\tif len(oldParts) > 1 {\n\t\tdir.OldVersion = oldParts[1]\n\t}\n\n\tnewPathOrModule := newParts[0]\n\tif strings.HasPrefix(newPathOrModule, \"./\") || strings.HasPrefix(newPathOrModule, \"../\") || filepath.IsAbs(newPathOrModule) {\n\t\tdir.IsLocal = true\n\t\tdir.NewPath = newPathOrModule\n\t\tif len(newParts) > 1 {\n\t\t\t// This case should ideally not happen for local paths as per go.mod spec,\n\t\t\t// but we'll capture it if present.\n\t\t\t// The go command itself might error on such go.mod.\n\t\t\treturn ReplaceDirective{}, fmt.Errorf(\"local replacement path %q should not have a version: %q\", dir.NewPath, line)\n\t\t}\n\t} else {\n\t\tdir.IsLocal = false\n\t\tdir.NewPath = newPathOrModule\n\t\tif len(newParts) > 1 {\n\t\t\tdir.NewVersion = newParts[1]\n\t\t} else {\n\t\t\t// If it's not local and no version is specified, it's an error according to go.mod replace spec\n\t\t\t// unless it's a wildcard replacement (oldpath => newpath vX.Y.Z),\n\t\t\t// but our parsing targets specific versions or local paths.\n\t\t\t// For \"oldmodule => newmodule\", a version is required for newmodule.\n\t\t\treturn ReplaceDirective{}, fmt.Errorf(\"non-local replacement path %q requires a version: %q\", dir.NewPath, line)\n\t\t}\n\t}\n\n\treturn dir, nil\n}\n\n// PathToImport converts an absolute directory path to its corresponding Go import path.\n// It considers the module's own path and any `replace` directives.\nfunc (l *Locator) PathToImport(absPath string) (string, error) {\n\tabsPath, err := filepath.Abs(absPath)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to get absolute path for %s: %w\", absPath, err)\n\t}\n\n\t// 1. Check if it's inside the main module root.\n\tif strings.HasPrefix(absPath, l.rootDir) {\n\t\trelPath, err := filepath.Rel(l.rootDir, absPath)\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"failed to get relative path for %s from root %s: %w\", absPath, l.rootDir, err)\n\t\t}\n\t\tif relPath == \".\" {\n\t\t\treturn l.modulePath, nil\n\t\t}\n\t\treturn filepath.ToSlash(filepath.Join(l.modulePath, relPath)), nil\n\t}\n\n\t// 2. Check if it's inside a replaced local directory.\n\tfor _, r := range l.replaces {\n\t\tif !r.IsLocal {\n\t\t\tcontinue\n\t\t}\n\t\tvar replacedDirAbs string\n\t\tif filepath.IsAbs(r.NewPath) {\n\t\t\treplacedDirAbs = r.NewPath\n\t\t} else {\n\t\t\treplacedDirAbs = filepath.Join(l.rootDir, r.NewPath)\n\t\t}\n\n\t\tif strings.HasPrefix(absPath, replacedDirAbs) {\n\t\t\trelPath, err := filepath.Rel(replacedDirAbs, absPath)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", fmt.Errorf(\"failed to get relative path for %s from replaced dir %s: %w\", absPath, replacedDirAbs, err)\n\t\t\t}\n\t\t\tif relPath == \".\" {\n\t\t\t\treturn r.OldPath, nil\n\t\t\t}\n\t\t\treturn filepath.ToSlash(filepath.Join(r.OldPath, relPath)), nil\n\t\t}\n\t}\n\n\treturn \"\", fmt.Errorf(\"could not determine import path for directory %s\", absPath)\n}\n\n// ResolvePkgPath converts a file path to a full Go package path.\n// If the path exists on the filesystem, it is treated as a file path and resolved.\n// If it does not exist, it's assumed to be a package path unless it has a relative\n// path prefix (like `./`), in which case it's an error.\nfunc ResolvePkgPath(ctx context.Context, path string) (string, error) {\n\tisFilePathLike := strings.HasPrefix(path, \".\") || filepath.IsAbs(path)\n\n\tinfo, err := os.Stat(path)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tif isFilePathLike {\n\t\t\t\t// It looks like a file path but doesn't exist. This is an error.\n\t\t\t\treturn \"\", fmt.Errorf(\"path %q does not exist: %w\", path, err)\n\t\t\t}\n\t\t\t// It doesn't look like a file path and doesn't exist. Assume it's a package path.\n\t\t\treturn path, nil\n\t\t}\n\t\t// Other stat error.\n\t\treturn \"\", fmt.Errorf(\"error checking path %q: %w\", path, err)\n\t}\n\n\t// Path exists, so it's a file/dir path.\n\tabsPath, err := filepath.Abs(path)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"could not get absolute path for %q: %w\", path, err)\n\t}\n\n\tsearchDir := absPath\n\tif !info.IsDir() {\n\t\tsearchDir = filepath.Dir(absPath)\n\t}\n\n\tmodRoot, err := findModuleRoot(searchDir)\n\tif err != nil {\n\t\t// Re-wrap the error for more context.\n\t\treturn \"\", fmt.Errorf(\"could not find go.mod for path %q: %w\", path, err)\n\t}\n\tgoModPath := filepath.Join(modRoot, \"go.mod\")\n\n\tmodBytes, err := os.ReadFile(goModPath)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"could not read go.mod at %s: %w\", goModPath, err)\n\t}\n\n\tmodulePath, err := getModulePathFromBytes(modBytes)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"could not parse module path from %s: %w\", goModPath, err)\n\t}\n\n\t// Use searchDir to get the relative path for the package, not the file.\n\trelPath, err := filepath.Rel(modRoot, searchDir)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"could not determine relative path of %s from %s: %w\", searchDir, modRoot, err)\n\t}\n\n\tpkgPath := filepath.ToSlash(relPath)\n\tif pkgPath == \".\" {\n\t\treturn modulePath, nil\n\t}\n\treturn modulePath + \"/\" + pkgPath, nil\n}\n"
time=2025-09-18T09:43:11.379Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.379Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.379Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.379Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/locator types=3
time=2025-09-18T09:43:11.379Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.379Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.379Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.379Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/locator
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/locator scanned=true
time=2025-09-18T09:43:11.380Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/minigo/stdlib/fmt
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/minigo/stdlib/fmt/install.go:3:1 source="// Code generated by minigo-gen-bindings. DO NOT EDIT.\n\npackage fmt\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"github.com/podhmo/go-scan/minigo\"\n)\n\n// Install binds all exported symbols from the \"fmt\" package to the interpreter.\nfunc Install(interp *minigo.Interpreter) {\n\tinterp.Register(\"fmt\", map[string]any{\n\t\t\"Append\":\tfmt.Append,\n\t\t\"Appendf\":\tfmt.Appendf,\n\t\t\"Appendln\":\tfmt.Appendln,\n\t\t\"Errorf\":\tfmt.Errorf,\n\t\t\"FormatString\":\tfmt.FormatString,\n\t\t\"Fprint\":\tfmt.Fprint,\n\t\t\"Fprintf\":\tfmt.Fprintf,\n\t\t\"Fprintln\":\tfmt.Fprintln,\n\t\t\"Fscan\":\tfmt.Fscan,\n\t\t\"Fscanf\":\tfmt.Fscanf,\n\t\t\"Fscanln\":\tfmt.Fscanln,\n\t\t\"Print\":\tfmt.Print,\n\t\t\"Printf\":\tfmt.Printf,\n\t\t\"Println\":\tfmt.Println,\n\t\t\"Scan\":\t\tfmt.Scan,\n\t\t\"Scanf\":\tfmt.Scanf,\n\t\t\"Scanln\":\tfmt.Scanln,\n\t\t\"Sprint\":\tfmt.Sprint,\n\t\t\"Sprintf\":\tfmt.Sprintf,\n\t\t\"Sprintln\":\tfmt.Sprintln,\n\t\t\"Sscan\":\tfmt.Sscan,\n\t\t\"Sscanf\":\tfmt.Sscanf,\n\t\t\"Sscanln\":\tfmt.Sscanln,\n\t\t\"Formatter\":\treflect.TypeOf((*fmt.Formatter)(nil)).Elem(),\n\t\t\"GoStringer\":\treflect.TypeOf((*fmt.GoStringer)(nil)).Elem(),\n\t\t\"ScanState\":\treflect.TypeOf((*fmt.ScanState)(nil)).Elem(),\n\t\t\"Scanner\":\treflect.TypeOf((*fmt.Scanner)(nil)).Elem(),\n\t\t\"State\":\treflect.TypeOf((*fmt.State)(nil)).Elem(),\n\t\t\"Stringer\":\treflect.TypeOf((*fmt.Stringer)(nil)).Elem(),\n\t})\n}\n"
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/fmt
time=2025-09-18T09:43:11.380Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/minigo/stdlib/fmt
time=2025-09-18T09:43:11.381Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/minigo/stdlib/fmt
time=2025-09-18T09:43:11.381Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/minigo/stdlib/fmt types=0
time=2025-09-18T09:43:11.381Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/fmt scanned=true
time=2025-09-18T09:43:11.381Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/minigo/stdlib/fmt
time=2025-09-18T09:43:11.381Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/fmt scanned=true
time=2025-09-18T09:43:11.381Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/fmt
time=2025-09-18T09:43:11.381Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/stdlib/fmt scanned=true
time=2025-09-18T09:43:11.381Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/fmt scanned=true
time=2025-09-18T09:43:11.381Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.385Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/examples/docgen/patterns/patterns.go:2:1 source="// Package patterns defines the extensible call patterns for the docgen tool.\npackage patterns\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/podhmo/go-scan/examples/docgen/openapi\"\n\t\"github.com/podhmo/go-scan/scanner\"\n\t\"github.com/podhmo/go-scan/symgo\"\n)\n\n// Analyzer is a subset of the docgen.Analyzer interface needed by patterns.\n// This avoids a circular dependency.\ntype Analyzer interface {\n\tOperationStack() []*openapi.Operation\n\tGetOpenAPI() *openapi.OpenAPI\n}\n\n// PatternType defines the type of analysis to perform for a custom pattern.\ntype PatternType string\n\nconst (\n\t// RequestBody indicates the pattern should analyze a function argument as a request body.\n\tRequestBody\tPatternType\t= \"requestBody\"\n\t// ResponseBody indicates the pattern should analyze a function argument as a response body.\n\tResponseBody\tPatternType\t= \"responseBody\"\n\t// CustomResponse indicates the pattern should analyze a function argument as a response body with a specific status code.\n\tCustomResponse\tPatternType\t= \"customResponse\"\n\t// DefaultResponse indicates the pattern should analyze a function argument as a default response body (without a status code).\n\tDefaultResponse\tPatternType\t= \"defaultResponse\"\n\t// PathParameter indicates the pattern should extract a path parameter.\n\tPathParameter\tPatternType\t= \"path\"\n\t// QueryParameter indicates the pattern should extract a query parameter.\n\tQueryParameter\tPatternType\t= \"query\"\n\t// HeaderParameter indicates the pattern should extract a header parameter.\n\tHeaderParameter\tPatternType\t= \"header\"\n)\n\n// PatternConfig defines a user-configurable pattern for docgen analysis.\n// It maps a function call to a specific analysis type.\ntype PatternConfig struct {\n\tName\tstring\n\t// Description is a longer explanation of what the pattern does.\n\tDescription\tstring\n\n\t// Key is the fully-qualified function or method name to match.\n\t// This is used if `Fn` is not provided.\n\t// e.g., \"github.com/my-org/my-app/utils.DecodeJSON\"\n\t// e.g., \"(*net/http.Request).Context\"\n\tKey\tstring\n\n\t// Fn provides a type-safe way to specify the target function.\n\t// If `Fn` is provided, `Key` is ignored.\n\tFn\tany\t// e.g., mypkg.MyFunc\n\n\t// Type specifies the kind of analysis to perform.\n\tType\tPatternType\n\n\t// ArgIndex is the 0-based index of the function argument to analyze.\n\t// For \"requestBody\", this is the argument that will be decoded into.\n\t// For \"responseBody\", this is the argument that will be encoded from.\n\t// For \"path\" or \"query\", this is the argument holding the parameter's value.\n\tArgIndex\tint\n\n\t// StatusCode is the HTTP status code for the response.\n\t// Required for \"customResponse\" type.\n\t// e.g., \"400\", \"500\"\n\tStatusCode\tstring\n\n\t// NameArgIndex is the 0-based index of the argument containing the parameter's name.\n\t// Used for parameter patterns (`path`, `query`, `header`).\n\tNameArgIndex\tint\n}\n\n// Pattern defines a mapping between a function call signature (the key)\n// and a handler function that performs analysis when that call is found.\ntype Pattern struct {\n\tKey\tstring\n\tApply\tfunc(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object\n}\n\n// HandleCustomRequestBody returns a pattern handler that treats a specific argument\n// as a request body, similar to `json.Decode`.\nfunc HandleCustomRequestBody(argIndex int) func(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\treturn func(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\t\top := a.OperationStack()[len(a.OperationStack())-1]\n\t\tif len(args) <= argIndex {\n\t\t\treturn &symgo.SymbolicPlaceholder{Reason: fmt.Sprintf(\"custom requestBody pattern: not enough args (want %d, got %d)\", argIndex+1, len(args))}\n\t\t}\n\n\t\tptr, ok := args[argIndex].(*symgo.Pointer)\n\t\tif !ok {\n\t\t\treturn &symgo.SymbolicPlaceholder{Reason: fmt.Sprintf(\"custom requestBody pattern: argument %d is not a pointer\", argIndex)}\n\t\t}\n\n\t\ttypeInfo := ptr.TypeInfo()\n\t\tif typeInfo != nil {\n\t\t\tschema := BuildSchemaForType(ctx, a, typeInfo, make(map[string]*openapi.Schema))\n\t\t\tif schema != nil {\n\t\t\t\top.RequestBody = &openapi.RequestBody{\n\t\t\t\t\tContent:\tmap[string]openapi.MediaType{\"application/json\": {Schema: schema}},\n\t\t\t\t\tRequired:\ttrue,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// The return value of the custom function is not known, so we return a placeholder.\n\t\treturn &symgo.SymbolicPlaceholder{Reason: \"result of custom request body function\"}\n\t}\n}\n\n// HandleCustomResponse returns a pattern handler that treats a specific argument\n// as a response body for a given status code.\nfunc HandleCustomResponse(statusCode string, argIndex int) func(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\treturn func(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\t\top := a.OperationStack()[len(a.OperationStack())-1]\n\t\tif len(args) <= argIndex {\n\t\t\treturn &symgo.SymbolicPlaceholder{Reason: fmt.Sprintf(\"custom response pattern: not enough args (want %d, got %d)\", argIndex+1, len(args))}\n\t\t}\n\n\t\targ := args[argIndex]\n\t\tvar schema *openapi.Schema\n\n\t\tif slice, ok := arg.(*symgo.Slice); ok {\n\t\t\tschema = buildSchemaFromFieldType(ctx, a, slice.SliceFieldType, make(map[string]*openapi.Schema))\n\t\t} else {\n\t\t\ttypeInfo := arg.TypeInfo()\n\t\t\tif typeInfo != nil {\n\t\t\t\tschema = BuildSchemaForType(ctx, a, typeInfo, make(map[string]*openapi.Schema))\n\t\t\t}\n\t\t}\n\n\t\tif schema != nil {\n\t\t\tif op.Responses == nil {\n\t\t\t\top.Responses = make(map[string]*openapi.Response)\n\t\t\t}\n\t\t\top.Responses[statusCode] = &openapi.Response{\n\t\t\t\tDescription:\tfmt.Sprintf(\"Response for status code %s\", statusCode),\n\t\t\t\tContent:\tmap[string]openapi.MediaType{\"application/json\": {Schema: schema}},\n\t\t\t}\n\t\t}\n\t\treturn &symgo.SymbolicPlaceholder{Reason: \"result of custom response function\"}\n\t}\n}\n\n// HandleDefaultResponse returns a pattern handler that treats a specific argument\n// as a default response body.\nfunc HandleDefaultResponse(argIndex int) func(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\treturn func(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\t\top := a.OperationStack()[len(a.OperationStack())-1]\n\t\tif len(args) <= argIndex {\n\t\t\treturn &symgo.SymbolicPlaceholder{Reason: fmt.Sprintf(\"default response pattern: not enough args (want %d, got %d)\", argIndex+1, len(args))}\n\t\t}\n\n\t\targ := args[argIndex]\n\t\tvar schema *openapi.Schema\n\n\t\tif slice, ok := arg.(*symgo.Slice); ok {\n\t\t\tschema = buildSchemaFromFieldType(ctx, a, slice.SliceFieldType, make(map[string]*openapi.Schema))\n\t\t} else {\n\t\t\ttypeInfo := arg.TypeInfo()\n\t\t\tif typeInfo != nil {\n\t\t\t\tschema = BuildSchemaForType(ctx, a, typeInfo, make(map[string]*openapi.Schema))\n\t\t\t}\n\t\t}\n\n\t\tif schema != nil {\n\t\t\tif op.Responses == nil {\n\t\t\t\top.Responses = make(map[string]*openapi.Response)\n\t\t\t}\n\t\t\top.Responses[\"default\"] = &openapi.Response{\n\t\t\t\tDescription:\t\"Default error response\",\n\t\t\t\tContent:\tmap[string]openapi.MediaType{\"application/json\": {Schema: schema}},\n\t\t\t}\n\t\t}\n\t\treturn &symgo.SymbolicPlaceholder{Reason: \"result of default response function\"}\n\t}\n}\n\n// HandleCustomResponseBody returns a pattern handler that treats a specific argument\n// as a response body, similar to `json.Encode`.\nfunc HandleCustomResponseBody(argIndex int) func(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\treturn func(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\t\top := a.OperationStack()[len(a.OperationStack())-1]\n\t\tif len(args) <= argIndex {\n\t\t\treturn &symgo.SymbolicPlaceholder{Reason: fmt.Sprintf(\"custom responseBody pattern: not enough args (want %d, got %d)\", argIndex+1, len(args))}\n\t\t}\n\n\t\targ := args[argIndex]\n\t\tvar schema *openapi.Schema\n\n\t\tif slice, ok := arg.(*symgo.Slice); ok {\n\t\t\tschema = buildSchemaFromFieldType(ctx, a, slice.SliceFieldType, make(map[string]*openapi.Schema))\n\t\t} else {\n\t\t\ttypeInfo := arg.TypeInfo()\n\t\t\tif typeInfo != nil {\n\t\t\t\tschema = BuildSchemaForType(ctx, a, typeInfo, make(map[string]*openapi.Schema))\n\t\t\t}\n\t\t}\n\n\t\tif schema != nil {\n\t\t\tif op.Responses == nil {\n\t\t\t\top.Responses = make(map[string]*openapi.Response)\n\t\t\t}\n\t\t\t// Assume 200 OK if no status code has been set.\n\t\t\tif _, ok := op.Responses[\"200\"]; !ok {\n\t\t\t\top.Responses[\"200\"] = &openapi.Response{Description: \"OK\"}\n\t\t\t}\n\t\t\top.Responses[\"200\"].Content = map[string]openapi.MediaType{\"application/json\": {Schema: schema}}\n\t\t}\n\n\t\t// The return value of the custom function is not known, so we return a placeholder.\n\t\treturn &symgo.SymbolicPlaceholder{Reason: \"result of custom response body function\"}\n\t}\n}\n\n// HandleCustomParameter returns a pattern handler that extracts a parameter (path or query)\n// from a function argument. The parameter's name is extracted dynamically from an argument.\nfunc HandleCustomParameter(in, description string, nameArgIndex, valueArgIndex int) func(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\treturn func(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\t\top := a.OperationStack()[len(a.OperationStack())-1]\n\t\tif len(args) <= nameArgIndex {\n\t\t\treturn &symgo.SymbolicPlaceholder{Reason: fmt.Sprintf(\"custom %s parameter pattern: not enough args for name (want %d, got %d)\", in, nameArgIndex+1, len(args))}\n\t\t}\n\t\tif len(args) <= valueArgIndex {\n\t\t\treturn &symgo.SymbolicPlaceholder{Reason: fmt.Sprintf(\"custom %s parameter pattern: not enough args for value (want %d, got %d)\", in, valueArgIndex+1, len(args))}\n\t\t}\n\n\t\t// Extract the parameter name from the specified argument.\n\t\tnameObj, ok := args[nameArgIndex].(*symgo.String)\n\t\tif !ok {\n\t\t\t// If the name is not a string literal, we can't determine it statically.\n\t\t\treturn &symgo.SymbolicPlaceholder{Reason: fmt.Sprintf(\"custom %s parameter pattern: name argument at index %d is not a string literal\", in, nameArgIndex)}\n\t\t}\n\t\tparamName := nameObj.Value\n\n\t\t// Extract the schema from the value argument's type.\n\t\targ := args[valueArgIndex]\n\t\tvar schema *openapi.Schema\n\t\ttypeInfo := arg.TypeInfo()\n\t\tif typeInfo != nil && typeInfo.Underlying != nil {\n\t\t\tschema = buildSchemaFromFieldType(ctx, a, typeInfo.Underlying, make(map[string]*openapi.Schema))\n\t\t}\n\t\tif schema == nil {\n\t\t\tschema = &openapi.Schema{Type: \"string\"}\n\t\t}\n\n\t\tparam := &openapi.Parameter{\n\t\t\tName:\t\tparamName,\n\t\t\tIn:\t\tin,\n\t\t\tDescription:\tdescription,\n\t\t\tSchema:\t\tschema,\n\t\t}\n\t\tif in == \"path\" {\n\t\t\tparam.Required = true\n\t\t}\n\n\t\top.Parameters = append(op.Parameters, param)\n\n\t\t// The return value of the custom function is not known, so we return a placeholder.\n\t\treturn &symgo.SymbolicPlaceholder{Reason: fmt.Sprintf(\"result of custom %s parameter function\", in)}\n\t}\n}\n\n// GetDefaultPatterns returns a slice of all the default call patterns\n// used for analyzing standard net/http handlers.\nfunc GetDefaultPatterns() []Pattern {\n\treturn []Pattern{\n\t\t// net/http related\n\t\t{Key: \"(net/http.ResponseWriter).Header\", Apply: handleHeader},\n\t\t{Key: \"(net/http.ResponseWriter).Write\", Apply: handleResponseWriterWrite},\n\t\t{Key: \"(net/http.ResponseWriter).WriteHeader\", Apply: handleWriteHeader},\n\t\t{Key: \"(net/http.Header).Set\", Apply: handleHeaderSet},\n\n\t\t// httptest.ResponseRecorder, for when ResponseWriter is bound to it.\n\t\t{Key: \"(*net/http/httptest.ResponseRecorder).Header\", Apply: handleHeader},\n\t\t{Key: \"(*net/http/httptest.ResponseRecorder).Write\", Apply: handleResponseWriterWrite},\n\t\t{Key: \"(*net/http/httptest.ResponseRecorder).WriteHeader\", Apply: handleWriteHeader},\n\n\t\t// net/url related\n\t\t{Key: \"(*net/url.URL).Query\", Apply: handleURLQuery},\n\t\t{Key: \"(net/url.Values).Get\", Apply: handleValuesGet},\n\n\t\t// encoding/json related\n\t\t{Key: \"encoding/json.NewDecoder\", Apply: handleNewDecoder},\n\t\t{Key: \"(*encoding/json.Decoder).Decode\", Apply: handleDecode},\n\t\t{Key: \"encoding/json.NewEncoder\", Apply: handleNewEncoder},\n\t\t{Key: \"(*encoding/json.Encoder).Encode\", Apply: handleEncode},\n\t}\n}\n\n// -----------------------------------------------------------------------------\n// Pattern Handler Implementations\n// -----------------------------------------------------------------------------\n\nfunc handleResponseWriterWrite(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\top := a.OperationStack()[len(a.OperationStack())-1]\n\n\t// Find the response object, assuming WriteHeader was called first.\n\tvar resp *openapi.Response\n\tvar statusCode string\n\tif op.Responses != nil {\n\t\tfor code, r := range op.Responses {\n\t\t\tstatusCode = code\n\t\t\tresp = r\n\t\t\tbreak\t// Assume first status code found is the one we want to add content to.\n\t\t}\n\t}\n\n\t// If no response entry exists (e.g., WriteHeader wasn't called or detected), default to 200.\n\tif resp == nil {\n\t\tif op.Responses == nil {\n\t\t\top.Responses = make(map[string]*openapi.Response)\n\t\t}\n\t\tstatusCode = \"200\"\n\t\top.Responses[statusCode] = &openapi.Response{Description: \"OK\"}\n\t\tresp = op.Responses[statusCode]\n\t}\n\n\tif resp.Content == nil {\n\t\tresp.Content = make(map[string]openapi.MediaType)\n\t}\n\n\t// For a raw Write, we assume text/plain content.\n\t// A more sophisticated analysis could check for a prior `Header.Set(\"Content-Type\", ...)` call.\n\tresp.Content[\"text/plain\"] = openapi.MediaType{\n\t\tSchema: &openapi.Schema{Type: \"string\"},\n\t}\n\n\t// w.Write returns (int, error)\n\treturn &symgo.MultiReturn{\n\t\tValues: []symgo.Object{\n\t\t\t&symgo.SymbolicPlaceholder{Reason: \"return value from Write (int)\"},\n\t\t\t&symgo.Nil{},\n\t\t},\n\t}\n}\n\nfunc handleHeader(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\treturn NewSymbolicInstance(interp, \"net/http.Header\")\n}\n\nfunc handleWriteHeader(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\top := a.OperationStack()[len(a.OperationStack())-1]\n\tif len(args) != 2 {\n\t\treturn nil\n\t}\n\t// args[1] is the status code. It could be a constant like http.StatusOK\n\t// or an integer literal. For now, we'll just hardcode 200 for the test.\n\t// A more advanced implementation would resolve the constant value.\n\tstatusCode := \"200\"\t// Hardcoded for simplicity\n\tif op.Responses == nil {\n\t\top.Responses = make(map[string]*openapi.Response)\n\t}\n\tif _, exists := op.Responses[statusCode]; !exists {\n\t\top.Responses[statusCode] = &openapi.Response{Description: \"OK\"}\n\t}\n\treturn nil\n}\n\nfunc handleHeaderSet(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\treturn nil\t// We don't need to track header values for now.\n}\n\nfunc handleURLQuery(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\treturn NewSymbolicInstance(interp, \"net/url.Values\")\n}\n\nfunc handleValuesGet(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\top := a.OperationStack()[len(a.OperationStack())-1]\n\tif len(args) != 2 {\n\t\treturn &symgo.SymbolicPlaceholder{Reason: \"invalid Get call\"}\n\t}\n\tparamNameObj, ok := args[1].(*symgo.String)\n\tif !ok {\n\t\treturn &symgo.SymbolicPlaceholder{Reason: \"parameter name is not a string literal\"}\n\t}\n\tparamName := paramNameObj.Value\n\top.Parameters = append(op.Parameters, &openapi.Parameter{\n\t\tName:\tparamName,\n\t\tIn:\t\"query\",\n\t\tSchema: &openapi.Schema{\n\t\t\tType: \"string\",\t// Default to string, could be enhanced later.\n\t\t},\n\t})\n\treturn &symgo.String{Value: \"\"}\t// The actual value doesn't matter for analysis.\n}\n\nfunc handleNewDecoder(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\treturn NewSymbolicInstance(interp, \"encoding/json.Decoder\")\n}\n\nfunc handleDecode(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\top := a.OperationStack()[len(a.OperationStack())-1]\n\tif len(args) != 2 {\n\t\treturn &symgo.SymbolicPlaceholder{Reason: \"decode error: wrong arg count\"}\n\t}\n\tptr, ok := args[1].(*symgo.Pointer)\n\tif !ok {\n\t\treturn &symgo.SymbolicPlaceholder{Reason: \"decode error: second arg is not a pointer\"}\n\t}\n\ttypeInfo := ptr.TypeInfo()\n\tif typeInfo != nil {\n\t\tschema := BuildSchemaForType(ctx, a, typeInfo, make(map[string]*openapi.Schema))\n\t\tif schema != nil {\n\t\t\top.RequestBody = &openapi.RequestBody{\n\t\t\t\tContent:\tmap[string]openapi.MediaType{\"application/json\": {Schema: schema}},\n\t\t\t\tRequired:\ttrue,\n\t\t\t}\n\t\t}\n\t}\n\treturn &symgo.SymbolicPlaceholder{Reason: \"result of json.Decode\"}\n}\n\nfunc handleNewEncoder(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\treturn NewSymbolicInstance(interp, \"encoding/json.Encoder\")\n}\n\nfunc handleEncode(ctx context.Context, interp *symgo.Interpreter, a Analyzer, args []symgo.Object) symgo.Object {\n\top := a.OperationStack()[len(a.OperationStack())-1]\n\tif len(args) != 2 {\n\t\treturn &symgo.SymbolicPlaceholder{Reason: \"encode error: wrong arg count\"}\n\t}\n\targ := args[1]\n\tvar schema *openapi.Schema\n\n\tif slice, ok := arg.(*symgo.Slice); ok {\n\t\tschema = buildSchemaFromFieldType(ctx, a, slice.SliceFieldType, make(map[string]*openapi.Schema))\n\t} else {\n\t\ttypeInfo := arg.TypeInfo()\n\t\tif typeInfo != nil {\n\t\t\tschema = BuildSchemaForType(ctx, a, typeInfo, make(map[string]*openapi.Schema))\n\t\t}\n\t}\n\n\tif schema != nil {\n\t\tif op.Responses == nil {\n\t\t\top.Responses = make(map[string]*openapi.Response)\n\t\t}\n\t\top.Responses[\"200\"] = &openapi.Response{\n\t\t\tDescription:\t\"OK\",\n\t\t\tContent:\tmap[string]openapi.MediaType{\"application/json\": {Schema: schema}},\n\t\t}\n\t}\n\n\treturn &symgo.SymbolicPlaceholder{Reason: \"result of json.Encode\"}\n}\n\n// -----------------------------------------------------------------------------\n// Helper function for creating symbolic instances\n// -----------------------------------------------------------------------------\n\n// NewSymbolicInstance is a helper to create a symgo.Instance with its type information resolved.\nfunc NewSymbolicInstance(interp *symgo.Interpreter, fqtn string) symgo.Object {\n\tlastDot := strings.LastIndex(fqtn, \".\")\n\tif lastDot == -1 {\n\t\treturn &symgo.Error{Message: fmt.Sprintf(\"invalid fully-qualified type name: %s\", fqtn)}\n\t}\n\tpkgPath := fqtn[:lastDot]\n\ttypeName := fqtn[lastDot+1:]\n\n\tpkg, err := interp.Scanner().ScanPackageByImport(context.Background(), pkgPath)\n\tif err != nil {\n\t\treturn &symgo.Error{Message: fmt.Sprintf(\"could not load package %s: %v\", pkgPath, err)}\n\t}\n\n\tvar resolvedType *scanner.TypeInfo\n\tfor _, t := range pkg.Types {\n\t\tif t.Name == typeName {\n\t\t\tresolvedType = t\n\t\t\tbreak\n\t\t}\n\t}\n\tif resolvedType == nil {\n\t\treturn &symgo.Error{Message: fmt.Sprintf(\"could not find type %s in package %s\", typeName, pkgPath)}\n\t}\n\n\treturn &symgo.Instance{\n\t\tTypeName:\tfqtn,\n\t\tBaseObject:\tsymgo.BaseObject{ResolvedTypeInfo: resolvedType},\n\t}\n}\n\n// -----------------------------------------------------------------------------\n// Schema Building Logic (moved from schema.go)\n// -----------------------------------------------------------------------------\n\n// BuildSchemaForType generates an OpenAPI schema for a given Go type.\n// If the type is a struct, it ensures the full schema is defined in the\n// components section and returns a $ref schema.\nfunc BuildSchemaForType(ctx context.Context, a Analyzer, typeInfo *scanner.TypeInfo, cache map[string]*openapi.Schema) *openapi.Schema {\n\tif typeInfo == nil {\n\t\treturn &openapi.Schema{Type: \"object\", Description: \"unknown type\"}\n\t}\n\tif typeInfo.Underlying != nil {\n\t\treturn buildSchemaFromFieldType(ctx, a, typeInfo.Underlying, cache)\n\t}\n\tif typeInfo.Kind != scanner.StructKind || typeInfo.Struct == nil {\n\t\t// Not a struct, or not a struct we can analyze.\n\t\t// Fallback to building the schema directly without creating a component.\n\t\treturn buildSchemaFromFieldType(ctx, a, &scanner.FieldType{Definition: typeInfo}, cache)\n\t}\n\n\t// It's a struct. We will register it as a component.\n\tdoc := a.GetOpenAPI()\n\tif doc.Components == nil {\n\t\tdoc.Components = &openapi.Components{}\n\t}\n\tif doc.Components.Schemas == nil {\n\t\tdoc.Components.Schemas = make(map[string]*openapi.Schema)\n\t}\n\n\t// Generate a unique name for the schema component.\n\t// e.g., \"github.com/podhmo/go-scan/examples/docgen/sampleapi.User\" -> \"docgen_sampleapi_User\"\n\t// This is a simplification; a robust implementation would handle non-alphanumeric characters better.\n\tpkgPathForName := strings.ReplaceAll(typeInfo.PkgPath, \"/\", \"_\")\n\tpkgPathForName = strings.ReplaceAll(pkgPathForName, \".\", \"_\")\n\t// take the last 2 parts of the package path\n\tparts := strings.Split(pkgPathForName, \"_\")\n\tif len(parts) > 2 {\n\t\tpkgPathForName = strings.Join(parts[len(parts)-2:], \"_\")\n\t}\n\tschemaName := fmt.Sprintf(\"%s_%s\", pkgPathForName, typeInfo.Name)\n\n\t// If the schema is already being defined (recursion), return a ref.\n\tif _, inProgress := cache[schemaName]; inProgress {\n\t\treturn &openapi.Schema{Ref: \"#/components/schemas/\" + schemaName}\n\t}\n\t// If the schema is already fully defined, return a ref.\n\tif _, exists := doc.Components.Schemas[schemaName]; exists {\n\t\treturn &openapi.Schema{Ref: \"#/components/schemas/\" + schemaName}\n\t}\n\n\t// Mark this schema as \"in progress\" to handle recursion.\n\tcache[schemaName] = nil\n\n\t// Build the full schema.\n\tschema := &openapi.Schema{\n\t\tType:\t\t\"object\",\n\t\tProperties:\tmake(map[string]*openapi.Schema),\n\t}\n\n\tfor _, field := range typeInfo.Struct.Fields {\n\t\tif !field.IsExported {\n\t\t\tcontinue\t// Skip unexported fields\n\t\t}\n\t\tjsonName := field.TagValue(\"json\")\n\t\tif jsonName == \"-\" {\n\t\t\tcontinue\n\t\t}\n\t\tif jsonName == \"\" {\n\t\t\tjsonName = field.Name\n\t\t}\n\t\tschema.Properties[jsonName] = buildSchemaFromFieldType(ctx, a, field.Type, cache)\n\t}\n\n\t// Add the complete schema to the components and remove from progress cache.\n\tdoc.Components.Schemas[schemaName] = schema\n\tdelete(cache, schemaName)\n\n\t// Return a reference to the newly created component.\n\treturn &openapi.Schema{Ref: \"#/components/schemas/\" + schemaName}\n}\n\nfunc buildSchemaFromFieldType(ctx context.Context, a Analyzer, ft *scanner.FieldType, cache map[string]*openapi.Schema) *openapi.Schema {\n\tif ft == nil {\n\t\treturn nil\n\t}\n\tif ft.IsMap {\n\t\t// In OpenAPI 3.0, map keys must be strings. A more robust implementation\n\t\t// might check ft.MapKey to ensure it's a string type.\n\t\treturn &openapi.Schema{\n\t\t\tType:\t\t\t\"object\",\n\t\t\tAdditionalProperties:\tbuildSchemaFromFieldType(ctx, a, ft.Elem, cache),\n\t\t}\n\t}\n\tif ft.IsSlice {\n\t\treturn &openapi.Schema{Type: \"array\", Items: buildSchemaFromFieldType(ctx, a, ft.Elem, cache)}\n\t}\n\tif ft.IsPointer {\n\t\treturn buildSchemaFromFieldType(ctx, a, ft.Elem, cache)\n\t}\n\tif ft.IsBuiltin {\n\t\treturn buildSchemaFromBasic(ft.Name)\n\t}\n\ttypeInfo, err := ft.Resolve(ctx)\n\tif err != nil {\n\t\tfmt.Printf(\"warn: could not resolve type %q: %v\\n\", ft.Name, err)\n\t\treturn &openapi.Schema{Type: \"object\", Description: \"unresolved type\"}\n\t}\n\treturn BuildSchemaForType(ctx, a, typeInfo, cache)\n}\n\nfunc buildSchemaFromBasic(typeName string) *openapi.Schema {\n\tswitch typeName {\n\tcase \"string\":\n\t\treturn &openapi.Schema{Type: \"string\"}\n\tcase \"int\", \"int8\", \"int16\", \"int32\":\n\t\treturn &openapi.Schema{Type: \"integer\", Format: \"int32\"}\n\tcase \"int64\":\n\t\treturn &openapi.Schema{Type: \"integer\", Format: \"int64\"}\n\tcase \"uint\", \"uint8\", \"uint16\", \"uint32\", \"uint64\", \"uintptr\":\n\t\treturn &openapi.Schema{Type: \"integer\", Format: \"int64\"}\t// Unsigned ints are usually represented as integers.\n\tcase \"bool\":\n\t\treturn &openapi.Schema{Type: \"boolean\"}\n\tcase \"float32\":\n\t\treturn &openapi.Schema{Type: \"number\", Format: \"float\"}\n\tcase \"float64\":\n\t\treturn &openapi.Schema{Type: \"number\", Format: \"double\"}\n\tdefault:\n\t\treturn &openapi.Schema{Type: \"string\", Description: fmt.Sprintf(\"unsupported basic type: %s\", typeName)}\n\t}\n}\n"
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/examples/docgen/patterns types=4
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.386Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.387Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.387Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.387Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.387Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.387Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.387Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.387Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.387Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.387Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen/patterns
time=2025-09-18T09:43:11.387Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.387Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen/patterns scanned=true
time=2025-09-18T09:43:11.387Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/minigo/stdlib/time
time=2025-09-18T09:43:11.388Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/minigo/stdlib/time/install.go:3:1 source="// Code generated by minigo-gen-bindings. DO NOT EDIT.\n\npackage time\n\nimport (\n\t\"reflect\"\n\t\"time\"\n\n\t\"github.com/podhmo/go-scan/minigo\"\n)\n\n// Install binds all exported symbols from the \"time\" package to the interpreter.\nfunc Install(interp *minigo.Interpreter) {\n\tinterp.Register(\"time\", map[string]any{\n\t\t\"ANSIC\":\t\t\ttime.ANSIC,\n\t\t\"After\":\t\t\ttime.After,\n\t\t\"AfterFunc\":\t\t\ttime.AfterFunc,\n\t\t\"April\":\t\t\ttime.April,\n\t\t\"August\":\t\t\ttime.August,\n\t\t\"Date\":\t\t\t\ttime.Date,\n\t\t\"DateOnly\":\t\t\ttime.DateOnly,\n\t\t\"DateTime\":\t\t\ttime.DateTime,\n\t\t\"December\":\t\t\ttime.December,\n\t\t\"February\":\t\t\ttime.February,\n\t\t\"FixedZone\":\t\t\ttime.FixedZone,\n\t\t\"Friday\":\t\t\ttime.Friday,\n\t\t\"Hour\":\t\t\t\ttime.Hour,\n\t\t\"January\":\t\t\ttime.January,\n\t\t\"July\":\t\t\t\ttime.July,\n\t\t\"June\":\t\t\t\ttime.June,\n\t\t\"Kitchen\":\t\t\ttime.Kitchen,\n\t\t\"Layout\":\t\t\ttime.Layout,\n\t\t\"LoadLocation\":\t\t\ttime.LoadLocation,\n\t\t\"LoadLocationFromTZData\":\ttime.LoadLocationFromTZData,\n\t\t\"Local\":\t\t\ttime.Local,\n\t\t\"March\":\t\t\ttime.March,\n\t\t\"May\":\t\t\t\ttime.May,\n\t\t\"Microsecond\":\t\t\ttime.Microsecond,\n\t\t\"Millisecond\":\t\t\ttime.Millisecond,\n\t\t\"Minute\":\t\t\ttime.Minute,\n\t\t\"Monday\":\t\t\ttime.Monday,\n\t\t\"Nanosecond\":\t\t\ttime.Nanosecond,\n\t\t\"NewTicker\":\t\t\ttime.NewTicker,\n\t\t\"NewTimer\":\t\t\ttime.NewTimer,\n\t\t\"November\":\t\t\ttime.November,\n\t\t\"Now\":\t\t\t\ttime.Now,\n\t\t\"October\":\t\t\ttime.October,\n\t\t\"Parse\":\t\t\ttime.Parse,\n\t\t\"ParseDuration\":\t\ttime.ParseDuration,\n\t\t\"ParseInLocation\":\t\ttime.ParseInLocation,\n\t\t\"RFC1123\":\t\t\ttime.RFC1123,\n\t\t\"RFC1123Z\":\t\t\ttime.RFC1123Z,\n\t\t\"RFC3339\":\t\t\ttime.RFC3339,\n\t\t\"RFC3339Nano\":\t\t\ttime.RFC3339Nano,\n\t\t\"RFC822\":\t\t\ttime.RFC822,\n\t\t\"RFC822Z\":\t\t\ttime.RFC822Z,\n\t\t\"RFC850\":\t\t\ttime.RFC850,\n\t\t\"RubyDate\":\t\t\ttime.RubyDate,\n\t\t\"Saturday\":\t\t\ttime.Saturday,\n\t\t\"Second\":\t\t\ttime.Second,\n\t\t\"September\":\t\t\ttime.September,\n\t\t\"Since\":\t\t\ttime.Since,\n\t\t\"Sleep\":\t\t\ttime.Sleep,\n\t\t\"Stamp\":\t\t\ttime.Stamp,\n\t\t\"StampMicro\":\t\t\ttime.StampMicro,\n\t\t\"StampMilli\":\t\t\ttime.StampMilli,\n\t\t\"StampNano\":\t\t\ttime.StampNano,\n\t\t\"Sunday\":\t\t\ttime.Sunday,\n\t\t\"Thursday\":\t\t\ttime.Thursday,\n\t\t\"Tick\":\t\t\t\ttime.Tick,\n\t\t\"TimeOnly\":\t\t\ttime.TimeOnly,\n\t\t\"Tuesday\":\t\t\ttime.Tuesday,\n\t\t\"UTC\":\t\t\t\ttime.UTC,\n\t\t\"Unix\":\t\t\t\ttime.Unix,\n\t\t\"UnixDate\":\t\t\ttime.UnixDate,\n\t\t\"UnixMicro\":\t\t\ttime.UnixMicro,\n\t\t\"UnixMilli\":\t\t\ttime.UnixMilli,\n\t\t\"Until\":\t\t\ttime.Until,\n\t\t\"Wednesday\":\t\t\ttime.Wednesday,\n\t\t\"Duration\":\t\t\treflect.TypeOf((*time.Duration)(nil)).Elem(),\n\t\t\"Location\":\t\t\treflect.TypeOf((*time.Location)(nil)).Elem(),\n\t\t\"Month\":\t\t\treflect.TypeOf((*time.Month)(nil)).Elem(),\n\t\t\"ParseError\":\t\t\treflect.TypeOf((*time.ParseError)(nil)).Elem(),\n\t\t\"Ticker\":\t\t\treflect.TypeOf((*time.Ticker)(nil)).Elem(),\n\t\t\"Time\":\t\t\t\treflect.TypeOf((*time.Time)(nil)).Elem(),\n\t\t\"Timer\":\t\t\treflect.TypeOf((*time.Timer)(nil)).Elem(),\n\t\t\"Weekday\":\t\t\treflect.TypeOf((*time.Weekday)(nil)).Elem(),\n\t})\n}\n"
time=2025-09-18T09:43:11.388Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/time
time=2025-09-18T09:43:11.388Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/minigo/stdlib/time
time=2025-09-18T09:43:11.388Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/minigo/stdlib/time
time=2025-09-18T09:43:11.388Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/minigo/stdlib/time types=0
time=2025-09-18T09:43:11.388Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/time scanned=true
time=2025-09-18T09:43:11.388Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/minigo/stdlib/time
time=2025-09-18T09:43:11.388Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/time scanned=true
time=2025-09-18T09:43:11.388Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/time
time=2025-09-18T09:43:11.388Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/stdlib/time scanned=true
time=2025-09-18T09:43:11.388Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/time scanned=true
time=2025-09-18T09:43:11.388Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/examples/derivingjson
time=2025-09-18T09:43:11.389Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/examples/derivingjson/main.go:1:1 source="package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"go/format\"\n\t\"log/slog\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\tgoscan \"github.com/podhmo/go-scan\"\n\t\"github.com/podhmo/go-scan/examples/derivingjson/gen\"\n\t\"github.com/podhmo/go-scan/scanner\"\n)\n\n// logLevelVar is a custom flag.Value implementation for slog.LevelVar\ntype logLevelVar struct {\n\tlevelVar *slog.LevelVar\n}\n\nfunc (v *logLevelVar) String() string {\n\tif v.levelVar == nil {\n\t\treturn \"\"\n\t}\n\treturn v.levelVar.Level().String()\n}\n\nfunc (v *logLevelVar) Set(s string) error {\n\tvar level slog.Level\n\tswitch strings.ToLower(s) {\n\tcase \"debug\":\n\t\tlevel = slog.LevelDebug\n\tcase \"info\":\n\t\tlevel = slog.LevelInfo\n\tcase \"warn\":\n\t\tlevel = slog.LevelWarn\n\tcase \"error\":\n\t\tlevel = slog.LevelError\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown log level: %s\", s)\n\t}\n\tv.levelVar.Set(level)\n\treturn nil\n}\n\nfunc main() {\n\tvar (\n\t\tcwd\t\tstring\n\t\tdryRun\t\tbool\n\t\tinspect\t\tbool\n\t\tlogLevel\t= new(slog.LevelVar)\n\t)\n\n\tflag.StringVar(&cwd, \"cwd\", \".\", \"current working directory\")\n\tflag.BoolVar(&dryRun, \"dry-run\", false, \"don't write files, just print to stdout\")\n\tflag.BoolVar(&inspect, \"inspect\", false, \"enable inspection logging for annotations\")\n\tflag.Var(&logLevelVar{levelVar: logLevel}, \"log-level\", \"set log level (debug, info, warn, error)\")\n\tflag.Usage = func() {\n\t\tfmt.Fprintf(os.Stderr, \"Usage: derivingjson [options] <file_or_dir_path_1> [file_or_dir_path_2 ...]\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"Example (file): derivingjson examples/derivingjson/testdata/simple/models.go\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"Example (dir):  derivingjson examples/derivingjson/testdata/simple/\\n\")\n\t\tflag.PrintDefaults()\n\t}\n\tflag.Parse()\n\n\topts := slog.HandlerOptions{Level: logLevel}\n\tlogger := slog.New(slog.NewTextHandler(os.Stderr, &opts))\n\tslog.SetDefault(logger)\n\n\tctx := context.Background()\n\tif len(flag.Args()) == 0 {\n\t\tflag.Usage()\n\t\tos.Exit(1)\n\t}\n\n\tscannerOptions := []goscan.ScannerOption{\n\t\tgoscan.WithWorkDir(cwd),\n\t\tgoscan.WithDryRun(dryRun),\n\t\tgoscan.WithInspect(inspect),\n\t\tgoscan.WithLogger(logger),\n\t}\n\tgscn, err := goscan.New(scannerOptions...)\n\tif err != nil {\n\t\tslog.ErrorContext(ctx, \"Failed to create go-scan scanner\", slog.Any(\"error\", err))\n\t\tos.Exit(1)\n\t}\n\n\tfilesByPackage := make(map[string][]string)\n\tdirsToScan := []string{}\n\n\tfor _, path := range flag.Args() {\n\t\tstat, err := os.Stat(path)\n\t\tif err != nil {\n\t\t\tslog.ErrorContext(ctx, \"Error accessing path\", slog.String(\"path\", path), slog.Any(\"error\", err))\n\t\t\tcontinue\n\t\t}\n\t\tif stat.IsDir() {\n\t\t\tdirsToScan = append(dirsToScan, path)\n\t\t} else if strings.HasSuffix(path, \".go\") {\n\t\t\tpkgDir := filepath.Dir(path)\n\t\t\tfilesByPackage[pkgDir] = append(filesByPackage[pkgDir], path)\n\t\t} else {\n\t\t\tslog.WarnContext(ctx, \"Argument is not a .go file or directory, skipping\", slog.String(\"path\", path))\n\t\t}\n\t}\n\n\tvar successCount, errorCount int\n\n\tprocessPackage := func(pkgInfo *scanner.PackageInfo) {\n\t\tif pkgInfo == nil {\n\t\t\tslog.ErrorContext(ctx, \"Scanned package info is nil\")\n\t\t\terrorCount++\n\t\t\treturn\n\t\t}\n\n\t\timportManager := goscan.NewImportManager(pkgInfo)\n\t\tcode, err := gen.Generate(ctx, gscn, pkgInfo, importManager)\n\t\tif err != nil {\n\t\t\tslog.ErrorContext(ctx, \"Error generating code for package\", \"path\", pkgInfo.Path, slog.Any(\"error\", err))\n\t\t\terrorCount++\n\t\t\treturn\n\t\t}\n\n\t\tif len(code) == 0 {\n\t\t\tslog.InfoContext(ctx, \"No code generated for package\", \"path\", pkgInfo.Path)\n\t\t\tsuccessCount++\n\t\t\treturn\n\t\t}\n\n\t\toutputDir := goscan.NewPackageDirectory(pkgInfo.Path, pkgInfo.Name)\n\t\tgoFile := goscan.GoFile{\n\t\t\tPackageName:\tpkgInfo.Name,\n\t\t\tImports:\timportManager.Imports(),\n\t\t\tCodeSet:\tstring(code),\n\t\t}\n\n\t\toutputFilename := fmt.Sprintf(\"%s_deriving.go\", strings.ToLower(pkgInfo.Name))\n\t\tif gscn.DryRun {\n\t\t\tslog.InfoContext(ctx, \"Dry run: skipping file write\", \"path\", filepath.Join(outputDir.Path, outputFilename))\n\t\t\tfmt.Fprintf(os.Stdout, \"---\\n// file: %s\\n---\\n\", filepath.Join(outputDir.Path, outputFilename))\n\n\t\t\tvar buf bytes.Buffer\n\t\t\t// Manually construct and format the file content for stdout\n\t\t\tbuf.WriteString(fmt.Sprintf(\"package %s\\n\\n\", goFile.PackageName))\n\t\t\tif len(goFile.Imports) > 0 {\n\t\t\t\tbuf.WriteString(\"import (\\n\")\n\t\t\t\tfor path, alias := range goFile.Imports {\n\t\t\t\t\tif alias != \"\" {\n\t\t\t\t\t\tbuf.WriteString(fmt.Sprintf(\"\\t%s \\\"%s\\\"\\n\", alias, path))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuf.WriteString(fmt.Sprintf(\"\\t\\\"%s\\\"\\n\", path))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuf.WriteString(\")\\n\\n\")\n\t\t\t}\n\t\t\tbuf.WriteString(goFile.CodeSet)\n\n\t\t\tformatted, err := format.Source(buf.Bytes())\n\t\t\tif err != nil {\n\t\t\t\tslog.ErrorContext(ctx, \"Failed to format generated code for stdout\", \"path\", pkgInfo.Path, slog.Any(\"error\", err))\n\t\t\t\t// Print unformatted code on error\n\t\t\t\tos.Stdout.Write(buf.Bytes())\n\t\t\t\terrorCount++\n\t\t\t} else {\n\t\t\t\tos.Stdout.Write(formatted)\n\t\t\t\tsuccessCount++\n\t\t\t}\n\t\t} else {\n\t\t\tif err := outputDir.SaveGoFile(ctx, goFile, outputFilename); err != nil {\n\t\t\t\tslog.ErrorContext(ctx, \"Failed to save generated file for package\", \"path\", pkgInfo.Path, slog.Any(\"error\", err))\n\t\t\t\terrorCount++\n\t\t\t} else {\n\t\t\t\tslog.InfoContext(ctx, \"Successfully generated UnmarshalJSON for package\", \"path\", pkgInfo.Path)\n\t\t\t\tsuccessCount++\n\t\t\t}\n\t\t}\n\t}\n\n\t// Process directories\n\tfor _, dirPath := range dirsToScan {\n\t\tslog.InfoContext(ctx, \"Scanning directory\", \"path\", dirPath)\n\t\tpkgInfo, err := gscn.ScanPackage(ctx, dirPath)\n\t\tif err != nil {\n\t\t\tslog.ErrorContext(ctx, \"Error scanning package\", \"path\", dirPath, slog.Any(\"error\", err))\n\t\t\terrorCount++\n\t\t\tcontinue\n\t\t}\n\t\tprocessPackage(pkgInfo)\n\t}\n\n\t// Process file groups\n\tfor pkgDir, filePaths := range filesByPackage {\n\t\tslog.InfoContext(ctx, \"Scanning files in package\", \"package\", pkgDir, \"files\", filePaths)\n\t\tpkgInfo, err := gscn.ScanFiles(ctx, filePaths)\n\t\tif err != nil {\n\t\t\tslog.ErrorContext(ctx, \"Error scanning files\", \"package\", pkgDir, slog.Any(\"error\", err))\n\t\t\terrorCount++\n\t\t\tcontinue\n\t\t}\n\t\tprocessPackage(pkgInfo)\n\t}\n\n\tslog.InfoContext(ctx, \"Generation summary\", slog.Int(\"successful_packages\", successCount), slog.Int(\"failed_packages/files\", errorCount))\n\tif errorCount > 0 {\n\t\tos.Exit(1)\n\t}\n}\n"
time=2025-09-18T09:43:11.389Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson
time=2025-09-18T09:43:11.389Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/examples/derivingjson
time=2025-09-18T09:43:11.389Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/examples/derivingjson
time=2025-09-18T09:43:11.389Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/examples/derivingjson types=1
time=2025-09-18T09:43:11.389Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson scanned=true
time=2025-09-18T09:43:11.389Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/examples/derivingjson
time=2025-09-18T09:43:11.389Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson scanned=true
time=2025-09-18T09:43:11.389Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson
time=2025-09-18T09:43:11.389Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson scanned=true
time=2025-09-18T09:43:11.389Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson scanned=true
time=2025-09-18T09:43:11.389Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson
time=2025-09-18T09:43:11.389Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson scanned=true
time=2025-09-18T09:43:11.389Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson scanned=true
time=2025-09-18T09:43:11.389Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson
time=2025-09-18T09:43:11.389Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson scanned=true
time=2025-09-18T09:43:11.389Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson scanned=true
time=2025-09-18T09:43:11.389Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.398Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/goscan.go:1:1 source="package goscan\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/token\"\n\t\"io/fs\"\n\t\"log/slog\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/podhmo/go-scan/locator\"\n\t\"github.com/podhmo/go-scan/scanner\"\n)\n\n// Package is an alias for scanner.PackageInfo, representing all the extracted information from a single package.\ntype Package = scanner.PackageInfo\n\n// TypeInfo is an alias for scanner.TypeInfo.\ntype TypeInfo = scanner.TypeInfo\n\n// ConstantInfo is an alias for scanner.ConstantInfo.\ntype ConstantInfo = scanner.ConstantInfo\n\n// FunctionInfo is an alias for scanner.FunctionInfo.\ntype FunctionInfo = scanner.FunctionInfo\n\n// PackageImports is an alias for scanner.PackageImports.\ntype PackageImports = scanner.PackageImports\n\n// Visitor is an alias for scanner.Visitor.\ntype Visitor = scanner.Visitor\n\n// Re-export scanner kinds for convenience.\nconst (\n\tStructKind\t= scanner.StructKind\n\tAliasKind\t= scanner.AliasKind\n\tFuncKind\t= scanner.FuncKind\n\tInterfaceKind\t= scanner.InterfaceKind\t// Ensure InterfaceKind is available\n)\n\n// Scanner is the main entry point for the type scanning library.\n// It combines a locator for finding packages, a scanner for parsing them,\n// and caches for improving performance over multiple calls.\n// Scanner instances are stateful regarding which files have been visited (parsed).\ntype Scanner struct {\n\t*Config\n\tpackageCache\t\tmap[string]*Package\t// Cache for PackageInfo from ScanPackage/ScanPackageByImport, key is import path\n\tvisitedFiles\t\tmap[string]struct{}\t// Set of visited (parsed) file absolute paths for this Scanner instance.\n\tmu\t\t\tsync.RWMutex\n\tCachePath\t\tstring\n\tsymbolCache\t\t*symbolCache\t// Symbol cache (persisted across Scanner instances if path is reused)\n\tExternalTypeOverrides\tscanner.ExternalTypeOverride\n\n\t// Walker is responsible for lightweight, dependency-focused scanning operations.\n\tWalker\t*ModuleWalker\n\n\t// For multi-module workspace support\n\tisWorkspace\t\t\tbool\n\tlocators\t\t\t[]*locator.Locator\n\tmoduleDirs\t\t\t[]string\t// temporary holder for module directories\n\tdeclarationsOnlyPackages\t[]string\n}\n\n// Fset returns the FileSet associated with the scanner.\nfunc (s *Scanner) Fset() *token.FileSet {\n\treturn s.fset\n}\n\n// Locator returns the primary locator instance. In workspace mode, this is the\n// locator for the first module, which might not be appropriate for all operations.\n// Use `locatorForImportPath` for path-specific lookups in workspace mode.\nfunc (s *Scanner) Locator() *locator.Locator {\n\tif s.isWorkspace && len(s.locators) > 0 {\n\t\treturn s.locators[0]\n\t}\n\treturn s.locator\n}\n\n// IsWorkspace returns true if the scanner is configured for multi-module mode.\nfunc (s *Scanner) IsWorkspace() bool {\n\treturn s.isWorkspace\n}\n\n// ModuleRoots returns the root directories of all modules in the workspace.\nfunc (s *Scanner) ModuleRoots() []string {\n\tif !s.isWorkspace {\n\t\tif s.locator != nil {\n\t\t\treturn []string{s.locator.RootDir()}\n\t\t}\n\t\treturn nil\n\t}\n\troots := make([]string, len(s.locators))\n\tfor i, loc := range s.locators {\n\t\troots[i] = loc.RootDir()\n\t}\n\treturn roots\n}\n\n// Modules returns information about all modules in the workspace.\nfunc (s *Scanner) Modules() []*scanner.ModuleInfo {\n\tif !s.isWorkspace {\n\t\tif s.locator != nil {\n\t\t\treturn []*scanner.ModuleInfo{\n\t\t\t\t{Path: s.locator.ModulePath(), Dir: s.locator.RootDir()},\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\tmodules := make([]*scanner.ModuleInfo, len(s.locators))\n\tfor i, loc := range s.locators {\n\t\tmodules[i] = &scanner.ModuleInfo{Path: loc.ModulePath(), Dir: loc.RootDir()}\n\t}\n\treturn modules\n}\n\n// locatorForImportPath finds the correct locator for a given import path in workspace mode.\nfunc (s *Scanner) locatorForImportPath(importPath string) (*locator.Locator, error) {\n\tif !s.isWorkspace {\n\t\treturn s.locator, nil\n\t}\n\n\tvar bestMatch *locator.Locator\n\tvar bestMatchLen int\n\n\tfor _, loc := range s.locators {\n\t\tmodulePath := loc.ModulePath()\n\t\t// Check for exact match or if the import path is a sub-package of the module.\n\t\tif importPath == modulePath || strings.HasPrefix(importPath, modulePath+\"/\") {\n\t\t\tif len(modulePath) > bestMatchLen {\n\t\t\t\tbestMatch = loc\n\t\t\t\tbestMatchLen = len(modulePath)\n\t\t\t}\n\t\t}\n\t}\n\n\tif bestMatch != nil {\n\t\treturn bestMatch, nil\n\t}\n\n\t// Fallback for standard library packages: any locator can find them.\n\tif !strings.Contains(importPath, \".\") {\n\t\tif len(s.locators) > 0 {\n\t\t\treturn s.locators[0], nil\n\t\t}\n\t}\n\n\treturn nil, fmt.Errorf(\"could not find a module responsible for import path %q in workspace\", importPath)\n}\n\n// BuildImportLookup creates a map of local import names to their full package paths for a given file.\nfunc (s *Scanner) BuildImportLookup(file *ast.File) map[string]string {\n\treturn s.scanner.BuildImportLookup(file)\n}\n\n// TypeInfoFromExpr resolves an AST expression that represents a type into a FieldType.\nfunc (s *Scanner) TypeInfoFromExpr(ctx context.Context, expr ast.Expr, currentTypeParams []*scanner.TypeParamInfo, info *scanner.PackageInfo, importLookup map[string]string) *scanner.FieldType {\n\treturn s.scanner.TypeInfoFromExpr(ctx, expr, currentTypeParams, info, importLookup)\n}\n\n// ScanPackageByPos finds and scans the package containing the given token.Pos.\nfunc (s *Scanner) ScanPackageByPos(ctx context.Context, pos token.Pos) (*scanner.PackageInfo, error) {\n\tif !pos.IsValid() {\n\t\treturn nil, fmt.Errorf(\"invalid position\")\n\t}\n\tfile := s.fset.File(pos)\n\tif file == nil {\n\t\treturn nil, fmt.Errorf(\"no file found for position\")\n\t}\n\n\tpkgDir := filepath.Dir(file.Name())\n\treturn s.ScanPackage(ctx, pkgDir)\n}\n\n// ScannerForSymgo is a temporary helper for tests to access the internal scanner.\n// TODO: Refactor evaluator to use the top-level goscan.Scanner instead.\nfunc (s *Scanner) ScannerForSymgo() (*scanner.Scanner, error) {\n\treturn s.scanner, nil\n}\n\n// ModulePath returns the module path from the scanner's locator.\nfunc (s *Scanner) ModulePath() string {\n\tif s.locator == nil {\n\t\treturn \"\"\n\t}\n\treturn s.locator.ModulePath()\n}\n\n// RootDir returns the module root directory from the scanner's locator.\nfunc (s *Scanner) RootDir() string {\n\tif s.locator == nil {\n\t\treturn \"\"\n\t}\n\treturn s.locator.RootDir()\n}\n\n// LookupOverride checks if a fully qualified type name exists in the external type override map.\nfunc (s *Scanner) LookupOverride(qualifiedName string) (*scanner.TypeInfo, bool) {\n\tif s.ExternalTypeOverrides == nil {\n\t\treturn nil, false\n\t}\n\tti, ok := s.ExternalTypeOverrides[qualifiedName]\n\treturn ti, ok\n}\n\n// Scan scans Go packages based on the provided patterns.\n// Each pattern can be a directory path or a file path relative to the scanner's workDir.\n// It returns a list of scanned packages.\nfunc (s *Scanner) Scan(ctx context.Context, patterns ...string) ([]*Package, error) {\n\tpkgsMap := make(map[string]*Package)\t// Use map to handle duplicates\n\n\tfor _, pattern := range patterns {\n\t\tif strings.Contains(pattern, \"...\") {\n\t\t\t// Handle wildcard pattern\n\t\t\tbasePath := strings.TrimSuffix(pattern, \"/...\")\n\t\t\tvar absBasePath string\n\n\t\t\tif filepath.IsAbs(basePath) {\n\t\t\t\tabsBasePath = basePath\n\t\t\t} else if strings.HasPrefix(basePath, \".\") {\n\t\t\t\tabsBasePath = filepath.Join(s.workDir, basePath)\n\t\t\t} else {\n\t\t\t\tvar err error\n\t\t\t\tabsBasePath, err = s.locator.FindPackageDir(basePath)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"could not find directory for import path pattern %q: %w\", pattern, err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twalkErr := filepath.WalkDir(absBasePath, func(path string, d fs.DirEntry, err error) error {\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif !d.IsDir() {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\t// Check if the directory contains any .go files.\n\t\t\t\tentries, err := os.ReadDir(path)\n\t\t\t\tif err != nil {\n\t\t\t\t\t// Log and continue. Don't let permission errors stop the whole walk.\n\t\t\t\t\tslog.DebugContext(ctx, \"cannot read directory during walk, skipping\", \"path\", path, \"error\", err)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\thasGoFiles := false\n\t\t\t\tfor _, entry := range entries {\n\t\t\t\t\tif !entry.IsDir() && strings.HasSuffix(entry.Name(), \".go\") {\n\t\t\t\t\t\thasGoFiles = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif hasGoFiles {\n\t\t\t\t\tpkg, err := s.ScanPackage(ctx, path)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t// Log error but continue walking\n\t\t\t\t\t\tslog.WarnContext(ctx, \"failed to scan package during wildcard walk\", \"path\", path, \"error\", err)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t\tif pkg != nil && pkg.ImportPath != \"\" {\n\t\t\t\t\t\tpkgsMap[pkg.ImportPath] = pkg\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\n\t\t\tif walkErr != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error walking directory for pattern %q: %w\", pattern, walkErr)\n\t\t\t}\n\t\t} else {\n\t\t\t// Handle single file or directory pattern (legacy behavior)\n\t\t\tabsPath := pattern\n\t\t\tif !filepath.IsAbs(pattern) {\n\t\t\t\tabsPath = filepath.Join(s.workDir, pattern)\n\t\t\t}\n\n\t\t\tinfo, err := os.Stat(absPath)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"could not stat pattern %q (resolved to %q): %w\", pattern, absPath, err)\n\t\t\t}\n\n\t\t\tvar pkg *Package\n\t\t\tif info.IsDir() {\n\t\t\t\tpkg, err = s.ScanPackage(ctx, absPath)\n\t\t\t} else {\n\t\t\t\tpkg, err = s.ScanFiles(ctx, []string{absPath})\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to scan path %q: %w\", absPath, err)\n\t\t\t}\n\t\t\tif pkg != nil && pkg.ImportPath != \"\" {\n\t\t\t\tpkgsMap[pkg.ImportPath] = pkg\n\t\t\t}\n\t\t}\n\t}\n\n\t// Convert map to slice\n\tpkgs := make([]*Package, 0, len(pkgsMap))\n\tfor _, pkg := range pkgsMap {\n\t\tpkgs = append(pkgs, pkg)\n\t}\n\t// Sort for deterministic output\n\tsort.Slice(pkgs, func(i, j int) bool {\n\t\treturn pkgs[i].ImportPath < pkgs[j].ImportPath\n\t})\n\treturn pkgs, nil\n}\n\n// ScannerOption is a function that configures a Scanner.\ntype ScannerOption func(*Scanner) error\n\n// WithWorkDir sets the working directory for the scanner.\nfunc WithWorkDir(path string) ScannerOption {\n\treturn func(s *Scanner) error {\n\t\tabsPath, err := filepath.Abs(path)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"getting absolute path for workdir %q: %w\", path, err)\n\t\t}\n\t\ts.workDir = absPath\n\t\treturn nil\n\t}\n}\n\n// WithDryRun enables or disables dry-run mode.\nfunc WithDryRun(dryRun bool) ScannerOption {\n\treturn func(s *Scanner) error {\n\t\ts.DryRun = dryRun\n\t\treturn nil\n\t}\n}\n\n// WithInspect enables or disables inspect mode.\nfunc WithInspect(inspect bool) ScannerOption {\n\treturn func(s *Scanner) error {\n\t\ts.Inspect = inspect\n\t\treturn nil\n\t}\n}\n\n// WithLogger sets the logger for the scanner.\nfunc WithLogger(logger *slog.Logger) ScannerOption {\n\treturn func(s *Scanner) error {\n\t\ts.Logger = logger\n\t\treturn nil\n\t}\n}\n\n// WithIncludeTests includes test files in the scan.\nfunc WithIncludeTests(include bool) ScannerOption {\n\treturn func(s *Scanner) error {\n\t\ts.IncludeTests = include\n\t\treturn nil\n\t}\n}\n\n// WithGoModuleResolver enables the scanner to find packages in the Go module cache and GOROOT.\nfunc WithGoModuleResolver() ScannerOption {\n\treturn func(s *Scanner) error {\n\t\ts.useGoModuleResolver = true\n\t\treturn nil\n\t}\n}\n\n// WithModuleDirs configures the scanner to operate in workspace mode over a set of modules.\n// It stores the directories, and the actual locator initialization happens in `New`.\nfunc WithModuleDirs(moduleDirs []string) ScannerOption {\n\treturn func(s *Scanner) error {\n\t\tif len(moduleDirs) > 0 {\n\t\t\ts.isWorkspace = true\n\t\t\ts.moduleDirs = moduleDirs\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithOverlay provides in-memory file content to the scanner.\nfunc WithOverlay(overlay scanner.Overlay) ScannerOption {\n\treturn func(s *Scanner) error {\n\t\tif s.overlay == nil {\n\t\t\ts.overlay = make(scanner.Overlay)\n\t\t}\n\t\tfor k, v := range overlay {\n\t\t\ts.overlay[k] = v\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithExternalTypeOverrides sets the external type override map for the scanner.\nfunc WithExternalTypeOverrides(overrides scanner.ExternalTypeOverride) ScannerOption {\n\treturn func(s *Scanner) error {\n\t\tif s.ExternalTypeOverrides == nil {\n\t\t\ts.ExternalTypeOverrides = make(scanner.ExternalTypeOverride)\n\t\t}\n\t\tfor k, v := range overrides {\n\t\t\ts.ExternalTypeOverrides[k] = v\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithDeclarationsOnlyPackages sets packages that should be scanned for declarations only.\nfunc WithDeclarationsOnlyPackages(importPaths []string) ScannerOption {\n\treturn func(s *Scanner) error {\n\t\tif s.scanner != nil {\n\t\t\ts.scanner.DeclarationsOnlyPackages = append(s.scanner.DeclarationsOnlyPackages, importPaths...)\n\t\t}\n\t\t// Also store it on the goscan.Scanner for initialization phase\n\t\ts.declarationsOnlyPackages = append(s.declarationsOnlyPackages, importPaths...)\n\t\treturn nil\n\t}\n}\n\n// New creates a new Scanner. It finds the module root starting from the given path.\n// It also initializes an empty set of visited files for this scanner instance.\nfunc New(options ...ScannerOption) (*Scanner, error) {\n\tcfg := &Config{\n\t\tfset:\t\ttoken.NewFileSet(),\n\t\toverlay:\tmake(scanner.Overlay),\n\t}\n\n\ts := &Scanner{\n\t\tConfig:\t\t\tcfg,\n\t\tpackageCache:\t\tmake(map[string]*Package),\n\t\tvisitedFiles:\t\tmake(map[string]struct{}),\n\t\tExternalTypeOverrides:\tmake(scanner.ExternalTypeOverride),\n\t\tWalker: &ModuleWalker{\n\t\t\tConfig:\t\t\tcfg,\n\t\t\tpackageImportsCache:\tmake(map[string]*scanner.PackageImports),\n\t\t},\n\t}\n\n\tfor _, option := range options {\n\t\tif err := option(s); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tlocatorOpts := []locator.Option{locator.WithOverlay(s.overlay)}\n\tif s.useGoModuleResolver {\n\t\tlocatorOpts = append(locatorOpts, locator.WithGoModuleResolver())\n\t}\n\n\tif s.isWorkspace {\n\t\tif len(s.moduleDirs) == 0 {\n\t\t\treturn nil, fmt.Errorf(\"scanner is in workspace mode but no module directories were provided\")\n\t\t}\n\t\ts.locators = make([]*locator.Locator, len(s.moduleDirs))\n\t\tfor i, dir := range s.moduleDirs {\n\t\t\tloc, err := locator.New(dir, locatorOpts...)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"workspace mode: failed to create locator for module %q: %w\", dir, err)\n\t\t\t}\n\t\t\ts.locators[i] = loc\n\t\t}\n\t\t// Set the primary locator to the first one.\n\t\ts.locator = s.locators[0]\n\t\ts.workDir = s.locator.RootDir()\t// Set workDir to the first module's root.\n\t} else {\n\t\tif s.workDir == \"\" {\n\t\t\tcwd, err := os.Getwd()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"getwd: %w\", err)\n\t\t\t}\n\t\t\ts.workDir = cwd\n\t\t}\n\t\tloc, err := locator.New(s.workDir, locatorOpts...)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to initialize locator: %w\", err)\n\t\t}\n\t\ts.locator = loc\n\t}\n\n\t// The internal scanner needs a module path and root dir to initialize.\n\t// In workspace mode, we use the primary (first) locator's info.\n\t// This is a slight simplification, but the internal scanner's primary role\n\t// is parsing, and type resolution logic will use the full workspace-aware Scanner.\n\tinitialScanner, err := scanner.New(s.fset, s.ExternalTypeOverrides, s.overlay, s.locator.ModulePath(), s.locator.RootDir(), s, s.Inspect, s.Logger)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create internal scanner: %w\", err)\n\t}\n\t// Propagate declarations-only packages to the internal scanner\n\tif s.declarationsOnlyPackages != nil {\n\t\tinitialScanner.DeclarationsOnlyPackages = append(initialScanner.DeclarationsOnlyPackages, s.declarationsOnlyPackages...)\n\t}\n\ts.scanner = initialScanner\n\n\treturn s, nil\n}\n\n// ResolvePath converts a file path to a full Go package path.\n// If the path exists on the filesystem, it is treated as a file path and resolved against\n// the module's go.mod file. If it does not exist, it is assumed to be a package path\n// and is returned as-is, unless it has a relative path prefix (like `./`), in which\n// case an error is returned.\n//\n// This function is a facade for `locator.ResolvePkgPath`.\nfunc ResolvePath(ctx context.Context, path string) (string, error) {\n\treturn locator.ResolvePkgPath(ctx, path)\n}\n\n// SetExternalTypeOverrides sets the external type override map for the scanner.\nfunc (s *Scanner) SetExternalTypeOverrides(ctx context.Context, overrides scanner.ExternalTypeOverride) {\n\tif overrides == nil {\n\t\toverrides = make(scanner.ExternalTypeOverride)\n\t}\n\ts.ExternalTypeOverrides = overrides\n\tnewInternalScanner, err := scanner.New(s.fset, s.ExternalTypeOverrides, s.overlay, s.locator.ModulePath(), s.locator.RootDir(), s, s.Inspect, s.Logger)\n\tif err != nil {\n\t\tslog.WarnContext(ctx, \"Failed to re-initialize internal scanner with new overrides. Continuing with previous scanner settings.\", slog.Any(\"error\", err))\n\t\treturn\n\t}\n\ts.scanner = newInternalScanner\n}\n\n// AddDeclarationsOnlyPackages adds packages to the list of packages that should be scanned for declarations only.\nfunc (s *Scanner) AddDeclarationsOnlyPackages(importPaths []string) {\n\tif s.scanner == nil {\n\t\t// This should not happen if called after New()\n\t\treturn\n\t}\n\ts.scanner.DeclarationsOnlyPackages = append(s.scanner.DeclarationsOnlyPackages, importPaths...)\n}\n\n// ResolveType starts the type resolution process for a given field type.\n// It's the public entry point for resolving types. It prepares the context\n// with necessary loggers and flags for the entire resolution chain.\nfunc (s *Scanner) ResolveType(ctx context.Context, fieldType *scanner.FieldType) (*scanner.TypeInfo, error) {\n\tif s.scanner == nil {\n\t\treturn nil, fmt.Errorf(\"internal scanner is not initialized\")\n\t}\n\n\t// Prepare the context for the entire resolution chain starting from this call.\n\tif s.Logger != nil {\n\t\tctx = context.WithValue(ctx, scanner.LoggerKey, s.Logger)\n\t}\n\tctx = context.WithValue(ctx, scanner.InspectKey, s.Inspect)\n\n\t// This delegates to the internal scanner's ResolveType, which now handles\n\t// the creation of the initial resolution path.\n\treturn s.scanner.ResolveType(ctx, fieldType)\n}\n\n// listGoFiles lists all .go files in a directory.\n// If includeTests is false, it excludes _test.go files.\n// It returns a list of absolute file paths.\nfunc listGoFiles(dirPath string, includeTests bool) ([]string, error) {\n\tvar files []string\n\tentries, err := os.ReadDir(dirPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"listGoFiles: failed to read dir %s: %w\", dirPath, err)\n\t}\n\tfor _, entry := range entries {\n\t\tif entry.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tname := entry.Name()\n\t\tif !strings.HasSuffix(name, \".go\") {\n\t\t\tcontinue\n\t\t}\n\t\tif !includeTests && strings.HasSuffix(name, \"_test.go\") {\n\t\t\tcontinue\n\t\t}\n\n\t\tabsPath, err := filepath.Abs(filepath.Join(dirPath, name))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"listGoFiles: could not get absolute path for %s: %w\", name, err)\n\t\t}\n\t\tfiles = append(files, absPath)\n\t}\n\treturn files, nil\n}\n\n// ScanPackage scans a single package at a given directory path (absolute or relative to CWD).\n// It parses all .go files (excluding _test.go) in that directory that have not yet been\n// visited (parsed) by this Scanner instance.\n// The returned PackageInfo contains information derived ONLY from the files parsed in THIS specific call.\n// If no unvisited files are found in the package, the returned PackageInfo will be minimal\n// (e.g., Path and ImportPath set, but no types/functions unless a previous cached version for the entire package is returned).\n// The result of this call (representing the newly parsed files, or a prior cached full result if no new files were parsed and cache existed)\n// is stored in an in-memory package cache (s.packageCache) for subsequent calls to ScanPackage or ScanPackageByImport\n// for the same import path.\n// The global symbol cache (s.symbolCache), if enabled, is updated with symbols from the newly parsed files.\nfunc (s *Scanner) ScanPackage(ctx context.Context, pkgPath string) (*scanner.PackageInfo, error) {\n\tabsPkgPath, err := filepath.Abs(pkgPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not get absolute path for package path %s: %w\", pkgPath, err)\n\t}\n\tinfo, err := os.Stat(absPkgPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not stat path %s: %w\", absPkgPath, err)\n\t}\n\tif !info.IsDir() {\n\t\treturn nil, fmt.Errorf(\"path %s is not a directory\", absPkgPath)\n\t}\n\n\tmoduleRoot := s.locator.RootDir()\n\tmodulePath := s.locator.ModulePath()\n\tvar importPath string\n\n\tif modulePath != \"\" && moduleRoot != \"\" && strings.HasPrefix(absPkgPath, moduleRoot) {\n\t\trelPath, rErr := filepath.Rel(moduleRoot, absPkgPath)\n\t\tif rErr != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not determine relative path for %s from module root %s: %w\", absPkgPath, moduleRoot, rErr)\n\t\t}\n\t\tif relPath == \".\" || relPath == \"\" {\n\t\t\timportPath = modulePath\n\t\t} else {\n\t\t\timportPath = filepath.ToSlash(filepath.Join(modulePath, relPath))\n\t\t}\n\t} else {\n\t\t// Try to determine import path for standard library packages or other non-module paths\n\t\t// This part might be complex and require go list or similar logic for full accuracy.\n\t\t// For now, if not in module, we might not be able to form a canonical import path.\n\t\t// However, ScanPackage is often called with a direct path, so importPath might be less critical\n\t\t// than for ScanPackageByImport. Let's use the directory name as a fallback package name.\n\t\t// If a robust import path is needed for out-of-module packages, this needs enhancement.\n\t\tif modulePath == \"\" && moduleRoot == \"\" {\t// Likely not in a module context\n\t\t\tslog.WarnContext(ctx, \"ScanPackage called for path likely outside a Go module, import path may be inaccurate.\", slog.String(\"path\", absPkgPath))\n\t\t\timportPath = filepath.Base(absPkgPath)\t// Fallback\n\t\t} else if modulePath == \"\" {\t// Locator initialized but no go.mod?\n\t\t\treturn nil, fmt.Errorf(\"module path is empty, but ScanPackage called for %s. Locator issue or not in module?\", absPkgPath)\n\t\t}\n\t\t// The original `else` block here was too restrictive. It prevented scanning\n\t\t// packages resolved via a `replace` directive that points outside the main\n\t\t// module's root directory. The locator is responsible for finding the correct\n\t\t// directory for an import path, and `go-scan` should trust that result.\n\t\t// A new mechanism is needed to get the import path for a directory that\n\t\t// might be outside the module root, but we should not fail here.\n\t\t// For now, we'll try to find the import path via the locator again.\n\t\tif importPath == \"\" {\n\t\t\tvar err error\n\t\t\timportPath, err = s.locator.PathToImport(absPkgPath)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"could not determine import path for directory %s: %w\", absPkgPath, err)\n\t\t\t}\n\t\t}\n\t}\n\n\tallFilesInDir, err := listGoFiles(absPkgPath, s.IncludeTests)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"ScanPackage: could not list go files in %s: %w\", absPkgPath, err)\n\t}\n\n\tvar filesToParseNow []string\n\ts.mu.RLock()\n\tfor _, fp := range allFilesInDir {\n\t\tif _, visited := s.visitedFiles[fp]; !visited {\n\t\t\tfilesToParseNow = append(filesToParseNow, fp)\n\t\t}\n\t}\n\ts.mu.RUnlock()\n\n\tvar currentCallPkgInfo *scanner.PackageInfo\n\tif len(filesToParseNow) > 0 {\n\t\tcurrentCallPkgInfo, err = s.scanner.ScanFiles(ctx, filesToParseNow, absPkgPath)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"ScanPackage: internal scan of files for package %s failed: %w\", absPkgPath, err)\n\t\t}\n\t\tif currentCallPkgInfo != nil {\n\t\t\ts.mu.Lock()\n\t\t\tfor _, fp := range currentCallPkgInfo.Files {\t// Files actually parsed in this call\n\t\t\t\ts.visitedFiles[fp] = struct{}{}\n\t\t\t}\n\t\t\ts.mu.Unlock()\n\t\t\tcurrentCallPkgInfo.ImportPath = importPath\t// Set import path for this call's result\n\t\t\tcurrentCallPkgInfo.Path = absPkgPath\t\t// Ensure path is set\n\t\t\ts.updateSymbolCacheWithPackageInfo(ctx, importPath, currentCallPkgInfo)\n\t\t}\n\t}\n\n\t// Update the main package cache with the cumulative information for this importPath.\n\t// This requires merging if a previous entry existed. For now, replace.\n\t// A more robust strategy might involve storing all PackageInfo from each scan call and merging on demand.\n\t// For now, the cache will store the result of the latest ScanPackage or ScanPackageByImport call.\n\t// If no new files were parsed, currentCallPkgInfo will be nil.\n\t// We should ensure a PackageInfo object is always cached if the package itself is valid (even if empty of new symbols).\n\tif currentCallPkgInfo == nil {\t// No new files parsed\n\t\ts.mu.RLock()\n\t\texistingCachedInfo, found := s.packageCache[importPath]\n\t\ts.mu.RUnlock()\n\t\tif found {\n\t\t\treturn existingCachedInfo, nil\t// Return existing full cache if nothing new parsed\n\t\t}\n\t\t// If no cache and no new files, create a minimal PackageInfo\n\t\tcurrentCallPkgInfo = &scanner.PackageInfo{\n\t\t\tPath:\t\tabsPkgPath,\n\t\t\tImportPath:\timportPath,\n\t\t\tName:\t\tfilepath.Base(absPkgPath),\t// Best guess for name\n\t\t\tFset:\t\ts.fset,\n\t\t\tFiles:\t\t[]string{},\t// No files parsed in *this call*\n\t\t}\n\t}\n\n\t// Ensure the PackageInfo reflects all known files in the directory for its Files list if it's a full ScanPackage result\n\t// This is tricky without merging. The current `currentCallPkgInfo.Files` only has *newly* parsed files.\n\t// For ScanPackage, the expectation is often a view of the whole package.\n\t// Let's adjust: if currentCallPkgInfo was non-nil (new files parsed), its .Files is correct for *this scan*.\n\t// If we are to cache a \"full\" view, we'd need to merge or reconstruct.\n\t// Given \"no merge\" for ScanFiles, let's keep ScanPackage simple: its return and cache reflect *this call's parsed files*.\n\t// This means s.packageCache might hold partial info if ScanPackage is called after ScanFiles visited some.\n\t// This seems to align with the \"no merge\" philosophy more consistently.\n\t// The `Files` field of PackageInfo will list files parsed in *this specific call*.\n\n\ts.mu.Lock()\n\ts.packageCache[importPath] = currentCallPkgInfo\t// Cache the result of this specific call\n\ts.mu.Unlock()\n\n\treturn currentCallPkgInfo, nil\n}\n\n// resolveFilePath attempts to resolve a given path string (rawPath) into an absolute file path.\nfunc (s *Scanner) resolveFilePath(rawPath string) (string, error) {\n\tcheckFile := func(p string) (string, bool) {\n\t\tabsP, err := filepath.Abs(p)\n\t\tif err != nil {\n\t\t\treturn \"\", false\n\t\t}\n\t\tinfo, err := os.Stat(absP)\n\t\tif err == nil && !info.IsDir() && strings.HasSuffix(strings.ToLower(absP), \".go\") {\t// Check .go case-insensitively for robustness\n\t\t\treturn absP, true\n\t\t}\n\t\treturn \"\", false\n\t}\n\n\t// Try as absolute or CWD-relative path first\n\tif absPath, ok := checkFile(rawPath); ok {\n\t\treturn absPath, nil\n\t}\n\n\t// Try as module-qualified path\n\tif s.locator != nil {\n\t\tmodulePath := s.locator.ModulePath()\n\t\tmoduleRoot := s.locator.RootDir()\n\t\tif modulePath != \"\" && moduleRoot != \"\" && strings.HasPrefix(rawPath, modulePath) {\n\t\t\tprefixToTrim := modulePath\n\t\t\t// Ensure we are trimming \"modulePath/\" not just \"modulePath\" if there's more path\n\t\t\tif !strings.HasSuffix(modulePath, \"/\") && len(rawPath) > len(modulePath) && rawPath[len(modulePath)] == '/' {\n\t\t\t\tprefixToTrim += \"/\"\n\t\t\t} else if rawPath == modulePath {\t// rawPath is just the module path, not a file in it\n\t\t\t\treturn \"\", fmt.Errorf(\"path %q is a module path, not a file path within the module\", rawPath)\n\t\t\t}\n\n\t\t\tif strings.HasPrefix(rawPath, prefixToTrim) {\n\t\t\t\tsuffixPath := strings.TrimPrefix(rawPath, prefixToTrim)\n\t\t\t\tcandidatePath := filepath.Join(moduleRoot, suffixPath)\n\t\t\t\tif absPath, ok := checkFile(candidatePath); ok {\n\t\t\t\t\treturn absPath, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", fmt.Errorf(\"could not resolve path %q to an existing .go file\", rawPath)\n}\n\n// ScanFiles scans a specified set of Go files.\n//\n// File paths in the `filePaths` argument can be provided in three forms:\n//  1. Absolute path (e.g., \"/path/to/your/project/pkg/file.go\").\n//  2. Path relative to the current working directory (CWD) (e.g., \"pkg/file.go\").\n//  3. Module-qualified path (e.g., \"github.com/your/module/pkg/file.go\"), which is resolved\n//     using the Scanner's associated module information (from go.mod).\n//\n// All provided file paths, after resolution, must belong to the same directory,\n// effectively meaning they must be part of the same Go package.\n//\n// This function only parses files that have not been previously visited (parsed)\n// by this specific Scanner instance (tracked in `s.visitedFiles`).\n//\n// The returned `scanner.PackageInfo` contains information derived *only* from the\n// files that were newly parsed in *this specific call*. If all specified files\n// were already visited, the `PackageInfo.Files` list (and consequently Types, Functions, etc.)\n// will be empty, though `Path` and `ImportPath` will be set according to the files' package.\n//\n// Results from `ScanFiles` are *not* stored in the main package cache (`s.packageCache`)\n// because they represent partial package information. However, the global symbol\n// cache (`s.symbolCache`), if enabled, *is* updated with symbols from the newly parsed files.\n// Files parsed by this function are marked as visited in `s.visitedFiles`.\nfunc (s *Scanner) ScanFiles(ctx context.Context, filePaths []string) (*scanner.PackageInfo, error) {\n\tif len(filePaths) == 0 {\n\t\treturn nil, fmt.Errorf(\"no file paths provided to ScanFiles\")\n\t}\n\tif s.locator == nil {\n\t\treturn nil, fmt.Errorf(\"scanner locator is not initialized\")\n\t}\n\tmoduleRoot := s.locator.RootDir()\n\tmodulePath := s.locator.ModulePath()\n\tif modulePath == \"\" && moduleRoot == \"\" {\t// Heuristic: not in a module context at all\n\t\t// Allow scanning if files are absolute paths and locator isn't strictly needed for path resolution itself\n\t\t// but import path calculation will be severely limited.\n\t\tslog.WarnContext(ctx, \"ScanFiles called likely outside a Go module context. Import path resolution will be affected.\")\n\t} else if modulePath == \"\" || moduleRoot == \"\" {\t// Inconsistent module info\n\t\treturn nil, fmt.Errorf(\"module path or root is empty, ensure a go.mod file exists and is discoverable by the scanner's locator\")\n\t}\n\n\tvar resolvedAbsFilePaths []string\n\tvar firstFileDir string\n\n\tfor i, rawFp := range filePaths {\n\t\tabsFp, err := s.resolveFilePath(rawFp)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to resolve file path %q: %w\", rawFp, err)\n\t\t}\n\t\tresolvedAbsFilePaths = append(resolvedAbsFilePaths, absFp)\n\t\tcurrentFileDir := filepath.Dir(absFp)\n\t\tif i == 0 {\n\t\t\tfirstFileDir = currentFileDir\n\t\t} else if currentFileDir != firstFileDir {\n\t\t\treturn nil, fmt.Errorf(\"all files must belong to the same directory (package); %s is in %s, but expected %s\", absFp, currentFileDir, firstFileDir)\n\t\t}\n\t}\n\n\tpkgDirAbs := firstFileDir\n\tvar importPath string\n\n\tif modulePath != \"\" && moduleRoot != \"\" {\t// Only attempt module-based import path if module context is valid\n\t\t// if !strings.HasPrefix(pkgDirAbs, moduleRoot) {\n\t\t// \t// This check is too strict for modules that use `replace` directives\n\t\t// \t// to point to a parent directory. The locator has already resolved the\n\t\t// \t// import path to this directory, so we should trust it.\n\t\t// \treturn nil, fmt.Errorf(\"package directory %s is outside the module root %s, cannot determine module-relative import path\", pkgDirAbs, moduleRoot)\n\t\t// }\n\t\trelPath, err := filepath.Rel(moduleRoot, pkgDirAbs)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not determine relative path for %s from module root %s: %w\", pkgDirAbs, moduleRoot, err)\n\t\t}\n\t\tif relPath == \".\" || relPath == \"\" {\n\t\t\timportPath = modulePath\n\t\t} else {\n\t\t\timportPath = filepath.ToSlash(filepath.Join(modulePath, relPath))\n\t\t}\n\t} else {\t// Fallback if not in a clear module context (e.g. scanning /usr/local/go/src/fmt)\n\t\t// This part needs careful consideration for how to represent non-module packages.\n\t\t// For now, use the directory path as a pseudo-import path.\n\t\timportPath = filepath.ToSlash(pkgDirAbs)\n\t\tslog.WarnContext(ctx, \"Creating pseudo import path for package\", slog.String(\"import_path\", importPath), slog.String(\"package_dir\", pkgDirAbs))\n\t}\n\n\tvar filesToParse []string\n\ts.mu.RLock()\n\tfor _, absFp := range resolvedAbsFilePaths {\n\t\tif _, visited := s.visitedFiles[absFp]; !visited {\n\t\t\tfilesToParse = append(filesToParse, absFp)\n\t\t}\n\t}\n\ts.mu.RUnlock()\n\n\tif len(filesToParse) == 0 {\t// All specified files already visited\n\t\t// Return an empty PackageInfo but with correct Path/ImportPath\n\t\treturn &scanner.PackageInfo{\n\t\t\tPath:\t\tpkgDirAbs,\n\t\t\tImportPath:\timportPath,\n\t\t\tName:\t\t\"\",\t// Name would require parsing or looking up a cached full PackageInfo\n\t\t\tFset:\t\ts.fset,\n\t\t\tFiles:\t\t[]string{},\t// No files *newly* parsed\n\t\t}, nil\n\t}\n\n\tpkgInfo, err := s.scanner.ScanFiles(ctx, filesToParse, pkgDirAbs)\t// Scan only unvisited files\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to scan files in %s (import path %s): %w\", pkgDirAbs, importPath, err)\n\t}\n\n\tif pkgInfo != nil {\n\t\tpkgInfo.ImportPath = importPath\t// Set the calculated import path\n\t\tpkgInfo.Path = pkgDirAbs\t// Ensure directory path is also set\n\t\ts.mu.Lock()\n\t\tfor _, fp := range pkgInfo.Files {\t// Mark newly parsed files as visited\n\t\t\ts.visitedFiles[fp] = struct{}{}\n\t\t}\n\t\ts.mu.Unlock()\n\t\t// Results from ScanFiles (which are partial by design based on unvisited files)\n\t\t// are NOT cached in s.packageCache. Only symbol cache is updated.\n\t\ts.updateSymbolCacheWithPackageInfo(ctx, importPath, pkgInfo)\n\t}\n\treturn pkgInfo, nil\n}\n\n// UnscannedGoFiles returns a list of absolute paths to .go files\n// (and optionally _test.go files) within the specified package that have not\n// yet been visited (parsed) by this Scanner instance.\n//\n// The `packagePathOrImportPath` argument can be:\n//  1. An absolute directory path to the package.\n//  2. A directory path relative to the current working directory (CWD).\n//  3. A Go import path (e.g., \"github.com/your/module/pkg\"), which will be resolved\n//     to a directory using the Scanner's locator.\n//\n// This method lists all relevant .go files in the identified package directory\n// and filters out those already present in the Scanner's `visitedFiles` set.\n// It is useful for discovering which files in a package still need to be processed\n// if performing iterative scanning.\nfunc (s *Scanner) UnscannedGoFiles(packagePathOrImportPath string) ([]string, error) {\n\tif s.locator == nil && !(filepath.IsAbs(packagePathOrImportPath) && isDir(packagePathOrImportPath)) {\n\t\t// If locator is nil, we can only proceed if packagePathOrImportPath is an absolute directory path.\n\t\treturn nil, fmt.Errorf(\"scanner locator is not initialized, and path is not an absolute directory to a package\")\n\t}\n\n\tvar pkgDirAbs string\n\tvar err error\n\n\t// Try as a direct file system path first (absolute or CWD-relative directory)\n\tpathAsDir, err := filepath.Abs(packagePathOrImportPath)\n\tif err == nil {\n\t\tinfo, statErr := os.Stat(pathAsDir)\n\t\tif statErr == nil && info.IsDir() {\n\t\t\tpkgDirAbs = pathAsDir\n\t\t}\n\t}\n\n\t// If not resolved as a direct directory path, try as an import path via locator (if locator exists)\n\tif pkgDirAbs == \"\" {\n\t\tif s.locator == nil {\t// Guard again, as locator might be nil\n\t\t\treturn nil, fmt.Errorf(\"cannot resolve %q as import path: locator not available\", packagePathOrImportPath)\n\t\t}\n\t\tpkgDirAbs, err = s.locator.FindPackageDir(packagePathOrImportPath)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not find package directory for %q (tried as path and import path): %w\", packagePathOrImportPath, err)\n\t\t}\n\t}\n\n\tallGoFilesInDir, err := listGoFiles(pkgDirAbs, s.IncludeTests)\t// listGoFiles returns absolute paths\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"UnscannedGoFiles: could not list go files in %s: %w\", pkgDirAbs, err)\n\t}\n\n\tvar unscannedFiles []string\n\ts.mu.RLock()\n\tfor _, absFilePath := range allGoFilesInDir {\n\t\tif _, visited := s.visitedFiles[absFilePath]; !visited {\n\t\t\tunscannedFiles = append(unscannedFiles, absFilePath)\n\t\t}\n\t}\n\ts.mu.RUnlock()\n\treturn unscannedFiles, nil\n}\n\nfunc isDir(path string) bool {\n\tinfo, err := os.Stat(path)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn info.IsDir()\n}\n\n// ScanPackageByImport scans a single Go package identified by its import path.\n//\n// This function resolves the import path to a directory using the Scanner's locator.\n// It then attempts to parse all .go files (excluding _test.go files) in that directory\n// that have not yet been visited by this Scanner instance (`s.visitedFiles`).\n// The selection of files to parse may also be influenced by the state of the\n// symbol cache (`s.symbolCache`), if enabled, to avoid re-parsing unchanged files\n// for which symbol information is already cached and deemed valid.\n//\n// The returned `scanner.PackageInfo` contains information derived from the files\n// parsed or processed in *this specific call*.\n//\n// The result of this call is stored in an in-memory package cache (`s.packageCache`)\n// and is intended to represent the Scanner's current understanding of the package,\n// which might be based on a full parse of unvisited files or a combination of\n// cached data and newly parsed information.\n// The global symbol cache (`s.symbolCache`), if enabled, is updated with symbols\n// from any newly parsed files. Files parsed by this function are marked as visited\n// in `s.visitedFiles`.\nfunc (s *Scanner) ScanPackageByImport(ctx context.Context, importPath string) (*scanner.PackageInfo, error) {\n\ts.mu.RLock()\n\tcachedPkg, found := s.packageCache[importPath]\n\ts.mu.RUnlock()\n\tif found {\n\t\tslog.DebugContext(ctx, \"ScanPackageByImport CACHE HIT\", slog.String(\"importPath\", importPath), slog.Int(\"types\", len(cachedPkg.Types)))\n\t\treturn cachedPkg, nil\n\t}\n\tslog.DebugContext(ctx, \"ScanPackageByImport CACHE MISS\", slog.String(\"importPath\", importPath))\n\n\tloc, err := s.locatorForImportPath(importPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"ScanPackageByImport: %w\", err)\n\t}\n\n\tpkgDirAbs, err := loc.FindPackageDir(importPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not find directory for import path %s: %w\", importPath, err)\n\t}\n\tslog.DebugContext(ctx, \"ScanPackageByImport resolved import path\", slog.String(\"importPath\", importPath), slog.String(\"pkgDirAbs\", pkgDirAbs), slog.String(\"module\", loc.ModulePath()))\n\n\tallGoFilesInPkg, err := listGoFiles(pkgDirAbs, s.IncludeTests)\t// Gets absolute paths\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"ScanPackageByImport: failed to list go files in %s: %w\", pkgDirAbs, err)\n\t}\n\tslog.DebugContext(ctx, \"ScanPackageByImport found .go files\", slog.Int(\"count\", len(allGoFilesInPkg)), slog.String(\"pkgDirAbs\", pkgDirAbs), slog.Any(\"files\", allGoFilesInPkg))\n\n\tif len(allGoFilesInPkg) == 0 {\n\t\t// If a directory for an import path exists but has no .go files, cache an empty PackageInfo.\n\t\tslog.DebugContext(ctx, \"ScanPackageByImport found no .go files. Caching empty PackageInfo.\", slog.String(\"pkgDirAbs\", pkgDirAbs))\n\t\tpkgInfo := &scanner.PackageInfo{Path: pkgDirAbs, ImportPath: importPath, Name: \"\", Fset: s.fset, Files: []string{}, Types: []*scanner.TypeInfo{}}\n\t\ts.mu.Lock()\n\t\ts.packageCache[importPath] = pkgInfo\n\t\ts.mu.Unlock()\n\t\treturn pkgInfo, nil\n\t}\n\n\tvar filesToParseThisCall []string\n\tsymCache, _ := s.getOrCreateSymbolCache(ctx)\t// Error getting cache is not fatal here\n\tslog.DebugContext(ctx, \"ScanPackageByImport symbol cache status\", slog.String(\"importPath\", importPath), slog.Bool(\"enabled\", symCache != nil && symCache.isEnabled()))\n\n\tfilesConsideredBySymCache := make(map[string]struct{})\n\n\tif symCache != nil && symCache.isEnabled() {\n\t\tnewDiskFiles, existingDiskFiles, errSym := symCache.getFilesToScan(ctx, pkgDirAbs)\n\t\tif errSym != nil {\n\t\t\tslog.WarnContext(ctx, \"getFilesToScan failed. Will scan all unvisited files in the package.\", slog.String(\"import_path\", importPath), slog.String(\"package_dir\", pkgDirAbs), slog.Any(\"error\", errSym))\n\t\t\t// Fallback: scan all files in the package that this Scanner instance hasn't visited.\n\t\t\ts.mu.RLock()\n\t\t\tfor _, f := range allGoFilesInPkg {\n\t\t\t\tif _, visited := s.visitedFiles[f]; !visited {\n\t\t\t\t\tfilesToParseThisCall = append(filesToParseThisCall, f)\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.mu.RUnlock()\n\t\t} else {\n\t\t\t// Add files symCache identified as new/changed\n\t\t\tfor _, f := range newDiskFiles {\n\t\t\t\tfilesToParseThisCall = append(filesToParseThisCall, f)\n\t\t\t\tfilesConsideredBySymCache[f] = struct{}{}\n\t\t\t}\n\t\t\t// For files symCache says are existing (potentially unchanged),\n\t\t\t// only parse if this Scanner instance hasn't visited them yet.\n\t\t\ts.mu.RLock()\n\t\t\tfor _, f := range existingDiskFiles {\n\t\t\t\tfilesConsideredBySymCache[f] = struct{}{}\t// Mark as considered\n\t\t\t\tif _, visited := s.visitedFiles[f]; !visited {\n\t\t\t\t\tfilesToParseThisCall = append(filesToParseThisCall, f)\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.mu.RUnlock()\n\t\t}\n\t}\n\n\t// Add any file in the directory not mentioned by symCache (e.g. untracked) if unvisited by this Scanner instance\n\ts.mu.RLock()\n\tfor _, f := range allGoFilesInPkg {\n\t\tif _, considered := filesConsideredBySymCache[f]; !considered {\n\t\t\tif _, visited := s.visitedFiles[f]; !visited {\n\t\t\t\tfilesToParseThisCall = append(filesToParseThisCall, f)\n\t\t\t}\n\t\t}\n\t}\n\ts.mu.RUnlock()\n\n\t// Deduplicate filesToParseThisCall (abs paths, so simple map is fine)\n\tuniqueFilesToParse := make(map[string]struct{})\n\tvar dedupedFilesToParse []string\n\tfor _, f := range filesToParseThisCall {\n\t\tif _, exists := uniqueFilesToParse[f]; !exists {\n\t\t\tuniqueFilesToParse[f] = struct{}{}\n\t\t\tdedupedFilesToParse = append(dedupedFilesToParse, f)\n\t\t}\n\t}\n\tfilesToParseThisCall = dedupedFilesToParse\n\n\tvar currentCallPkgInfo *scanner.PackageInfo\n\tif len(filesToParseThisCall) > 0 {\n\t\t// Heuristic to check if it's a standard library package.\n\t\t// Determine if the package is outside the main module (e.g., in GOROOT or GOMODCACHE).\n\t\t// If so, we must use ScanFilesWithKnownImportPath to prevent incorrect import path derivation.\n\t\tisExternalModule := !strings.HasPrefix(pkgDirAbs, s.RootDir())\n\n\t\tif isExternalModule {\n\t\t\tcurrentCallPkgInfo, err = s.scanner.ScanFilesWithKnownImportPath(ctx, filesToParseThisCall, pkgDirAbs, importPath)\n\t\t} else {\n\t\t\tcurrentCallPkgInfo, err = s.scanner.ScanFiles(ctx, filesToParseThisCall, pkgDirAbs)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"ScanPackageByImport: scanning files for %s failed: %w\", importPath, err)\n\t\t}\n\n\t\tif currentCallPkgInfo != nil {\n\t\t\t// For non-std-lib packages, ScanFiles already calculates the import path.\n\t\t\t// For std-lib, ScanFilesWithKnownImportPath sets it.\n\t\t\t// We can still enforce it here to be safe, or trust the scanner.\n\t\t\t// Let's ensure it's what we expect.\n\t\t\tcurrentCallPkgInfo.ImportPath = importPath\n\t\t\tcurrentCallPkgInfo.Path = pkgDirAbs\t// Ensure path\n\t\t\ts.mu.Lock()\n\t\t\tfor _, fp := range currentCallPkgInfo.Files {\t// Mark newly parsed files as visited by this instance\n\t\t\t\ts.visitedFiles[fp] = struct{}{}\n\t\t\t}\n\t\t\ts.mu.Unlock()\n\t\t\ts.updateSymbolCacheWithPackageInfo(ctx, importPath, currentCallPkgInfo)\t// Update global symbol cache\n\t\t}\n\t}\n\n\t// If no new files were parsed in this call, but the package is not empty,\n\t// it means all files were either already visited or symcache deemed them unchanged & visited.\n\t// We should return a PackageInfo that reflects the package structure.\n\tif currentCallPkgInfo == nil {\n\t\tcurrentCallPkgInfo = &scanner.PackageInfo{\n\t\t\tPath:\t\tpkgDirAbs,\n\t\t\tImportPath:\timportPath,\n\t\t\tName:\t\t\"\",\t// Name might be derivable if any file was ever parsed for this package\n\t\t\tFset:\t\ts.fset,\n\t\t\tFiles:\t\t[]string{},\t// No files *newly* parsed in this call.\n\t\t}\n\t\t// Attempt to set a name if possible from a previously (partially) cached PackageInfo\n\t\t// This is a bit of a workaround for not merging.\n\t\ts.mu.RLock()\n\t\tif prevInfo, ok := s.packageCache[importPath]; ok && prevInfo.Name != \"\" {\n\t\t\tcurrentCallPkgInfo.Name = prevInfo.Name\n\t\t} else if len(allGoFilesInPkg) > 0 {\t// Try to get from any already visited file if no cache\n\t\t\t// This is complex; for now, leave Name blank if not easily found.\n\t\t}\n\t\ts.mu.RUnlock()\n\t}\n\n\t// The PackageInfo cached by ScanPackageByImport should represent the state of the package\n\t// as understood by this call (i.e., including all files parsed up to this point for this package).\n\t// Since \"no merge\" is a principle, the cache stores the result of *this specific call*.\n\t// If this call parsed new files, currentCallPkgInfo has them. If not, it's minimal.\n\t// This means the packageCache might not always have the \"fullest\" possible PackageInfo\n\t// if ScanFiles was used to visit parts of the package before this.\n\t// This is a known trade-off of the \"no merge\" + \"instance-visited\" design.\n\n\ts.mu.Lock()\n\ts.packageCache[importPath] = currentCallPkgInfo\n\ts.mu.Unlock()\n\n\treturn currentCallPkgInfo, nil\n}\n\n// getOrCreateSymbolCache ensures the symbolCache is initialized.\nfunc (s *Scanner) getOrCreateSymbolCache(ctx context.Context) (*symbolCache, error) {\n\tif s.CachePath == \"\" {\n\t\tif s.symbolCache == nil || s.symbolCache.isEnabled() {\n\t\t\trootDir := \"\"\n\t\t\tif s.locator != nil {\n\t\t\t\trootDir = s.locator.RootDir()\n\t\t\t}\n\t\t\tdisabledCache, err := newSymbolCache(rootDir, \"\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to initialize a disabled symbol cache: %w\", err)\n\t\t\t}\n\t\t\ts.symbolCache = disabledCache\n\t\t}\n\t\treturn s.symbolCache, nil\n\t}\n\n\tif s.symbolCache != nil && s.symbolCache.isEnabled() && s.symbolCache.getFilePath() == s.CachePath {\n\t\treturn s.symbolCache, nil\n\t}\n\n\trootDir := \"\"\n\tif s.locator != nil {\n\t\trootDir = s.locator.RootDir()\n\t} else {\n\t\treturn nil, fmt.Errorf(\"scanner locator is not initialized, cannot determine root directory for cache\")\n\t}\n\n\tsc, err := newSymbolCache(rootDir, s.CachePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to initialize symbol cache with path %s: %w\", s.CachePath, err)\n\t}\n\ts.symbolCache = sc\n\n\tif err := s.symbolCache.load(ctx); err != nil {\n\t\tslog.WarnContext(ctx, \"Could not load symbol cache\", slog.String(\"path\", s.symbolCache.getFilePath()), slog.Any(\"error\", err))\n\t}\n\treturn s.symbolCache, nil\n}\n\n// updateSymbolCacheWithPackageInfo updates the symbol cache with information from a given PackageInfo.\n// The pkgInfo provided should typically represent the symbols parsed from a specific set of files\n// in the context of the given importPath.\nfunc (s *Scanner) updateSymbolCacheWithPackageInfo(ctx context.Context, importPath string, pkgInfo *scanner.PackageInfo) {\n\tif s.CachePath == \"\" || pkgInfo == nil || len(pkgInfo.Files) == 0 {\n\t\treturn\n\t}\n\tsymCache, err := s.getOrCreateSymbolCache(ctx)\n\tif err != nil {\n\t\tslog.ErrorContext(ctx, \"Error getting symbol cache for update\", slog.Any(\"error\", err))\n\t\treturn\n\t}\n\tif !symCache.isEnabled() {\n\t\treturn\n\t}\n\n\tsymbolsByFile := make(map[string][]string)\n\taddSymbol := func(symbolName, absFilePath string) {\n\t\tif symbolName != \"\" && absFilePath != \"\" {\n\t\t\t// Ensure absFilePath is truly absolute for consistency\n\t\t\tabsFilePath, _ = filepath.Abs(absFilePath)\t// error unlikely if path came from system\n\t\t\tkey := importPath + \".\" + symbolName\n\t\t\tif err := symCache.setSymbol(key, absFilePath); err != nil {\n\t\t\t\tslog.ErrorContext(ctx, \"Error setting cache for symbol\", slog.String(\"symbol_key\", key), slog.Any(\"error\", err))\n\t\t\t}\n\t\t\tsymbolsByFile[absFilePath] = append(symbolsByFile[absFilePath], symbolName)\n\t\t}\n\t}\n\n\tfor _, typeInfo := range pkgInfo.Types {\n\t\taddSymbol(typeInfo.Name, typeInfo.FilePath)\n\t}\n\tfor _, funcInfo := range pkgInfo.Functions {\n\t\taddSymbol(funcInfo.Name, funcInfo.FilePath)\n\t}\n\tfor _, constInfo := range pkgInfo.Constants {\n\t\taddSymbol(constInfo.Name, constInfo.FilePath)\n\t}\n\n\tfor _, absFilePath := range pkgInfo.Files {\t// These are files that were actually parsed for pkgInfo\n\t\tabsFilePath, _ = filepath.Abs(absFilePath)\t// Ensure absolute\n\t\tif _, err := os.Stat(absFilePath); os.IsNotExist(err) {\n\t\t\tslog.WarnContext(ctx, \"File from pkgInfo.Files not found, skipping for fileMetadata update\", slog.String(\"file\", absFilePath))\n\t\t\tcontinue\n\t\t}\n\t\tfileSymbols := symbolsByFile[absFilePath]\n\t\tif fileSymbols == nil {\n\t\t\tfileSymbols = []string{}\n\t\t}\n\t\tmetadata := fileMetadata{Symbols: fileSymbols}\n\t\tif err := symCache.setFileMetadata(absFilePath, metadata); err != nil {\n\t\t\tslog.ErrorContext(ctx, \"Error setting file metadata\", slog.String(\"file\", absFilePath), slog.Any(\"error\", err))\n\t\t}\n\t}\n}\n\n// SaveSymbolCache saves the symbol cache to disk if CachePath is set.\nfunc (s *Scanner) SaveSymbolCache(ctx context.Context) error {\n\tif s.CachePath == \"\" {\n\t\treturn nil\n\t}\n\tif _, err := s.getOrCreateSymbolCache(ctx); err != nil {\n\t\treturn fmt.Errorf(\"cannot save symbol cache, failed to ensure cache initialization for path %s: %w\", s.CachePath, err)\n\t}\n\tif s.symbolCache != nil && s.symbolCache.isEnabled() {\n\t\tif err := s.symbolCache.save(); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save symbol cache to %s: %w\", s.symbolCache.getFilePath(), err)\n\t\t}\n\t}\n\treturn nil\n}\n\n// ListExportedSymbols scans a package by its import path and returns a list of all\n// its exported top-level symbol names (functions, types, and constants).\nfunc (s *Scanner) ListExportedSymbols(ctx context.Context, pkgPath string) ([]string, error) {\n\tpkgInfo, err := s.ScanPackageByImport(ctx, pkgPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to scan package %s: %w\", pkgPath, err)\n\t}\n\n\tvar exportedSymbols []string\n\n\tfor _, f := range pkgInfo.Functions {\n\t\t// We only care about top-level functions, not methods on types.\n\t\tif f.Receiver == nil && f.AstDecl != nil && f.AstDecl.Name != nil && f.AstDecl.Name.IsExported() {\n\t\t\texportedSymbols = append(exportedSymbols, f.Name)\n\t\t}\n\t}\n\n\tfor _, t := range pkgInfo.Types {\n\t\tif typeSpec, ok := t.Node.(*ast.TypeSpec); ok {\n\t\t\tif typeSpec.Name != nil && typeSpec.Name.IsExported() {\n\t\t\t\texportedSymbols = append(exportedSymbols, t.Name)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, c := range pkgInfo.Constants {\n\t\tif c.IsExported {\n\t\t\texportedSymbols = append(exportedSymbols, c.Name)\n\t\t}\n\t}\n\n\tsort.Strings(exportedSymbols)\n\treturn exportedSymbols, nil\n}\n\n// FindSymbolDefinitionLocation attempts to find the absolute file path where a given symbol is defined.\n// The `symbolFullName` should be in the format \"package/import/path.SymbolName\".\n//\n// It first checks the persistent symbol cache (if enabled and loaded).\n// If not found in the cache, it triggers a scan of the relevant package\n// (using `ScanPackageByImport`) to populate caches and then re-checks.\n// Finally, it inspects the `PackageInfo` obtained from the scan.\nfunc (s *Scanner) FindSymbolDefinitionLocation(ctx context.Context, symbolFullName string) (string, error) {\n\tlastDot := strings.LastIndex(symbolFullName, \".\")\n\tif lastDot == -1 || lastDot == 0 || lastDot == len(symbolFullName)-1 {\n\t\treturn \"\", fmt.Errorf(\"invalid symbol full name format: %q. Expected 'package/import/path.SymbolName'\", symbolFullName)\n\t}\n\timportPath := symbolFullName[:lastDot]\n\tsymbolName := symbolFullName[lastDot+1:]\n\tcacheKey := importPath + \".\" + symbolName\n\n\tif s.CachePath != \"\" {\n\t\tsymCache, err := s.getOrCreateSymbolCache(ctx)\n\t\tif err != nil {\n\t\t\tslog.WarnContext(ctx, \"Could not get symbol cache. Proceeding with full scan.\", slog.String(\"symbol\", symbolFullName), slog.Any(\"error\", err))\n\t\t} else if symCache != nil && symCache.isEnabled() {\n\t\t\tfilePath, found := symCache.verifyAndGet(ctx, cacheKey)\n\t\t\tif found {\n\t\t\t\treturn filePath, nil\n\t\t\t}\n\t\t}\n\t}\n\t// If symbol not found in cache, try to scan the package.\n\tpkgInfo, err := s.ScanPackageByImport(ctx, importPath)\t// This will parse unvisited files and update caches\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"scan for package %s (for symbol %s) failed: %w\", importPath, symbolName, err)\n\t}\n\n\t// After scan, check cache again (if enabled)\n\tif s.CachePath != \"\" {\n\t\tif s.symbolCache != nil && s.symbolCache.isEnabled() {\n\t\t\tfilePath, found := s.symbolCache.get(cacheKey)\t// Get does not need context\n\t\t\tif found {\n\t\t\t\tif _, statErr := os.Stat(filePath); statErr == nil {\n\t\t\t\t\treturn filePath, nil\n\t\t\t\t}\n\t\t\t\tslog.WarnContext(ctx, \"Symbol found in cache after scan, but file does not exist.\", slog.String(\"symbol\", symbolFullName), slog.String(\"path\", filePath))\n\t\t\t}\n\t\t}\n\t}\n\n\t// If still not found via cache, check the pkgInfo returned by the ScanPackageByImport call.\n\t// This pkgInfo contains symbols from files *parsed in that specific call*.\n\tif pkgInfo != nil {\n\t\ttargetFilePath := \"\"\n\t\tfor _, t := range pkgInfo.Types {\n\t\t\tif t.Name == symbolName {\n\t\t\t\ttargetFilePath = t.FilePath\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif targetFilePath == \"\" {\n\t\t\tfor _, f := range pkgInfo.Functions {\n\t\t\t\tif f.Name == symbolName {\n\t\t\t\t\ttargetFilePath = f.FilePath\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif targetFilePath == \"\" {\n\t\t\tfor _, c := range pkgInfo.Constants {\n\t\t\t\tif c.Name == symbolName {\n\t\t\t\t\ttargetFilePath = c.FilePath\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif targetFilePath != \"\" {\n\t\t\tif _, statErr := os.Stat(targetFilePath); statErr == nil {\n\t\t\t\treturn targetFilePath, nil\n\t\t\t}\n\t\t\treturn \"\", fmt.Errorf(\"symbol %s found in package %s at %s by scan, but file does not exist\", symbolName, importPath, targetFilePath)\n\t\t}\n\t}\n\n\treturn \"\", fmt.Errorf(\"symbol %s not found in package %s even after scan and cache check\", symbolName, importPath)\n}\n\n// AllSeenPackages returns a copy of the in-memory cache of all packages\n// that have been scanned or loaded by this scanner instance.\n// This is primarily intended for tools that need to perform analysis\n// across all packages seen during a session, such as the symgo evaluator.\nfunc (s *Scanner) AllSeenPackages() map[string]*Package {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\n\tcopied := make(map[string]*Package, len(s.packageCache))\n\tfor k, v := range s.packageCache {\n\t\tcopied[k] = v\n\t}\n\treturn copied\n}\n\n// FindSymbolInPackage searches for a specific symbol within a package by scanning its files one by one.\n// It only scans files that have not yet been visited by this scanner instance.\n// If the symbol is found, it returns a cumulative PackageInfo of all files scanned in the package up to that point\n// and marks the file as visited. If the symbol is not found after checking all unscanned files, it returns an error.\nfunc (s *Scanner) FindSymbolInPackage(ctx context.Context, importPath string, symbolName string) (*scanner.PackageInfo, error) {\n\tunscannedFiles, err := s.UnscannedGoFiles(importPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not get unscanned files for package %s: %w\", importPath, err)\n\t}\n\n\t// Heuristic to check if it's a standard library package.\n\tisStdLib := !strings.Contains(importPath, \".\")\n\tvar pkgDirAbs string\n\tif isStdLib {\n\t\t// We need the absolute path for ScanFilesWithKnownImportPath\n\t\tpkgDirAbs, err = s.locator.FindPackageDir(importPath)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not find directory for stdlib import path %s: %w\", importPath, err)\n\t\t}\n\t}\n\n\tvar cumulativePkgInfo *scanner.PackageInfo\n\n\tfor _, fileToScan := range unscannedFiles {\n\t\tvar pkgInfo *scanner.PackageInfo\n\t\tvar scanErr error\n\n\t\tif isStdLib {\n\t\t\t// For stdlib packages, we need to bypass the public `ScanFiles` because it cannot\n\t\t\t// calculate the import path for paths outside the module root.\n\t\t\t// We call the internal scanner directly and then manually perform the necessary updates\n\t\t\t// that the public `ScanFiles` would have done (updating visited files and symbol cache).\n\t\t\tpkgInfo, scanErr = s.scanner.ScanFilesWithKnownImportPath(ctx, []string{fileToScan}, pkgDirAbs, importPath)\n\t\t\tif scanErr == nil && pkgInfo != nil {\n\t\t\t\ts.mu.Lock()\n\t\t\t\tfor _, fp := range pkgInfo.Files {\n\t\t\t\t\ts.visitedFiles[fp] = struct{}{}\n\t\t\t\t}\n\t\t\t\ts.mu.Unlock()\n\t\t\t\ts.updateSymbolCacheWithPackageInfo(ctx, importPath, pkgInfo)\n\t\t\t}\n\t\t} else {\n\t\t\t// For in-module packages, the public `ScanFiles` method works correctly.\n\t\t\tpkgInfo, scanErr = s.ScanFiles(ctx, []string{fileToScan})\n\t\t}\n\n\t\tif scanErr != nil {\n\t\t\t// Log the error but continue trying other files. A single file might have syntax errors.\n\t\t\tslog.WarnContext(ctx, \"failed to scan file while searching for symbol\", \"file\", fileToScan, \"symbol\", symbolName, \"error\", scanErr)\n\t\t\tcontinue\n\t\t}\n\n\t\tif pkgInfo == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Merge the just-scanned info into a cumulative PackageInfo for this package.\n\t\tif cumulativePkgInfo == nil {\n\t\t\tcumulativePkgInfo = pkgInfo\n\t\t} else {\n\t\t\t// This is a simplified merge. A more robust implementation would handle conflicts.\n\t\t\tcumulativePkgInfo.Types = append(cumulativePkgInfo.Types, pkgInfo.Types...)\n\t\t\tcumulativePkgInfo.Functions = append(cumulativePkgInfo.Functions, pkgInfo.Functions...)\n\t\t\tcumulativePkgInfo.Constants = append(cumulativePkgInfo.Constants, pkgInfo.Constants...)\n\n\t\t\t// Merge AstFiles and Files lists\n\t\t\tif cumulativePkgInfo.AstFiles == nil {\n\t\t\t\tcumulativePkgInfo.AstFiles = make(map[string]*ast.File)\n\t\t\t}\n\t\t\tfor path, ast := range pkgInfo.AstFiles {\n\t\t\t\tif _, exists := cumulativePkgInfo.AstFiles[path]; !exists {\n\t\t\t\t\tcumulativePkgInfo.AstFiles[path] = ast\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Avoid duplicating file paths\n\t\t\texistingFiles := make(map[string]struct{}, len(cumulativePkgInfo.Files))\n\t\t\tfor _, f := range cumulativePkgInfo.Files {\n\t\t\t\texistingFiles[f] = struct{}{}\n\t\t\t}\n\t\t\tfor _, f := range pkgInfo.Files {\n\t\t\t\tif _, exists := existingFiles[f]; !exists {\n\t\t\t\t\tcumulativePkgInfo.Files = append(cumulativePkgInfo.Files, f)\n\t\t\t\t\texistingFiles[f] = struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif cumulativePkgInfo == nil {\n\t\treturn nil, fmt.Errorf(\"no unscanned files found and symbol %q not in cache for package %q\", symbolName, importPath)\n\t}\n\n\t// Now, check for the symbol in the fully cumulative package info.\n\tfor _, t := range cumulativePkgInfo.Types {\n\t\tif t.Name == symbolName {\n\t\t\treturn cumulativePkgInfo, nil\t// Found it\n\t\t}\n\t}\n\tfor _, f := range cumulativePkgInfo.Functions {\n\t\tif f.Name == symbolName {\n\t\t\treturn cumulativePkgInfo, nil\t// Found it\n\t\t}\n\t}\n\tfor _, c := range cumulativePkgInfo.Constants {\n\t\tif c.Name == symbolName {\n\t\t\treturn cumulativePkgInfo, nil\t// Found it\n\t\t}\n\t}\n\n\treturn nil, fmt.Errorf(\"symbol %q not found in package %q\", symbolName, importPath)\n}\n"
time=2025-09-18T09:43:11.400Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.425Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.425Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.425Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan types=19
time=2025-09-18T09:43:11.425Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.425Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.425Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.426Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/type_relation.go:1:1 source="package goscan\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/podhmo/go-scan/scanner\"\n)\n\n// Implements checks if a struct type implements an interface type.\n// It uses a robust, scanner-based analysis to resolve methods and types,\n// correctly handling pointer/value receivers and embedded types.\nfunc (s *Scanner) Implements(ctx context.Context, structCandidate *scanner.TypeInfo, interfaceDef *scanner.TypeInfo) bool {\n\treturn s.isImplementer(ctx, structCandidate, interfaceDef)\n}\n\n// isImplementer checks if a given concrete type implements an interface.\n// This is ported from the more robust symgo/evaluator.\nfunc (s *Scanner) isImplementer(ctx context.Context, concreteType *scanner.TypeInfo, interfaceType *scanner.TypeInfo) bool {\n\tif concreteType == nil || interfaceType == nil || interfaceType.Interface == nil {\n\t\treturn false\n\t}\n\tif concreteType.Kind != scanner.StructKind {\n\t\treturn false\n\t}\n\tif interfaceType.Kind != scanner.InterfaceKind {\n\t\treturn false\n\t}\n\n\t// Get all methods from the interface, including from embedded interfaces.\n\tallInterfaceMethods := s.getAllInterfaceMethods(ctx, interfaceType, make(map[string]struct{}))\n\n\t// For every method in the complete method set...\n\tfor _, ifaceMethodInfo := range allInterfaceMethods {\n\t\t// ...find a matching method in the concrete type.\n\t\t// A concrete type T can implement an interface method with a *T receiver.\n\t\t// So we need to check both T and *T.\n\t\tconcreteMethodInfo := s.findMethodInfoOnType(ctx, concreteType, ifaceMethodInfo.Name)\n\n\t\tif concreteMethodInfo == nil && !strings.HasPrefix(concreteType.Name, \"*\") {\n\t\t\t// If not found on T, check on *T.\n\t\t\t// Create a synthetic pointer type for the check.\n\t\t\tpointerType := *concreteType\n\t\t\tpointerType.Name = \"*\" + concreteType.Name\n\t\t\tconcreteMethodInfo = s.findMethodInfoOnType(ctx, &pointerType, ifaceMethodInfo.Name)\n\t\t}\n\n\t\tif concreteMethodInfo == nil {\n\t\t\treturn false\t// Method not found\n\t\t}\n\n\t\t// Compare signatures\n\t\tif len(ifaceMethodInfo.Parameters) != len(concreteMethodInfo.Parameters) {\n\t\t\treturn false\n\t\t}\n\t\tif len(ifaceMethodInfo.Results) != len(concreteMethodInfo.Results) {\n\t\t\treturn false\n\t\t}\n\n\t\tfor i, p1 := range ifaceMethodInfo.Parameters {\n\t\t\tp2 := concreteMethodInfo.Parameters[i]\n\t\t\tif !s.fieldTypeEquals(p1.Type, p2.Type) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\tfor i, r1 := range ifaceMethodInfo.Results {\n\t\t\tr2 := concreteMethodInfo.Results[i]\n\t\t\tif !s.fieldTypeEquals(r1.Type, r2.Type) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\n// getAllInterfaceMethods recursively collects all methods from an interface and its embedded interfaces.\n// It handles cycles by keeping track of visited interface types.\nfunc (s *Scanner) getAllInterfaceMethods(ctx context.Context, ifaceType *scanner.TypeInfo, visited map[string]struct{}) []*scanner.MethodInfo {\n\tif ifaceType == nil || ifaceType.Interface == nil {\n\t\treturn nil\n\t}\n\n\t// Cycle detection\n\ttypeName := ifaceType.PkgPath + \".\" + ifaceType.Name\n\tif _, ok := visited[typeName]; ok {\n\t\treturn nil\n\t}\n\tvisited[typeName] = struct{}{}\n\n\tvar allMethods []*scanner.MethodInfo\n\tallMethods = append(allMethods, ifaceType.Interface.Methods...)\n\n\tfor _, embeddedField := range ifaceType.Interface.Embedded {\n\t\tembeddedTypeInfo, err := embeddedField.Resolve(ctx)\n\t\tif err != nil {\n\t\t\ts.Logger.WarnContext(ctx, \"could not resolve embedded interface\", \"type\", embeddedField.String(), \"error\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif embeddedTypeInfo != nil && embeddedTypeInfo.Kind == scanner.InterfaceKind {\n\t\t\t// Recursively get methods from the embedded interface.\n\t\t\tembeddedMethods := s.getAllInterfaceMethods(ctx, embeddedTypeInfo, visited)\n\t\t\tallMethods = append(allMethods, embeddedMethods...)\n\t\t}\n\t}\n\n\treturn allMethods\n}\n\n// fieldTypeEquals compares two FieldType objects for equality.\n// It uses the string representation for a robust comparison of the type structure.\nfunc (s *Scanner) fieldTypeEquals(a, b *scanner.FieldType) bool {\n\tif a == b {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\treturn a.String() == b.String()\n}\n\n// findMethodInfoOnType finds the scanner.FunctionInfo for a method on a type, handling embedding.\n// Ported from symgo/evaluator/accessor.go\nfunc (s *Scanner) findMethodInfoOnType(ctx context.Context, typeInfo *scanner.TypeInfo, methodName string) *scanner.FunctionInfo {\n\tif typeInfo == nil {\n\t\treturn nil\n\t}\n\tvisited := make(map[string]bool)\n\treturn s.findMethodInfoRecursive(ctx, typeInfo, methodName, visited)\n}\n\nfunc (s *Scanner) findMethodInfoRecursive(ctx context.Context, typeInfo *scanner.TypeInfo, methodName string, visited map[string]bool) *scanner.FunctionInfo {\n\tif typeInfo == nil {\n\t\treturn nil\n\t}\n\ttypeKey := fmt.Sprintf(\"%s.%s\", typeInfo.PkgPath, typeInfo.Name)\n\tif visited[typeKey] {\n\t\treturn nil\t// Cycle detected\n\t}\n\tvisited[typeKey] = true\n\n\t// 1. Search for a direct method on the current type.\n\tif methodInfo, err := s.findDirectMethodInfoOnType(ctx, typeInfo, methodName); err == nil && methodInfo != nil {\n\t\treturn methodInfo\n\t}\n\n\t// 2. If not found, search in embedded structs.\n\tif typeInfo.Struct != nil {\n\t\tfor _, field := range typeInfo.Struct.Fields {\n\t\t\tif field.Embedded {\n\t\t\t\tembeddedTypeInfo, _ := field.Type.Resolve(ctx)\n\t\t\t\tif embeddedTypeInfo != nil {\n\t\t\t\t\tif foundMethod := s.findMethodInfoRecursive(ctx, embeddedTypeInfo, methodName, visited); foundMethod != nil {\n\t\t\t\t\t\treturn foundMethod\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\t// Not found\n}\n\nfunc (s *Scanner) findDirectMethodInfoOnType(ctx context.Context, typeInfo *scanner.TypeInfo, methodName string) (*scanner.FunctionInfo, error) {\n\tif typeInfo == nil || typeInfo.PkgPath == \"\" {\n\t\treturn nil, nil\n\t}\n\n\t// Check the scanner's cache first to avoid re-scanning.\n\ts.mu.RLock()\n\tmethodPkg, exists := s.packageCache[typeInfo.PkgPath]\n\ts.mu.RUnlock()\n\n\tif !exists {\n\t\t// If not in cache, use the scanner to get the package info.\n\t\tvar err error\n\t\tmethodPkg, err = s.ScanPackage(ctx, typeInfo.PkgPath)\n\t\tif err != nil {\n\t\t\t// Suppress errors that are expected for certain types (e.g., built-ins, unresolved packages).\n\t\t\tif strings.Contains(err.Error(), \"cannot find package\") || strings.Contains(err.Error(), \"no such file or directory\") {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\ts.Logger.WarnContext(ctx, \"could not load package for method resolution\", \"package\", typeInfo.PkgPath, \"error\", err)\n\t\t\treturn nil, nil\n\t\t}\n\t}\n\n\tfor _, fn := range methodPkg.Functions {\n\t\tif fn.Receiver == nil || fn.Name != methodName {\n\t\t\tcontinue\n\t\t}\n\n\t\trecvTypeName := fn.Receiver.Type.TypeName\n\t\tif recvTypeName == \"\" {\n\t\t\trecvTypeName = fn.Receiver.Type.Name\n\t\t}\n\t\tbaseRecvTypeName := strings.TrimPrefix(recvTypeName, \"*\")\n\t\tbaseTypeName := strings.TrimPrefix(typeInfo.Name, \"*\")\n\n\t\tif baseRecvTypeName == baseTypeName {\n\t\t\treturn fn, nil\n\t\t}\n\t}\n\treturn nil, nil\n}\n"
time=2025-09-18T09:43:11.427Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.427Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.427Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.427Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.429Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/modulewalker.go:1:1 source="package goscan\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"go/token\"\n\t\"io/fs\"\n\t\"log/slog\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/podhmo/go-scan/locator\"\n\t\"github.com/podhmo/go-scan/scanner\"\n)\n\n// Config holds shared configuration and state for both Scanner and ModuleWalker.\n// It is intended to be embedded in both structs.\ntype Config struct {\n\tworkDir\t\t\tstring\n\tlocator\t\t\t*locator.Locator\n\tscanner\t\t\t*scanner.Scanner\t// low-level scanner\n\tfset\t\t\t*token.FileSet\n\tuseGoModuleResolver\tbool\n\tIncludeTests\t\tbool\n\tDryRun\t\t\tbool\n\tInspect\t\t\tbool\n\tLogger\t\t\t*slog.Logger\n\toverlay\t\t\tscanner.Overlay\n}\n\n// ModuleWalker is responsible for lightweight, dependency-focused scanning operations.\n// It primarily deals with parsing package imports and building dependency graphs,\n// without parsing the full details of type and function bodies.\ntype ModuleWalker struct {\n\t*Config\n\tpackageImportsCache\tmap[string]*scanner.PackageImports\n\treverseDepCache\t\tmap[string][]string\n\tmu\t\t\tsync.RWMutex\n}\n\n// ScanPackageImports scans a single Go package identified by its import path,\n// parsing only the package clause and import declarations for efficiency.\n// It returns a lightweight PackageImports struct containing the package name\n// and a list of its direct dependencies.\n// Results are cached in memory for the lifetime of the ModuleWalker instance.\nfunc (w *ModuleWalker) ScanPackageImports(ctx context.Context, importPath string) (*scanner.PackageImports, error) {\n\tw.mu.RLock()\n\tcachedPkg, found := w.packageImportsCache[importPath]\n\tw.mu.RUnlock()\n\tif found {\n\t\tslog.DebugContext(ctx, \"ScanPackageImports CACHE HIT\", slog.String(\"importPath\", importPath))\n\t\treturn cachedPkg, nil\n\t}\n\tslog.DebugContext(ctx, \"ScanPackageImports CACHE MISS\", slog.String(\"importPath\", importPath))\n\n\tpkgDirAbs, err := w.locator.FindPackageDir(importPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not find directory for import path %s: %w\", importPath, err)\n\t}\n\n\tallGoFilesInPkg, err := listGoFilesForWalker(pkgDirAbs, w.IncludeTests)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"ScanPackageImports: failed to list go files in %s: %w\", pkgDirAbs, err)\n\t}\n\n\tif len(allGoFilesInPkg) == 0 {\n\t\t// If a directory for an import path exists but has no .go files, cache an empty PackageImports.\n\t\tpkgInfo := &scanner.PackageImports{\n\t\t\tImportPath:\timportPath,\n\t\t\tName:\t\tfilepath.Base(pkgDirAbs),\t// Best guess for name\n\t\t\tImports:\t[]string{},\n\t\t}\n\t\tw.mu.Lock()\n\t\tw.packageImportsCache[importPath] = pkgInfo\n\t\tw.mu.Unlock()\n\t\treturn pkgInfo, nil\n\t}\n\n\tpkgImports, err := w.scanner.ScanPackageImports(ctx, allGoFilesInPkg, pkgDirAbs, importPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"ScanPackageImports: scanning imports for %s failed: %w\", importPath, err)\n\t}\n\n\tw.mu.Lock()\n\tw.packageImportsCache[importPath] = pkgImports\n\tw.mu.Unlock()\n\n\treturn pkgImports, nil\n}\n\n// FindImporters scans the entire module to find packages that import the targetImportPath.\n// It performs an efficient, imports-only scan of all potential package directories in the module.\n// The result is a list of packages that have a direct dependency on the target.\nfunc (w *ModuleWalker) FindImporters(ctx context.Context, targetImportPath string) ([]*PackageImports, error) {\n\trootDir := w.locator.RootDir()\n\tmodulePath := w.locator.ModulePath()\n\n\tif rootDir == \"\" {\n\t\treturn nil, fmt.Errorf(\"module root directory not found, cannot perform reverse dependency search\")\n\t}\n\n\tvar importers []*PackageImports\n\n\terr := filepath.WalkDir(rootDir, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !d.IsDir() {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Skip hidden directories and vendor\n\t\tif d.Name() == \"vendor\" || (len(d.Name()) > 1 && d.Name()[0] == '.') {\n\t\t\treturn filepath.SkipDir\n\t\t}\n\n\t\t// path is a directory. Let's see if it's a package.\n\t\t// We can check for .go files inside it.\n\t\tgoFiles, err := listGoFilesForWalker(path, w.IncludeTests)\t// listGoFiles is an existing helper in goscan.go\n\t\tif err != nil {\n\t\t\tslog.WarnContext(ctx, \"could not list go files in directory, skipping\", slog.String(\"path\", path), slog.Any(\"error\", err))\n\t\t\treturn nil\t// continue walking\n\t\t}\n\n\t\tif len(goFiles) == 0 {\n\t\t\treturn nil\t// Not a package, continue\n\t\t}\n\n\t\t// We have a package. Determine its import path.\n\t\trelPath, err := filepath.Rel(rootDir, path)\n\t\tif err != nil {\n\t\t\tslog.WarnContext(ctx, \"could not determine relative path for package, skipping\", slog.String(\"path\", path), slog.Any(\"error\", err))\n\t\t\treturn nil\t// Continue walking\n\t\t}\n\n\t\tcurrentPkgImportPath := filepath.ToSlash(filepath.Join(modulePath, relPath))\n\t\tif relPath == \".\" {\n\t\t\tcurrentPkgImportPath = modulePath\n\t\t}\n\n\t\t// Now we can use the existing efficient scanner method.\n\t\tpkgImports, err := w.ScanPackageImports(ctx, currentPkgImportPath)\n\t\tif err != nil {\n\t\t\tslog.WarnContext(ctx, \"failed to scan package imports, skipping\", \"importPath\", currentPkgImportPath, \"error\", err)\n\t\t\treturn nil\t// continue\n\t\t}\n\n\t\t// Check if it imports our target\n\t\tfor _, imp := range pkgImports.Imports {\n\t\t\tif imp == targetImportPath {\n\t\t\t\timporters = append(importers, pkgImports)\n\t\t\t\tbreak\t// Found it, no need to check other imports\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error walking module directory for importers: %w\", err)\n\t}\n\n\t// Sort for deterministic output\n\tsort.Slice(importers, func(i, j int) bool {\n\t\treturn importers[i].ImportPath < importers[j].ImportPath\n\t})\n\n\treturn importers, nil\n}\n\n// FindImportersAggressively scans the module using `git grep` to quickly find files\n// that likely import the targetImportPath, then confirms them. This can be much\n// faster than walking the entire directory structure in large repositories.\n// A git repository is required.\nfunc (w *ModuleWalker) FindImportersAggressively(ctx context.Context, targetImportPath string) ([]*PackageImports, error) {\n\trootDir := w.locator.RootDir()\n\tmodulePath := w.locator.ModulePath()\n\n\tif rootDir == \"\" {\n\t\treturn nil, fmt.Errorf(\"module root directory not found, cannot perform aggressive reverse dependency search\")\n\t}\n\n\t// Pattern to find import statements. We just look for the quoted import path.\n\t// This is a broad but effective pattern for `git grep`, as the results are\n\t// verified by a proper Go parser anyway. This correctly handles both\n\t// `import \"...\"` and `import ( ... \"...\" ... )` forms.\n\tpattern := fmt.Sprintf(`\"%s\"`, targetImportPath)\n\n\tcmd := exec.CommandContext(ctx, \"git\", \"grep\", \"-l\", \"-F\", pattern, \"--\", \"*.go\")\n\tcmd.Dir = rootDir\n\tvar stdout, stderr bytes.Buffer\n\tcmd.Stdout = &stdout\n\tcmd.Stderr = &stderr\n\n\tslog.DebugContext(ctx, \"executing git grep\", slog.String(\"dir\", cmd.Dir), slog.Any(\"args\", cmd.Args))\n\n\tif err := cmd.Run(); err != nil {\n\t\t// git grep exits with 1 if no matches are found, which is not an error for us.\n\t\tif exitErr, ok := err.(*exec.ExitError); ok && exitErr.ExitCode() == 1 {\n\t\t\t// No files found, return empty list.\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"git grep failed: %w\\n%s\", err, stderr.String())\n\t}\n\n\tpotentialFiles := strings.Split(strings.TrimSpace(stdout.String()), \"\\n\")\n\tif len(potentialFiles) == 0 || (len(potentialFiles) == 1 && potentialFiles[0] == \"\") {\n\t\treturn nil, nil\t// No matches\n\t}\n\n\t// Group files by directory (package)\n\tpackagesToScan := make(map[string]struct{})\n\tfor _, fileRelPath := range potentialFiles {\n\t\tif fileRelPath == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tdir := filepath.Dir(fileRelPath)\n\t\tpackagesToScan[dir] = struct{}{}\n\t}\n\n\tvar importers []*PackageImports\n\tfor relDir := range packagesToScan {\n\t\tvar currentPkgImportPath string\n\t\tif relDir == \".\" {\n\t\t\tcurrentPkgImportPath = modulePath\n\t\t} else {\n\t\t\tcurrentPkgImportPath = filepath.ToSlash(filepath.Join(modulePath, relDir))\n\t\t}\n\n\t\t// Now we can use the existing efficient scanner method to confirm.\n\t\tpkgImports, err := w.ScanPackageImports(ctx, currentPkgImportPath)\n\t\tif err != nil {\n\t\t\tslog.WarnContext(ctx, \"failed to scan potential importer package, skipping\", \"importPath\", currentPkgImportPath, \"error\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check if it really imports our target\n\t\tfor _, imp := range pkgImports.Imports {\n\t\t\tif imp == targetImportPath {\n\t\t\t\timporters = append(importers, pkgImports)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Sort for deterministic output\n\tsort.Slice(importers, func(i, j int) bool {\n\t\treturn importers[i].ImportPath < importers[j].ImportPath\n\t})\n\n\treturn importers, nil\n}\n\n// BuildReverseDependencyMap scans the entire module to build a map of reverse dependencies.\n// The key of the map is an import path, and the value is a list of packages that import it.\n// The result is cached within the scanner instance.\nfunc (w *ModuleWalker) BuildReverseDependencyMap(ctx context.Context) (map[string][]string, error) {\n\tw.mu.RLock()\n\tif w.reverseDepCache != nil {\n\t\tw.mu.RUnlock()\n\t\treturn w.reverseDepCache, nil\n\t}\n\tw.mu.RUnlock()\n\n\trootDir := w.locator.RootDir()\n\tmodulePath := w.locator.ModulePath()\n\n\tif rootDir == \"\" {\n\t\treturn nil, fmt.Errorf(\"module root directory not found, cannot build reverse dependency map\")\n\t}\n\n\treverseDeps := make(map[string][]string)\n\n\terr := filepath.WalkDir(rootDir, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !d.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tif d.Name() == \"vendor\" || (len(d.Name()) > 1 && d.Name()[0] == '.') {\n\t\t\treturn filepath.SkipDir\n\t\t}\n\t\tgoFiles, err := listGoFilesForWalker(path, w.IncludeTests)\n\t\tif err != nil {\n\t\t\tslog.WarnContext(ctx, \"could not list go files in directory, skipping\", \"path\", path, \"error\", err)\n\t\t\treturn nil\n\t\t}\n\t\tif len(goFiles) == 0 {\n\t\t\treturn nil\n\t\t}\n\t\trelPath, err := filepath.Rel(rootDir, path)\n\t\tif err != nil {\n\t\t\tslog.WarnContext(ctx, \"could not determine relative path for package, skipping\", \"path\", path, \"error\", err)\n\t\t\treturn nil\n\t\t}\n\t\tcurrentPkgImportPath := filepath.ToSlash(filepath.Join(modulePath, relPath))\n\t\tif relPath == \".\" {\n\t\t\tcurrentPkgImportPath = modulePath\n\t\t}\n\t\tpkgImports, err := w.ScanPackageImports(ctx, currentPkgImportPath)\n\t\tif err != nil {\n\t\t\tslog.WarnContext(ctx, \"failed to scan package imports, skipping\", \"importPath\", currentPkgImportPath, \"error\", err)\n\t\t\treturn nil\n\t\t}\n\t\tfor _, imp := range pkgImports.Imports {\n\t\t\treverseDeps[imp] = append(reverseDeps[imp], currentPkgImportPath)\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error walking module directory for reverse dependency map: %w\", err)\n\t}\n\n\t// Sort for deterministic output\n\tfor _, importers := range reverseDeps {\n\t\tsort.Strings(importers)\n\t}\n\n\tw.mu.Lock()\n\tw.reverseDepCache = reverseDeps\n\tw.mu.Unlock()\n\n\treturn reverseDeps, nil\n}\n\n// Walk performs a dependency graph traversal starting from a set of root packages\n// identified by the input patterns.\n// It uses the efficient ScanPackageImports method to fetch dependencies at each step.\n// The provided Visitor's Visit method is called for each discovered package,\n// allowing the caller to inspect the package and control which of its dependencies\n// are followed next.\n// Patterns can include the `...` wildcard to specify all packages under a directory.\nfunc (w *ModuleWalker) Walk(ctx context.Context, visitor Visitor, patterns ...string) error {\n\tinitialQueue, err := w.resolvePatternsToImportPaths(ctx, patterns)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not resolve initial patterns for walk: %w\", err)\n\t}\n\n\tqueue := initialQueue\n\tvisited := make(map[string]struct{})\n\n\tfor len(queue) > 0 {\n\t\tcurrentImportPath := queue[0]\n\t\tqueue = queue[1:]\n\n\t\tif _, ok := visited[currentImportPath]; ok {\n\t\t\tcontinue\n\t\t}\n\t\tvisited[currentImportPath] = struct{}{}\n\n\t\tpkgImports, err := w.ScanPackageImports(ctx, currentImportPath)\n\t\tif err != nil {\n\t\t\t// For a visualization tool, it might be better to log and continue.\n\t\t\t// However, for a generic utility, failing fast is safer.\n\t\t\treturn fmt.Errorf(\"error scanning imports for %s: %w\", currentImportPath, err)\n\t\t}\n\n\t\timportsToFollow, err := visitor.Visit(pkgImports)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"visitor failed for package %s: %w\", currentImportPath, err)\n\t\t}\n\n\t\tfor _, imp := range importsToFollow {\n\t\t\tif _, ok := visited[imp]; !ok {\n\t\t\t\tqueue = append(queue, imp)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// resolvePatternsToImportPaths resolves filesystem patterns (including `...` wildcards)\n// into a list of unique, sorted Go import paths.\nfunc (w *ModuleWalker) resolvePatternsToImportPaths(ctx context.Context, patterns []string) ([]string, error) {\n\trootPaths := make(map[string]struct{})\n\n\tfor _, pattern := range patterns {\n\t\tif strings.Contains(pattern, \"...\") {\n\t\t\tbaseDir := strings.TrimSuffix(pattern, \"...\")\n\t\t\tbaseDir = strings.TrimSuffix(baseDir, \"/\")\n\n\t\t\tabsBasePath := baseDir\n\t\t\tif !filepath.IsAbs(baseDir) {\n\t\t\t\tabsBasePath = filepath.Join(w.workDir, baseDir)\n\t\t\t}\n\n\t\t\twalkErr := filepath.WalkDir(absBasePath, func(path string, d fs.DirEntry, err error) error {\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif !d.IsDir() {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\t// Check if the directory contains any .go files.\n\t\t\t\tok, err := hasGoFiles(path)\n\t\t\t\tif err != nil {\n\t\t\t\t\tslog.DebugContext(ctx, \"cannot check for go files, skipping\", \"path\", path, \"error\", err)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\n\t\t\t\tif ok {\n\t\t\t\t\timportPath, err := w.locator.PathToImport(path)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tslog.WarnContext(ctx, \"could not resolve import path, skipping\", \"path\", path, \"error\", err)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t\trootPaths[importPath] = struct{}{}\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tif walkErr != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error walking for pattern %q: %w\", pattern, walkErr)\n\t\t\t}\n\t\t} else {\n\t\t\t// Assume non-wildcard patterns are literal import paths.\n\t\t\trootPaths[pattern] = struct{}{}\n\t\t}\n\t}\n\n\t// Convert map to slice for the queue\n\tpathList := make([]string, 0, len(rootPaths))\n\tfor path := range rootPaths {\n\t\tpathList = append(pathList, path)\n\t}\n\tsort.Strings(pathList)\t// Sort for deterministic walk start\n\treturn pathList, nil\n}\n\nfunc hasGoFiles(dirPath string) (bool, error) {\n\tentries, err := os.ReadDir(dirPath)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tfor _, entry := range entries {\n\t\tif !entry.IsDir() && strings.HasSuffix(entry.Name(), \".go\") {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\treturn false, nil\n}\n\n// listGoFilesForWalker lists all .go files in a directory.\n// If includeTests is false, it excludes _test.go files.\n// It returns a list of absolute file paths.\nfunc listGoFilesForWalker(dirPath string, includeTests bool) ([]string, error) {\n\tvar files []string\n\tentries, err := os.ReadDir(dirPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"listGoFiles: failed to read dir %s: %w\", dirPath, err)\n\t}\n\tfor _, entry := range entries {\n\t\tname := entry.Name()\n\t\tif entry.IsDir() || !strings.HasSuffix(name, \".go\") {\n\t\t\tcontinue\n\t\t}\n\t\tif !includeTests && strings.HasSuffix(name, \"_test.go\") {\n\t\t\tcontinue\n\t\t}\n\n\t\tabsPath, err := filepath.Abs(filepath.Join(dirPath, name))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"listGoFiles: could not get absolute path for %s: %w\", name, err)\n\t\t}\n\t\tfiles = append(files, absPath)\n\t}\n\treturn files, nil\n}\n"
time=2025-09-18T09:43:11.430Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.430Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.430Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.430Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.431Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/writer.go:1:1 source="package goscan\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"go/format\"\n\t\"log/slog\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// GoFile represents a Go source file to be generated.\ntype GoFile struct {\n\tPackageName\tstring\t// PackageName is the name of the package (e.g., \"main\", \"models\").\n\t// Imports is a map of import path to alias.\n\t// If an alias is not needed, the alias should be an empty string.\n\t// Example:\n\t//   Imports = map[string]string{\n\t//     \"fmt\": \"\", // for `import \"fmt\"`\n\t//     \"custom_errors\": \"errors\", // for `import errors \"custom_errors\"`\n\t//     \"github.com/pkg/errors\": \"\", // for `import \"github.com/pkg/errors\"`\n\t//   }\n\tImports\tmap[string]string\n\tCodeSet\tstring\t// CodeSet is the body of the Go code to be generated.\n}\n\n// PackageDirectory represents a directory where Go files will be saved.\ntype PackageDirectory struct {\n\tPath\t\t\tstring\t// Path is the directory path of the package.\n\tDefaultPackageName\tstring\t// DefaultPackageName is used if GoFile.PackageName is empty.\n\tOverwrite\t\tbool\t// Overwrite specifies if existing files should be overwritten. Defaults to true.\n}\n\n// NewPackageDirectory creates a new PackageDirectory with default Overwrite behavior (true).\nfunc NewPackageDirectory(path string, defaultPackageName string) *PackageDirectory {\n\treturn &PackageDirectory{\n\t\tPath:\t\t\tpath,\n\t\tDefaultPackageName:\tdefaultPackageName,\n\t\tOverwrite:\t\ttrue,\t// Default to true\n\t}\n}\n\n// SaveGoFile generates and saves a Go source file.\n// It formats the source code and handles imports.\n// filename is the complete name of the file to be saved (e.g., \"models_deriving.go\").\nfunc (pd *PackageDirectory) SaveGoFile(ctx context.Context, gf GoFile, filename string) error {\n\tpkgName := gf.PackageName\n\tif pkgName == \"\" {\n\t\tpkgName = pd.DefaultPackageName\n\t}\n\tif pkgName == \"\" {\n\t\treturn fmt.Errorf(\"package name is empty and no default package name is set in PackageDirectory\")\n\t}\n\n\tif filename == \"\" {\n\t\treturn fmt.Errorf(\"filename cannot be empty\")\n\t}\n\tif !strings.HasSuffix(filename, \".go\") {\n\t\treturn fmt.Errorf(\"filename must end with .go: %s\", filename)\n\t}\n\tif strings.HasPrefix(filename, \"_\") {\t// Conventionally, files starting with _ or . are ignored by go build\n\t\tslog.WarnContext(ctx, \"Generated filename starts with an underscore, which might be ignored by go tools\", slog.String(\"filename\", filename))\n\t}\n\n\tfullOutputPath := filepath.Join(pd.Path, filename)\n\n\t// Check if file exists and if overwrite is allowed\n\tif !pd.Overwrite {\n\t\tif _, err := os.Stat(fullOutputPath); err == nil {\n\t\t\treturn fmt.Errorf(\"file %s already exists and overwrite is disabled\", fullOutputPath)\n\t\t} else if !os.IsNotExist(err) {\n\t\t\treturn fmt.Errorf(\"failed to check if file %s exists: %w\", fullOutputPath, err)\n\t\t}\n\t}\n\n\tvar finalOutput bytes.Buffer\n\tfinalOutput.WriteString(fmt.Sprintf(\"// Code generated by go-scan for package %s. DO NOT EDIT.\\n\\n\", pkgName))\n\tfinalOutput.WriteString(fmt.Sprintf(\"package %s\\n\\n\", pkgName))\n\n\tif len(gf.Imports) > 0 {\n\t\tfinalOutput.WriteString(\"import (\\n\")\n\t\t// Sort imports by path for consistent output\n\t\timportPaths := make([]string, 0, len(gf.Imports))\n\t\tfor path := range gf.Imports {\n\t\t\timportPaths = append(importPaths, path)\n\t\t}\n\t\tsort.Strings(importPaths)\n\n\t\tfor _, importPath := range importPaths {\n\t\t\talias := gf.Imports[importPath]\n\t\t\tif alias != \"\" {\n\t\t\t\tfinalOutput.WriteString(fmt.Sprintf(\"\\t%s \\\"%s\\\"\\n\", alias, importPath))\n\t\t\t} else {\n\t\t\t\tfinalOutput.WriteString(fmt.Sprintf(\"\\t\\\"%s\\\"\\n\", importPath))\n\t\t\t}\n\t\t}\n\t\tfinalOutput.WriteString(\")\\n\\n\")\n\t}\n\n\tfinalOutput.WriteString(gf.CodeSet)\n\n\tformattedCode, err := format.Source(finalOutput.Bytes())\n\tif err != nil {\n\t\t// Log the unformatted code for debugging if formatting fails\n\t\tslog.ErrorContext(ctx, \"Failed to format generated code\",\n\t\t\tslog.String(\"package\", pkgName),\n\t\t\tslog.String(\"path\", fullOutputPath),\n\t\t\tslog.Any(\"error\", err),\n\t\t\tslog.String(\"unformatted_code\", finalOutput.String()),\t// Be cautious with large code strings\n\t\t)\n\t\treturn fmt.Errorf(\"failed to format generated code for package %s (file: %s): %w. Unformatted code logged.\", pkgName, filename, err)\n\t}\n\n\t// Ensure the directory exists\n\tif err := os.MkdirAll(pd.Path, 0755); err != nil {\n\t\treturn fmt.Errorf(\"failed to create directory %s: %w\", pd.Path, err)\n\t}\n\n\t// Remove existing file before writing if Overwrite is true\n\tif pd.Overwrite {\n\t\tif _, statErr := os.Stat(fullOutputPath); statErr == nil {\t// File exists\n\t\t\tif removeErr := os.Remove(fullOutputPath); removeErr != nil {\n\t\t\t\tslog.WarnContext(ctx, \"Failed to remove existing generated file before writing\", slog.String(\"path\", fullOutputPath), slog.Any(\"error\", removeErr))\n\t\t\t\t// Continue, as WriteFile will likely truncate or overwrite.\n\t\t\t}\n\t\t}\n\t}\n\n\tif err := WriteFile(ctx, fullOutputPath, formattedCode, 0644); err != nil {\n\t\treturn fmt.Errorf(\"failed to write generated code to %s: %w\", fullOutputPath, err)\n\t}\n\tslog.InfoContext(ctx, \"Generated code written\", slog.String(\"path\", fullOutputPath))\n\treturn nil\n}\n\n// ContextKey is a private type for context keys to avoid collisions.\ntype ContextKey string\n\nconst (\n\t// FileWriterKey is the context key for the file writer interceptor.\n\tFileWriterKey = ContextKey(\"fileWriter\")\n)\n\n// FileWriter is an interface for writing files, allowing for interception during tests.\ntype FileWriter interface {\n\tWriteFile(ctx context.Context, path string, data []byte, perm os.FileMode) error\n}\n\n// defaultFileWriter is the default implementation of FileWriter that writes to the filesystem.\ntype defaultFileWriter struct{}\n\nfunc (w *defaultFileWriter) WriteFile(ctx context.Context, path string, data []byte, perm os.FileMode) error {\n\treturn os.WriteFile(path, data, perm)\n}\n\n// WriteFile is a context-aware file writing function.\n// It checks the context for a FileWriter and uses it if available.\n// Otherwise, it falls back to os.WriteFile.\nfunc WriteFile(ctx context.Context, path string, data []byte, perm os.FileMode) error {\n\tif writer, ok := ctx.Value(FileWriterKey).(FileWriter); ok {\n\t\treturn writer.WriteFile(ctx, path, data, perm)\n\t}\n\treturn os.WriteFile(path, data, perm)\n}\n"
time=2025-09-18T09:43:11.431Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.431Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.431Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.431Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.435Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/cache.go:1:1 source="package goscan\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\t// Added\n\t\"sync\"\n\t// \"time\" // Removed: No longer needed after ModTime removal from fileMetadata\n)\n\n// fileMetadata stores metadata about a cached file.\ntype fileMetadata struct {\n\t// ModTime time.Time `json:\"mod_time\"` // Removed as per user feedback\n\tSymbols []string `json:\"symbols\"`\n}\n\n// cacheContent holds all data that is serialized to the cache file.\ntype cacheContent struct {\n\tSymbols\tmap[string]string\t`json:\"symbols\"`\t// Key: \"<pkg_path>.<symbol_name>\", Value: \"relative_filepath\"\n\tFiles\tmap[string]fileMetadata\t`json:\"files\"`\t\t// Key: \"relative_filepath\", Value: fileMetadata\n}\n\n// symbolCache manages the symbol definition cache.\n// It is responsible for loading, saving, and providing access to cached symbol locations and file metadata.\ntype symbolCache struct {\n\tmu\tsync.RWMutex\n\t// cacheData map[string]string // Key: \"<pkg_path>.<symbol_name>\", Value: \"filepath\" // Replaced by content.Symbols\n\t// fileCacheData map[string]fileMetadata // Key: \"relative_filepath\", Value: fileMetadata // Replaced by content.Files\n\tcontent\t\tcacheContent\n\tfilePath\tstring\n\tuseCache\tbool\n\trootDir\t\tstring\t// Project root directory, used to make filepaths relative\n}\n\n// newSymbolCache creates a new symbolCache.\n//\n// rootDir is the project's root directory. Filepaths in the cache will be relative to this directory.\n// configCachePath is the user-configured path for the cache file. If empty, caching is disabled.\nfunc newSymbolCache(rootDir string, configCachePath string) (*symbolCache, error) {\t// Removed configUseCache\n\tsc := &symbolCache{\n\t\tcontent: cacheContent{\n\t\t\tSymbols:\tmake(map[string]string),\n\t\t\tFiles:\t\tmake(map[string]fileMetadata),\n\t\t},\n\t\trootDir:\trootDir,\n\t\t// filePath and useCache will be set based on configCachePath\n\t}\n\n\tif configCachePath == \"\" {\n\t\tsc.useCache = false\n\t\tsc.filePath = \"\"\t// Ensure filePath is empty if no path is provided\n\t\treturn sc, nil\t\t// Caching is disabled, no further setup needed for path\n\t}\n\n\t// If configCachePath is provided, caching is considered enabled\n\tsc.useCache = true\n\tsc.filePath = configCachePath\n\n\treturn sc, nil\n}\n\n// load loads the cache data from the file if useCache is true.\n// If the file does not exist, it's not an error; an empty cache will be used.\nfunc (sc *symbolCache) load(ctx context.Context) error {\n\tif !sc.useCache || sc.filePath == \"\" {\n\t\treturn nil\t// Do nothing if cache is disabled or path is not set\n\t}\n\n\tsc.mu.Lock()\n\tdefer sc.mu.Unlock()\n\n\tdata, err := os.ReadFile(sc.filePath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tsc.content = cacheContent{\t// Initialize with empty maps\n\t\t\t\tSymbols:\tmake(map[string]string),\n\t\t\t\tFiles:\t\tmake(map[string]fileMetadata),\n\t\t\t}\n\t\t\treturn nil\t// File not existing is not an error, just means no cache yet\n\t\t}\n\t\treturn fmt.Errorf(\"failed to read cache file %s: %w\", sc.filePath, err)\n\t}\n\n\tif len(data) == 0 {\t// Handle empty file case\n\t\tsc.content = cacheContent{\t// Initialize with empty maps\n\t\t\tSymbols:\tmake(map[string]string),\n\t\t\tFiles:\t\tmake(map[string]fileMetadata),\n\t\t}\n\t\treturn nil\n\t}\n\n\tvar newContent cacheContent\n\terr = json.Unmarshal(data, &newContent)\n\tif err != nil {\n\t\t// If unmarshaling fails, treat it as a corrupted cache and start fresh\n\t\tslog.WarnContext(ctx, \"Failed to unmarshal cache file, starting with an empty cache\", slog.String(\"path\", sc.filePath), slog.Any(\"error\", err))\n\t\tsc.content = cacheContent{\t// Initialize with empty maps\n\t\t\tSymbols:\tmake(map[string]string),\n\t\t\tFiles:\t\tmake(map[string]fileMetadata),\n\t\t}\n\t\treturn nil\t// Return nil to allow the program to continue with an empty cache\n\t}\n\tsc.content = newContent\n\t// Ensure maps are not nil if JSON had them as null\n\tif sc.content.Symbols == nil {\n\t\tsc.content.Symbols = make(map[string]string)\n\t}\n\tif sc.content.Files == nil {\n\t\tsc.content.Files = make(map[string]fileMetadata)\n\t}\n\treturn nil\n}\n\n// save saves the current cache data to the file if useCache is true.\nfunc (sc *symbolCache) save() error {\n\tif !sc.useCache || sc.filePath == \"\" {\n\t\treturn nil\t// Do nothing if cache is disabled or path is not set\n\t}\n\n\tsc.mu.RLock()\n\t// Create a deep copy of content to marshal, to avoid holding lock during MarshalIndent\n\tcontentToSave := cacheContent{\n\t\tSymbols:\tmake(map[string]string, len(sc.content.Symbols)),\n\t\tFiles:\t\tmake(map[string]fileMetadata, len(sc.content.Files)),\n\t}\n\tfor k, v := range sc.content.Symbols {\n\t\tcontentToSave.Symbols[k] = v\n\t}\n\tfor k, v := range sc.content.Files {\n\t\tcontentToSave.Files[k] = v\t// fileMetadata is a struct, so direct assignment is a copy\n\t}\n\tsc.mu.RUnlock()\t// Unlock RLock before potential write operations (MarshalIndent, MkdirAll, WriteFile)\n\n\t// Marshal even if maps are empty to produce \"{}\" or {\"symbols\":{}, \"files\":{}}\n\tdata, err := json.MarshalIndent(contentToSave, \"\", \"  \")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal cache data: %w\", err)\n\t}\n\n\t// Ensure the directory exists\n\tdir := filepath.Dir(sc.filePath)\n\t// Check if directory exists before trying to create it\n\tif _, statErr := os.Stat(dir); os.IsNotExist(statErr) {\n\t\t// MkdirAll also handles the case where the path already exists as a directory\n\t\terr = os.MkdirAll(dir, 0750)\t// Read/write/execute for user, read/execute for group\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to create cache directory %s: %w\", dir, err)\n\t\t}\n\t} else if statErr != nil {\n\t\t// Some other error occurred when stating the directory\n\t\treturn fmt.Errorf(\"failed to stat cache directory %s: %w\", dir, statErr)\n\t}\n\n\terr = os.WriteFile(sc.filePath, data, 0640)\t// Read/write for user, read for group\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to write cache file %s: %w\", sc.filePath, err)\n\t}\n\treturn nil\n}\n\n// get retrieves a filepath for a given symbol key.\n// The key is typically \"<package_import_path>.<SymbolName>\".\n// Returns the filepath and true if found, otherwise an empty string and false.\n// The returned filepath is an absolute path.\nfunc (sc *symbolCache) get(key string) (string, bool) {\n\tif !sc.useCache {\n\t\treturn \"\", false\n\t}\n\n\tsc.mu.RLock()\n\tdefer sc.mu.RUnlock()\n\n\trelativePath, found := sc.content.Symbols[key]\n\tif !found {\n\t\treturn \"\", false\n\t}\n\t// Cache stores relative paths, convert to absolute before returning\n\tif filepath.IsAbs(relativePath) {\t// Should not happen if saved correctly\n\t\treturn relativePath, true\t// Should be logged as a warning or fixed upon load\n\t}\n\treturn filepath.Join(sc.rootDir, relativePath), true\n}\n\n// setSymbol stores a filepath for a given symbol key.\n// The key is typically \"<package_import_path>.<SymbolName>\".\n// The filepath should be an absolute path; it will be converted to relative before storing.\nfunc (sc *symbolCache) setSymbol(key string, absoluteFilepath string) error {\n\tif !sc.useCache {\n\t\treturn nil\n\t}\n\n\tsc.mu.Lock()\n\tdefer sc.mu.Unlock()\n\n\tif sc.rootDir == \"\" {\n\t\treturn fmt.Errorf(\"rootDir is empty in symbolCache, cannot set symbol key %s. symbolCache must be initialized with a valid rootDir\", key)\n\t}\n\tif !filepath.IsAbs(absoluteFilepath) {\n\t\treturn fmt.Errorf(\"filepath to cache for symbol must be absolute, got %s for key %s\", absoluteFilepath, key)\n\t}\n\n\trelativeFilepath, err := sc.makeRelative(absoluteFilepath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to make filepath relative for symbol key %s: %w\", key, err)\n\t}\n\n\tsc.content.Symbols[key] = relativeFilepath\n\t// Also update the file's symbol list in fileCacheData\n\t// This assumes that when a symbol is set, its containing file's metadata should also be updated or created.\n\t// It might be better to have a separate mechanism for updating fileMetadata if symbols can be added without a full file rescan.\n\t// For now, let's ensure the file metadata knows about this symbol.\n\t// This part is tricky: setSymbol might be called without full fileMetadata (ModTime, all other symbols).\n\t// It's safer to manage fileMetadata.Symbols when fileMetadata is explicitly set via setFileMetadata.\n\t// So, we will *not* modify sc.content.Files[relativeFilepath].Symbols here directly.\n\t// Instead, the caller (e.g., goscan.Scanner) should ensure setFileMetadata is called after scanning.\n\treturn nil\n}\n\n// setFileMetadata stores/updates the metadata for a given file.\n// The absoluteFilepath will be converted to relative before storing.\nfunc (sc *symbolCache) setFileMetadata(absoluteFilepath string, metadata fileMetadata) error {\n\tif !sc.useCache {\n\t\treturn nil\n\t}\n\tsc.mu.Lock()\n\tdefer sc.mu.Unlock()\n\n\tif sc.rootDir == \"\" {\n\t\treturn fmt.Errorf(\"rootDir is empty in symbolCache, cannot set file metadata for %s. symbolCache must be initialized with a valid rootDir\", absoluteFilepath)\n\t}\n\tif !filepath.IsAbs(absoluteFilepath) {\n\t\treturn fmt.Errorf(\"filepath for file metadata must be absolute, got %s\", absoluteFilepath)\n\t}\n\n\trelativeFilepath, err := sc.makeRelative(absoluteFilepath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to make filepath relative for file metadata %s: %w\", absoluteFilepath, err)\n\t}\n\tsc.content.Files[relativeFilepath] = metadata\n\treturn nil\n}\n\n// removeSymbolsForFile removes all symbol entries from content.Symbols that point to the given relativeFilepath.\n// This is a helper, typically called when a file is detected as deleted or its symbols are being refreshed.\n// Must be called with appropriate lock if used externally (though primarily for internal use within other locked methods).\nfunc (sc *symbolCache) removeSymbolsForFile(relativeFilepath string) {\n\tfor key, path := range sc.content.Symbols {\n\t\tif path == relativeFilepath {\n\t\t\tdelete(sc.content.Symbols, key)\n\t\t}\n\t}\n}\n\n// makeRelative converts an absolute path to a path relative to sc.rootDir.\n// Assumes sc.rootDir is set and absoluteFilepath is absolute.\nfunc (sc *symbolCache) makeRelative(absoluteFilepath string) (string, error) {\n\tcleanedRootDir := filepath.Clean(sc.rootDir)\n\tcleanedAbsFilepath := filepath.Clean(absoluteFilepath)\n\n\trootDirPrefix := cleanedRootDir\n\tif cleanedRootDir != string(filepath.Separator) && !strings.HasSuffix(cleanedRootDir, string(filepath.Separator)) {\n\t\trootDirPrefix += string(filepath.Separator)\n\t}\n\n\tif !strings.HasPrefix(cleanedAbsFilepath, rootDirPrefix) && cleanedAbsFilepath != cleanedRootDir {\n\t\treturn \"\", fmt.Errorf(\"filepath %s is not within the configured rootDir %s\", absoluteFilepath, sc.rootDir)\n\t}\n\n\trelativeFilepath, err := filepath.Rel(cleanedRootDir, cleanedAbsFilepath)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"filepath.Rel failed for %s relative to %s: %w\", cleanedAbsFilepath, cleanedRootDir, err)\n\t}\n\t// Ensure all backslashes are converted to forward slashes before final ToSlash.\n\t// This handles cases where 'absoluteFilepath' might have contained '\\' (e.g. from user input or cross-platform scenarios)\n\t// which, on Unix, might be part of a segment name after filepath.Clean and filepath.Rel.\n\t// We want to enforce '/' as the universal separator in the cache.\n\tuniversalRelativePath := strings.ReplaceAll(relativeFilepath, \"\\\\\", \"/\")\n\treturn filepath.ToSlash(universalRelativePath), nil\t// filepath.ToSlash is good practice here, though universalRelativePath should already be fine.\n}\n\n// verifyAndGet checks if the symbol likely still exists at the cached path.\n// It returns the absolute path if the file exists, otherwise it removes the\n// stale entry from the cache and returns false.\n// This is a basic check; it doesn't re-parse the file to confirm the symbol.\nfunc (sc *symbolCache) verifyAndGet(ctx context.Context, key string) (string, bool) {\n\tif !sc.useCache {\n\t\treturn \"\", false\n\t}\n\n\tsc.mu.RLock()\t// Start with RLock for initial checks\n\trelativePath, symbolFoundInSymbolsMap := sc.content.Symbols[key]\n\trootDir := sc.rootDir\t// Read while RLock is held\n\tsc.mu.RUnlock()\n\n\tif !symbolFoundInSymbolsMap {\n\t\treturn \"\", false\n\t}\n\n\tabsolutePath := filepath.Join(rootDir, relativePath)\n\tif filepath.IsAbs(relativePath) {\t// Should not happen\n\t\tabsolutePath = relativePath\n\t}\n\n\t// Check if the file still exists\n\tif _, err := os.Stat(absolutePath); err != nil {\n\t\tsc.mu.Lock()\n\t\tdefer sc.mu.Unlock()\n\n\t\t// File doesn't exist or error stating it, remove the symbol from sc.content.Symbols\n\t\tdelete(sc.content.Symbols, key)\n\n\t\t// Also, remove this specific symbol from the sc.content.Files[relativePath].Symbols list\n\t\tif fileMeta, ok := sc.content.Files[relativePath]; ok {\n\t\t\tnewSymbols := []string{}\n\t\t\tsymbolName := getSymbolNameFromKey(key)\t// Helper function needed\n\t\t\tfor _, s := range fileMeta.Symbols {\n\t\t\t\tif s != symbolName {\n\t\t\t\t\tnewSymbols = append(newSymbols, s)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(newSymbols) < len(fileMeta.Symbols) {\t// If symbol was actually removed\n\t\t\t\tfileMeta.Symbols = newSymbols\n\t\t\t\tif len(fileMeta.Symbols) == 0 {\n\t\t\t\t\t// Optional: If no symbols left for this file, consider removing the file entry itself.\n\t\t\t\t\t// delete(sc.content.Files, relativePath)\n\t\t\t\t\t// For now, keep the file entry for its ModTime, unless it's also proven stale.\n\t\t\t\t\t// If we decide to delete, ensure this doesn't conflict with getFilesToScan logic.\n\t\t\t\t}\n\t\t\t\tsc.content.Files[relativePath] = fileMeta\t// Update the map with modified slice\n\t\t\t}\n\t\t}\n\n\t\tif !os.IsNotExist(err) {\n\t\t\tslog.WarnContext(ctx, \"Removing cache entry due to error accessing file\", slog.String(\"symbol_key\", key), slog.String(\"file\", absolutePath), slog.Any(\"error\", err))\n\t\t}\n\t\treturn \"\", false\n\t}\n\n\treturn absolutePath, true\n}\n\n// getSymbolNameFromKey extracts the symbol name from a key like \"pkg/path.SymbolName\".\nfunc getSymbolNameFromKey(key string) string {\n\tlastDot := strings.LastIndex(key, \".\")\n\tif lastDot == -1 || lastDot == len(key)-1 {\n\t\treturn key\t// Or handle error, though symbols usually have a package path\n\t}\n\treturn key[lastDot+1:]\n}\n\n// getRootDir returns the project root directory used by the cache.\nfunc (sc *symbolCache) getRootDir() string {\n\treturn sc.rootDir\n}\n\n// getFilePath returns the path to the cache file.\nfunc (sc *symbolCache) getFilePath() string {\n\treturn sc.filePath\n}\n\n// isEnabled returns true if the cache is configured to be used.\nfunc (sc *symbolCache) isEnabled() bool {\n\treturn sc.useCache\n}\n\n// getFilesToScan analyzes the files in a given package directory against the cache.\n// It identifies new files, existing (cached) files, and deleted files.\n// It returns:\n// - newFilesToScan: Absolute paths of new files in the directory not yet in cache.\n// - existingFilesInCache: Absolute paths of files present in both directory and cache.\n// - err: An error if any.\n// It also cleans up cache entries for deleted files.\nfunc (sc *symbolCache) getFilesToScan(ctx context.Context, packageDirPath string) (newFilesToScan []string, existingFilesInCache []string, err error) {\n\tif !sc.useCache {\n\t\t// If cache is disabled, the caller should ideally list all files and scan them.\n\t\t// This method's contract is to interact with the cache.\n\t\treturn nil, nil, fmt.Errorf(\"cache is disabled, getFilesToScan should not be called in this state\")\n\t}\n\n\tsc.mu.Lock()\t// Lock for the duration as we might modify cache\n\tdefer sc.mu.Unlock()\n\n\tcurrentDirRelativeFiles := make(map[string]bool)\t// Relative paths (to rootDir) of files currently in the package directory\n\n\tdirEntries, err := os.ReadDir(packageDirPath)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to read package directory %s: %w\", packageDirPath, err)\n\t}\n\n\tfor _, entry := range dirEntries {\n\t\tif entry.IsDir() || !strings.HasSuffix(entry.Name(), \".go\") {\n\t\t\tcontinue\n\t\t}\n\t\t// NOTE: We do not filter `_test.go` here. The cache should be a neutral\n\t\t// reflection of all .go files. The decision to include/exclude tests\n\t\t// belongs to the primary file-listing function (`listGoFiles`) that\n\t\t// receives the `includeTests` configuration.\n\t\tabsPath := filepath.Join(packageDirPath, entry.Name())\n\t\trelPath, err := sc.makeRelative(absPath)\t// Converts to path relative to sc.rootDir\n\t\tif err != nil {\n\t\t\tslog.WarnContext(ctx, \"Could not make path relative to root\", slog.String(\"path\", absPath), slog.String(\"root_dir\", sc.rootDir), slog.Any(\"error\", err))\n\t\t\tcontinue\t// Skip files not processable\n\t\t}\n\t\tcurrentDirRelativeFiles[relPath] = true\n\n\t\t// Check if this file (now identified by its path relative to rootDir) is in cache\n\t\tif _, isCached := sc.content.Files[relPath]; !isCached {\n\t\t\tnewFilesToScan = append(newFilesToScan, absPath)\t// File is new to the cache\n\t\t} else {\n\t\t\texistingFilesInCache = append(existingFilesInCache, absPath)\t// File exists in directory and is in cache\n\t\t}\n\t}\n\n\t// Identify and clean up deleted files from cache\n\t// Iterate over cached files that are supposed to be in this packageDirPath\n\tcachedFilesInPackageScope := make([]string, 0)\n\tfor relPathInCacheStore := range sc.content.Files {\n\t\t// To determine if relPathInCacheStore (relative to root) belongs to packageDirPath (absolute):\n\t\t// Construct its absolute path and check if it's within packageDirPath.\n\t\tabsCachedFilePath := filepath.Join(sc.rootDir, relPathInCacheStore)\n\n\t\t// Check if the parent directory of absCachedFilePath is packageDirPath\n\t\t// A simple string prefix check on absolute paths is often sufficient if paths are clean.\n\t\t// Ensure packageDirPath is cleaned to avoid issues with trailing slashes.\n\t\tcleanedPackageDirPath := filepath.Clean(packageDirPath)\n\t\tif filepath.Dir(absCachedFilePath) == cleanedPackageDirPath {\n\t\t\tcachedFilesInPackageScope = append(cachedFilesInPackageScope, relPathInCacheStore)\n\t\t}\n\t}\n\n\tfor _, relPathInCache := range cachedFilesInPackageScope {\n\t\tif _, stillExistsInDir := currentDirRelativeFiles[relPathInCache]; !stillExistsInDir {\n\t\t\t// This file, previously cached and belonging to this package, is no longer in the directory.\n\t\t\tdelete(sc.content.Files, relPathInCache)\t// Remove from file metadata cache\n\t\t\tsc.removeSymbolsForFile(relPathInCache)\t\t// Remove associated symbols from symbol map\n\t\t}\n\t}\n\n\treturn newFilesToScan, existingFilesInCache, nil\n}\n"
time=2025-09-18T09:43:11.436Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.436Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.436Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.436Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.437Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/importmanager.go:1:1 source="package goscan\n\nimport (\n\t\"fmt\"\n\t\"go/token\"\n\t\"log/slog\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/podhmo/go-scan/scanner\"\n)\n\n// ImportManager helps manage import statements for generated Go code.\ntype ImportManager struct {\n\tmu\t\t\tsync.Mutex\n\tcurrentPackagePath\tstring\n\timports\t\t\tmap[string]string\t// import path -> alias\n\taliasesInUse\t\tmap[string]string\t// alias -> import path\n}\n\nvar goKeywords = map[string]bool{\n\t\"break\":\ttrue,\n\t\"case\":\t\ttrue,\n\t\"chan\":\t\ttrue,\n\t\"const\":\ttrue,\n\t\"continue\":\ttrue,\n\t\"default\":\ttrue,\n\t\"defer\":\ttrue,\n\t\"else\":\t\ttrue,\n\t\"fallthrough\":\ttrue,\n\t\"for\":\t\ttrue,\n\t\"func\":\t\ttrue,\n\t\"go\":\t\ttrue,\n\t\"goto\":\t\ttrue,\n\t\"if\":\t\ttrue,\n\t\"import\":\ttrue,\n\t\"interface\":\ttrue,\n\t\"map\":\t\ttrue,\n\t\"package\":\ttrue,\n\t\"range\":\ttrue,\n\t\"return\":\ttrue,\n\t\"select\":\ttrue,\n\t\"struct\":\ttrue,\n\t\"switch\":\ttrue,\n\t\"type\":\t\ttrue,\n\t\"var\":\t\ttrue,\n\t// Common predeclared identifiers that might cause issues if used as package names\n\t\"true\":\t\ttrue,\n\t\"false\":\ttrue,\n\t\"iota\":\t\ttrue,\n\t\"nil\":\t\ttrue,\n\t\"append\":\ttrue,\n\t\"cap\":\t\ttrue,\n\t\"close\":\ttrue,\n\t\"complex\":\ttrue,\n\t\"copy\":\t\ttrue,\n\t\"delete\":\ttrue,\n\t\"imag\":\t\ttrue,\n\t\"len\":\t\ttrue,\n\t\"make\":\t\ttrue,\n\t\"new\":\t\ttrue,\n\t\"panic\":\ttrue,\n\t\"print\":\ttrue,\n\t\"println\":\ttrue,\n\t\"real\":\t\ttrue,\n\t\"recover\":\ttrue,\n}\n\n// NewImportManager creates a new ImportManager.\n// currentPkgInfo is the package information for the file being generated.\n// If currentPkgInfo is nil, the ImportManager assumes no specific current package context.\nfunc NewImportManager(currentPkgInfo *scanner.PackageInfo) *ImportManager {\n\tim := &ImportManager{\n\t\timports:\tmake(map[string]string),\n\t\taliasesInUse:\tmake(map[string]string),\n\t}\n\tif currentPkgInfo != nil {\n\t\tim.currentPackagePath = currentPkgInfo.ImportPath\n\t}\n\treturn im\n}\n\n// Add registers an import path and its desired alias.\n// It handles conflicts by adjusting aliases if necessary.\n// Returns the actual alias that should be used for the package.\n// If the path is the current package's path, it returns an empty string (no alias needed for qualification).\nfunc (im *ImportManager) Add(path string, requestedAlias string) string {\n\tif path == \"\" {\n\t\treturn \"\"\t// Cannot import an empty path\n\t}\n\tif im.currentPackagePath != \"\" && path == im.currentPackagePath {\n\t\treturn \"\"\t// Return empty string to signify no alias needed for qualification\n\t}\n\n\tim.mu.Lock()\n\tdefer im.mu.Unlock()\n\n\t// Check if this path is already imported\n\tif alias, ok := im.imports[path]; ok {\n\t\treturn alias\t// Return existing alias\n\t}\n\n\t// Determine initial aliasCandidate\n\tvar aliasCandidate string\n\tif requestedAlias == \"\" {\n\t\taliasCandidate = filepath.Base(path)\n\t\taliasCandidate = strings.ReplaceAll(aliasCandidate, \"-\", \"_\")\n\t\taliasCandidate = strings.ReplaceAll(aliasCandidate, \".\", \"_\")\n\t} else {\n\t\taliasCandidate = requestedAlias\n\t\t// Also sanitize user-provided alias\n\t\taliasCandidate = strings.ReplaceAll(aliasCandidate, \"-\", \"_\")\n\t\taliasCandidate = strings.ReplaceAll(aliasCandidate, \".\", \"_\")\n\t}\n\n\t// First, check if the sanitized base/requested name is a keyword.\n\t// If so, append \"_pkg\" immediately.\n\tif goKeywords[aliasCandidate] {\n\t\taliasCandidate += \"_pkg\"\n\t}\n\n\t// Now, ensure the (potentially keyword-adjusted) alias is a valid identifier.\n\tif aliasCandidate == \"\" || !token.IsIdentifier(aliasCandidate) {\n\t\t// If path itself was something like \".\", base becomes \".\" then \"_\", then invalid.\n\t\t// Or if user provided \"123\", it becomes invalid.\n\t\t// Or if keyword adjustment made it invalid (unlikely for \"_pkg\" suffix).\n\n\t\t// Avoid double prefixing if it already somehow starts with pkg_ from a bad state\n\t\tif !(strings.HasPrefix(aliasCandidate, \"pkg_\") && len(aliasCandidate) > 4) {\n\t\t\taliasCandidate = \"pkg_\" + aliasCandidate\n\t\t}\n\n\t\t// If aliasCandidate became \"pkg_\" or (it was like \"pkg_keyword\" and keyword was removed, leaving \"pkg_\"), it means original was problematic.\n\t\t// Create a more unique fallback.\n\t\t// A more robust check for \"pkg_keyword\" being reduced to \"pkg_\" needs to consider the original keyword.\n\t\t// For simplicity, just check if it's \"pkg_\".\n\t\tif aliasCandidate == \"pkg_\" {\n\t\t\tvar h uint32\n\t\t\tfor _, r := range path {\n\t\t\t\th = h*31 + uint32(r)\n\t\t\t}\n\t\t\taliasCandidate = fmt.Sprintf(\"p%x\", h)\t// Use a short hash of the path\n\t\t\t// Re-check keyword for the hashed version, though extremely unlikely\n\t\t\tif goKeywords[aliasCandidate] {\t// Check keyword again for the hashed version\n\t\t\t\taliasCandidate += \"_pkg\"\n\t\t\t}\n\t\t}\n\t}\n\t// It's possible that aliasCandidate is now a keyword_pkg which is fine,\n\t// or pkg_nonkeyword which is fine, or p<hash> which is fine, or p<hash>_pkg if hash was a keyword.\n\t// A final explicit check for keyword status on `finalAlias` inside the conflict resolution loop\n\t// is already present and should ensure safety.\n\n\t// Handle alias conflicts with existing aliases\n\tfinalAlias := aliasCandidate\n\tcounter := 1\n\tfor {\n\t\texistingPathForAlias, aliasInUse := im.aliasesInUse[finalAlias]\n\t\tisKeyword := goKeywords[finalAlias]\t// Keyword check for the current finalAlias iteration\n\n\t\t// Break condition:\n\t\t// 1. It's NOT a keyword AND\n\t\t// 2. EITHER it's not in use OR it's in use by the current path we are trying to add.\n\t\t//    (The `existingPathForAlias == path` case should ideally be caught by the `im.imports[path]` check\n\t\t//     before this loop, but this is a safeguard).\n\t\tif !isKeyword && (!aliasInUse || existingPathForAlias == path) {\n\t\t\tbreak\n\t\t}\n\n\t\t// If we are here, it means there's a conflict:\n\t\t// - The `finalAlias` is a keyword (even after initial adjustments, possibly due to prior `_pkg` suffixing if `aliasCandidate` itself was a keyword like `type_pkg` and then `type_pkg` is also a keyword in `goKeywords` - unlikely but defensive).\n\t\t// - Or, the `finalAlias` is already in use by a *different* package path.\n\n\t\t// Conflict: generate a new alias using the original `aliasCandidate` as base for numeric suffix.\n\t\tfinalAlias = fmt.Sprintf(\"%s%d\", aliasCandidate, counter)\t// Suffix to the original candidate\n\t\tcounter++\n\t\tif counter > 100 {\t// Safety break for very unusual scenarios\n\t\t\t// Fallback to a more unique name based on a part of the path.\n\t\t\t// This is a very rough way to get a potentially more unique base.\n\t\t\tpathParts := strings.Split(path, \"/\")\n\t\t\tvar uniquePart string\n\t\t\tif len(pathParts) > 1 {\n\t\t\t\tuniquePart = strings.ReplaceAll(pathParts[len(pathParts)-2], \"-\", \"_\")\n\t\t\t\tuniquePart = strings.ReplaceAll(uniquePart, \".\", \"_\")\n\t\t\t} else {\n\t\t\t\tuniquePart = \"p\"\t// very generic prefix\n\t\t\t}\n\t\t\tbaseHashAlias := uniquePart + \"_\" + filepath.Base(path)\t// e.g. github_com_my_pkg\n\t\t\tbaseHashAlias = strings.ReplaceAll(baseHashAlias, \"-\", \"_\")\n\t\t\tbaseHashAlias = strings.ReplaceAll(baseHashAlias, \".\", \"_\")\n\n\t\t\tfinalAlias = baseHashAlias\n\t\t\taltCounter := 1\n\t\t\tfor {\n\t\t\t\tep, iu := im.aliasesInUse[finalAlias]\n\t\t\t\tgk := goKeywords[finalAlias]\n\t\t\t\tif (!iu || ep == path) && !gk {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tfinalAlias = fmt.Sprintf(\"%s%d\", baseHashAlias, altCounter)\n\t\t\t\taltCounter++\n\t\t\t\tif altCounter > 20 {\t// Extremely unlikely deep conflict with fallback\n\t\t\t\t\tslog.Error(\"Failed to generate a unique alias after multiple fallbacks\", \"path\", path, \"requestedAlias\", requestedAlias)\n\t\t\t\t\treturn path\t// Return the path itself as a last resort (will likely cause compile error, but signals problem)\n\t\t\t\t}\n\t\t\t}\n\t\t\tslog.Warn(fmt.Sprintf(\"High alias conflict count for path %s with base %s. Using generated alias: %s\", path, aliasCandidate, finalAlias))\n\t\t\tbreak\n\t\t}\n\t}\n\n\tim.imports[path] = finalAlias\n\tif finalAlias != \"\" {\t// Don't record an empty alias as \"in use\" for qualification purposes\n\t\tim.aliasesInUse[finalAlias] = path\n\t}\n\treturn finalAlias\n}\n\n// Qualify returns the qualified type name (e.g., \"alias.TypeName\" or \"TypeName\").\n// It ensures the package path is registered with an alias.\n// If packagePath is empty or matches currentPackagePath, typeName is returned as is.\nfunc (im *ImportManager) Qualify(packagePath string, typeName string) string {\n\tif packagePath == \"\" || (im.currentPackagePath != \"\" && packagePath == im.currentPackagePath) {\n\t\treturn typeName\t// Type is in current package, built-in, or no package path given\n\t}\n\n\tim.mu.Lock()\n\talias, ok := im.imports[packagePath]\n\tim.mu.Unlock()\n\n\tif !ok {\n\t\t// Ensure the package is added and get its alias.\n\t\t// Pass the original package name (last part of path) as a requested alias hint.\n\t\trequestedAliasHint := \"\"\n\t\tif packagePath != \"\" {\n\t\t\trequestedAliasHint = filepath.Base(packagePath)\n\t\t}\n\t\talias = im.Add(packagePath, requestedAliasHint)\n\t}\n\n\tif alias == \"\" {\t// This implies it's the current package (handled by Add) or an error/empty path.\n\t\treturn typeName\n\t}\n\treturn alias + \".\" + typeName\n}\n\n// Imports returns a copy of the map of import paths to aliases for use in GoFile.\n// It excludes entries where the alias is empty, as those typically don't need an explicit import line\n// (e.g., the current package itself if it were ever added with an empty alias, though Add prevents this for currentPackagePath).\nfunc (im *ImportManager) Imports() map[string]string {\n\tim.mu.Lock()\n\tdefer im.mu.Unlock()\n\n\timportsCopy := make(map[string]string, len(im.imports))\n\tfor path, alias := range im.imports {\n\t\t// We generally want all registered imports for the `import (...)` block.\n\t\t// `Add` should ensure that `currentPackagePath` isn't in `im.imports` to avoid `import . \"current/pkg\"`.\n\t\t// If an alias is intentionally set to \"_\" (blank identifier), it should still be included.\n\t\timportsCopy[path] = alias\n\t}\n\treturn importsCopy\n}\n"
time=2025-09-18T09:43:11.437Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.437Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.437Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.437Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/importmanager.go:22:18 source="map[string]bool{\n\t\"break\":\ttrue,\n\t\"case\":\t\ttrue,\n\t\"chan\":\t\ttrue,\n\t\"const\":\ttrue,\n\t\"continue\":\ttrue,\n\t\"default\":\ttrue,\n\t\"defer\":\ttrue,\n\t\"else\":\t\ttrue,\n\t\"fallthrough\":\ttrue,\n\t\"for\":\t\ttrue,\n\t\"func\":\t\ttrue,\n\t\"go\":\t\ttrue,\n\t\"goto\":\t\ttrue,\n\t\"if\":\t\ttrue,\n\t\"import\":\ttrue,\n\t\"interface\":\ttrue,\n\t\"map\":\t\ttrue,\n\t\"package\":\ttrue,\n\t\"range\":\ttrue,\n\t\"return\":\ttrue,\n\t\"select\":\ttrue,\n\t\"struct\":\ttrue,\n\t\"switch\":\ttrue,\n\t\"type\":\t\ttrue,\n\t\"var\":\t\ttrue,\n\n\t\"true\":\t\ttrue,\n\t\"false\":\ttrue,\n\t\"iota\":\t\ttrue,\n\t\"nil\":\t\ttrue,\n\t\"append\":\ttrue,\n\t\"cap\":\t\ttrue,\n\t\"close\":\ttrue,\n\t\"complex\":\ttrue,\n\t\"copy\":\t\ttrue,\n\t\"delete\":\ttrue,\n\t\"imag\":\t\ttrue,\n\t\"len\":\t\ttrue,\n\t\"make\":\t\ttrue,\n\t\"new\":\t\ttrue,\n\t\"panic\":\ttrue,\n\t\"print\":\ttrue,\n\t\"println\":\ttrue,\n\t\"real\":\t\ttrue,\n\t\"recover\":\ttrue,\n}"
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:23:17 source=true
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:23:2 source="\"break\""
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:24:17 source=true
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:24:2 source="\"case\""
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:25:17 source=true
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:25:2 source="\"chan\""
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:26:17 source=true
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:26:2 source="\"const\""
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:27:17 source=true
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:27:2 source="\"continue\""
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:28:17 source=true
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:28:2 source="\"default\""
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:29:17 source=true
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:29:2 source="\"defer\""
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:30:17 source=true
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.438Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:30:2 source="\"else\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:31:17 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:31:2 source="\"fallthrough\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:32:17 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:32:2 source="\"for\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:33:17 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:33:2 source="\"func\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:34:17 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:34:2 source="\"go\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:35:17 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:35:2 source="\"goto\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:36:17 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:36:2 source="\"if\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:37:17 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:37:2 source="\"import\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:38:17 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:38:2 source="\"interface\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:39:17 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:39:2 source="\"map\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:40:17 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:40:2 source="\"package\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:41:17 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:41:2 source="\"range\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:42:17 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:42:2 source="\"return\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:43:17 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:43:2 source="\"select\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:44:17 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:44:2 source="\"struct\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:45:17 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:45:2 source="\"switch\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:46:17 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:46:2 source="\"type\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:47:17 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:47:2 source="\"var\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:49:13 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:49:2 source="\"true\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:50:13 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:50:2 source="\"false\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:51:13 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:51:2 source="\"iota\""
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:52:13 source=true
time=2025-09-18T09:43:11.439Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:52:2 source="\"nil\""
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:53:13 source=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:53:2 source="\"append\""
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:54:13 source=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:54:2 source="\"cap\""
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:55:13 source=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:55:2 source="\"close\""
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:56:13 source=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:56:2 source="\"complex\""
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:57:13 source=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:57:2 source="\"copy\""
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:58:13 source=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:58:2 source="\"delete\""
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:59:13 source=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:59:2 source="\"imag\""
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:60:13 source=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:60:2 source="\"len\""
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:61:13 source=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:61:2 source="\"make\""
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:62:13 source=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:62:2 source="\"new\""
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:63:13 source=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:63:2 source="\"panic\""
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:64:13 source=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:64:2 source="\"print\""
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:65:13 source=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:65:2 source="\"println\""
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:66:13 source=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:66:2 source="\"real\""
time=2025-09-18T09:43:11.440Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.Ident pos=/app/importmanager.go:67:13 source=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2789 msg="evalIdent: found in env" name=true type=BOOLEAN val=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/importmanager.go:67:2 source="\"recover\""
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.441Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.442Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.443Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.444Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan scanned=true
time=2025-09-18T09:43:11.445Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/examples/deps-walk
time=2025-09-18T09:43:11.449Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/examples/deps-walk/main.go:1:1 source="package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"log/slog\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\n\tgoscan \"github.com/podhmo/go-scan\"\n)\n\n// logLevelVar is a custom flag.Value implementation for slog.LevelVar\ntype logLevelVar struct {\n\tlevelVar *slog.LevelVar\n}\n\nfunc (v *logLevelVar) String() string {\n\tif v.levelVar == nil {\n\t\treturn \"\"\n\t}\n\treturn v.levelVar.Level().String()\n}\n\nfunc (v *logLevelVar) Set(s string) error {\n\tvar level slog.Level\n\tswitch strings.ToLower(s) {\n\tcase \"debug\":\n\t\tlevel = slog.LevelDebug\n\tcase \"info\":\n\t\tlevel = slog.LevelInfo\n\tcase \"warn\":\n\t\tlevel = slog.LevelWarn\n\tcase \"error\":\n\t\tlevel = slog.LevelError\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown log level: %s\", s)\n\t}\n\tv.levelVar.Set(level)\n\treturn nil\n}\n\nfunc main() {\n\tvar (\n\t\thops\t\tint\n\t\tignore\t\tstring\n\t\thide\t\tstring\n\t\toutput\t\tstring\n\t\tformat\t\tstring\n\t\tgranularity\tstring\n\t\tfull\t\tbool\n\t\tshort\t\tbool\n\t\tdirection\tstring\n\t\taggressive\tbool\n\t\ttest\t\tbool\n\t\tdryRun\t\tbool\n\t\tinspect\t\tbool\n\t\tlogLevel\t= new(slog.LevelVar)\n\t)\n\n\t// No -start-pkg flag, positional arguments are used instead\n\tflag.IntVar(&hops, \"hops\", 1, \"Maximum number of hops to walk from the start package\")\n\tflag.StringVar(&ignore, \"ignore\", \"\", \"A comma-separated list of package patterns to ignore\")\n\tflag.StringVar(&hide, \"hide\", \"\", \"A comma-separated list of package patterns to hide from the output\")\n\tflag.StringVar(&output, \"output\", \"\", \"Output file path for the graph (defaults to stdout)\")\n\tflag.StringVar(&format, \"format\", \"dot\", \"Output format (dot, mermaid, or json)\")\n\tflag.StringVar(&granularity, \"granularity\", \"package\", \"Dependency granularity (package or file)\")\n\tflag.BoolVar(&full, \"full\", false, \"Include dependencies outside the current module\")\n\tflag.BoolVar(&short, \"short\", false, \"Omit module prefix from package paths in the output\")\n\tflag.StringVar(&direction, \"direction\", \"forward\", \"Direction of dependency walk (forward, reverse, bidi)\")\n\tflag.BoolVar(&aggressive, \"aggressive\", false, \"Use aggressive git-grep based search for reverse mode\")\n\tflag.BoolVar(&test, \"test\", false, \"Include test files in the analysis\")\n\tflag.BoolVar(&dryRun, \"dry-run\", false, \"don't write to output file, just print to stdout\")\n\tflag.BoolVar(&inspect, \"inspect\", false, \"enable inspection logging\")\n\tflag.Var(&logLevelVar{levelVar: logLevel}, \"log-level\", \"set log level (debug, info, warn, error)\")\n\tflag.Parse()\n\n\tstartPkgs := flag.Args()\n\tif len(startPkgs) == 0 {\n\t\tflag.Usage()\n\t\tos.Exit(1)\n\t}\n\n\topts := slog.HandlerOptions{Level: logLevel}\n\tlogger := slog.New(slog.NewTextHandler(os.Stderr, &opts))\n\tslog.SetDefault(logger)\n\n\tif err := run(context.Background(), startPkgs, hops, ignore, hide, output, format, granularity, full, short, direction, aggressive, test, dryRun, inspect, logger); err != nil {\n\t\tslog.ErrorContext(context.Background(), \"Error\", slog.Any(\"error\", err))\n\t\tos.Exit(1)\n\t}\n}\n\nfunc run(ctx context.Context, startPkgs []string, hops int, ignore string, hide string, output string, format string, granularity string, full bool, short bool, direction string, aggressive bool, test bool, dryRun bool, inspect bool, logger *slog.Logger) error {\n\tvar finalOutput bytes.Buffer\n\n\tvar scannerOpts []goscan.ScannerOption\n\tif full {\n\t\tscannerOpts = append(scannerOpts, goscan.WithGoModuleResolver())\n\t}\n\tscannerOpts = append(scannerOpts, goscan.WithIncludeTests(test))\n\tscannerOpts = append(scannerOpts, goscan.WithDryRun(dryRun))\n\tscannerOpts = append(scannerOpts, goscan.WithInspect(inspect))\n\tscannerOpts = append(scannerOpts, goscan.WithLogger(logger))\n\n\ts, err := goscan.New(scannerOpts...)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create scanner: %w\", err)\n\t}\n\n\tfor i, startPkg := range startPkgs {\n\t\t// Use the facade function from the root goscan package\n\t\tresolvedStartPkg, err := goscan.ResolvePath(ctx, startPkg)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to resolve start package path for %q: %w\", startPkg, err)\n\t\t}\n\t\tstartPkg = resolvedStartPkg\n\n\t\tignorePatterns := []string{}\n\t\tif ignore != \"\" {\n\t\t\tignorePatterns = strings.Split(ignore, \",\")\n\t\t}\n\t\thidePatterns := []string{}\n\t\tif hide != \"\" {\n\t\t\thidePatterns = strings.Split(hide, \",\")\n\t\t}\n\n\t\tvisitor := &graphVisitor{\n\t\t\tstartPkg:\t\tstartPkg,\n\t\t\ts:\t\t\ts,\n\t\t\thops:\t\t\thops,\n\t\t\tfull:\t\t\tfull,\n\t\t\tshort:\t\t\tshort,\n\t\t\tgranularity:\t\tgranularity,\n\t\t\tignorePatterns:\t\tignorePatterns,\n\t\t\thidePatterns:\t\thidePatterns,\n\t\t\tdependencies:\t\tmake(map[string][]string),\n\t\t\treverseDependencies:\tmake(map[string][]string),\n\t\t\tpackageHops:\t\tmake(map[string]int),\n\t\t}\n\n\t\tif aggressive && !(direction == \"reverse\" || direction == \"bidi\") {\n\t\t\treturn fmt.Errorf(\"--aggressive is only valid with --direction=reverse or --direction=bidi\")\n\t\t}\n\t\tif granularity == \"file\" && (direction == \"reverse\" || direction == \"bidi\") {\n\t\t\treturn fmt.Errorf(\"--granularity=file is not compatible with --direction=reverse or --direction=bidi\")\n\t\t}\n\n\t\tdoForwardSearch := func() error {\n\t\t\tvisitor.packageHops[startPkg] = 0\n\t\t\treturn s.Walker.Walk(ctx, visitor, startPkg)\n\t\t}\n\n\t\tdoReverseSearch := func() error {\n\t\t\tif aggressive {\n\t\t\t\t// Aggressive search using git grep\n\t\t\t\tqueue := []string{startPkg}\n\t\t\t\tpkgHops := map[string]int{startPkg: 0}\n\t\t\t\thead := 0\n\t\t\t\tfor head < len(queue) {\n\t\t\t\t\tcurrentPkg := queue[head]\n\t\t\t\t\thead++\n\n\t\t\t\t\tcurrentHops := pkgHops[currentPkg]\n\t\t\t\t\tif currentHops >= hops {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\timporters, err := s.Walker.FindImportersAggressively(ctx, currentPkg)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"aggressive search for importers of %s failed: %w\", currentPkg, err)\n\t\t\t\t\t}\n\n\t\t\t\t\tfor _, importer := range importers {\n\t\t\t\t\t\tvisitor.reverseDependencies[importer.ImportPath] = append(visitor.reverseDependencies[importer.ImportPath], currentPkg)\n\t\t\t\t\t\tif _, visited := pkgHops[importer.ImportPath]; !visited {\n\t\t\t\t\t\t\tpkgHops[importer.ImportPath] = currentHops + 1\n\t\t\t\t\t\t\tqueue = append(queue, importer.ImportPath)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Default search using pre-built map\n\t\t\trevDepMap, err := s.Walker.BuildReverseDependencyMap(ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"could not build reverse dependency map: %w\", err)\n\t\t\t}\n\n\t\t\tqueue := []string{startPkg}\n\t\t\tpkgHops := map[string]int{startPkg: 0}\n\t\t\thead := 0\n\t\t\tfor head < len(queue) {\n\t\t\t\tcurrentPkg := queue[head]\n\t\t\t\thead++\n\n\t\t\t\tcurrentHops := pkgHops[currentPkg]\n\t\t\t\tif currentHops >= hops {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\timporters := revDepMap[currentPkg]\n\t\t\t\tfor _, importer := range importers {\n\t\t\t\t\tvisitor.reverseDependencies[importer] = append(visitor.reverseDependencies[importer], currentPkg)\n\t\t\t\t\tif _, visited := pkgHops[importer]; !visited {\n\t\t\t\t\t\tpkgHops[importer] = currentHops + 1\n\t\t\t\t\t\tqueue = append(queue, importer)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tswitch direction {\n\t\tcase \"forward\":\n\t\t\tif err := doForwardSearch(); err != nil {\n\t\t\t\treturn fmt.Errorf(\"walk failed for %q: %w\", startPkg, err)\n\t\t\t}\n\t\tcase \"reverse\":\n\t\t\tif err := doReverseSearch(); err != nil {\n\t\t\t\treturn fmt.Errorf(\"find importers failed for %q: %w\", startPkg, err)\n\t\t\t}\n\t\tcase \"bidi\":\n\t\t\tif err := doForwardSearch(); err != nil {\n\t\t\t\treturn fmt.Errorf(\"bidi walk (forward part) failed for %q: %w\", startPkg, err)\n\t\t\t}\n\t\t\tif err := doReverseSearch(); err != nil {\n\t\t\t\treturn fmt.Errorf(\"bidi walk (reverse part) failed for %q: %w\", startPkg, err)\n\t\t\t}\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"invalid direction: %q. must be one of forward, reverse, or bidi\", direction)\n\t\t}\n\n\t\tvar buf bytes.Buffer\n\t\tswitch format {\n\t\tcase \"dot\":\n\t\t\tif err := visitor.WriteDOT(&buf); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to generate DOT graph for %q: %w\", startPkg, err)\n\t\t\t}\n\t\tcase \"mermaid\":\n\t\t\tif err := visitor.WriteMermaid(&buf); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to generate Mermaid graph for %q: %w\", startPkg, err)\n\t\t\t}\n\t\tcase \"json\":\n\t\t\tif err := visitor.WriteJSON(&buf, startPkg, direction); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to generate JSON output for %q: %w\", startPkg, err)\n\t\t\t}\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unsupported format: %q\", format)\n\t\t}\n\n\t\tfinalOutput.Write(buf.Bytes())\n\t\tif i < len(startPkgs)-1 {\n\t\t\tfinalOutput.WriteString(\"\\n\\n\")\n\t\t}\n\t}\n\n\tif output == \"\" || dryRun {\n\t\tif dryRun && output != \"\" {\n\t\t\tslog.InfoContext(ctx, \"Dry run: skipping file write\", \"path\", output)\n\t\t}\n\t\t_, err = os.Stdout.Write(finalOutput.Bytes())\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"writing to stdout: %w\", err)\n\t\t}\n\t\treturn nil\n\t}\n\treturn os.WriteFile(output, finalOutput.Bytes(), 0644)\n}\n\ntype graphVisitor struct {\n\tstartPkg\t\tstring\n\ts\t\t\t*goscan.Scanner\n\thops\t\t\tint\n\tfull\t\t\tbool\n\tshort\t\t\tbool\n\tgranularity\t\tstring\n\tignorePatterns\t\t[]string\n\thidePatterns\t\t[]string\n\tdependencies\t\tmap[string][]string\t// from -> to[]\n\treverseDependencies\tmap[string][]string\t// to -> from[]\n\tpackageHops\t\tmap[string]int\t\t// package -> hop level\n}\n\nfunc (v *graphVisitor) Visit(pkg *goscan.PackageImports) ([]string, error) {\n\tcurrentHop, exists := v.packageHops[pkg.ImportPath]\n\tif !exists {\n\t\treturn nil, fmt.Errorf(\"internal error: visiting package %q with no hop level assigned\", pkg.ImportPath)\n\t}\n\n\tif currentHop >= v.hops {\n\t\treturn nil, nil\t// Stop traversal from this node\n\t}\n\n\tvar importsToFollow []string\n\tmodulePath := v.s.ModulePath()\n\n\tvar importsToProcess map[string][]string\n\tif v.granularity == \"file\" {\n\t\timportsToProcess = pkg.FileImports\n\t} else {\n\t\timportsToProcess = map[string][]string{pkg.ImportPath: pkg.Imports}\n\t}\n\n\tfor source, imps := range importsToProcess {\n\t\tfor _, imp := range imps {\n\t\t\tisIgnored := false\n\t\t\tfor _, pattern := range v.ignorePatterns {\n\t\t\t\t// Check against full import path\n\t\t\t\tif matched, _ := filepath.Match(pattern, imp); matched {\n\t\t\t\t\tisIgnored = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\t// If short is enabled, also check against the short package path\n\t\t\t\tif v.short {\n\t\t\t\t\tmodulePath := v.s.ModulePath()\n\t\t\t\t\tif modulePath != \"\" && strings.HasPrefix(imp, modulePath) {\n\t\t\t\t\t\tshortImp := strings.TrimPrefix(imp, modulePath)\n\t\t\t\t\t\tshortImp = strings.TrimPrefix(shortImp, \"/\")\n\t\t\t\t\t\tif matched, _ := filepath.Match(pattern, shortImp); matched {\n\t\t\t\t\t\t\tisIgnored = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif isIgnored {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tisInternalModule := modulePath != \"\" && strings.HasPrefix(imp, modulePath)\n\n\t\t\t// If not in full mode, we skip any dependency that is not part of the current module.\n\t\t\tif !v.full && !isInternalModule {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Add the dependency to the graph data.\n\t\t\tv.dependencies[source] = append(v.dependencies[source], imp)\n\n\t\t\t// Add the dependency to the queue for the next level of the walk if it hasn't been visited.\n\t\t\tif _, visited := v.packageHops[imp]; !visited {\n\t\t\t\tv.packageHops[imp] = currentHop + 1\n\t\t\t\timportsToFollow = append(importsToFollow, imp)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn importsToFollow, nil\n}\n\nfunc (v *graphVisitor) isHidden(nodePath string) bool {\n\tfor _, pattern := range v.hidePatterns {\n\t\t// Check against full import path\n\t\tif matched, _ := filepath.Match(pattern, nodePath); matched {\n\t\t\treturn true\n\t\t}\n\n\t\t// If short is enabled, also check against the short package path\n\t\tif v.short {\n\t\t\tmodulePath := v.s.ModulePath()\n\t\t\tif modulePath != \"\" && strings.HasPrefix(nodePath, modulePath) {\n\t\t\t\tshortPath := strings.TrimPrefix(nodePath, modulePath)\n\t\t\t\tshortPath = strings.TrimPrefix(shortPath, \"/\")\n\t\t\t\tif matched, _ := filepath.Match(pattern, shortPath); matched {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (v *graphVisitor) WriteDOT(w io.Writer) error {\n\tfmt.Fprintln(w, \"digraph dependencies {\")\n\tfmt.Fprintln(w, `  rankdir=\"LR\";`)\n\tif v.granularity == \"package\" {\n\t\tfmt.Fprintln(w, `  node [shape=box, style=\"rounded,filled\", fillcolor=lightgrey];`)\n\t}\n\n\tallNodes := make(map[string]string)\t// name -> type (\"file\" or \"package\")\n\n\t// Collect all nodes from both dependency maps\n\tfor from, toList := range v.dependencies {\n\t\tif v.granularity == \"file\" {\n\t\t\tallNodes[from] = \"file\"\n\t\t} else {\n\t\t\tallNodes[from] = \"package\"\n\t\t}\n\t\tfor _, to := range toList {\n\t\t\tallNodes[to] = \"package\"\n\t\t}\n\t}\n\tfor from, toList := range v.reverseDependencies {\n\t\tallNodes[from] = \"package\"\n\t\tfor _, to := range toList {\n\t\t\tallNodes[to] = \"package\"\n\t\t}\n\t}\n\n\tsortedNodes := make([]string, 0, len(allNodes))\n\tfor node := range allNodes {\n\t\tsortedNodes = append(sortedNodes, node)\n\t}\n\tsort.Strings(sortedNodes)\n\n\tmodulePath := v.s.ModulePath()\n\tmoduleRootDir := v.s.RootDir()\n\n\tfor _, node := range sortedNodes {\n\t\tif v.isHidden(node) {\n\t\t\tcontinue\n\t\t}\n\t\tlabel := node\n\t\tif v.granularity == \"file\" {\n\t\t\trelPath, err := filepath.Rel(moduleRootDir, node)\n\t\t\tif err == nil {\n\t\t\t\tlabel = relPath\n\t\t\t}\n\t\t} else if v.short && modulePath != \"\" && strings.HasPrefix(node, modulePath) {\n\t\t\tlabel = strings.TrimPrefix(node, modulePath)\n\t\t\tlabel = strings.TrimPrefix(label, \"/\")\n\t\t}\n\n\t\t// Highlight start node\n\t\tif node == v.startPkg {\n\t\t\tvar attributes string\n\t\t\tswitch allNodes[node] {\n\t\t\tcase \"file\":\n\t\t\t\tattributes = `shape=note, style=\"filled\", fillcolor=lightblue`\n\t\t\tcase \"package\":\n\t\t\t\tattributes = `shape=box, style=\"rounded,filled\", fillcolor=lightblue`\n\t\t\t}\n\t\t\tfmt.Fprintf(w, `  \"%s\" [label=\"%s\", %s];`+\"\\n\", node, label, attributes)\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch allNodes[node] {\n\t\tcase \"file\":\n\t\t\tfmt.Fprintf(w, `  \"%s\" [label=\"%s\", shape=note, style=filled, fillcolor=khaki];`+\"\\n\", node, label)\n\t\tcase \"package\":\n\t\t\tif v.granularity == \"package\" {\n\t\t\t\tfmt.Fprintf(w, `  \"%s\" [label=\"%s\"];`+\"\\n\", node, label)\n\t\t\t} else {\n\t\t\t\tfmt.Fprintf(w, `  \"%s\" [label=\"%s\", shape=box, style=\"rounded,filled\", fillcolor=lightgrey];`+\"\\n\", node, label)\n\t\t\t}\n\t\t}\n\t}\n\n\tfmt.Fprintln(w, \"\")\n\n\t// Write forward dependencies\n\tsortedFroms := make([]string, 0, len(v.dependencies))\n\tfor from := range v.dependencies {\n\t\tsortedFroms = append(sortedFroms, from)\n\t}\n\tsort.Strings(sortedFroms)\n\n\tfor _, from := range sortedFroms {\n\t\ttoList := v.dependencies[from]\n\t\tsort.Strings(toList)\n\t\tfor _, to := range toList {\n\t\t\tif v.isHidden(from) || v.isHidden(to) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfmt.Fprintf(w, `  \"%s\" -> \"%s\";`+\"\\n\", from, to)\n\t\t}\n\t}\n\n\t// Write reverse dependencies with a different style\n\tsortedFromsRev := make([]string, 0, len(v.reverseDependencies))\n\tfor from := range v.reverseDependencies {\n\t\tsortedFromsRev = append(sortedFromsRev, from)\n\t}\n\tsort.Strings(sortedFromsRev)\n\n\tfor _, from := range sortedFromsRev {\n\t\ttoList := v.reverseDependencies[from]\n\t\tsort.Strings(toList)\n\t\tfor _, to := range toList {\n\t\t\tif v.isHidden(from) || v.isHidden(to) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Using [dir=back] to indicate a reverse dependency\n\t\t\tfmt.Fprintf(w, `  \"%s\" -> \"%s\" [dir=back, style=dashed];`+\"\\n\", to, from)\n\t\t}\n\t}\n\n\tfmt.Fprintln(w, \"}\")\n\treturn nil\n}\n\nfunc (v *graphVisitor) WriteMermaid(w io.Writer) error {\n\tfmt.Fprintln(w, \"graph LR\")\n\n\tallNodes := make(map[string]string)\t// name -> type (\"file\" or \"package\")\n\tfor from, toList := range v.dependencies {\n\t\tif v.granularity == \"file\" {\n\t\t\tallNodes[from] = \"file\"\n\t\t} else {\n\t\t\tallNodes[from] = \"package\"\n\t\t}\n\t\tfor _, to := range toList {\n\t\t\tallNodes[to] = \"package\"\n\t\t}\n\t}\n\tfor from, toList := range v.reverseDependencies {\n\t\tallNodes[from] = \"package\"\n\t\tfor _, to := range toList {\n\t\t\tallNodes[to] = \"package\"\n\t\t}\n\t}\n\n\tsortedNodes := make([]string, 0, len(allNodes))\n\tfor node := range allNodes {\n\t\tsortedNodes = append(sortedNodes, node)\n\t}\n\tsort.Strings(sortedNodes)\n\n\tnodeIDs := make(map[string]string)\n\tfor i, node := range sortedNodes {\n\t\tnodeIDs[node] = fmt.Sprintf(\"id%d\", i)\n\t}\n\n\tmodulePath := v.s.ModulePath()\n\tmoduleRootDir := v.s.RootDir()\n\tindent := \"  \"\n\n\tif v.short && modulePath != \"\" && v.granularity == \"package\" {\n\t\tfmt.Fprintf(w, \"\\n  subgraph module [%s]\\n\", modulePath)\n\t\tindent = \"    \"\n\t}\n\n\tfmt.Fprintln(w, \"\")\n\n\tfor _, node := range sortedNodes {\n\t\tif v.isHidden(node) {\n\t\t\tcontinue\n\t\t}\n\t\tid := nodeIDs[node]\n\t\tlabel := node\n\t\tif v.granularity == \"file\" {\n\t\t\trelPath, err := filepath.Rel(moduleRootDir, node)\n\t\t\tif err == nil {\n\t\t\t\tlabel = relPath\n\t\t\t}\n\t\t} else if v.short && modulePath != \"\" && strings.HasPrefix(node, modulePath) {\n\t\t\tlabel = strings.TrimPrefix(node, modulePath)\n\t\t\tlabel = strings.TrimPrefix(label, \"/\")\n\t\t}\n\n\t\tswitch allNodes[node] {\n\t\tcase \"file\":\n\t\t\tfmt.Fprintf(w, `%s%s(\"%s\")`+\"\\n\", indent, id, label)\n\t\tcase \"package\":\n\t\t\tfmt.Fprintf(w, `%s%s[\"%s\"]`+\"\\n\", indent, id, label)\n\t\t}\n\t}\n\n\tfmt.Fprintln(w, \"\")\n\n\t// Write forward dependencies\n\tsortedFroms := make([]string, 0, len(v.dependencies))\n\tfor from := range v.dependencies {\n\t\tsortedFroms = append(sortedFroms, from)\n\t}\n\tsort.Strings(sortedFroms)\n\n\tfor _, from := range sortedFroms {\n\t\ttoList := v.dependencies[from]\n\t\tsort.Strings(toList)\n\t\tfromID := nodeIDs[from]\n\t\tfor _, to := range toList {\n\t\t\tif v.isHidden(from) || v.isHidden(to) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttoID, ok := nodeIDs[to]\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfmt.Fprintf(w, \"%s%s --> %s\\n\", indent, fromID, toID)\n\t\t}\n\t}\n\n\t// Write reverse dependencies\n\tsortedFromsRev := make([]string, 0, len(v.reverseDependencies))\n\tfor from := range v.reverseDependencies {\n\t\tsortedFromsRev = append(sortedFromsRev, from)\n\t}\n\tsort.Strings(sortedFromsRev)\n\n\tfor _, from := range sortedFromsRev {\n\t\ttoList := v.reverseDependencies[from]\n\t\tsort.Strings(toList)\n\t\tfromID := nodeIDs[from]\n\t\tfor _, to := range toList {\n\t\t\tif v.isHidden(from) || v.isHidden(to) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttoID, ok := nodeIDs[to]\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Using a dashed line for reverse dependencies\n\t\t\tfmt.Fprintf(w, \"%s%s -.-> %s\\n\", indent, fromID, toID)\n\t\t}\n\t}\n\n\tif v.short && modulePath != \"\" && v.granularity == \"package\" {\n\t\tfmt.Fprintln(w, \"  end\")\n\t}\n\n\t// Add styling for the start package\n\tif startNodeID, ok := nodeIDs[v.startPkg]; ok {\n\t\tfmt.Fprintf(w, \"\\n%sstyle %s fill:#add8e6,stroke:#333,stroke-width:2px\\n\", indent, startNodeID)\n\t}\n\n\treturn nil\n}\n\nfunc (v *graphVisitor) WriteJSON(w io.Writer, startPkg, direction string) error {\n\ttype jsonOutput struct {\n\t\tConfig\t\t\tmap[string]interface{}\t`json:\"config\"`\n\t\tDependencies\t\tmap[string][]string\t`json:\"dependencies\"`\n\t\tReverseDependencies\tmap[string][]string\t`json:\"reverseDependencies\"`\n\t}\n\n\tsortMap := func(m map[string][]string) map[string][]string {\n\t\tsortedMap := make(map[string][]string, len(m))\n\t\tkeys := make([]string, 0, len(m))\n\t\tfor k := range m {\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t\tsort.Strings(keys)\n\t\tfor _, k := range keys {\n\t\t\tsort.Strings(m[k])\n\t\t\tsortedMap[k] = m[k]\n\t\t}\n\t\treturn sortedMap\n\t}\n\n\t// Filter hidden nodes\n\tfilteredDeps := make(map[string][]string)\n\tfor from, toList := range v.dependencies {\n\t\tif v.isHidden(from) {\n\t\t\tcontinue\n\t\t}\n\t\tvar filteredToList []string\n\t\tfor _, to := range toList {\n\t\t\tif !v.isHidden(to) {\n\t\t\t\tfilteredToList = append(filteredToList, to)\n\t\t\t}\n\t\t}\n\t\tif len(filteredToList) > 0 {\n\t\t\tfilteredDeps[from] = filteredToList\n\t\t}\n\t}\n\n\tfilteredRevDeps := make(map[string][]string)\n\tfor from, toList := range v.reverseDependencies {\n\t\tif v.isHidden(from) {\n\t\t\tcontinue\n\t\t}\n\t\tvar filteredToList []string\n\t\tfor _, to := range toList {\n\t\t\tif !v.isHidden(to) {\n\t\t\t\tfilteredToList = append(filteredToList, to)\n\t\t\t}\n\t\t}\n\t\tif len(filteredToList) > 0 {\n\t\t\tfilteredRevDeps[from] = filteredToList\n\t\t}\n\t}\n\n\toutput := jsonOutput{\n\t\tConfig: map[string]interface{}{\n\t\t\t\"startPkg\":\tstartPkg,\n\t\t\t\"direction\":\tdirection,\n\t\t\t\"hops\":\t\tv.hops,\n\t\t},\n\t\tDependencies:\t\tsortMap(filteredDeps),\n\t\tReverseDependencies:\tsortMap(filteredRevDeps),\n\t}\n\n\tencoder := json.NewEncoder(w)\n\tencoder.SetIndent(\"\", \"  \")\n\tif err := encoder.Encode(output); err != nil {\n\t\treturn fmt.Errorf(\"failed to encode dependencies to JSON: %w\", err)\n\t}\n\treturn nil\n}\n"
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/deps-walk
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/examples/deps-walk
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/examples/deps-walk
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/examples/deps-walk types=2
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/examples/deps-walk
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/deps-walk
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/deps-walk
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/deps-walk
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/deps-walk
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/deps-walk
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/deps-walk
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/deps-walk
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.450Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/deps-walk
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/deps-walk
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/deps-walk scanned=true
time=2025-09-18T09:43:11.451Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/examples/derivingbind/anotherpkg
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/examples/derivingbind/anotherpkg/models_another.go:1:1 source="package anotherpkg\n\n// @deriving:binding\ntype AnotherModel struct {\n\tItemName\tstring\t`in:\"query\" query:\"item_name\" required:\"true\"`\n\tQuantity\t*int\t`in:\"query\" query:\"quantity\"`\n\tIsSpecial\tbool\t`in:\"header\" header:\"X-Special\"`\n}\n"
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/anotherpkg
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/examples/derivingbind/anotherpkg
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/examples/derivingbind/anotherpkg
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/examples/derivingbind/anotherpkg types=1
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/anotherpkg scanned=true
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/examples/derivingbind/anotherpkg
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/anotherpkg scanned=true
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/examples/derivingbind/anotherpkg/anotherpkg_deriving.go:3:1 source="// Code generated by go-scan for package anotherpkg. DO NOT EDIT.\n\npackage anotherpkg\n\nimport (\n\terrors \"errors\"\n\thttp \"net/http\"\n\n\tbinding \"github.com/podhmo/go-scan/examples/derivingbind/binding\"\n\tparser \"github.com/podhmo/go-scan/examples/derivingbind/parser\"\n)\n\nfunc (s *AnotherModel) Bind(req *http.Request, pathVar func(string) string) error {\n\tb := binding.New(req, pathVar)\n\treturn errors.Join(\n\n\t\tbinding.One(b, &s.ItemName, binding.Query, \"item_name\", parser.String, binding.Required),\t// Field: ItemName (string)\n\n\t\tbinding.OnePtr(b, &s.Quantity, binding.Query, \"quantity\", parser.Int, binding.Optional),\t// Field: Quantity (*int)\n\n\t\tbinding.One(b, &s.IsSpecial, binding.Header, \"X-Special\", parser.Bool, binding.Optional),\t// Field: IsSpecial (bool)\n\n\t)\n}\n"
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/anotherpkg
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingbind/anotherpkg scanned=true
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/anotherpkg scanned=true
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/anotherpkg scanned=true
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingbind/anotherpkg
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingbind/anotherpkg scanned=true
time=2025-09-18T09:43:11.451Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingbind/anotherpkg scanned=true
time=2025-09-18T09:43:11.451Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/minigo/stdlib/bufio
time=2025-09-18T09:43:11.452Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/minigo/stdlib/bufio/install.go:3:1 source="// Code generated by minigo-gen-bindings. DO NOT EDIT.\n\npackage bufio\n\nimport (\n\t\"bufio\"\n\t\"reflect\"\n\n\t\"github.com/podhmo/go-scan/minigo\"\n)\n\n// Install binds all exported symbols from the \"bufio\" package to the interpreter.\nfunc Install(interp *minigo.Interpreter) {\n\tinterp.Register(\"bufio\", map[string]any{\n\t\t\"ErrAdvanceTooFar\":\tbufio.ErrAdvanceTooFar,\n\t\t\"ErrBadReadCount\":\tbufio.ErrBadReadCount,\n\t\t\"ErrBufferFull\":\tbufio.ErrBufferFull,\n\t\t\"ErrFinalToken\":\tbufio.ErrFinalToken,\n\t\t\"ErrInvalidUnreadByte\":\tbufio.ErrInvalidUnreadByte,\n\t\t\"ErrInvalidUnreadRune\":\tbufio.ErrInvalidUnreadRune,\n\t\t\"ErrNegativeAdvance\":\tbufio.ErrNegativeAdvance,\n\t\t\"ErrNegativeCount\":\tbufio.ErrNegativeCount,\n\t\t\"ErrTooLong\":\t\tbufio.ErrTooLong,\n\t\t\"MaxScanTokenSize\":\tbufio.MaxScanTokenSize,\n\t\t\"NewReadWriter\":\tbufio.NewReadWriter,\n\t\t\"NewReader\":\t\tbufio.NewReader,\n\t\t\"NewReaderSize\":\tbufio.NewReaderSize,\n\t\t\"NewScanner\":\t\tbufio.NewScanner,\n\t\t\"NewWriter\":\t\tbufio.NewWriter,\n\t\t\"NewWriterSize\":\tbufio.NewWriterSize,\n\t\t\"ScanBytes\":\t\tbufio.ScanBytes,\n\t\t\"ScanLines\":\t\tbufio.ScanLines,\n\t\t\"ScanRunes\":\t\tbufio.ScanRunes,\n\t\t\"ScanWords\":\t\tbufio.ScanWords,\n\t\t\"ReadWriter\":\t\treflect.TypeOf((*bufio.ReadWriter)(nil)).Elem(),\n\t\t\"Reader\":\t\treflect.TypeOf((*bufio.Reader)(nil)).Elem(),\n\t\t\"Scanner\":\t\treflect.TypeOf((*bufio.Scanner)(nil)).Elem(),\n\t\t\"SplitFunc\":\t\treflect.TypeOf((*bufio.SplitFunc)(nil)).Elem(),\n\t\t\"Writer\":\t\treflect.TypeOf((*bufio.Writer)(nil)).Elem(),\n\t})\n}\n"
time=2025-09-18T09:43:11.452Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/bufio
time=2025-09-18T09:43:11.452Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/minigo/stdlib/bufio
time=2025-09-18T09:43:11.452Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/minigo/stdlib/bufio
time=2025-09-18T09:43:11.452Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/minigo/stdlib/bufio types=0
time=2025-09-18T09:43:11.452Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/bufio scanned=true
time=2025-09-18T09:43:11.452Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/minigo/stdlib/bufio
time=2025-09-18T09:43:11.452Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/bufio scanned=true
time=2025-09-18T09:43:11.452Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/bufio
time=2025-09-18T09:43:11.452Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/stdlib/bufio scanned=true
time=2025-09-18T09:43:11.452Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/bufio scanned=true
time=2025-09-18T09:43:11.452Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/minigo/stdlib/text/scanner
time=2025-09-18T09:43:11.452Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/minigo/stdlib/text/scanner/install.go:3:1 source="// Code generated by minigo-gen-bindings. DO NOT EDIT.\n\npackage scanner\n\nimport (\n\t\"reflect\"\n\t\"text/scanner\"\n\n\t\"github.com/podhmo/go-scan/minigo\"\n)\n\n// Install binds all exported symbols from the \"text/scanner\" package to the interpreter.\nfunc Install(interp *minigo.Interpreter) {\n\tinterp.Register(\"text/scanner\", map[string]any{\n\t\t\"Char\":\t\t\tscanner.Char,\n\t\t\"Comment\":\t\tscanner.Comment,\n\t\t\"EOF\":\t\t\tscanner.EOF,\n\t\t\"Float\":\t\tscanner.Float,\n\t\t\"GoTokens\":\t\tscanner.GoTokens,\n\t\t\"GoWhitespace\":\t\tscanner.GoWhitespace,\n\t\t\"Ident\":\t\tscanner.Ident,\n\t\t\"Int\":\t\t\tscanner.Int,\n\t\t\"RawString\":\t\tscanner.RawString,\n\t\t\"ScanChars\":\t\tscanner.ScanChars,\n\t\t\"ScanComments\":\t\tscanner.ScanComments,\n\t\t\"ScanFloats\":\t\tscanner.ScanFloats,\n\t\t\"ScanIdents\":\t\tscanner.ScanIdents,\n\t\t\"ScanInts\":\t\tscanner.ScanInts,\n\t\t\"ScanRawStrings\":\tscanner.ScanRawStrings,\n\t\t\"ScanStrings\":\t\tscanner.ScanStrings,\n\t\t\"SkipComments\":\t\tscanner.SkipComments,\n\t\t\"String\":\t\tscanner.String,\n\t\t\"TokenString\":\t\tscanner.TokenString,\n\t\t\"Position\":\t\treflect.TypeOf((*scanner.Position)(nil)).Elem(),\n\t\t\"Scanner\":\t\treflect.TypeOf((*scanner.Scanner)(nil)).Elem(),\n\t})\n}\n"
time=2025-09-18T09:43:11.452Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/text/scanner
time=2025-09-18T09:43:11.452Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/minigo/stdlib/text/scanner
time=2025-09-18T09:43:11.452Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/minigo/stdlib/text/scanner
time=2025-09-18T09:43:11.452Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/minigo/stdlib/text/scanner types=0
time=2025-09-18T09:43:11.452Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/text/scanner scanned=true
time=2025-09-18T09:43:11.452Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/minigo/stdlib/text/scanner
time=2025-09-18T09:43:11.453Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/text/scanner scanned=true
time=2025-09-18T09:43:11.453Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/text/scanner
time=2025-09-18T09:43:11.453Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/stdlib/text/scanner scanned=true
time=2025-09-18T09:43:11.453Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/text/scanner scanned=true
time=2025-09-18T09:43:11.453Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/examples/convert-define
time=2025-09-18T09:43:11.453Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/examples/convert-define/main.go:1:1 source="package main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"os\"\n\t\"strings\"\n\n\tgoscan \"github.com/podhmo/go-scan\"\n\t\"github.com/podhmo/go-scan/examples/convert-define/internal\"\n\t\"github.com/podhmo/go-scan/examples/convert/generator\"\n\t\"github.com/podhmo/go-scan/scanner\"\n\t\"golang.org/x/tools/imports\"\n)\n\n// logLevelVar is a custom flag.Value implementation for slog.LevelVar\ntype logLevelVar struct {\n\tlevelVar *slog.LevelVar\n}\n\nfunc (v *logLevelVar) String() string {\n\tif v.levelVar == nil {\n\t\treturn \"\"\n\t}\n\treturn v.levelVar.Level().String()\n}\n\nfunc (v *logLevelVar) Set(s string) error {\n\tvar level slog.Level\n\tswitch strings.ToLower(s) {\n\tcase \"debug\":\n\t\tlevel = slog.LevelDebug\n\tcase \"info\":\n\t\tlevel = slog.LevelInfo\n\tcase \"warn\":\n\t\tlevel = slog.LevelWarn\n\tcase \"error\":\n\t\tlevel = slog.LevelError\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown log level: %s\", s)\n\t}\n\tv.levelVar.Set(level)\n\treturn nil\n}\n\nfunc main() {\n\tvar (\n\t\tdefineFile\t= flag.String(\"file\", \"\", \"path to the go file with conversion definitions\")\n\t\toutput\t\t= flag.String(\"output\", \"generated.go\", \"output file name\")\n\t\tdryRun\t\t= flag.Bool(\"dry-run\", false, \"don't write files, just print to stdout\")\n\t\tbuildTags\t= flag.String(\"tags\", \"\", \"build tags to use when running the code generator\")\n\t\tlogLevel\t= new(slog.LevelVar)\n\t)\n\tflag.Var(&logLevelVar{levelVar: logLevel}, \"log-level\", \"set log level (debug, info, warn, error)\")\n\tflag.Usage = func() {\n\t\tfmt.Fprintf(os.Stderr, \"Usage: convert-define -file <definitions.go> [-output <filename>]\\n\")\n\t\tflag.PrintDefaults()\n\t}\n\tflag.Parse()\n\n\tif *defineFile == \"\" {\n\t\tflag.Usage()\n\t\tos.Exit(1)\n\t}\n\n\topts := slog.HandlerOptions{Level: logLevel}\n\tlogger := slog.New(slog.NewTextHandler(os.Stderr, &opts))\n\tslog.SetDefault(logger)\n\n\tctx := context.Background()\n\n\tif err := run(ctx, *defineFile, *output, *dryRun, *buildTags); err != nil {\n\t\tslog.ErrorContext(ctx, \"Error\", slog.Any(\"error\", err))\n\t\tos.Exit(1)\n\t}\n}\n\nfunc run(ctx context.Context, defineFile, output string, dryRun bool, buildTags string) error {\n\tslog.InfoContext(ctx, \"Starting parser\", \"file\", defineFile)\n\n\t// Add overrides for standard library types that cause scanning issues.\n\toverrides := scanner.ExternalTypeOverride{\n\t\t\"time.Time\": &scanner.TypeInfo{\n\t\t\tName:\t\t\"Time\",\n\t\t\tPkgPath:\t\"time\",\n\t\t\tKind:\t\tscanner.StructKind,\n\t\t},\n\t\t\"*time.Time\": &scanner.TypeInfo{\n\t\t\tName:\t\t\"Time\",\n\t\t\tPkgPath:\t\"time\",\n\t\t\tKind:\t\tscanner.StructKind,\n\t\t},\n\t}\n\trunner, err := internal.NewRunner(\n\t\tgoscan.WithGoModuleResolver(),\n\t\tgoscan.WithExternalTypeOverrides(overrides),\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create interpreter runner: %w\", err)\n\t}\n\n\tif err := runner.Run(ctx, defineFile); err != nil {\n\t\treturn fmt.Errorf(\"failed to run definition script: %w\", err)\n\t}\n\n\t// Set the package name after running, so the file has been parsed.\n\trunner.Info.PackageName = runner.PackageName()\n\n\tslog.InfoContext(ctx, \"Successfully parsed define file\", \"parsed_info\", runner.Info)\n\n\theader := \"\"\n\tif buildTags != \"\" {\n\t\theader = fmt.Sprintf(\"\\n//go:build %s\\n// +build %s\\n\\n\", buildTags, buildTags)\n\t}\n\tgeneratedCode, err := generator.Generate(runner.Scanner(), runner.Info, header)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to generate code: %w\", err)\n\t}\n\n\tslog.DebugContext(ctx, \"Writing output\", \"file\", output)\n\tformatted, err := formatCode(ctx, output, generatedCode)\n\tif err != nil {\n\t\tslog.WarnContext(ctx, \"code formatting failed, using unformatted code\", \"error\", err)\n\t\tformatted = generatedCode\t// Use unformatted code on format error\n\t}\n\n\tif dryRun {\n\t\tslog.InfoContext(ctx, \"Dry run: skipping file write\", \"path\", output)\n\t\tfmt.Fprintf(os.Stdout, \"---\\n// file: %s\\n---\\n\", output)\n\t\tos.Stdout.Write(formatted)\n\t} else {\n\t\tif err := os.WriteFile(output, formatted, 0644); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to write formatted code to %s: %w\", output, err)\n\t\t}\n\t}\n\n\tslog.InfoContext(ctx, \"Successfully generated skeleton file\", \"output\", output)\n\treturn nil\n}\n\nfunc formatCode(ctx context.Context, filename string, src []byte) ([]byte, error) {\n\tformatted, err := imports.Process(filename, src, nil)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"goimports failed: %w\", err)\n\t}\n\treturn formatted, nil\n}\n"
time=2025-09-18T09:43:11.454Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert-define
time=2025-09-18T09:43:11.454Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/examples/convert-define
time=2025-09-18T09:43:11.454Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/examples/convert-define
time=2025-09-18T09:43:11.454Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/examples/convert-define types=1
time=2025-09-18T09:43:11.457Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert-define scanned=true
time=2025-09-18T09:43:11.457Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/examples/convert-define
time=2025-09-18T09:43:11.457Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert-define scanned=true
time=2025-09-18T09:43:11.457Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert-define
time=2025-09-18T09:43:11.457Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert-define scanned=true
time=2025-09-18T09:43:11.457Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert-define scanned=true
time=2025-09-18T09:43:11.457Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert-define
time=2025-09-18T09:43:11.457Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert-define scanned=true
time=2025-09-18T09:43:11.457Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert-define scanned=true
time=2025-09-18T09:43:11.457Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert-define
time=2025-09-18T09:43:11.457Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert-define scanned=true
time=2025-09-18T09:43:11.470Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert-define scanned=true
time=2025-09-18T09:43:11.470Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert-define
time=2025-09-18T09:43:11.470Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert-define scanned=true
time=2025-09-18T09:43:11.470Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert-define scanned=true
time=2025-09-18T09:43:11.470Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/convert-define
time=2025-09-18T09:43:11.470Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/convert-define scanned=true
time=2025-09-18T09:43:11.470Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/convert-define scanned=true
time=2025-09-18T09:43:11.470Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/examples/derivingjson/gen
time=2025-09-18T09:43:11.471Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/examples/derivingjson/gen/generate.go:1:1 source="package gen\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"embed\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"text/template\"\n\n\tgoscan \"github.com/podhmo/go-scan\"\n\t\"github.com/podhmo/go-scan/scanner\"\n)\n\n//go:embed unmarshal.tmpl marshal.tmpl\nvar templateFile embed.FS\n\nconst unmarshalAnnotation = \"deriving:unmarshal\"\nconst marshalAnnotation = \"deriving:marshal\"\n\ntype TemplateData struct {\n\tStructName\t\t\tstring\n\tOtherFields\t\t\t[]FieldInfo\n\tOneOfFields\t\t\t[]OneOfFieldDetail\n\tDiscriminatorFieldJSONName\tstring\n}\n\ntype MarshalTemplateData struct {\n\tStructName\t\t\tstring\n\tDiscriminatorFieldJSONName\tstring\n\tDiscriminatorValue\t\tstring\n}\n\ntype FieldInfo struct {\n\tName\tstring\n\tType\tstring\n\tJSONTag\tstring\n}\n\ntype OneOfFieldDetail struct {\n\tFieldName\tstring\n\tFieldType\tstring\n\tJSONTag\t\tstring\n\tImplementers\t[]OneOfTypeMapping\n}\n\ntype OneOfTypeMapping struct {\n\tJSONValue\tstring\n\tGoType\t\tstring\n}\n\nfunc findTypeInPackage(pkgInfo *scanner.PackageInfo, typeName string) *scanner.TypeInfo {\n\tfor _, t := range pkgInfo.Types {\n\t\tif t.Name == typeName {\n\t\t\treturn t\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc Generate(ctx context.Context, gscn *goscan.Scanner, pkgInfo *scanner.PackageInfo, importManager *goscan.ImportManager) ([]byte, error) {\n\tif pkgInfo == nil {\n\t\treturn nil, fmt.Errorf(\"cannot generate code for a nil package\")\n\t}\n\tvar generatedCodeForAllStructs bytes.Buffer\n\tanyCodeGenerated := false\n\n\tfor _, typeInfo := range pkgInfo.Types {\n\t\tif typeInfo.Kind != scanner.StructKind || typeInfo.Struct == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif _, ok := typeInfo.Annotation(ctx, unmarshalAnnotation); !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tdata := TemplateData{\n\t\t\tStructName:\t\t\ttypeInfo.Name,\n\t\t\tOneOfFields:\t\t\t[]OneOfFieldDetail{},\n\t\t\tOtherFields:\t\t\t[]FieldInfo{},\n\t\t\tDiscriminatorFieldJSONName:\t\"type\",\t// Default discriminator\n\t\t}\n\n\t\tfor _, field := range typeInfo.Struct.Fields {\n\t\t\tjsonTag := field.TagValue(\"json\")\n\t\t\tvar resolvedFieldType *scanner.TypeInfo\n\t\t\tif field.Type.FullImportPath == \"\" {\n\t\t\t\tresolvedFieldType = findTypeInPackage(pkgInfo, field.Type.Name)\n\t\t\t} else {\n\t\t\t\tresolvedFieldType, _ = gscn.ResolveType(ctx, field.Type)\n\t\t\t}\n\n\t\t\tisInterfaceField := false\n\t\t\tif resolvedFieldType != nil && resolvedFieldType.Kind == scanner.InterfaceKind {\n\t\t\t\tisInterfaceField = true\n\t\t\t} else if resolvedFieldType == nil && strings.Contains(field.Type.Name, \"interface{\") {\t// Heuristic for anonymous interfaces\n\t\t\t\tisInterfaceField = true\n\t\t\t}\n\n\t\t\tif isInterfaceField {\n\t\t\t\toneOfDetail := OneOfFieldDetail{\n\t\t\t\t\tFieldName:\tfield.Name,\n\t\t\t\t\tJSONTag:\tjsonTag,\n\t\t\t\t\tImplementers:\t[]OneOfTypeMapping{},\n\t\t\t\t}\n\n\t\t\t\tvar interfaceDef *scanner.TypeInfo = resolvedFieldType\n\t\t\t\tvar interfaceDefiningPkgImportPath string\n\n\t\t\t\tif interfaceDef != nil {\t// Resolved interface\n\t\t\t\t\tif field.Type.FullImportPath != \"\" && field.Type.FullImportPath != pkgInfo.ImportPath {\n\t\t\t\t\t\tinterfaceDefiningPkgImportPath = field.Type.FullImportPath\n\t\t\t\t\t} else if interfaceDef.FilePath != \"\" {\n\t\t\t\t\t\tinterfaceDir := filepath.Dir(interfaceDef.FilePath)\n\t\t\t\t\t\tscannedPkgForInterfaceFile, errPkgScan := gscn.ScanPackage(ctx, interfaceDir)\n\t\t\t\t\t\tif errPkgScan == nil && scannedPkgForInterfaceFile != nil && scannedPkgForInterfaceFile.ImportPath != \"\" {\n\t\t\t\t\t\t\tinterfaceDefiningPkgImportPath = scannedPkgForInterfaceFile.ImportPath\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinterfaceDefiningPkgImportPath = pkgInfo.ImportPath\t// Fallback\n\t\t\t\t\t\t\tif errPkgScan != nil {\n\t\t\t\t\t\t\t\tslog.WarnContext(ctx, \"Could not determine import path for interface's defining package, falling back.\", \"interfaceName\", interfaceDef.Name, \"filePath\", interfaceDef.FilePath, \"error\", errPkgScan)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinterfaceDefiningPkgImportPath = pkgInfo.ImportPath\n\t\t\t\t\t}\n\t\t\t\t\toneOfDetail.FieldType = importManager.Qualify(interfaceDefiningPkgImportPath, interfaceDef.Name)\n\t\t\t\t} else {\t// Likely an anonymous interface string like \"interface{...}\"\n\t\t\t\t\toneOfDetail.FieldType = field.Type.Name\n\t\t\t\t\tinterfaceDefiningPkgImportPath = pkgInfo.ImportPath\n\t\t\t\t\tslog.DebugContext(ctx, \"Handling field as anonymous interface\", \"fieldName\", field.Name, \"fieldType\", field.Type.Name)\n\t\t\t\t\tif interfaceDef == nil {\n\t\t\t\t\t\tslog.WarnContext(ctx, \"Cannot find implementers for anonymous interface field without a resolved TypeInfo\", \"fieldName\", field.Name, \"fieldType\", field.Type.Name)\n\t\t\t\t\t\tdata.OneOfFields = append(data.OneOfFields, oneOfDetail)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsearchPkgs := []*scanner.PackageInfo{pkgInfo}\n\t\t\t\tif interfaceDefiningPkgImportPath != \"\" && interfaceDefiningPkgImportPath != pkgInfo.ImportPath {\n\t\t\t\t\tscannedInterfacePkg, errScan := gscn.ScanPackageByImport(ctx, interfaceDefiningPkgImportPath)\n\t\t\t\t\tif errScan == nil && scannedInterfacePkg != nil {\n\t\t\t\t\t\tif !isPackageInSlice(searchPkgs, scannedInterfacePkg.ImportPath) {\n\t\t\t\t\t\t\tsearchPkgs = append(searchPkgs, scannedInterfacePkg)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if errScan != nil {\n\t\t\t\t\t\tslog.WarnContext(ctx, \"Failed to scan interface's defining package\", \"importPath\", interfaceDefiningPkgImportPath, \"error\", errScan)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprocessedImplementerKeys := make(map[string]bool)\n\t\t\t\tfor _, currentSearchPkg := range searchPkgs {\n\t\t\t\t\tif currentSearchPkg == nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tfor _, candidateType := range currentSearchPkg.Types {\n\t\t\t\t\t\tif candidateType.Kind != scanner.StructKind || candidateType.Struct == nil {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\timplementerKey := currentSearchPkg.ImportPath + \".\" + candidateType.Name\n\t\t\t\t\t\tif processedImplementerKeys[implementerKey] {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif gscn.Implements(ctx, candidateType, interfaceDef) {\n\t\t\t\t\t\t\tprocessedImplementerKeys[implementerKey] = true\n\t\t\t\t\t\t\tvar goTypeString string\n\t\t\t\t\t\t\tif currentSearchPkg.ImportPath != \"\" && currentSearchPkg.ImportPath != pkgInfo.ImportPath {\n\t\t\t\t\t\t\t\tgoTypeString = importManager.Qualify(currentSearchPkg.ImportPath, candidateType.Name)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgoTypeString = candidateType.Name\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif !strings.HasPrefix(goTypeString, \"*\") {\n\t\t\t\t\t\t\t\tgoTypeString = \"*\" + goTypeString\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdiscriminatorValue := strings.ToLower(strings.TrimSuffix(strings.TrimPrefix(candidateType.Name, \"*\"), \"Event\"))\n\n\t\t\t\t\t\t\toneOfDetail.Implementers = append(oneOfDetail.Implementers, OneOfTypeMapping{\n\t\t\t\t\t\t\t\tJSONValue:\tdiscriminatorValue,\n\t\t\t\t\t\t\t\tGoType:\t\tgoTypeString,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdata.OneOfFields = append(data.OneOfFields, oneOfDetail)\n\n\t\t\t} else {\t// Other fields\n\t\t\t\tvar typeName string\n\t\t\t\tif resolvedFieldType != nil && resolvedFieldType.Name != \"\" {\n\t\t\t\t\tdefiningPkgPath := pkgInfo.ImportPath\n\t\t\t\t\tif resolvedFieldType.FilePath != \"\" {\n\t\t\t\t\t\tdir := filepath.Dir(resolvedFieldType.FilePath)\n\t\t\t\t\t\tdefiningActualPkg, errScan := gscn.ScanPackage(ctx, dir)\n\t\t\t\t\t\tif errScan == nil && definingActualPkg != nil && definingActualPkg.ImportPath != \"\" {\n\t\t\t\t\t\t\tdefiningPkgPath = definingActualPkg.ImportPath\n\t\t\t\t\t\t} else if errScan != nil {\n\t\t\t\t\t\t\tslog.DebugContext(ctx, \"Could not scan package for resolved field type, using current package for qualification.\", \"field\", field.Name, \"resolvedTypeName\", resolvedFieldType.Name, \"error\", errScan)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if field.Type.FullImportPath != \"\" {\n\t\t\t\t\t\tdefiningPkgPath = field.Type.FullImportPath\n\t\t\t\t\t}\n\t\t\t\t\ttypeName = importManager.Qualify(definingPkgPath, resolvedFieldType.Name)\n\t\t\t\t} else {\n\t\t\t\t\ttypeName = importManager.Qualify(field.Type.FullImportPath, field.Type.Name)\n\t\t\t\t}\n\t\t\t\tdata.OtherFields = append(data.OtherFields, FieldInfo{Name: field.Name, Type: typeName, JSONTag: jsonTag})\n\t\t\t}\n\t\t}\n\n\t\tif len(data.OneOfFields) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tanyCodeGenerated = true\n\n\t\ttmpl, err := template.ParseFS(templateFile, \"unmarshal.tmpl\")\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to parse template: %w\", err)\n\t\t}\n\t\tvar currentGeneratedCode bytes.Buffer\n\t\tif err := tmpl.Execute(&currentGeneratedCode, data); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to execute template for struct %s: %w\", typeInfo.Name, err)\n\t\t}\n\t\tgeneratedCodeForAllStructs.Write(currentGeneratedCode.Bytes())\n\t\tgeneratedCodeForAllStructs.WriteString(\"\\n\\n\")\n\t}\n\n\t// Scan for marshal annotation\n\tfor _, typeInfo := range pkgInfo.Types {\n\t\tif typeInfo.Kind != scanner.StructKind || typeInfo.Struct == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif _, ok := typeInfo.Annotation(ctx, marshalAnnotation); !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Prepare data for the marshaling template\n\t\tmarshalData := MarshalTemplateData{\n\t\t\tStructName:\t\t\ttypeInfo.Name,\n\t\t\tDiscriminatorFieldJSONName:\t\"type\",\t// Hardcoded for now\n\t\t\tDiscriminatorValue:\t\tstrings.ToLower(typeInfo.Name),\n\t\t}\n\n\t\t// Generate code using the marshal template\n\t\ttmpl, err := template.ParseFS(templateFile, \"marshal.tmpl\")\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to parse marshal template: %w\", err)\n\t\t}\n\t\tvar currentGeneratedCode bytes.Buffer\n\t\tif err := tmpl.Execute(&currentGeneratedCode, marshalData); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to execute marshal template for struct %s: %w\", typeInfo.Name, err)\n\t\t}\n\t\tgeneratedCodeForAllStructs.Write(currentGeneratedCode.Bytes())\n\t\tgeneratedCodeForAllStructs.WriteString(\"\\n\\n\")\n\t\tanyCodeGenerated = true\t// Mark that we've generated some code\n\t}\n\n\tif !anyCodeGenerated {\n\t\tslog.InfoContext(ctx, \"No structs found requiring UnmarshalJSON generation in package\", slog.String(\"package_path\", pkgInfo.Path))\n\t\treturn nil, nil\t// No code generated, but not an error\n\t}\n\n\timportManager.Add(\"encoding/json\", \"\")\n\timportManager.Add(\"fmt\", \"\")\n\n\treturn generatedCodeForAllStructs.Bytes(), nil\n}\n\nfunc isPackageInSlice(slice []*scanner.PackageInfo, importPath string) bool {\n\tfor _, p := range slice {\n\t\tif p.ImportPath == importPath {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
time=2025-09-18T09:43:11.472Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/gen
time=2025-09-18T09:43:11.472Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/examples/derivingjson/gen
time=2025-09-18T09:43:11.472Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/examples/derivingjson/gen
time=2025-09-18T09:43:11.472Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/examples/derivingjson/gen types=5
time=2025-09-18T09:43:11.472Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/gen scanned=true
time=2025-09-18T09:43:11.472Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/examples/derivingjson/gen
time=2025-09-18T09:43:11.472Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/gen scanned=true
time=2025-09-18T09:43:11.472Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/gen
time=2025-09-18T09:43:11.472Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/gen scanned=true
time=2025-09-18T09:43:11.472Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/gen scanned=true
time=2025-09-18T09:43:11.472Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/gen
time=2025-09-18T09:43:11.472Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/gen scanned=true
time=2025-09-18T09:43:11.472Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/gen scanned=true
time=2025-09-18T09:43:11.472Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/gen
time=2025-09-18T09:43:11.472Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/gen scanned=true
time=2025-09-18T09:43:11.472Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/gen scanned=true
time=2025-09-18T09:43:11.472Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.472Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/examples/derivingjson/integrationtest/multioneof.go:1:1 source="package integrationtest\n\n// --- Interfaces for multi oneOf test ---\n\n// Animal interface (for first oneOf field)\ntype Animal interface {\n\tSpeak() string\n\tAnimalKind() string\t// Discriminator value provider\n}\n\n// Vehicle interface (for second oneOf field)\ntype Vehicle interface {\n\tMove() string\n\tVehicleType() string\t// Discriminator value provider\n}\n\n// --- Implementers for Animal ---\n\n// Dog implements Animal\n// @deriving:marshal\ntype Dog struct {\n\tBreed\tstring\t`json:\"breed\"`\n\tNoise\tstring\t`json:\"noise\"`\n}\n\nfunc (d *Dog) Speak() string\t\t{ return d.Noise }\nfunc (d *Dog) AnimalKind() string\t{ return \"dog\" }\n\n// Cat implements Animal\n// @deriving:marshal\ntype Cat struct {\n\tColor\tstring\t`json:\"color\"`\n\tPurr\tbool\t`json:\"purr\"`\n}\n\nfunc (c *Cat) Speak() string\t\t{ return \"meow\" }\nfunc (c *Cat) AnimalKind() string\t{ return \"cat\" }\n\n// --- Implementers for Vehicle ---\n\n// Car implements Vehicle\n// @deriving:marshal\ntype Car struct {\n\tMake\tstring\t`json:\"make\"`\n\tWheels\tint\t`json:\"wheels\"`\n}\n\nfunc (c *Car) Move() string\t\t{ return \"vroom\" }\nfunc (c *Car) VehicleType() string\t{ return \"car\" }\n\n// Bicycle implements Vehicle\n// @deriving:marshal\ntype Bicycle struct {\n\tGears\tint\t`json:\"gears\"`\n\tHasBell\tbool\t`json:\"has_bell\"`\n}\n\nfunc (b *Bicycle) Move() string\t\t{ return \"ding ding\" }\nfunc (b *Bicycle) VehicleType() string\t{ return \"bicycle\" }\n\n// --- Structs with multiple oneOf fields ---\n\n// Scene contains multiple different oneOf fields\n// @deriving:unmarshal\ntype Scene struct {\n\tName\t\tstring\t`json:\"name\"`\n\tMainAnimal\tAnimal\t`json:\"main_animal,omitempty\"`\t// oneOf\n\tMainVehicle\tVehicle\t`json:\"main_vehicle,omitempty\"`\t// oneOf\n\tDescription\tstring\t`json:\"description,omitempty\"`\n}\n\n// Parade contains multiple oneOf fields of the same interface type\n// @deriving:unmarshal\ntype Parade struct {\n\tEventName\tstring\t`json:\"event_name\"`\n\tLeadAnimal\tAnimal\t`json:\"lead_animal,omitempty\"`\t\t// oneOf (Animal)\n\tTrailingAnimal\tAnimal\t`json:\"trailing_animal,omitempty\"`\t// oneOf (Animal)\n\tFloats\t\tint\t`json:\"floats,omitempty\"`\n}\n\n// For these to work with the current generator, the generator needs to be updated\n// to extract the discriminator value (e.g., \"dog\", \"cat\") from a method like AnimalKind() or VehicleType()\n// or from a field within the JSON of the implementer (e.g. a \"type\" field).\n// The current generator hardcodes \"circle\" and \"rectangle\" or uses ToLower(TypeName).\n// I will adjust the generator's discriminator logic slightly to look for a \"type\" field\n// in the JSON if the hardcoded values don't match, and then fall back to ToLower(TypeName).\n// For test data, I will ensure the JSON payloads include a \"type\" field.\n\n// --- Another interface and implementer for testing same package resolution ---\ntype Pet interface {\n\tIsFriendly() bool\n\tPetKind() string\n}\n\n// @deriving:marshal\ntype Goldfish struct {\n\tName\t\tstring\t`json:\"name\"`\n\tBowlShape\tstring\t`json:\"bowl_shape\"`\n}\n\nfunc (g *Goldfish) IsFriendly() bool\t{ return true }\nfunc (g *Goldfish) PetKind() string\t{ return \"goldfish\" }\n\n// @deriving:unmarshal\ntype PetOwner struct {\n\tOwnerName\tstring\t`json:\"owner_name\"`\n\tPet\t\tPet\t`json:\"pet_data,omitempty\"`\t// oneOf\n\tAccessory\tVehicle\t`json:\"accessory,omitempty\"`\t// another oneOf, different type\n}\n"
time=2025-09-18T09:43:11.473Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.473Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.473Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.473Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/examples/derivingjson/integrationtest types=15
time=2025-09-18T09:43:11.473Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.473Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.473Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.475Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/examples/derivingjson/integrationtest/integrationtest_deriving.go:3:1 source="// Code generated by go-scan for package integrationtest. DO NOT EDIT.\n\npackage integrationtest\n\nimport (\n\tjson \"encoding/json\"\n\tfmt \"fmt\"\n)\n\nfunc (s *APIResponse) UnmarshalJSON(data []byte) error {\n\t// Define an alias type to prevent infinite recursion with UnmarshalJSON.\n\ttype Alias APIResponse\n\taux := &struct {\n\t\tData\tjson.RawMessage\t`json:\"data\"`\n\n\t\t// All other fields will be handled by the standard unmarshaler via the Alias.\n\t\t*Alias\n\t}{\n\t\tAlias: (*Alias)(s),\n\t}\n\n\tif err := json.Unmarshal(data, &aux); err != nil {\n\t\treturn fmt.Errorf(\"failed to unmarshal into aux struct for APIResponse: %w\", err)\n\t}\n\n\t// Process Data\n\tif aux.Data != nil && string(aux.Data) != \"null\" {\n\t\tvar discriminatorDoc struct {\n\t\t\tType string `json:\"type\"`\t// Discriminator field\n\t\t}\n\t\tif err := json.Unmarshal(aux.Data, &discriminatorDoc); err != nil {\n\t\t\treturn fmt.Errorf(\"could not detect type from field 'data' (content: %s): %w\", string(aux.Data), err)\n\t\t}\n\n\t\tswitch discriminatorDoc.Type {\n\n\t\tcase \"userprofile\":\n\t\t\tvar content *UserProfile\n\t\t\tif err := json.Unmarshal(aux.Data, &content); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to unmarshal 'data' as *UserProfile for type 'userprofile' (content: %s): %w\", string(aux.Data), err)\n\t\t\t}\n\t\t\ts.Data = content\n\n\t\tcase \"productinfo\":\n\t\t\tvar content *ProductInfo\n\t\t\tif err := json.Unmarshal(aux.Data, &content); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to unmarshal 'data' as *ProductInfo for type 'productinfo' (content: %s): %w\", string(aux.Data), err)\n\t\t\t}\n\t\t\ts.Data = content\n\n\t\tdefault:\n\t\t\tif discriminatorDoc.Type == \"\" {\n\t\t\t\treturn fmt.Errorf(\"discriminator field 'type' missing or empty in 'data' (content: %s)\", string(aux.Data))\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"unknown data type '%s' for field 'data' (content: %s)\", discriminatorDoc.Type, string(aux.Data))\n\t\t}\n\t} else {\n\t\ts.Data = nil\t// Explicitly set to nil if null or empty\n\t}\n\n\treturn nil\n}\n\nfunc (s *Scene) UnmarshalJSON(data []byte) error {\n\t// Define an alias type to prevent infinite recursion with UnmarshalJSON.\n\ttype Alias Scene\n\taux := &struct {\n\t\tMainAnimal\tjson.RawMessage\t`json:\"main_animal\"`\n\n\t\tMainVehicle\tjson.RawMessage\t`json:\"main_vehicle\"`\n\n\t\t// All other fields will be handled by the standard unmarshaler via the Alias.\n\t\t*Alias\n\t}{\n\t\tAlias: (*Alias)(s),\n\t}\n\n\tif err := json.Unmarshal(data, &aux); err != nil {\n\t\treturn fmt.Errorf(\"failed to unmarshal into aux struct for Scene: %w\", err)\n\t}\n\n\t// Process MainAnimal\n\tif aux.MainAnimal != nil && string(aux.MainAnimal) != \"null\" {\n\t\tvar discriminatorDoc struct {\n\t\t\tType string `json:\"type\"`\t// Discriminator field\n\t\t}\n\t\tif err := json.Unmarshal(aux.MainAnimal, &discriminatorDoc); err != nil {\n\t\t\treturn fmt.Errorf(\"could not detect type from field 'main_animal' (content: %s): %w\", string(aux.MainAnimal), err)\n\t\t}\n\n\t\tswitch discriminatorDoc.Type {\n\n\t\tcase \"dog\":\n\t\t\tvar content *Dog\n\t\t\tif err := json.Unmarshal(aux.MainAnimal, &content); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to unmarshal 'main_animal' as *Dog for type 'dog' (content: %s): %w\", string(aux.MainAnimal), err)\n\t\t\t}\n\t\t\ts.MainAnimal = content\n\n\t\tcase \"cat\":\n\t\t\tvar content *Cat\n\t\t\tif err := json.Unmarshal(aux.MainAnimal, &content); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to unmarshal 'main_animal' as *Cat for type 'cat' (content: %s): %w\", string(aux.MainAnimal), err)\n\t\t\t}\n\t\t\ts.MainAnimal = content\n\n\t\tdefault:\n\t\t\tif discriminatorDoc.Type == \"\" {\n\t\t\t\treturn fmt.Errorf(\"discriminator field 'type' missing or empty in 'main_animal' (content: %s)\", string(aux.MainAnimal))\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"unknown data type '%s' for field 'main_animal' (content: %s)\", discriminatorDoc.Type, string(aux.MainAnimal))\n\t\t}\n\t} else {\n\t\ts.MainAnimal = nil\t// Explicitly set to nil if null or empty\n\t}\n\n\t// Process MainVehicle\n\tif aux.MainVehicle != nil && string(aux.MainVehicle) != \"null\" {\n\t\tvar discriminatorDoc struct {\n\t\t\tType string `json:\"type\"`\t// Discriminator field\n\t\t}\n\t\tif err := json.Unmarshal(aux.MainVehicle, &discriminatorDoc); err != nil {\n\t\t\treturn fmt.Errorf(\"could not detect type from field 'main_vehicle' (content: %s): %w\", string(aux.MainVehicle), err)\n\t\t}\n\n\t\tswitch discriminatorDoc.Type {\n\n\t\tcase \"car\":\n\t\t\tvar content *Car\n\t\t\tif err := json.Unmarshal(aux.MainVehicle, &content); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to unmarshal 'main_vehicle' as *Car for type 'car' (content: %s): %w\", string(aux.MainVehicle), err)\n\t\t\t}\n\t\t\ts.MainVehicle = content\n\n\t\tcase \"bicycle\":\n\t\t\tvar content *Bicycle\n\t\t\tif err := json.Unmarshal(aux.MainVehicle, &content); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to unmarshal 'main_vehicle' as *Bicycle for type 'bicycle' (content: %s): %w\", string(aux.MainVehicle), err)\n\t\t\t}\n\t\t\ts.MainVehicle = content\n\n\t\tdefault:\n\t\t\tif discriminatorDoc.Type == \"\" {\n\t\t\t\treturn fmt.Errorf(\"discriminator field 'type' missing or empty in 'main_vehicle' (content: %s)\", string(aux.MainVehicle))\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"unknown data type '%s' for field 'main_vehicle' (content: %s)\", discriminatorDoc.Type, string(aux.MainVehicle))\n\t\t}\n\t} else {\n\t\ts.MainVehicle = nil\t// Explicitly set to nil if null or empty\n\t}\n\n\treturn nil\n}\n\nfunc (s *Parade) UnmarshalJSON(data []byte) error {\n\t// Define an alias type to prevent infinite recursion with UnmarshalJSON.\n\ttype Alias Parade\n\taux := &struct {\n\t\tLeadAnimal\tjson.RawMessage\t`json:\"lead_animal\"`\n\n\t\tTrailingAnimal\tjson.RawMessage\t`json:\"trailing_animal\"`\n\n\t\t// All other fields will be handled by the standard unmarshaler via the Alias.\n\t\t*Alias\n\t}{\n\t\tAlias: (*Alias)(s),\n\t}\n\n\tif err := json.Unmarshal(data, &aux); err != nil {\n\t\treturn fmt.Errorf(\"failed to unmarshal into aux struct for Parade: %w\", err)\n\t}\n\n\t// Process LeadAnimal\n\tif aux.LeadAnimal != nil && string(aux.LeadAnimal) != \"null\" {\n\t\tvar discriminatorDoc struct {\n\t\t\tType string `json:\"type\"`\t// Discriminator field\n\t\t}\n\t\tif err := json.Unmarshal(aux.LeadAnimal, &discriminatorDoc); err != nil {\n\t\t\treturn fmt.Errorf(\"could not detect type from field 'lead_animal' (content: %s): %w\", string(aux.LeadAnimal), err)\n\t\t}\n\n\t\tswitch discriminatorDoc.Type {\n\n\t\tcase \"dog\":\n\t\t\tvar content *Dog\n\t\t\tif err := json.Unmarshal(aux.LeadAnimal, &content); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to unmarshal 'lead_animal' as *Dog for type 'dog' (content: %s): %w\", string(aux.LeadAnimal), err)\n\t\t\t}\n\t\t\ts.LeadAnimal = content\n\n\t\tcase \"cat\":\n\t\t\tvar content *Cat\n\t\t\tif err := json.Unmarshal(aux.LeadAnimal, &content); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to unmarshal 'lead_animal' as *Cat for type 'cat' (content: %s): %w\", string(aux.LeadAnimal), err)\n\t\t\t}\n\t\t\ts.LeadAnimal = content\n\n\t\tdefault:\n\t\t\tif discriminatorDoc.Type == \"\" {\n\t\t\t\treturn fmt.Errorf(\"discriminator field 'type' missing or empty in 'lead_animal' (content: %s)\", string(aux.LeadAnimal))\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"unknown data type '%s' for field 'lead_animal' (content: %s)\", discriminatorDoc.Type, string(aux.LeadAnimal))\n\t\t}\n\t} else {\n\t\ts.LeadAnimal = nil\t// Explicitly set to nil if null or empty\n\t}\n\n\t// Process TrailingAnimal\n\tif aux.TrailingAnimal != nil && string(aux.TrailingAnimal) != \"null\" {\n\t\tvar discriminatorDoc struct {\n\t\t\tType string `json:\"type\"`\t// Discriminator field\n\t\t}\n\t\tif err := json.Unmarshal(aux.TrailingAnimal, &discriminatorDoc); err != nil {\n\t\t\treturn fmt.Errorf(\"could not detect type from field 'trailing_animal' (content: %s): %w\", string(aux.TrailingAnimal), err)\n\t\t}\n\n\t\tswitch discriminatorDoc.Type {\n\n\t\tcase \"dog\":\n\t\t\tvar content *Dog\n\t\t\tif err := json.Unmarshal(aux.TrailingAnimal, &content); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to unmarshal 'trailing_animal' as *Dog for type 'dog' (content: %s): %w\", string(aux.TrailingAnimal), err)\n\t\t\t}\n\t\t\ts.TrailingAnimal = content\n\n\t\tcase \"cat\":\n\t\t\tvar content *Cat\n\t\t\tif err := json.Unmarshal(aux.TrailingAnimal, &content); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to unmarshal 'trailing_animal' as *Cat for type 'cat' (content: %s): %w\", string(aux.TrailingAnimal), err)\n\t\t\t}\n\t\t\ts.TrailingAnimal = content\n\n\t\tdefault:\n\t\t\tif discriminatorDoc.Type == \"\" {\n\t\t\t\treturn fmt.Errorf(\"discriminator field 'type' missing or empty in 'trailing_animal' (content: %s)\", string(aux.TrailingAnimal))\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"unknown data type '%s' for field 'trailing_animal' (content: %s)\", discriminatorDoc.Type, string(aux.TrailingAnimal))\n\t\t}\n\t} else {\n\t\ts.TrailingAnimal = nil\t// Explicitly set to nil if null or empty\n\t}\n\n\treturn nil\n}\n\nfunc (s *PetOwner) UnmarshalJSON(data []byte) error {\n\t// Define an alias type to prevent infinite recursion with UnmarshalJSON.\n\ttype Alias PetOwner\n\taux := &struct {\n\t\tPet\tjson.RawMessage\t`json:\"pet_data\"`\n\n\t\tAccessory\tjson.RawMessage\t`json:\"accessory\"`\n\n\t\t// All other fields will be handled by the standard unmarshaler via the Alias.\n\t\t*Alias\n\t}{\n\t\tAlias: (*Alias)(s),\n\t}\n\n\tif err := json.Unmarshal(data, &aux); err != nil {\n\t\treturn fmt.Errorf(\"failed to unmarshal into aux struct for PetOwner: %w\", err)\n\t}\n\n\t// Process Pet\n\tif aux.Pet != nil && string(aux.Pet) != \"null\" {\n\t\tvar discriminatorDoc struct {\n\t\t\tType string `json:\"type\"`\t// Discriminator field\n\t\t}\n\t\tif err := json.Unmarshal(aux.Pet, &discriminatorDoc); err != nil {\n\t\t\treturn fmt.Errorf(\"could not detect type from field 'pet_data' (content: %s): %w\", string(aux.Pet), err)\n\t\t}\n\n\t\tswitch discriminatorDoc.Type {\n\n\t\tcase \"goldfish\":\n\t\t\tvar content *Goldfish\n\t\t\tif err := json.Unmarshal(aux.Pet, &content); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to unmarshal 'pet_data' as *Goldfish for type 'goldfish' (content: %s): %w\", string(aux.Pet), err)\n\t\t\t}\n\t\t\ts.Pet = content\n\n\t\tdefault:\n\t\t\tif discriminatorDoc.Type == \"\" {\n\t\t\t\treturn fmt.Errorf(\"discriminator field 'type' missing or empty in 'pet_data' (content: %s)\", string(aux.Pet))\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"unknown data type '%s' for field 'pet_data' (content: %s)\", discriminatorDoc.Type, string(aux.Pet))\n\t\t}\n\t} else {\n\t\ts.Pet = nil\t// Explicitly set to nil if null or empty\n\t}\n\n\t// Process Accessory\n\tif aux.Accessory != nil && string(aux.Accessory) != \"null\" {\n\t\tvar discriminatorDoc struct {\n\t\t\tType string `json:\"type\"`\t// Discriminator field\n\t\t}\n\t\tif err := json.Unmarshal(aux.Accessory, &discriminatorDoc); err != nil {\n\t\t\treturn fmt.Errorf(\"could not detect type from field 'accessory' (content: %s): %w\", string(aux.Accessory), err)\n\t\t}\n\n\t\tswitch discriminatorDoc.Type {\n\n\t\tcase \"car\":\n\t\t\tvar content *Car\n\t\t\tif err := json.Unmarshal(aux.Accessory, &content); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to unmarshal 'accessory' as *Car for type 'car' (content: %s): %w\", string(aux.Accessory), err)\n\t\t\t}\n\t\t\ts.Accessory = content\n\n\t\tcase \"bicycle\":\n\t\t\tvar content *Bicycle\n\t\t\tif err := json.Unmarshal(aux.Accessory, &content); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to unmarshal 'accessory' as *Bicycle for type 'bicycle' (content: %s): %w\", string(aux.Accessory), err)\n\t\t\t}\n\t\t\ts.Accessory = content\n\n\t\tdefault:\n\t\t\tif discriminatorDoc.Type == \"\" {\n\t\t\t\treturn fmt.Errorf(\"discriminator field 'type' missing or empty in 'accessory' (content: %s)\", string(aux.Accessory))\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"unknown data type '%s' for field 'accessory' (content: %s)\", discriminatorDoc.Type, string(aux.Accessory))\n\t\t}\n\t} else {\n\t\ts.Accessory = nil\t// Explicitly set to nil if null or empty\n\t}\n\n\treturn nil\n}\n\nfunc (s *UserProfile) MarshalJSON() ([]byte, error) {\n\ttype Alias UserProfile\n\treturn json.Marshal(&struct {\n\t\t*Alias\n\t\tType\tstring\t`json:\"type\"`\n\t}{\n\t\tAlias:\t(*Alias)(s),\n\t\tType:\t\"userprofile\",\n\t})\n}\n\nfunc (s *ProductInfo) MarshalJSON() ([]byte, error) {\n\ttype Alias ProductInfo\n\treturn json.Marshal(&struct {\n\t\t*Alias\n\t\tType\tstring\t`json:\"type\"`\n\t}{\n\t\tAlias:\t(*Alias)(s),\n\t\tType:\t\"productinfo\",\n\t})\n}\n\nfunc (s *Dog) MarshalJSON() ([]byte, error) {\n\ttype Alias Dog\n\treturn json.Marshal(&struct {\n\t\t*Alias\n\t\tType\tstring\t`json:\"type\"`\n\t}{\n\t\tAlias:\t(*Alias)(s),\n\t\tType:\t\"dog\",\n\t})\n}\n\nfunc (s *Cat) MarshalJSON() ([]byte, error) {\n\ttype Alias Cat\n\treturn json.Marshal(&struct {\n\t\t*Alias\n\t\tType\tstring\t`json:\"type\"`\n\t}{\n\t\tAlias:\t(*Alias)(s),\n\t\tType:\t\"cat\",\n\t})\n}\n\nfunc (s *Car) MarshalJSON() ([]byte, error) {\n\ttype Alias Car\n\treturn json.Marshal(&struct {\n\t\t*Alias\n\t\tType\tstring\t`json:\"type\"`\n\t}{\n\t\tAlias:\t(*Alias)(s),\n\t\tType:\t\"car\",\n\t})\n}\n\nfunc (s *Bicycle) MarshalJSON() ([]byte, error) {\n\ttype Alias Bicycle\n\treturn json.Marshal(&struct {\n\t\t*Alias\n\t\tType\tstring\t`json:\"type\"`\n\t}{\n\t\tAlias:\t(*Alias)(s),\n\t\tType:\t\"bicycle\",\n\t})\n}\n\nfunc (s *Goldfish) MarshalJSON() ([]byte, error) {\n\ttype Alias Goldfish\n\treturn json.Marshal(&struct {\n\t\t*Alias\n\t\tType\tstring\t`json:\"type\"`\n\t}{\n\t\tAlias:\t(*Alias)(s),\n\t\tType:\t\"goldfish\",\n\t})\n}\n"
time=2025-09-18T09:43:11.476Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.476Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.476Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.476Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/examples/derivingjson/integrationtest/models.go:2:1 source="// Package models defines the data structures for API responses.\npackage integrationtest\n\n// DataInterface is implemented by types that can be in APIResponse.Data.\n// This helps the generator identify the \"oneOf\" field and its possible concrete types.\ntype DataInterface interface {\n\tisData()\t// A dummy method to make it a concrete interface that types can implement.\n}\n\n// APIResponse is a generic API response structure where the Data field\n// can contain different types of objects that implement DataInterface.\n// @deriving:unmarshal\ntype APIResponse struct {\n\tStatus\tstring\t\t`json:\"status\"`\n\tData\tDataInterface\t`json:\"data\"`\t// Changed from interface{} to DataInterface\n}\n\n// UserProfile is one of the possible types for the Data field.\n// It represents a user's profile information.\n// @deriving:marshal\ntype UserProfile struct {\n\tType\t\tstring\t`json:\"type\"`\t// Discriminator: \"user_profile\" (expected value based on original user request)\n\tUserID\t\tstring\t`json:\"userId\"`\n\tUserName\tstring\t`json:\"userName\"`\n}\n\n// isData implements the DataInterface for UserProfile.\nfunc (UserProfile) isData()\t{}\n\n// ProductInfo is another possible type for the Data field.\n// It represents information about a product.\n// @deriving:marshal\ntype ProductInfo struct {\n\tType\t\tstring\t`json:\"type\"`\t// Discriminator: \"product_info\" (expected value based on original user request)\n\tProductID\tstring\t`json:\"productId\"`\n\tProductName\tstring\t`json:\"productName\"`\n\tPrice\t\tint\t`json:\"price\"`\n}\n\n// isData implements the DataInterface for ProductInfo.\nfunc (ProductInfo) isData()\t{}\n\n// Notes on discriminator values for the generator:\n// The current generator logic (as of the last check) uses:\n//   discriminatorValue = strings.ToLower(candidateType.Name)\n// This would result in \"userprofile\" for UserProfile and \"productinfo\" for ProductInfo.\n// The test JSON in main_test.go has been adjusted to use these lowercase values for now\n// to allow testing of the UnmarshalJSON structure.\n// For the generator to use \"user_profile\" and \"product_info\" (as in the struct tags here),\n// the generator's logic for determining `JSONValue` in `OneOfTypeMapping` would need to be enhanced\n// to inspect struct tags (e.g., from the 'Type' field) or a method on the implementing types.\n// This is a known TODO in the generator code.\n"
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.477Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/derivingjson/integrationtest scanned=true
time=2025-09-18T09:43:11.478Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.514Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/minigo/evaluator/evaluator.go:1:1 source="package evaluator\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/constant\"\n\t\"go/token\"\n\t\"io\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\n\tgoscan \"github.com/podhmo/go-scan\"\n\t\"github.com/podhmo/go-scan/minigo/ffibridge\"\n\t\"github.com/podhmo/go-scan/minigo/object\"\n)\n\n// SpecialFormFunction is the signature for special form functions.\ntype SpecialFormFunction func(e *Evaluator, fscope *object.FileScope, pos token.Pos, args []ast.Expr) object.Object\n\n// SpecialForm represents a special form function.\ntype SpecialForm struct {\n\tFn SpecialFormFunction\n}\n\n// Type returns the type of the SpecialForm object.\nfunc (sf *SpecialForm) Type() object.ObjectType\t{ return object.SPECIAL_FORM_OBJ }\n\n// Inspect returns a string representation of the special form function.\nfunc (sf *SpecialForm) Inspect() string\t{ return \"special form\" }\n\nvar builtins = map[string]*object.Builtin{\n\t\"readln\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 0 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=0, want=0\")\n\t\t\t}\n\t\t\treader := bufio.NewReader(ctx.Stdin)\n\t\t\tline, err := reader.ReadString('\\n')\n\t\t\tif err != nil && err != io.EOF {\n\t\t\t\treturn ctx.NewError(pos, \"error reading from stdin: %v\", err)\n\t\t\t}\n\t\t\treturn &object.String{Value: strings.TrimSpace(line)}\n\t\t},\n\t},\n\t\"len\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 1 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t\t}\n\t\t\tswitch arg := args[0].(type) {\n\t\t\tcase *object.Array:\n\t\t\t\treturn &object.Integer{Value: int64(len(arg.Elements))}\n\t\t\tcase *object.String:\n\t\t\t\treturn &object.Integer{Value: int64(len(arg.Value))}\n\t\t\tcase *object.Map:\n\t\t\t\treturn &object.Integer{Value: int64(len(arg.Pairs))}\n\t\t\tcase *object.GoValue:\n\t\t\t\tval := arg.Value\n\t\t\t\tswitch val.Kind() {\n\t\t\t\tcase reflect.Array, reflect.Slice, reflect.Map, reflect.String:\n\t\t\t\t\treturn &object.Integer{Value: int64(val.Len())}\n\t\t\t\tdefault:\n\t\t\t\t\treturn ctx.NewError(pos, \"argument to `len` not supported, got Go value of type %s\", val.Kind())\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn ctx.NewError(pos, \"argument to `len` not supported, got %s\", args[0].Type())\n\t\t\t}\n\t\t},\n\t},\n\t\"cap\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 1 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t\t}\n\t\t\tswitch arg := args[0].(type) {\n\t\t\tcase *object.Array:\n\t\t\t\treturn &object.Integer{Value: int64(cap(arg.Elements))}\n\t\t\tcase *object.GoValue:\n\t\t\t\tval := arg.Value\n\t\t\t\tswitch val.Kind() {\n\t\t\t\tcase reflect.Array, reflect.Slice:\n\t\t\t\t\treturn &object.Integer{Value: int64(val.Cap())}\n\t\t\t\tdefault:\n\t\t\t\t\treturn ctx.NewError(pos, \"argument to `cap` not supported, got Go value of type %s\", val.Kind())\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn ctx.NewError(pos, \"argument to `cap` not supported, got %s\", args[0].Type())\n\t\t\t}\n\t\t},\n\t},\n\t\"copy\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 2 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=2\", len(args))\n\t\t\t}\n\t\t\tdst, ok := args[0].(*object.Array)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"argument 1 to `copy` must be array, got %s\", args[0].Type())\n\t\t\t}\n\t\t\tsrc, ok := args[1].(*object.Array)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"argument 2 to `copy` must be array, got %s\", args[1].Type())\n\t\t\t}\n\n\t\t\tn := copy(dst.Elements, src.Elements)\n\t\t\treturn &object.Integer{Value: int64(n)}\n\t\t},\n\t},\n\t\"delete\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 2 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=2\", len(args))\n\t\t\t}\n\t\t\tm, ok := args[0].(*object.Map)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"argument to `delete` must be a map, got %s\", args[0].Type())\n\t\t\t}\n\t\t\tkey, ok := args[1].(object.Hashable)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"unusable as map key: %s\", args[1].Type())\n\t\t\t}\n\t\t\tdelete(m.Pairs, key.HashKey())\n\t\t\treturn object.NIL\n\t\t},\n\t},\n\t\"make\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) == 0 {\n\t\t\t\treturn ctx.NewError(pos, \"missing argument to make\")\n\t\t\t}\n\n\t\t\tswitch typeArg := args[0].(type) {\n\t\t\tcase *object.MapType:\n\t\t\t\tif len(args) > 2 {\n\t\t\t\t\treturn ctx.NewError(pos, \"make(map) takes at most 1 size argument\")\n\t\t\t\t}\n\t\t\t\t// The optional size argument is ignored for now.\n\t\t\t\treturn &object.Map{Pairs: make(map[object.HashKey]object.MapPair)}\n\n\t\t\tcase *object.ArrayType:\n\t\t\t\tif len(args) < 2 || len(args) > 3 {\n\t\t\t\t\treturn ctx.NewError(pos, \"make([]T) requires len and optional cap arguments\")\n\t\t\t\t}\n\t\t\t\tlenArg, ok := args[1].(*object.Integer)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn ctx.NewError(pos, \"argument 2 to `make` must be an integer, got %s\", args[1].Type())\n\t\t\t\t}\n\t\t\t\tlength := lenArg.Value\n\n\t\t\t\tvar capacity int64\n\t\t\t\tif len(args) == 3 {\n\t\t\t\t\tcapArg, ok := args[2].(*object.Integer)\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn ctx.NewError(pos, \"argument 3 to `make` must be an integer, got %s\", args[2].Type())\n\t\t\t\t\t}\n\t\t\t\t\tcapacity = capArg.Value\n\t\t\t\t} else {\n\t\t\t\t\tcapacity = length\n\t\t\t\t}\n\n\t\t\t\tif length < 0 || capacity < 0 || length > capacity {\n\t\t\t\t\treturn ctx.NewError(pos, \"invalid arguments: len=%d, cap=%d\", length, capacity)\n\t\t\t\t}\n\n\t\t\t\telements := make([]object.Object, length, capacity)\n\t\t\t\tfor i := range elements {\n\t\t\t\t\telements[i] = object.NIL\t// Zero-value for slices is nil elements\n\t\t\t\t}\n\t\t\t\treturn &object.Array{Elements: elements}\n\t\t\tdefault:\n\t\t\t\treturn ctx.NewError(pos, \"argument 1 to `make` must be a slice or map type, got %s\", typeArg.Type())\n\t\t\t}\n\t\t},\n\t},\n\t\"clear\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 1 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t\t}\n\t\t\tswitch arg := args[0].(type) {\n\t\t\tcase *object.Map:\n\t\t\t\targ.Pairs = make(map[object.HashKey]object.MapPair)\n\t\t\t\treturn object.NIL\n\t\t\tcase *object.Array:\n\t\t\t\tfor i := range arg.Elements {\n\t\t\t\t\targ.Elements[i] = object.NIL\t// In a real GC'd language, this would be the zero value for the element type.\n\t\t\t\t}\n\t\t\t\treturn object.NIL\n\t\t\tdefault:\n\t\t\t\treturn ctx.NewError(pos, \"argument to `clear` must be map or slice, got %s\", arg.Type())\n\t\t\t}\n\t\t},\n\t},\n\t\"complex\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 2 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=2\", len(args))\n\t\t\t}\n\n\t\t\tgetNumberAsFloat := func(arg object.Object) (float64, bool) {\n\t\t\t\tswitch n := arg.(type) {\n\t\t\t\tcase *object.Integer:\n\t\t\t\t\treturn float64(n.Value), true\n\t\t\t\tcase *object.Float:\n\t\t\t\t\treturn n.Value, true\n\t\t\t\tdefault:\n\t\t\t\t\treturn 0, false\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tr, ok := getNumberAsFloat(args[0])\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"argument 1 to `complex` must be a number, got %s\", args[0].Type())\n\t\t\t}\n\t\t\ti, ok := getNumberAsFloat(args[1])\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"argument 2 to `complex` must be a number, got %s\", args[1].Type())\n\t\t\t}\n\n\t\t\treturn &object.Complex{Real: r, Imag: i}\n\t\t},\n\t},\n\t\"real\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 1 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t\t}\n\t\t\tc, ok := args[0].(*object.Complex)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"argument to `real` must be a complex number, got %s\", args[0].Type())\n\t\t\t}\n\t\t\treturn &object.Float{Value: c.Real}\n\t\t},\n\t},\n\t\"imag\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 1 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t\t}\n\t\t\tc, ok := args[0].(*object.Complex)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"argument to `imag` must be a complex number, got %s\", args[0].Type())\n\t\t\t}\n\t\t\treturn &object.Float{Value: c.Imag}\n\t\t},\n\t},\n\t\"append\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) < 2 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want at least 2\", len(args))\n\t\t\t}\n\n\t\t\tvar elements []object.Object\n\t\t\tif arr, ok := args[0].(*object.Array); ok {\n\t\t\t\telements = arr.Elements\n\t\t\t} else if args[0] == object.NIL || args[0].Type() == object.TYPED_NIL_OBJ {\n\t\t\t\telements = []object.Object{}\n\t\t\t} else {\n\t\t\t\treturn ctx.NewError(pos, \"argument to `append` must be array or nil, got %s\", args[0].Type())\n\t\t\t}\n\n\t\t\tnewElements := make([]object.Object, len(elements), len(elements)+len(args)-1)\n\t\t\tcopy(newElements, elements)\n\t\t\tnewElements = append(newElements, args[1:]...)\n\n\t\t\treturn &object.Array{Elements: newElements}\n\t\t},\n\t},\n\t\"max\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) == 0 {\n\t\t\t\treturn ctx.NewError(pos, \"max() requires at least one argument\")\n\t\t\t}\n\t\t\tmaxVal, ok := args[0].(*object.Integer)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"all arguments to max() must be integers\")\n\t\t\t}\n\t\t\tfor i := 1; i < len(args); i++ {\n\t\t\t\tval, ok := args[i].(*object.Integer)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn ctx.NewError(pos, \"all arguments to max() must be integers\")\n\t\t\t\t}\n\t\t\t\tif val.Value > maxVal.Value {\n\t\t\t\t\tmaxVal = val\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn maxVal\n\t\t},\n\t},\n\t\"min\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) == 0 {\n\t\t\t\treturn ctx.NewError(pos, \"min() requires at least one argument\")\n\t\t\t}\n\t\t\tminVal, ok := args[0].(*object.Integer)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"all arguments to min() must be integers\")\n\t\t\t}\n\t\t\tfor i := 1; i < len(args); i++ {\n\t\t\t\tval, ok := args[i].(*object.Integer)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn ctx.NewError(pos, \"all arguments to min() must be integers\")\n\t\t\t\t}\n\t\t\t\tif val.Value < minVal.Value {\n\t\t\t\t\tminVal = val\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn minVal\n\t\t},\n\t},\n\t\"new\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 1 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t\t}\n\t\t\t// We can't call resolveType here directly because we don't have the evaluator.\n\t\t\t// This means `new(MyAlias)` where `MyAlias = MyStruct` won't work yet.\n\t\t\t// This is a limitation we'll accept for now. A better design would\n\t\t\t// make the evaluator available to builtins that need it.\n\t\t\tdef, ok := args[0].(*object.StructDefinition)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"argument to `new` must be a struct type, got %s\", args[0].Type())\n\t\t\t}\n\n\t\t\t// Create a zero-valued instance of the struct.\n\t\t\tinstance := &object.StructInstance{\n\t\t\t\tDef:\tdef,\n\t\t\t\tFields:\tmake(map[string]object.Object),\n\t\t\t}\n\t\t\tfor _, field := range def.Fields {\n\t\t\t\t// For now, we'll just initialize with NIL. A more advanced implementation\n\t\t\t\t// would handle zero values for different types (0, \"\", false).\n\t\t\t\tinstance.Fields[field.Names[0].Name] = object.NIL\n\t\t\t}\n\n\t\t\tvar obj object.Object = instance\n\t\t\treturn &object.Pointer{Element: &obj}\n\t\t},\n\t},\n\t\"panic\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 1 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t\t}\n\t\t\treturn &object.Panic{Value: args[0]}\n\t\t},\n\t},\n\t\"recover\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 0 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=0\", len(args))\n\t\t\t}\n\t\t\t// recover is only effective in deferred functions.\n\t\t\tif !ctx.IsExecutingDefer() {\n\t\t\t\treturn object.NIL\n\t\t\t}\n\t\t\tif p := ctx.GetPanic(); p != nil {\n\t\t\t\tctx.ClearPanic()\n\t\t\t\treturn p.Value\n\t\t\t}\n\t\t\treturn object.NIL\n\t\t},\n\t},\n\t\"close\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 1 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t\t}\n\t\t\t// Since channels are not supported, any argument is invalid.\n\t\t\treturn ctx.NewError(pos, \"argument to `close` must be a channel, got %s\", args[0].Type())\n\t\t},\n\t},\n\t\"print\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tfor i, arg := range args {\n\t\t\t\tif i > 0 {\n\t\t\t\t\tfmt.Fprint(ctx.Stdout, \" \")\n\t\t\t\t}\n\t\t\t\tfmt.Fprint(ctx.Stdout, arg.Inspect())\n\t\t\t}\n\t\t\treturn object.NIL\n\t\t},\n\t},\n\t\"println\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tfor i, arg := range args {\n\t\t\t\tif i > 0 {\n\t\t\t\t\tfmt.Fprint(ctx.Stdout, \" \")\n\t\t\t\t}\n\t\t\t\tfmt.Fprint(ctx.Stdout, arg.Inspect())\n\t\t\t}\n\t\t\tfmt.Fprintln(ctx.Stdout)\n\t\t\treturn object.NIL\n\t\t},\n\t},\n}\n\n// Evaluator is the main object that evaluates the AST.\ntype Evaluator struct {\n\tobject.BuiltinContext\n\tscanner\t\t\t*goscan.Scanner\n\tregistry\t\t*object.SymbolRegistry\n\tspecialForms\t\tmap[string]*SpecialForm\n\tpackages\t\tmap[string]*object.Package\t// Central package cache\n\tcallStack\t\t[]*object.CallFrame\n\tcurrentPanic\t\t*object.Panic\t// The currently active panic\n\tisExecutingDefer\tbool\t\t// True if the evaluator is currently running a deferred function\n}\n\n// Config holds the configuration for creating a new Evaluator.\ntype Config struct {\n\tFset\t\t*token.FileSet\n\tScanner\t\t*goscan.Scanner\n\tRegistry\t*object.SymbolRegistry\n\tSpecialForms\tmap[string]*SpecialForm\n\tPackages\tmap[string]*object.Package\n\tStdin\t\tio.Reader\n\tStdout\t\tio.Writer\n\tStderr\t\tio.Writer\n}\n\n// New creates a new Evaluator.\nfunc New(cfg Config) *Evaluator {\n\te := &Evaluator{\n\t\tscanner:\tcfg.Scanner,\n\t\tregistry:\tcfg.Registry,\n\t\tspecialForms:\tcfg.SpecialForms,\n\t\tpackages:\tcfg.Packages,\n\t\tcallStack:\tmake([]*object.CallFrame, 0),\n\t}\n\te.BuiltinContext = object.BuiltinContext{\n\t\tStdin:\tcfg.Stdin,\n\t\tStdout:\tcfg.Stdout,\n\t\tStderr:\tcfg.Stderr,\n\t\tFset:\tcfg.Fset,\n\t\tIsExecutingDefer: func() bool {\n\t\t\treturn e.isExecutingDefer\n\t\t},\n\t\tGetPanic: func() *object.Panic {\n\t\t\treturn e.currentPanic\n\t\t},\n\t\tClearPanic: func() {\n\t\t\te.currentPanic = nil\n\t\t},\n\t\tNewError: func(pos token.Pos, format string, v ...interface{}) *object.Error {\n\t\t\treturn e.newError(pos, format, v...)\n\t\t},\n\t}\n\treturn e\n}\n\n// inferTypeOf infers the object.Object representing the type of a given value object.\nfunc (e *Evaluator) inferTypeOf(obj object.Object) object.Object {\n\tswitch o := obj.(type) {\n\tcase *object.TypedNil:\n\t\treturn o.TypeObject\n\tcase *object.Integer:\n\t\treturn &object.Type{Name: \"int\"}\n\tcase *object.Float:\n\t\treturn &object.Type{Name: \"float64\"}\n\tcase *object.String:\n\t\treturn &object.Type{Name: \"string\"}\n\tcase *object.Boolean:\n\t\treturn &object.Type{Name: \"bool\"}\n\tcase *object.StructInstance:\n\t\t// The type of a struct instance is its definition.\n\t\treturn o.Def\n\tcase *object.Pointer:\n\t\tif o.Element == nil || *o.Element == nil {\n\t\t\t// Cannot infer type from a nil pointer.\n\t\t\treturn object.NIL\n\t\t}\n\t\t// Recursively find the type of the pointed-to element and wrap it in a pointer type.\n\t\telemType := e.inferTypeOf(*o.Element)\n\t\tif elemType == object.NIL {\n\t\t\treturn object.NIL\n\t\t}\n\t\treturn &object.PointerType{ElementType: elemType}\n\tcase *object.Array:\n\t\tif o.SliceType != nil {\n\t\t\treturn o.SliceType\n\t\t}\n\t\t// For a fully typed system, we would need to know the array's element type.\n\t\tif len(o.Elements) == 0 {\n\t\t\t// Cannot infer type from an empty slice.\n\t\t\t// This is a known limitation in Go's type inference too.\n\t\t\t// We could potentially return a special \"any\" type here if needed.\n\t\t\treturn nil\n\t\t}\n\t\t// Infer from the first element. Assumes a homogeneous slice.\n\t\telemType := e.inferTypeOf(o.Elements[0])\n\t\tif elemType == nil {\n\t\t\treturn nil\n\t\t}\n\t\t// Return an ArrayType object that represents `[]<elemType>`\n\t\treturn &object.ArrayType{ElementType: elemType}\n\tcase *object.Map:\n\t\tif o.MapType != nil {\n\t\t\treturn o.MapType\n\t\t}\n\t\tif len(o.Pairs) == 0 {\n\t\t\treturn nil\n\t\t}\n\t\tvar keyType, valType object.Object\n\t\tfor _, pair := range o.Pairs {\n\t\t\tkeyType = e.inferTypeOf(pair.Key)\n\t\t\tvalType = e.inferTypeOf(pair.Value)\n\t\t\tbreak\t// Infer from the first pair\n\t\t}\n\t\tif keyType == nil || valType == nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn &object.MapType{KeyType: keyType, ValueType: valType}\n\tdefault:\n\t\t// Fallback for types we can't infer simply.\n\t\treturn nil\n\t}\n}\n\nfunc (e *Evaluator) inferGenericTypes(pos token.Pos, f *object.Function, args []object.Object) ([]object.Object, object.Object) {\n\t// 1. Get the names of all type parameters (e.g., {\"T\": true, \"K\": true})\n\ttypeParamNames := make(map[string]bool)\n\tfor _, field := range f.TypeParams.List {\n\t\tfor _, name := range field.Names {\n\t\t\ttypeParamNames[name.Name] = true\n\t\t}\n\t}\n\n\t// 2. Map inferred types by name (e.g., \"T\" -> &object.Type{Name:\"int\"})\n\tinferredTypes := make(map[string]object.Object)\n\n\t// 3. Iterate through function parameters and corresponding arguments\n\tfor i, paramField := range f.Parameters.List {\n\t\t// Handle simple generic type like 'T'\n\t\tif paramTypeIdent, ok := paramField.Type.(*ast.Ident); ok {\n\t\t\t// Check if the parameter's type is one of the generic type parameters\n\t\t\tif _, isGeneric := typeParamNames[paramTypeIdent.Name]; isGeneric {\n\t\t\t\tif i >= len(args) {\n\t\t\t\t\t// Not enough arguments provided to infer this type.\n\t\t\t\t\treturn nil, e.newError(pos, \"cannot infer type for generic parameter %s: not enough arguments\", paramTypeIdent.Name)\n\t\t\t\t}\n\n\t\t\t\targType := e.inferTypeOf(args[i])\n\t\t\t\tif argType == nil || argType == object.NIL {\n\t\t\t\t\treturn nil, e.newError(pos, \"cannot infer type for generic parameter %s from argument %d of type %s\", paramTypeIdent.Name, i, args[i].Type())\n\t\t\t\t}\n\n\t\t\t\t// Check for conflicting inferences\n\t\t\t\tif existing, ok := inferredTypes[paramTypeIdent.Name]; ok {\n\t\t\t\t\t// A simple pointer comparison for types works for primitives. For complex types, we compare inspect strings.\n\t\t\t\t\tif existing != argType && existing.Inspect() != argType.Inspect() {\n\t\t\t\t\t\treturn nil, e.newError(pos, \"cannot infer type for %s: conflicting types %s and %s\", paramTypeIdent.Name, existing.Inspect(), argType.Inspect())\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tinferredTypes[paramTypeIdent.Name] = argType\n\t\t\t\t}\n\t\t\t}\n\t\t} else if paramTypeArray, ok := paramField.Type.(*ast.ArrayType); ok {\n\t\t\t// Handle slice of generic type like '[]T'\n\t\t\tif eltIdent, ok := paramTypeArray.Elt.(*ast.Ident); ok {\n\t\t\t\tif _, isGeneric := typeParamNames[eltIdent.Name]; isGeneric {\n\t\t\t\t\tif i >= len(args) {\n\t\t\t\t\t\treturn nil, e.newError(pos, \"cannot infer type for generic parameter %s: not enough arguments\", eltIdent.Name)\n\t\t\t\t\t}\n\t\t\t\t\targ := args[i]\n\t\t\t\t\tvar inferredElemType object.Object\n\t\t\t\t\tif tn, ok := arg.(*object.TypedNil); ok {\n\t\t\t\t\t\tif at, ok := tn.TypeObject.(*object.ArrayType); ok {\n\t\t\t\t\t\t\tinferredElemType = at.ElementType\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if arr, ok := arg.(*object.Array); ok {\n\t\t\t\t\t\tif arrType, ok := e.inferTypeOf(arr).(*object.ArrayType); ok {\n\t\t\t\t\t\t\tinferredElemType = arrType.ElementType\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif inferredElemType != nil {\n\t\t\t\t\t\tinferredTypes[eltIdent.Name] = inferredElemType\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if paramTypeMap, ok := paramField.Type.(*ast.MapType); ok {\n\t\t\t// Handle map of generic types like 'map[K]V'\n\t\t\tkeyIdent, keyIsIdent := paramTypeMap.Key.(*ast.Ident)\n\t\t\tvalIdent, valIsIdent := paramTypeMap.Value.(*ast.Ident)\n\n\t\t\tkeyIsGeneric := false\n\t\t\tif keyIsIdent {\n\t\t\t\t_, keyIsGeneric = typeParamNames[keyIdent.Name]\n\t\t\t}\n\t\t\tvalIsGeneric := false\n\t\t\tif valIsIdent {\n\t\t\t\t_, valIsGeneric = typeParamNames[valIdent.Name]\n\t\t\t}\n\n\t\t\tif (keyIsIdent && keyIsGeneric) || (valIsIdent && valIsGeneric) {\n\t\t\t\tif i >= len(args) {\n\t\t\t\t\treturn nil, e.newError(pos, \"cannot infer type for generic map: not enough arguments\")\n\t\t\t\t}\n\t\t\t\targ := args[i]\n\t\t\t\tvar inferredMapType *object.MapType\n\t\t\t\tif tn, ok := arg.(*object.TypedNil); ok {\n\t\t\t\t\tif mt, ok := tn.TypeObject.(*object.MapType); ok {\n\t\t\t\t\t\tinferredMapType = mt\n\t\t\t\t\t}\n\t\t\t\t} else if argMap, ok := arg.(*object.Map); ok {\n\t\t\t\t\tif mt, ok := e.inferTypeOf(argMap).(*object.MapType); ok {\n\t\t\t\t\t\tinferredMapType = mt\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif mapType := inferredMapType; mapType != nil {\n\t\t\t\t\tif keyIsIdent && keyIsGeneric {\n\t\t\t\t\t\tinferredTypes[keyIdent.Name] = mapType.KeyType\n\t\t\t\t\t}\n\t\t\t\t\tif valIsIdent && valIsGeneric {\n\t\t\t\t\t\tinferredTypes[valIdent.Name] = mapType.ValueType\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if paramTypeStar, ok := paramField.Type.(*ast.StarExpr); ok {\n\t\t\t// Handle pointer to generic type like '*T'\n\t\t\tif eltIdent, ok := paramTypeStar.X.(*ast.Ident); ok {\n\t\t\t\tif _, isGeneric := typeParamNames[eltIdent.Name]; isGeneric {\n\t\t\t\t\tif i >= len(args) {\n\t\t\t\t\t\treturn nil, e.newError(pos, \"cannot infer type for generic parameter %s: not enough arguments\", eltIdent.Name)\n\t\t\t\t\t}\n\t\t\t\t\targ := args[i]\n\t\t\t\t\tvar inferredElemType object.Object\n\t\t\t\t\tif tn, ok := arg.(*object.TypedNil); ok {\n\t\t\t\t\t\tif pt, ok := tn.TypeObject.(*object.PointerType); ok {\n\t\t\t\t\t\t\tinferredElemType = pt.ElementType\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ptr, ok := arg.(*object.Pointer); ok {\n\t\t\t\t\t\tif pt, ok := e.inferTypeOf(ptr).(*object.PointerType); ok {\n\t\t\t\t\t\t\tinferredElemType = pt.ElementType\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif inferredElemType != nil {\n\t\t\t\t\t\tinferredTypes[eltIdent.Name] = inferredElemType\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 4. Second pass for constraint-based inference.\n\t// This loop allows inferences to feed into each other. For example, inferring S\n\t// might allow us to infer E, which might then be used in another constraint.\n\tmadeProgress := true\n\tfor madeProgress {\n\t\tmadeProgress = false\n\t\tfor _, typeParamField := range f.TypeParams.List {\n\t\t\tparamName := typeParamField.Names[0].Name\n\n\t\t\t// If we have an inferred type for this parameter...\n\t\t\tif inferredType, ok := inferredTypes[paramName]; ok {\n\t\t\t\t// ...and its constraint is an array/slice type...\n\t\t\t\tconstraintExpr := typeParamField.Type\n\t\t\t\tif unary, ok := constraintExpr.(*ast.UnaryExpr); ok && unary.Op == token.TILDE {\n\t\t\t\t\tconstraintExpr = unary.X\t// Look past the ~\n\t\t\t\t}\n\n\t\t\t\tif arrayConstraint, ok := constraintExpr.(*ast.ArrayType); ok {\n\t\t\t\t\t// ...and the inferred type is indeed an array...\n\t\t\t\t\tif inferredArray, ok := inferredType.(*object.ArrayType); ok {\n\t\t\t\t\t\t// ...then we can try to infer the element type parameter.\n\t\t\t\t\t\tif elemParamIdent, ok := arrayConstraint.Elt.(*ast.Ident); ok {\n\t\t\t\t\t\t\telemParamName := elemParamIdent.Name\n\t\t\t\t\t\t\t// If we haven't inferred this element type yet...\n\t\t\t\t\t\t\tif _, alreadyInferred := inferredTypes[elemParamName]; !alreadyInferred {\n\t\t\t\t\t\t\t\t// ...then infer it from the actual array's element type.\n\t\t\t\t\t\t\t\tinferredTypes[elemParamName] = inferredArray.ElementType\n\t\t\t\t\t\t\t\tmadeProgress = true\t// We made progress, so loop again.\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// TODO: Add cases for other constraints like map[K]V\n\t\t\t}\n\t\t}\n\t}\n\n\t// 5. Convert the map of inferred types into an ordered slice\n\tfinalTypeArgs := make([]object.Object, len(f.TypeParams.List))\n\tfor i, field := range f.TypeParams.List {\n\t\tname := field.Names[0].Name\n\t\tinferred, ok := inferredTypes[name]\n\t\tif !ok {\n\t\t\treturn nil, e.newError(pos, \"could not infer type for generic parameter %s\", name)\n\t\t}\n\t\tfinalTypeArgs[i] = inferred\n\t}\n\n\treturn finalTypeArgs, nil\n}\n\nfunc (e *Evaluator) newError(pos token.Pos, format string, args ...interface{}) *object.Error {\n\tmsg := fmt.Sprintf(format, args...)\n\t// Create a copy of the current call stack for the error object.\n\tstackCopy := make([]*object.CallFrame, len(e.callStack))\n\tcopy(stackCopy, e.callStack)\n\n\terr := &object.Error{\n\t\tPos:\t\tpos,\n\t\tMessage:\tmsg,\n\t\tCallStack:\tstackCopy,\n\t}\n\terr.AttachFileSet(e.Fset)\t// Attach fset for formatting\n\treturn err\n}\n\nfunc isError(obj object.Object) bool {\n\tif obj != nil {\n\t\treturn obj.Type() == object.ERROR_OBJ\n\t}\n\treturn false\n}\n\n// nativeBoolToBooleanObject is a helper to convert a native bool to our object.Boolean.\nfunc (e *Evaluator) nativeBoolToBooleanObject(input bool) *object.Boolean {\n\tif input {\n\t\treturn object.TRUE\n\t}\n\treturn object.FALSE\n}\n\n// evalBangOperatorExpression evaluates the '!' prefix expression.\nfunc (e *Evaluator) evalBangOperatorExpression(right object.Object) object.Object {\n\tswitch right {\n\tcase object.TRUE:\n\t\treturn object.FALSE\n\tcase object.FALSE:\n\t\treturn object.TRUE\n\tcase object.NIL:\n\t\treturn object.TRUE\n\tdefault:\n\t\treturn object.FALSE\n\t}\n}\n\n// evalMinusPrefixOperatorExpression evaluates the '-' prefix expression.\nfunc (e *Evaluator) evalMinusPrefixOperatorExpression(node ast.Node, right object.Object) object.Object {\n\tif right.Type() != object.INTEGER_OBJ {\n\t\treturn e.newError(node.Pos(), \"unknown operator: -%s\", right.Type())\n\t}\n\tvalue := right.(*object.Integer).Value\n\treturn &object.Integer{Value: -value}\n}\n\n// evalPrefixExpression dispatches to the correct prefix evaluation function.\nfunc (e *Evaluator) evalPrefixExpression(node *ast.UnaryExpr, operator string, right object.Object) object.Object {\n\tswitch operator {\n\tcase \"!\":\n\t\treturn e.evalBangOperatorExpression(right)\n\tcase \"-\":\n\t\treturn e.evalMinusPrefixOperatorExpression(node, right)\n\tcase \"+\":\n\t\t// Unary plus is a no-op for numbers.\n\t\tif right.Type() != object.INTEGER_OBJ && right.Type() != object.FLOAT_OBJ {\n\t\t\treturn e.newError(node.Pos(), \"invalid operation: unary + on non-number %s\", right.Type())\n\t\t}\n\t\treturn right\n\tcase \"~\":\n\t\t// The tilde is for type approximation in constraints.\n\t\t// For our dynamic evaluation, we can treat ~T as just T.\n\t\treturn right\n\tdefault:\n\t\treturn e.newError(node.Pos(), \"unknown operator: %s%s\", operator, right.Type())\n\t}\n}\n\nfunc (e *Evaluator) evalDereferenceExpression(node ast.Node, right object.Object) object.Object {\n\tptr, ok := right.(*object.Pointer)\n\tif !ok {\n\t\treturn e.newError(node.Pos(), \"invalid indirect of %s (type %s)\", right.Inspect(), right.Type())\n\t}\n\treturn *ptr.Element\n}\n\nfunc (e *Evaluator) evalAddressOfExpression(node *ast.UnaryExpr, env *object.Environment, fscope *object.FileScope) object.Object {\n\tswitch operand := node.X.(type) {\n\tcase *ast.Ident:\n\t\taddr, ok := env.GetAddress(operand.Name)\n\t\tif !ok {\n\t\t\treturn e.newError(node.Pos(), \"cannot take the address of undeclared variable: %s\", operand.Name)\n\t\t}\n\t\treturn &object.Pointer{Element: addr}\n\tcase *ast.CompositeLit:\n\t\t// Evaluate the composite literal to create the object instance.\n\t\tobj := e.evalCompositeLit(operand, env, fscope)\n\t\tif isError(obj) {\n\t\t\treturn obj\n\t\t}\n\t\t// Return a pointer to the newly created object.\n\t\treturn &object.Pointer{Element: &obj}\n\tdefault:\n\t\treturn e.newError(node.Pos(), \"cannot take the address of %T\", node.X)\n\t}\n}\n\n// unwrapToInt64 is a helper to extract an int64 from an Integer or a GoValue.\nfunc (e *Evaluator) unwrapToInt64(obj object.Object) (int64, bool) {\n\tswitch o := obj.(type) {\n\tcase *object.Integer:\n\t\treturn o.Value, true\n\tcase *object.GoValue:\n\t\t// Check if the underlying Go value is some kind of integer.\n\t\tswitch o.Value.Kind() {\n\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\t\treturn o.Value.Int(), true\n\t\t}\n\t}\n\treturn 0, false\n}\n\n// evalMixedIntInfixExpression handles infix expressions for combinations of Integer and GoValue(int).\nfunc (e *Evaluator) evalMixedIntInfixExpression(node ast.Node, operator string, left, right object.Object) object.Object {\n\tleftVal, ok1 := e.unwrapToInt64(left)\n\tif !ok1 {\n\t\treturn e.newError(node.Pos(), \"left operand is not a valid integer: %s\", left.Type())\n\t}\n\trightVal, ok2 := e.unwrapToInt64(right)\n\tif !ok2 {\n\t\treturn e.newError(node.Pos(), \"right operand is not a valid integer: %s\", right.Type())\n\t}\n\n\t// Now that we have two int64s, we can perform the operation.\n\t// This logic is duplicated from evalIntegerInfixExpression.\n\t// A future refactor could merge them.\n\tswitch operator {\n\tcase \"+\":\n\t\treturn &object.Integer{Value: leftVal + rightVal}\n\tcase \"-\":\n\t\treturn &object.Integer{Value: leftVal - rightVal}\n\tcase \"*\":\n\t\treturn &object.Integer{Value: leftVal * rightVal}\n\tcase \"/\":\n\t\tif rightVal == 0 {\n\t\t\treturn e.newError(node.Pos(), \"division by zero\")\n\t\t}\n\t\treturn &object.Integer{Value: leftVal / rightVal}\n\tcase \"%\":\n\t\tif rightVal == 0 {\n\t\t\treturn e.newError(node.Pos(), \"division by zero\")\n\t\t}\n\t\treturn &object.Integer{Value: leftVal % rightVal}\n\tcase \"<<\":\n\t\treturn &object.Integer{Value: leftVal << rightVal}\n\tcase \">>\":\n\t\treturn &object.Integer{Value: leftVal >> rightVal}\n\tcase \"&\":\n\t\treturn &object.Integer{Value: leftVal & rightVal}\n\tcase \"|\":\n\t\treturn &object.Integer{Value: leftVal | rightVal}\n\tcase \"^\":\n\t\treturn &object.Integer{Value: leftVal ^ rightVal}\n\tcase \"<\":\n\t\treturn e.nativeBoolToBooleanObject(leftVal < rightVal)\n\tcase \"<=\":\n\t\treturn e.nativeBoolToBooleanObject(leftVal <= rightVal)\n\tcase \">\":\n\t\treturn e.nativeBoolToBooleanObject(leftVal > rightVal)\n\tcase \">=\":\n\t\treturn e.nativeBoolToBooleanObject(leftVal >= rightVal)\n\tcase \"==\":\n\t\treturn e.nativeBoolToBooleanObject(leftVal == rightVal)\n\tcase \"!=\":\n\t\treturn e.nativeBoolToBooleanObject(leftVal != rightVal)\n\tdefault:\n\t\t// This should be caught by the outer switch, but as a safeguard:\n\t\treturn e.newError(node.Pos(), \"unknown integer operator: %s\", operator)\n\t}\n}\n\n// evalIntegerInfixExpression evaluates infix expressions for integers.\nfunc (e *Evaluator) evalIntegerInfixExpression(node ast.Node, operator string, left, right object.Object) object.Object {\n\tleftVal := left.(*object.Integer).Value\n\trightVal := right.(*object.Integer).Value\n\n\tswitch operator {\n\tcase \"+\":\n\t\treturn &object.Integer{Value: leftVal + rightVal}\n\tcase \"-\":\n\t\treturn &object.Integer{Value: leftVal - rightVal}\n\tcase \"*\":\n\t\treturn &object.Integer{Value: leftVal * rightVal}\n\tcase \"/\":\n\t\tif rightVal == 0 {\n\t\t\treturn e.newError(node.Pos(), \"division by zero\")\n\t\t}\n\t\treturn &object.Integer{Value: leftVal / rightVal}\n\tcase \"%\":\n\t\tif rightVal == 0 {\n\t\t\treturn e.newError(node.Pos(), \"division by zero\")\n\t\t}\n\t\treturn &object.Integer{Value: leftVal % rightVal}\n\tcase \"<<\":\n\t\treturn &object.Integer{Value: leftVal << rightVal}\n\tcase \">>\":\n\t\treturn &object.Integer{Value: leftVal >> rightVal}\n\tcase \"&\":\n\t\treturn &object.Integer{Value: leftVal & rightVal}\n\tcase \"|\":\n\t\treturn &object.Integer{Value: leftVal | rightVal}\n\tcase \"^\":\n\t\treturn &object.Integer{Value: leftVal ^ rightVal}\n\tcase \"<\":\n\t\treturn e.nativeBoolToBooleanObject(leftVal < rightVal)\n\tcase \"<=\":\n\t\treturn e.nativeBoolToBooleanObject(leftVal <= rightVal)\n\tcase \">\":\n\t\treturn e.nativeBoolToBooleanObject(leftVal > rightVal)\n\tcase \">=\":\n\t\treturn e.nativeBoolToBooleanObject(leftVal >= rightVal)\n\tcase \"==\":\n\t\treturn e.nativeBoolToBooleanObject(leftVal == rightVal)\n\tcase \"!=\":\n\t\treturn e.nativeBoolToBooleanObject(leftVal != rightVal)\n\tdefault:\n\t\treturn e.newError(node.Pos(), \"unknown operator: %s %s %s\", left.Type(), operator, right.Type())\n\t}\n}\n\n// unwrapToString is a helper to extract a string from a String or a GoValue.\nfunc (e *Evaluator) unwrapToString(obj object.Object) (string, bool) {\n\tswitch o := obj.(type) {\n\tcase *object.String:\n\t\treturn o.Value, true\n\tcase *object.GoValue:\n\t\tif o.Value.Kind() == reflect.String {\n\t\t\treturn o.Value.String(), true\n\t\t}\n\t}\n\treturn \"\", false\n}\n\n// evalMixedStringInfixExpression handles infix expressions for combinations of String and GoValue(string).\nfunc (e *Evaluator) evalMixedStringInfixExpression(node ast.Node, operator string, left, right object.Object) object.Object {\n\tleftVal, ok1 := e.unwrapToString(left)\n\tif !ok1 {\n\t\t// If unwrap fails, it's not a string, so we can't proceed.\n\t\t// Fallback to the generic error message in evalInfixExpression.\n\t\treturn e.newError(node.Pos(), \"type mismatch: %s %s %s\", left.Type(), operator, right.Type())\n\t}\n\trightVal, ok2 := e.unwrapToString(right)\n\tif !ok2 {\n\t\treturn e.newError(node.Pos(), \"type mismatch: %s %s %s\", left.Type(), operator, right.Type())\n\t}\n\n\tswitch operator {\n\tcase \"+\":\n\t\treturn &object.String{Value: leftVal + rightVal}\n\tcase \"==\":\n\t\treturn e.nativeBoolToBooleanObject(leftVal == rightVal)\n\tcase \"!=\":\n\t\treturn e.nativeBoolToBooleanObject(leftVal != rightVal)\n\tdefault:\n\t\treturn e.newError(node.Pos(), \"unknown operator for strings: %s\", operator)\n\t}\n}\n\n// unwrapToBool is a helper to extract a bool from a Boolean or a GoValue.\nfunc (e *Evaluator) unwrapToBool(obj object.Object) (bool, bool) {\n\tswitch o := obj.(type) {\n\tcase *object.Boolean:\n\t\treturn o.Value, true\n\tcase *object.GoValue:\n\t\tif o.Value.Kind() == reflect.Bool {\n\t\t\treturn o.Value.Bool(), true\n\t\t}\n\t}\n\treturn false, false\n}\n\n// nativeToValue converts a native Go value (from reflect.Value) into a minigo object.\n// This is used when retrieving values from Go collections or structs.\nfunc (e *Evaluator) nativeToValue(val reflect.Value) object.Object {\n\tif !val.IsValid() {\n\t\treturn object.NIL\n\t}\n\n\t// Check if we can convert the interface value directly.\n\t// This handles cases where the value might be, for example, a named type\n\t// whose underlying type is a primitive.\n\ti := val.Interface()\n\tswitch v := i.(type) {\n\tcase int:\n\t\treturn &object.Integer{Value: int64(v)}\n\tcase int8:\n\t\treturn &object.Integer{Value: int64(v)}\n\tcase int16:\n\t\treturn &object.Integer{Value: int64(v)}\n\tcase int32:\n\t\treturn &object.Integer{Value: int64(v)}\n\tcase int64:\n\t\treturn &object.Integer{Value: v}\n\tcase uint:\n\t\treturn &object.Integer{Value: int64(v)}\n\tcase uint8:\t// byte\n\t\treturn &object.Integer{Value: int64(v)}\n\tcase uint16:\n\t\treturn &object.Integer{Value: int64(v)}\n\tcase uint32:\n\t\treturn &object.Integer{Value: int64(v)}\n\tcase uint64:\n\t\treturn &object.Integer{Value: int64(v)}\n\tcase float32:\n\t\treturn &object.Float{Value: float64(v)}\n\tcase float64:\n\t\treturn &object.Float{Value: v}\n\tcase string:\n\t\treturn &object.String{Value: v}\n\tcase bool:\n\t\treturn e.nativeBoolToBooleanObject(v)\n\tcase []byte:\n\t\telements := make([]object.Object, len(v))\n\t\tfor i, b := range v {\n\t\t\telements[i] = &object.Integer{Value: int64(b)}\n\t\t}\n\t\treturn &object.Array{Elements: elements}\n\tcase []string:\n\t\telements := make([]object.Object, len(v))\n\t\tfor i, s := range v {\n\t\t\telements[i] = &object.String{Value: s}\n\t\t}\n\t\treturn &object.Array{Elements: elements}\n\tcase nil:\n\t\treturn object.NIL\n\t}\n\n\t// If direct conversion fails, fall back to Kind-based conversion.\n\tswitch val.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn &object.Integer{Value: val.Int()}\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\treturn &object.Integer{Value: int64(val.Uint())}\t// Treat unsigned as signed for simplicity\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn &object.Float{Value: val.Float()}\n\tcase reflect.Ptr, reflect.Interface:\n\t\tif val.IsNil() {\n\t\t\treturn object.NIL\n\t\t}\n\t\t// Re-wrap the value to allow further operations on it.\n\t\treturn &object.GoValue{Value: val}\n\tcase reflect.Struct, reflect.Slice, reflect.Array, reflect.Map:\n\t\t// Wrap complex types so they can be operated on within the interpreter.\n\t\treturn &object.GoValue{Value: val}\n\tdefault:\n\t\t// For any other type, we can't safely represent it.\n\t\t// For now, we'll return a GoValue, but this could also be an error.\n\t\treturn &object.GoValue{Value: val}\n\t}\n}\n\n// objectToReflectValue converts a minigo object to a reflect.Value of a specific Go type.\n// This is a crucial helper for map indexing and function calls into Go code.\nfunc (e *Evaluator) objectToReflectValue(obj object.Object, targetType reflect.Type) (reflect.Value, error) {\n\t// Handle target type of interface{} separately.\n\t// We convert the minigo object to its \"best\" Go equivalent.\n\tif targetType.Kind() == reflect.Interface && targetType.NumMethod() == 0 {\n\t\tnativeVal, err := e.objectToNativeGoValue(obj)\n\t\tif err != nil {\n\t\t\treturn reflect.Value{}, fmt.Errorf(\"unsupported conversion from %s to interface{}: %w\", obj.Type(), err)\n\t\t}\n\n\t\tif nativeVal == nil {\n\t\t\treturn reflect.Zero(targetType), nil\n\t\t}\n\t\t// We have the native Go value; now we need to put it into a reflect.Value\n\t\t// of the target interface type.\n\t\tval := reflect.ValueOf(nativeVal)\n\n\t\t// This check is important. For example, if nativeVal is a map[string]any\n\t\t// from a struct, its type is not directly assignable to `any` if `any`\n\t\t// is from a different type system context (less common now, but good practice).\n\t\t// More importantly, it handles named interfaces.\n\t\tif !val.Type().AssignableTo(targetType) {\n\t\t\treturn reflect.Value{}, fmt.Errorf(\"value of type %T is not assignable to interface type %s\", nativeVal, targetType)\n\t\t}\n\t\treturn val, nil\n\t}\n\n\t// If the object is already a GoValue, try to use its underlying value directly if compatible.\n\tif goVal, ok := obj.(*object.GoValue); ok {\n\t\tif goVal.Value.Type().AssignableTo(targetType) {\n\t\t\treturn goVal.Value, nil\n\t\t}\n\t\tif goVal.Value.Type().ConvertibleTo(targetType) {\n\t\t\treturn goVal.Value.Convert(targetType), nil\n\t\t}\n\t\t// Fall through to allow conversions like minigo Integer -> Go float64\n\t}\n\n\tswitch o := obj.(type) {\n\tcase *object.AstNode:\n\t\t// Check if the underlying AST node (e.g., *ast.FuncLit) can be assigned\n\t\t// to the target Go function's argument type (e.g., ast.Node or *ast.FuncLit).\n\t\t// The `AssignableTo` method correctly handles assignment to interfaces.\n\t\tnodeType := reflect.TypeOf(o.Node)\n\t\tif nodeType.AssignableTo(targetType) {\n\t\t\treturn reflect.ValueOf(o.Node), nil\n\t\t}\n\t\treturn reflect.Value{}, fmt.Errorf(\"cannot convert %s (from AstNode) to %s\", nodeType, targetType)\n\tcase *object.Integer:\n\t\t// Create a reflect.Value of the target type and set its value.\n\t\tval := reflect.New(targetType).Elem()\n\t\tswitch targetType.Kind() {\n\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\t\tval.SetInt(o.Value)\n\t\t\treturn val, nil\n\t\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\t\tval.SetUint(uint64(o.Value))\n\t\t\treturn val, nil\n\t\tcase reflect.Float32, reflect.Float64:\n\t\t\tval.SetFloat(float64(o.Value))\n\t\t\treturn val, nil\n\t\tdefault:\n\t\t\treturn reflect.Value{}, fmt.Errorf(\"cannot convert integer to %s\", targetType)\n\t\t}\n\tcase *object.Float:\n\t\tval := reflect.New(targetType).Elem()\n\t\tswitch targetType.Kind() {\n\t\tcase reflect.Float32, reflect.Float64:\n\t\t\tval.SetFloat(o.Value)\n\t\t\treturn val, nil\n\t\tdefault:\n\t\t\treturn reflect.Value{}, fmt.Errorf(\"cannot convert float to %s\", targetType)\n\t\t}\n\tcase *object.String:\n\t\tif targetType.Kind() != reflect.String {\n\t\t\treturn reflect.Value{}, fmt.Errorf(\"cannot convert string to %s\", targetType)\n\t\t}\n\t\treturn reflect.ValueOf(o.Value).Convert(targetType), nil\n\tcase *object.Boolean:\n\t\tif targetType.Kind() != reflect.Bool {\n\t\t\treturn reflect.Value{}, fmt.Errorf(\"cannot convert boolean to %s\", targetType)\n\t\t}\n\t\treturn reflect.ValueOf(o.Value).Convert(targetType), nil\n\tcase *object.GoValue:\n\t\t// If the underlying Go value is assignable to the target type, use it directly.\n\t\tif o.Value.Type().AssignableTo(targetType) {\n\t\t\treturn o.Value, nil\n\t\t}\n\t\t// Also check for convertibility (e.g., int to int64).\n\t\tif o.Value.Type().ConvertibleTo(targetType) {\n\t\t\treturn o.Value.Convert(targetType), nil\n\t\t}\n\t\treturn reflect.Value{}, fmt.Errorf(\"GoValue of type %s is not assignable or convertible to %s\", o.Value.Type(), targetType)\n\tcase *object.Nil:\n\t\t// For nil, we can return a zero value of the target type if it's a pointer, map, slice, etc.\n\t\tswitch targetType.Kind() {\n\t\tcase reflect.Ptr, reflect.Map, reflect.Slice, reflect.Interface, reflect.Func:\n\t\t\treturn reflect.Zero(targetType), nil\n\t\t}\n\t\treturn reflect.Value{}, fmt.Errorf(\"cannot convert nil to non-nillable type %s\", targetType)\n\tcase *object.Array:\n\t\t// Handle conversion to []byte, which is common for stdlib functions.\n\t\tif targetType.Kind() == reflect.Slice && targetType.Elem().Kind() == reflect.Uint8 {\n\t\t\tbytes := make([]byte, len(o.Elements))\n\t\t\tfor i, el := range o.Elements {\n\t\t\t\tintVal, ok := el.(*object.Integer)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn reflect.Value{}, fmt.Errorf(\"cannot convert non-integer element in array to byte\")\n\t\t\t\t}\n\t\t\t\tbytes[i] = byte(intVal.Value)\n\t\t\t}\n\t\t\treturn reflect.ValueOf(bytes), nil\n\t\t}\n\t\t// Handle conversion to []int.\n\t\tif targetType.Kind() == reflect.Slice && targetType.Elem().Kind() == reflect.Int {\n\t\t\tints := make([]int, len(o.Elements))\n\t\t\tfor i, el := range o.Elements {\n\t\t\t\tintVal, ok := el.(*object.Integer)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn reflect.Value{}, fmt.Errorf(\"cannot convert non-integer element in array to int\")\n\t\t\t\t}\n\t\t\t\tints[i] = int(intVal.Value)\n\t\t\t}\n\t\t\treturn reflect.ValueOf(ints), nil\n\t\t}\n\t\t// Handle conversion to []float64.\n\t\tif targetType.Kind() == reflect.Slice && targetType.Elem().Kind() == reflect.Float64 {\n\t\t\tfloats := make([]float64, len(o.Elements))\n\t\t\tfor i, el := range o.Elements {\n\t\t\t\tfloatVal, ok := el.(*object.Float)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn reflect.Value{}, fmt.Errorf(\"cannot convert non-float element in array to float64\")\n\t\t\t\t}\n\t\t\t\tfloats[i] = floatVal.Value\n\t\t\t}\n\t\t\treturn reflect.ValueOf(floats), nil\n\t\t}\n\t\t// Handle conversion to []string.\n\t\tif targetType.Kind() == reflect.Slice && targetType.Elem().Kind() == reflect.String {\n\t\t\tstrings := make([]string, len(o.Elements))\n\t\t\tfor i, el := range o.Elements {\n\t\t\t\tstrVal, ok := el.(*object.String)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn reflect.Value{}, fmt.Errorf(\"cannot convert non-string element in array to string\")\n\t\t\t\t}\n\t\t\t\tstrings[i] = strVal.Value\n\t\t\t}\n\t\t\treturn reflect.ValueOf(strings), nil\n\t\t}\n\t}\n\n\treturn reflect.Value{}, fmt.Errorf(\"unsupported conversion from %s to %s\", obj.Type(), targetType)\n}\n\n// objectToNativeGoValue converts a minigo object to its most natural Go counterpart.\nfunc (e *Evaluator) objectToNativeGoValue(obj object.Object) (any, error) {\n\tswitch o := obj.(type) {\n\tcase *object.Integer:\n\t\treturn o.Value, nil\n\tcase *object.String:\n\t\treturn o.Value, nil\n\tcase *object.Boolean:\n\t\treturn o.Value, nil\n\tcase *object.Nil:\n\t\treturn nil, nil\n\tcase *object.GoValue:\n\t\treturn o.Value.Interface(), nil\n\tcase *object.Array:\n\t\tslice := make([]any, len(o.Elements))\n\t\tfor i, elem := range o.Elements {\n\t\t\tvar err error\n\t\t\tslice[i], err = e.objectToNativeGoValue(elem)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to convert element %d in array: %w\", i, err)\n\t\t\t}\n\t\t}\n\t\treturn slice, nil\n\tcase *object.StructInstance:\n\t\tm := make(map[string]any, len(o.Fields))\n\t\tfor name, fieldObj := range o.Fields {\n\t\t\ttag, ok := o.Def.FieldTags[name]\n\t\t\tif !ok {\n\t\t\t\ttag = name\t// Default to field name if no tag\n\t\t\t}\n\n\t\t\tif tag == \"-\" {\n\t\t\t\tcontinue\t// Skip ignored fields\n\t\t\t}\n\n\t\t\ttagName := tag\n\t\t\tomitempty := false\n\t\t\tif strings.HasSuffix(tag, \",omitempty\") {\n\t\t\t\tomitempty = true\n\t\t\t\ttagName = strings.TrimSuffix(tag, \",omitempty\")\n\t\t\t}\n\n\t\t\tif omitempty {\n\t\t\t\tisZero := false\n\t\t\t\tswitch v := fieldObj.(type) {\n\t\t\t\tcase *object.Integer:\n\t\t\t\t\tif v.Value == 0 {\n\t\t\t\t\t\tisZero = true\n\t\t\t\t\t}\n\t\t\t\tcase *object.Float:\n\t\t\t\t\tif v.Value == 0.0 {\n\t\t\t\t\t\tisZero = true\n\t\t\t\t\t}\n\t\t\t\tcase *object.String:\n\t\t\t\t\tif v.Value == \"\" {\n\t\t\t\t\t\tisZero = true\n\t\t\t\t\t}\n\t\t\t\tcase *object.Boolean:\n\t\t\t\t\tif !v.Value {\n\t\t\t\t\t\tisZero = true\n\t\t\t\t\t}\n\t\t\t\tcase *object.Nil:\n\t\t\t\t\tisZero = true\n\t\t\t\tcase *object.Array:\n\t\t\t\t\tif len(v.Elements) == 0 {\n\t\t\t\t\t\tisZero = true\n\t\t\t\t\t}\n\t\t\t\tcase *object.Map:\n\t\t\t\t\tif len(v.Pairs) == 0 {\n\t\t\t\t\t\tisZero = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif isZero {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar err error\n\t\t\tm[tagName], err = e.objectToNativeGoValue(fieldObj)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to convert field %q: %w\", name, err)\n\t\t\t}\n\t\t}\n\t\treturn m, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"cannot convert object type %s to a native Go value\", obj.Type())\n\t}\n}\n\n// evalMixedBoolInfixExpression handles infix expressions for combinations of Boolean and GoValue(bool).\nfunc (e *Evaluator) evalMixedBoolInfixExpression(node ast.Node, operator string, left, right object.Object) object.Object {\n\tleftVal, ok1 := e.unwrapToBool(left)\n\tif !ok1 {\n\t\treturn e.newError(node.Pos(), \"type mismatch: %s %s %s\", left.Type(), operator, right.Type())\n\t}\n\trightVal, ok2 := e.unwrapToBool(right)\n\tif !ok2 {\n\t\treturn e.newError(node.Pos(), \"type mismatch: %s %s %s\", left.Type(), operator, right.Type())\n\t}\n\n\tswitch operator {\n\tcase \"==\":\n\t\treturn e.nativeBoolToBooleanObject(leftVal == rightVal)\n\tcase \"!=\":\n\t\treturn e.nativeBoolToBooleanObject(leftVal != rightVal)\n\tdefault:\n\t\treturn e.newError(node.Pos(), \"unknown operator for booleans: %s\", operator)\n\t}\n}\n\n// evalStringInfixExpression evaluates infix expressions for strings.\nfunc (e *Evaluator) evalStringInfixExpression(node ast.Node, operator string, left, right object.Object) object.Object {\n\tleftVal := left.(*object.String).Value\n\trightVal := right.(*object.String).Value\n\n\tswitch operator {\n\tcase \"+\":\n\t\treturn &object.String{Value: leftVal + rightVal}\n\tcase \"==\":\n\t\treturn e.nativeBoolToBooleanObject(leftVal == rightVal)\n\tcase \"!=\":\n\t\treturn e.nativeBoolToBooleanObject(leftVal != rightVal)\n\tdefault:\n\t\treturn e.newError(node.Pos(), \"unknown operator: %s %s %s\", left.Type(), operator, right.Type())\n\t}\n}\n\n// evalInfixExpression dispatches to the correct infix evaluation function based on type.\nfunc (e *Evaluator) evalInfixExpression(node ast.Node, operator string, left, right object.Object) object.Object {\n\tswitch {\n\tcase left.Type() == object.INTEGER_OBJ && right.Type() == object.INTEGER_OBJ:\n\t\treturn e.evalIntegerInfixExpression(node, operator, left, right)\n\n\t// Handle arithmetic with injected Go values (integers).\n\tcase (left.Type() == object.INTEGER_OBJ || left.Type() == object.GO_VALUE_OBJ) &&\n\t\t(right.Type() == object.INTEGER_OBJ || right.Type() == object.GO_VALUE_OBJ):\n\t\treturn e.evalMixedIntInfixExpression(node, operator, left, right)\n\n\tcase left.Type() == object.STRING_OBJ && right.Type() == object.STRING_OBJ:\n\t\treturn e.evalStringInfixExpression(node, operator, left, right)\n\n\t// Handle operations with injected Go values (strings).\n\tcase (left.Type() == object.STRING_OBJ || left.Type() == object.GO_VALUE_OBJ) &&\n\t\t(right.Type() == object.STRING_OBJ || right.Type() == object.GO_VALUE_OBJ):\n\t\treturn e.evalMixedStringInfixExpression(node, operator, left, right)\n\n\t// Handle operations with injected Go values (booleans).\n\tcase (left.Type() == object.BOOLEAN_OBJ || left.Type() == object.GO_VALUE_OBJ) &&\n\t\t(right.Type() == object.BOOLEAN_OBJ || right.Type() == object.GO_VALUE_OBJ):\n\t\treturn e.evalMixedBoolInfixExpression(node, operator, left, right)\n\n\tcase operator == \"==\":\n\t\t// Handle nil comparisons first.\n\t\tisLeftNil := left.Type() == object.NIL_OBJ || left.Type() == object.TYPED_NIL_OBJ\n\t\tisRightNil := right.Type() == object.NIL_OBJ || right.Type() == object.TYPED_NIL_OBJ\n\t\tif isLeftNil || isRightNil {\n\t\t\t// If either is nil, they are equal only if both are nil.\n\t\t\treturn e.nativeBoolToBooleanObject(isLeftNil == isRightNil)\n\t\t}\n\t\t// Fallback to pointer comparison for reference types.\n\t\t// Note: The cases above handle value types like integers and strings.\n\t\treturn e.nativeBoolToBooleanObject(left == right)\n\tcase operator == \"!=\":\n\t\tisLeftNil := left.Type() == object.NIL_OBJ || left.Type() == object.TYPED_NIL_OBJ\n\t\tisRightNil := right.Type() == object.NIL_OBJ || right.Type() == object.TYPED_NIL_OBJ\n\t\tif isLeftNil || isRightNil {\n\t\t\t// If either is nil, they are not equal if one is nil and the other isn't.\n\t\t\treturn e.nativeBoolToBooleanObject(isLeftNil != isRightNil)\n\t\t}\n\t\treturn e.nativeBoolToBooleanObject(left != right)\n\tcase left.Type() != right.Type():\n\t\treturn e.newError(node.Pos(), \"type mismatch: %s %s %s\", left.Type(), operator, right.Type())\n\tdefault:\n\t\treturn e.newError(node.Pos(), \"unknown operator: %s %s %s\", left.Type(), operator, right.Type())\n\t}\n}\n\n// isTruthy checks if an object is considered true in a boolean context.\nfunc (e *Evaluator) isTruthy(obj object.Object) bool {\n\tswitch o := obj.(type) {\n\tcase *object.Boolean:\n\t\treturn o.Value\n\tcase *object.GoValue:\n\t\tif val, ok := e.unwrapToBool(o); ok {\n\t\t\treturn val\n\t\t}\n\t\t// If it's a GoValue but not a bool, consider it truthy if it's not nil/zero.\n\t\treturn o.Value.IsValid() && !o.Value.IsZero()\n\tcase *object.Nil, *object.TypedNil:\n\t\treturn false\n\tdefault:\n\t\t// Any other object type (Integer, String, etc.) is considered truthy.\n\t\treturn !isError(obj)\n\t}\n}\n\n// evalIfElseExpression evaluates an if-else expression.\nfunc (e *Evaluator) evalIfElseExpression(ie *ast.IfStmt, env *object.Environment, fscope *object.FileScope) object.Object {\n\t// Handle if with initializer\n\tifEnv := env\n\tif ie.Init != nil {\n\t\tifEnv = object.NewEnclosedEnvironment(env)\n\t\tinitResult := e.Eval(ie.Init, ifEnv, fscope)\n\t\tif isError(initResult) {\n\t\t\treturn initResult\n\t\t}\n\t}\n\n\tcondition := e.Eval(ie.Cond, ifEnv, fscope)\n\tif isError(condition) {\n\t\treturn condition\n\t}\n\n\tif e.isTruthy(condition) {\n\t\treturn e.Eval(ie.Body, ifEnv, fscope)\n\t} else if ie.Else != nil {\n\t\treturn e.Eval(ie.Else, ifEnv, fscope)\n\t} else {\n\t\treturn object.NIL\n\t}\n}\n\n// evalBlockStatement evaluates a block of statements within a new scope.\nfunc (e *Evaluator) evalBlockStatement(block *ast.BlockStmt, env *object.Environment, fscope *object.FileScope) object.Object {\n\tvar result object.Object\n\tenclosedEnv := object.NewEnclosedEnvironment(env)\n\n\tfor _, statement := range block.List {\n\t\tresult = e.Eval(statement, enclosedEnv, fscope)\n\t\tif result != nil {\n\t\t\trt := result.Type()\n\t\t\tif rt == object.RETURN_VALUE_OBJ || rt == object.BREAK_OBJ || rt == object.CONTINUE_OBJ || rt == object.ERROR_OBJ || rt == object.PANIC_OBJ {\n\t\t\t\treturn result\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}\n\n// evalForStmt evaluates a for loop.\nfunc (e *Evaluator) evalForStmt(fs *ast.ForStmt, env *object.Environment, fscope *object.FileScope) object.Object {\n\tloopEnv := object.NewEnclosedEnvironment(env)\n\n\tvar loopVars []string\n\tif fs.Init != nil {\n\t\t// If the init statement is a short variable declaration (:=),\n\t\t// record the names of the variables it declares. This is key\n\t\t// to emulating Go 1.22's per-iteration variable semantics.\n\t\tif assign, ok := fs.Init.(*ast.AssignStmt); ok && assign.Tok == token.DEFINE {\n\t\t\tfor _, lhs := range assign.Lhs {\n\t\t\t\tif ident, ok := lhs.(*ast.Ident); ok {\n\t\t\t\t\tloopVars = append(loopVars, ident.Name)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinitResult := e.Eval(fs.Init, loopEnv, fscope)\n\t\tif isError(initResult) {\n\t\t\treturn initResult\n\t\t}\n\t}\n\n\tfor {\n\t\tif fs.Cond != nil {\n\t\t\tcondition := e.Eval(fs.Cond, loopEnv, fscope)\n\t\t\tif isError(condition) {\n\t\t\t\treturn condition\n\t\t\t}\n\t\t\tif !e.isTruthy(condition) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Create a new environment for the loop body for each iteration.\n\t\tbodyEnv := object.NewEnclosedEnvironment(loopEnv)\n\t\t// If we identified loop variables from a `:=` statement, we create\n\t\t// a copy of them in the new body-specific environment.\n\t\t// This is the magic that makes closures capture the variable per-iteration.\n\t\tfor _, varName := range loopVars {\n\t\t\tval, ok := loopEnv.Get(varName)\n\t\t\tif ok {\n\t\t\t\tbodyEnv.Set(varName, val)\n\t\t\t}\n\t\t}\n\n\t\t// Evaluate the loop body in this new, per-iteration environment.\n\t\tbodyResult := e.Eval(fs.Body, bodyEnv, fscope)\n\n\t\t// Check for control flow statements\n\t\tif bodyResult != nil {\n\t\t\trt := bodyResult.Type()\n\t\t\tif rt == object.BREAK_OBJ {\n\t\t\t\tbreak\t// Break from the for-loop\n\t\t\t}\n\t\t\tif rt == object.CONTINUE_OBJ {\n\t\t\t\t// Execute the post statement before continuing.\n\t\t\t\tif fs.Post != nil {\n\t\t\t\t\tif postResult := e.Eval(fs.Post, loopEnv, fscope); isError(postResult) {\n\t\t\t\t\t\treturn postResult\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif rt == object.ERROR_OBJ || rt == object.RETURN_VALUE_OBJ || rt == object.PANIC_OBJ {\n\t\t\t\treturn bodyResult\t// Propagate up\n\t\t\t}\n\t\t}\n\n\t\tif fs.Post != nil {\n\t\t\tpostResult := e.Eval(fs.Post, loopEnv, fscope)\n\t\t\tif isError(postResult) {\n\t\t\t\treturn postResult\n\t\t\t}\n\t\t}\n\t}\n\n\treturn object.NIL\n}\n\n// evalForRangeStmt evaluates a for...range loop.\nfunc (e *Evaluator) evalForRangeStmt(rs *ast.RangeStmt, env *object.Environment, fscope *object.FileScope) object.Object {\n\titerable := e.Eval(rs.X, env, fscope)\n\tif isError(iterable) {\n\t\treturn iterable\n\t}\n\n\tswitch iterable := iterable.(type) {\n\tcase *object.Array:\n\t\treturn e.evalRangeArray(rs, iterable, env, fscope)\n\tcase *object.String:\n\t\treturn e.evalRangeString(rs, iterable, env, fscope)\n\tcase *object.Map:\n\t\treturn e.evalRangeMap(rs, iterable, env, fscope)\n\tcase *object.Integer:\n\t\treturn e.evalRangeInteger(rs, iterable, env, fscope)\n\tcase *object.GoValue:\n\t\treturn e.evalRangeGoValue(rs, iterable, env, fscope)\n\tcase *object.Function:\n\t\treturn e.evalRangeFunction(rs, iterable, env, fscope)\n\tdefault:\n\t\treturn e.newError(rs.X.Pos(), \"range operator not supported for %s\", iterable.Type())\n\t}\n}\n\nfunc (e *Evaluator) evalRangeFunction(rs *ast.RangeStmt, fn *object.Function, env *object.Environment, fscope *object.FileScope) object.Object {\n\tvar loopErr object.Object\t// To capture errors/returns from the yield function\n\n\tyield := &object.Builtin{\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tloopEnv := object.NewEnclosedEnvironment(env)\n\n\t\t\tkeyIdent, _ := rs.Key.(*ast.Ident)\n\n\t\t\tif rs.Value == nil {\n\t\t\t\t// Form: for v := range f\n\t\t\t\tif len(args) != 1 {\n\t\t\t\t\tloopErr = ctx.NewError(pos, \"yield must be called with 1 argument for a single-variable range loop, got %d\", len(args))\n\t\t\t\t\treturn object.FALSE\t// Stop iteration on error\n\t\t\t\t}\n\t\t\t\tif keyIdent != nil && keyIdent.Name != \"_\" {\n\t\t\t\t\tloopEnv.Set(keyIdent.Name, args[0])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Form: for k, v := range f\n\t\t\t\tvalIdent, _ := rs.Value.(*ast.Ident)\n\t\t\t\tif len(args) != 2 {\n\t\t\t\t\tloopErr = ctx.NewError(pos, \"yield must be called with 2 arguments for a two-variable range loop, got %d\", len(args))\n\t\t\t\t\treturn object.FALSE\t// Stop iteration on error\n\t\t\t\t}\n\t\t\t\tif keyIdent != nil && keyIdent.Name != \"_\" {\n\t\t\t\t\tloopEnv.Set(keyIdent.Name, args[0])\n\t\t\t\t}\n\t\t\t\tif valIdent != nil && valIdent.Name != \"_\" {\n\t\t\t\t\tloopEnv.Set(valIdent.Name, args[1])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult := e.Eval(rs.Body, loopEnv, fscope)\n\n\t\t\tswitch result {\n\t\t\tcase object.BREAK:\n\t\t\t\treturn object.FALSE\n\t\t\tcase object.CONTINUE:\n\t\t\t\treturn object.TRUE\n\t\t\t}\n\n\t\t\tif result != nil {\n\t\t\t\trt := result.Type()\n\t\t\t\tif rt == object.ERROR_OBJ || rt == object.RETURN_VALUE_OBJ {\n\t\t\t\t\tloopErr = result\n\t\t\t\t\treturn object.FALSE\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn object.TRUE\n\t\t},\n\t}\n\n\te.applyFunction(nil, fn, []object.Object{yield}, env, fscope)\n\n\tif loopErr != nil {\n\t\treturn loopErr\n\t}\n\n\treturn object.NIL\n}\n\nfunc (e *Evaluator) evalRangeInteger(rs *ast.RangeStmt, num *object.Integer, env *object.Environment, fscope *object.FileScope) object.Object {\n\tif rs.Value != nil {\n\t\treturn e.newError(rs.Pos(), \"range over integer does not support a second loop variable\")\n\t}\n\n\tfor i := int64(0); i < num.Value; i++ {\n\t\tloopEnv := object.NewEnclosedEnvironment(env)\n\t\tif rs.Key != nil {\n\t\t\tkeyIdent, ok := rs.Key.(*ast.Ident)\n\t\t\tif !ok {\n\t\t\t\treturn e.newError(rs.Key.Pos(), \"range key must be an identifier\")\n\t\t\t}\n\t\t\tif keyIdent.Name != \"_\" {\n\t\t\t\tloopEnv.Set(keyIdent.Name, &object.Integer{Value: i})\n\t\t\t}\n\t\t}\n\n\t\tresult := e.Eval(rs.Body, loopEnv, fscope)\n\t\tif result != nil {\n\t\t\trt := result.Type()\n\t\t\tif rt == object.BREAK_OBJ {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif rt == object.CONTINUE_OBJ {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif rt == object.ERROR_OBJ || rt == object.RETURN_VALUE_OBJ {\n\t\t\t\treturn result\n\t\t\t}\n\t\t}\n\t}\n\treturn object.NIL\n}\n\nfunc (e *Evaluator) evalRangeGoValue(rs *ast.RangeStmt, goVal *object.GoValue, env *object.Environment, fscope *object.FileScope) object.Object {\n\tval := goVal.Value\n\tswitch val.Kind() {\n\tcase reflect.Slice, reflect.Array:\n\t\tfor i := 0; i < val.Len(); i++ {\n\t\t\tloopEnv := object.NewEnclosedEnvironment(env)\n\t\t\telem := val.Index(i)\n\n\t\t\tif rs.Key != nil {\n\t\t\t\tkeyIdent, _ := rs.Key.(*ast.Ident)\t// This is safe in a valid AST\n\t\t\t\tif keyIdent.Name != \"_\" {\n\t\t\t\t\tloopEnv.Set(keyIdent.Name, &object.Integer{Value: int64(i)})\n\t\t\t\t}\n\t\t\t}\n\t\t\tif rs.Value != nil {\n\t\t\t\tvalueIdent, _ := rs.Value.(*ast.Ident)\t// This is safe in a valid AST\n\t\t\t\tif valueIdent.Name != \"_\" {\n\t\t\t\t\tloopEnv.Set(valueIdent.Name, e.nativeToValue(elem))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult := e.Eval(rs.Body, loopEnv, fscope)\n\t\t\tif result != nil {\n\t\t\t\trt := result.Type()\n\t\t\t\tif rt == object.BREAK_OBJ {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif rt == object.CONTINUE_OBJ {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif rt == object.ERROR_OBJ || rt == object.RETURN_VALUE_OBJ {\n\t\t\t\t\treturn result\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn object.NIL\n\n\tcase reflect.Map:\n\t\titer := val.MapRange()\n\t\tfor iter.Next() {\n\t\t\tloopEnv := object.NewEnclosedEnvironment(env)\n\t\t\tk := iter.Key()\n\t\t\tv := iter.Value()\n\n\t\t\tif rs.Key != nil {\n\t\t\t\tkeyIdent, _ := rs.Key.(*ast.Ident)\t// This is safe in a valid AST\n\t\t\t\tif keyIdent.Name != \"_\" {\n\t\t\t\t\tloopEnv.Set(keyIdent.Name, e.nativeToValue(k))\n\t\t\t\t}\n\t\t\t}\n\t\t\tif rs.Value != nil {\n\t\t\t\tvalueIdent, _ := rs.Value.(*ast.Ident)\t// This is safe in a valid AST\n\t\t\t\tif valueIdent.Name != \"_\" {\n\t\t\t\t\tloopEnv.Set(valueIdent.Name, e.nativeToValue(v))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult := e.Eval(rs.Body, loopEnv, fscope)\n\t\t\tif result != nil {\n\t\t\t\trt := result.Type()\n\t\t\t\tif rt == object.BREAK_OBJ {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif rt == object.CONTINUE_OBJ {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif rt == object.ERROR_OBJ || rt == object.RETURN_VALUE_OBJ {\n\t\t\t\t\treturn result\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn object.NIL\n\t}\n\n\treturn e.newError(rs.X.Pos(), \"range operator not supported for Go value of type %s\", val.Kind())\n}\n\nfunc (e *Evaluator) evalRangeArray(rs *ast.RangeStmt, arr *object.Array, env *object.Environment, fscope *object.FileScope) object.Object {\n\tfor i, element := range arr.Elements {\n\t\tloopEnv := object.NewEnclosedEnvironment(env)\n\t\tif rs.Key != nil {\n\t\t\tkeyIdent, ok := rs.Key.(*ast.Ident)\n\t\t\tif !ok {\n\t\t\t\treturn e.newError(rs.Key.Pos(), \"range key must be an identifier\")\n\t\t\t}\n\t\t\tif keyIdent.Name != \"_\" {\n\t\t\t\tloopEnv.Set(keyIdent.Name, &object.Integer{Value: int64(i)})\n\t\t\t}\n\t\t}\n\t\tif rs.Value != nil {\n\t\t\tvalueIdent, ok := rs.Value.(*ast.Ident)\n\t\t\tif !ok {\n\t\t\t\treturn e.newError(rs.Value.Pos(), \"range value must be an identifier\")\n\t\t\t}\n\t\t\tif valueIdent.Name != \"_\" {\n\t\t\t\tloopEnv.Set(valueIdent.Name, element)\n\t\t\t}\n\t\t}\n\n\t\tresult := e.Eval(rs.Body, loopEnv, fscope)\n\t\tif result != nil {\n\t\t\trt := result.Type()\n\t\t\tif rt == object.BREAK_OBJ {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif rt == object.CONTINUE_OBJ {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif rt == object.ERROR_OBJ || rt == object.RETURN_VALUE_OBJ {\n\t\t\t\treturn result\n\t\t\t}\n\t\t}\n\t}\n\treturn object.NIL\n}\n\nfunc (e *Evaluator) evalRangeString(rs *ast.RangeStmt, str *object.String, env *object.Environment, fscope *object.FileScope) object.Object {\n\tfor i, r := range str.Value {\n\t\tloopEnv := object.NewEnclosedEnvironment(env)\n\t\tif rs.Key != nil {\n\t\t\tkeyIdent, ok := rs.Key.(*ast.Ident)\n\t\t\tif !ok {\n\t\t\t\treturn e.newError(rs.Key.Pos(), \"range key must be an identifier\")\n\t\t\t}\n\t\t\tif keyIdent.Name != \"_\" {\n\t\t\t\tloopEnv.Set(keyIdent.Name, &object.Integer{Value: int64(i)})\n\t\t\t}\n\t\t}\n\t\tif rs.Value != nil {\n\t\t\tvalueIdent, ok := rs.Value.(*ast.Ident)\n\t\t\tif !ok {\n\t\t\t\treturn e.newError(rs.Value.Pos(), \"range value must be an identifier\")\n\t\t\t}\n\t\t\tif valueIdent.Name != \"_\" {\n\t\t\t\tloopEnv.Set(valueIdent.Name, &object.Integer{Value: int64(r)})\t// rune is an alias for int32\n\t\t\t}\n\t\t}\n\n\t\tresult := e.Eval(rs.Body, loopEnv, fscope)\n\t\tif result != nil {\n\t\t\trt := result.Type()\n\t\t\tif rt == object.BREAK_OBJ {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif rt == object.CONTINUE_OBJ {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif rt == object.ERROR_OBJ || rt == object.RETURN_VALUE_OBJ {\n\t\t\t\treturn result\n\t\t\t}\n\t\t}\n\t}\n\treturn object.NIL\n}\n\nfunc (e *Evaluator) evalRangeMap(rs *ast.RangeStmt, m *object.Map, env *object.Environment, fscope *object.FileScope) object.Object {\n\t// Note: Iteration order over maps is not guaranteed.\n\tfor _, pair := range m.Pairs {\n\t\tloopEnv := object.NewEnclosedEnvironment(env)\n\t\tif rs.Key != nil {\n\t\t\tkeyIdent, ok := rs.Key.(*ast.Ident)\n\t\t\tif !ok {\n\t\t\t\treturn e.newError(rs.Key.Pos(), \"range key must be an identifier\")\n\t\t\t}\n\t\t\tif keyIdent.Name != \"_\" {\n\t\t\t\tloopEnv.Set(keyIdent.Name, pair.Key)\n\t\t\t}\n\t\t}\n\t\tif rs.Value != nil {\n\t\t\tvalueIdent, ok := rs.Value.(*ast.Ident)\n\t\t\tif !ok {\n\t\t\t\treturn e.newError(rs.Value.Pos(), \"range value must be an identifier\")\n\t\t\t}\n\t\t\tif valueIdent.Name != \"_\" {\n\t\t\t\tloopEnv.Set(valueIdent.Name, pair.Value)\n\t\t\t}\n\t\t}\n\n\t\tresult := e.Eval(rs.Body, loopEnv, fscope)\n\t\tif result != nil {\n\t\t\trt := result.Type()\n\t\t\tif rt == object.BREAK_OBJ {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif rt == object.CONTINUE_OBJ {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif rt == object.ERROR_OBJ || rt == object.RETURN_VALUE_OBJ {\n\t\t\t\treturn result\n\t\t\t}\n\t\t}\n\t}\n\treturn object.NIL\n}\n\n// evalSwitchStmt evaluates a switch statement.\nfunc (e *Evaluator) evalSwitchStmt(ss *ast.SwitchStmt, env *object.Environment, fscope *object.FileScope) object.Object {\n\tswitchEnv := env\n\tif ss.Init != nil {\n\t\tswitchEnv = object.NewEnclosedEnvironment(env)\n\t\tinitResult := e.Eval(ss.Init, switchEnv, fscope)\n\t\tif isError(initResult) {\n\t\t\treturn initResult\n\t\t}\n\t}\n\n\tvar tag object.Object\n\tif ss.Tag != nil {\n\t\ttag = e.Eval(ss.Tag, switchEnv, fscope)\n\t\tif isError(tag) {\n\t\t\treturn tag\n\t\t}\n\t} else {\n\t\ttag = object.TRUE\n\t}\n\n\tvar defaultCase *ast.CaseClause\n\tvar matched bool\n\n\tfor _, stmt := range ss.Body.List {\n\t\tclause, ok := stmt.(*ast.CaseClause)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tif clause.List == nil {\n\t\t\tdefaultCase = clause\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, caseExpr := range clause.List {\n\t\t\tcaseVal := e.Eval(caseExpr, switchEnv, fscope)\n\t\t\tif isError(caseVal) {\n\t\t\t\treturn caseVal\n\t\t\t}\n\n\t\t\tvar condition bool\n\t\t\tif ss.Tag == nil {\n\t\t\t\tcondition = e.isTruthy(caseVal)\n\t\t\t} else {\n\t\t\t\teq := e.evalInfixExpression(caseExpr, \"==\", tag, caseVal)\n\t\t\t\tif isError(eq) {\n\t\t\t\t\t// We treat comparison errors as non-matches and continue.\n\t\t\t\t\tcondition = false\n\t\t\t\t} else {\n\t\t\t\t\tcondition = eq == object.TRUE\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif condition {\n\t\t\t\tmatched = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif matched {\n\t\t\tcaseEnv := object.NewEnclosedEnvironment(switchEnv)\n\t\t\tvar result object.Object\n\t\t\tfor _, caseBodyStmt := range clause.Body {\n\t\t\t\tresult = e.Eval(caseBodyStmt, caseEnv, fscope)\n\t\t\t\tif isError(result) {\n\t\t\t\t\treturn result\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result\n\t\t}\n\t}\n\n\tif defaultCase != nil {\n\t\tcaseEnv := object.NewEnclosedEnvironment(switchEnv)\n\t\tvar result object.Object\n\t\tfor _, caseBodyStmt := range defaultCase.Body {\n\t\t\tresult = e.Eval(caseBodyStmt, caseEnv, fscope)\n\t\t\tif isError(result) {\n\t\t\t\treturn result\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n\n\treturn object.NIL\n}\n\nfunc (e *Evaluator) evalExpressions(exps []ast.Expr, env *object.Environment, fscope *object.FileScope, expectedElementType object.Object) []object.Object {\n\tresult := make([]object.Object, len(exps))\n\n\tfor i, exp := range exps {\n\t\tvar evaluated object.Object\n\t\tif compLit, ok := exp.(*ast.CompositeLit); ok && compLit.Type == nil {\n\t\t\tif expectedElementType == nil {\n\t\t\t\tevaluated = e.newError(compLit.Pos(), \"untyped composite literal in context where type cannot be inferred\")\n\t\t\t} else {\n\t\t\t\tevaluated = e.evalCompositeLitWithType(compLit, expectedElementType, env, fscope)\n\t\t\t}\n\t\t} else {\n\t\t\tevaluated = e.Eval(exp, env, fscope)\n\t\t}\n\n\t\tif isError(evaluated) {\n\t\t\t// Return a slice containing just the error to stop further processing.\n\t\t\treturn []object.Object{evaluated}\n\t\t}\n\t\t// When a function call is used as an argument, its return value needs to be unwrapped.\n\t\tresult[i] = e.unwrapReturnValue(evaluated)\n\t}\n\n\treturn result\n}\n\n// getZeroValueForResolvedType creates a zero-value object for a given resolved type object.\nfunc (e *Evaluator) getZeroValueForResolvedType(typeObj object.Object) object.Object {\n\tswitch rt := typeObj.(type) {\n\tcase *object.GoType:\n\t\tptr := reflect.New(rt.GoType)\n\t\treturn &object.GoValue{Value: ptr.Elem()}\n\tcase *object.StructDefinition:\n\t\tinstance := &object.StructInstance{Def: rt, Fields: make(map[string]object.Object)}\n\t\tfor _, field := range rt.Fields {\n\t\t\tfor _, name := range field.Names {\n\t\t\t\t// Initialize fields to NIL. The recursive creation was causing stack overflows.\n\t\t\t\t// NIL is the correct zero value for any reference or struct type in the interpreter.\n\t\t\t\tinstance.Fields[name.Name] = object.NIL\n\t\t\t}\n\t\t}\n\t\treturn instance\n\tcase *object.Type:\n\t\tswitch rt.Name {\n\t\tcase \"int\", \"int64\", \"int32\", \"int16\", \"int8\", \"uint\", \"uint64\", \"uint32\", \"uint16\", \"uint8\", \"byte\":\n\t\t\treturn &object.Integer{Value: 0}\n\t\tcase \"string\":\n\t\t\treturn &object.String{Value: \"\"}\n\t\tcase \"bool\":\n\t\t\treturn object.FALSE\n\t\tcase \"float64\", \"float32\":\n\t\t\treturn &object.Float{Value: 0.0}\n\t\t}\n\t}\n\t// For any other type (pointers, interfaces, arrays, maps, etc.), the zero value is a typed nil.\n\treturn &object.TypedNil{TypeObject: typeObj}\n}\n\nfunc (e *Evaluator) getZeroValueForType(typeExpr ast.Expr, env *object.Environment, fscope *object.FileScope) object.Object {\n\t// First, evaluate the AST expression to get a minigo object representing the type.\n\ttypeObj := e.Eval(typeExpr, env, fscope)\n\tif isError(typeObj) {\n\t\treturn typeObj\n\t}\n\n\t// Then, resolve any aliases to get the underlying type definition.\n\tresolvedType := e.resolveType(typeObj, env, fscope)\n\tif isError(resolvedType) {\n\t\treturn resolvedType\n\t}\n\n\t// Finally, create the zero value based on the resolved type.\n\treturn e.getZeroValueForResolvedType(resolvedType)\n}\n\nfunc (e *Evaluator) applyFunction(call *ast.CallExpr, fn object.Object, args []object.Object, env *object.Environment, fscope *object.FileScope) object.Object {\n\tvar function *object.Function\n\tvar typeArgs []object.Object\n\tvar receiver object.Object\t// For bound methods\n\n\tswitch f := fn.(type) {\n\tcase *object.Function:\n\t\t// Check if this is a generic function being called without instantiation.\n\t\tif f.TypeParams != nil && len(f.TypeParams.List) > 0 {\n\t\t\t// It's a generic function. Try to infer type arguments from value arguments.\n\t\t\tinferred, errObj := e.inferGenericTypes(call.Pos(), f, args)\n\t\t\tif errObj != nil {\n\t\t\t\treturn errObj\n\t\t\t}\n\t\t\tfunction = f\n\t\t\ttypeArgs = inferred\n\t\t} else {\n\t\t\t// It's a regular, non-generic function.\n\t\t\tfunction = f\n\t\t}\n\tcase *object.InstantiatedType:\n\t\tgenericFn, ok := f.GenericDef.(*object.Function)\n\t\tif !ok {\n\t\t\treturn e.newError(call.Pos(), \"not a function: %s\", f.GenericDef.Type())\n\t\t}\n\t\tfunction = genericFn\n\t\ttypeArgs = f.TypeArgs\n\tcase *object.BoundMethod:\n\t\tfunction = f.Fn\n\t\treceiver = f.Receiver\n\t\t// Generic methods on generic structs are handled by the receiver's type args,\n\t\t// which are already bound in extendMethodEnv.\n\tcase *object.GoSourceFunction:\n\t\t// Convert GoSourceFunction to a standard Function object for execution.\n\t\t// The key is that we will use its DefEnv as the outer environment.\n\t\tfInfo := f.Fn\n\t\tastFunc := fInfo.AstDecl\n\t\tfunction = &object.Function{\n\t\t\tName:\t\tastFunc.Name,\n\t\t\tTypeParams:\tastFunc.Type.TypeParams,\n\t\t\tParameters:\tastFunc.Type.Params,\n\t\t\tResults:\tastFunc.Type.Results,\n\t\t\tBody:\t\tastFunc.Body,\n\t\t\tEnv:\t\tf.DefEnv,\t// Use the DEFINITION environment\n\t\t\tFScope:\t\tf.FScope,\t// Use the DEFINITION file scope\n\t\t}\n\t\t// This is also a generic function, so we must run the same type\n\t\t// inference logic as for a regular *object.Function.\n\t\tif function.TypeParams != nil && len(function.TypeParams.List) > 0 {\n\t\t\tinferred, errObj := e.inferGenericTypes(call.Pos(), function, args)\n\t\t\tif errObj != nil {\n\t\t\t\treturn errObj\n\t\t\t}\n\t\t\ttypeArgs = inferred\n\t\t}\n\tcase *object.Builtin:\n\t\tvar pos token.Pos\n\t\tif call != nil {\n\t\t\tpos = call.Pos()\n\t\t}\n\t\te.BuiltinContext.Env = env\n\t\te.BuiltinContext.FScope = fscope\n\t\treturn f.Fn(&e.BuiltinContext, pos, args...)\n\tdefault:\n\t\treturn e.newError(call.Pos(), \"not a function: %s\", fn.Type())\n\t}\n\n\t// --- Common logic for all user-defined function/method calls ---\n\tvar callPos token.Pos\n\tif call != nil {\n\t\tcallPos = call.Pos()\n\t}\n\n\t// Calculate the total number of non-variadic parameter names.\n\tparamCount := 0\n\tif function.Parameters != nil {\n\t\tfor _, field := range function.Parameters.List {\n\t\t\t// For `func(a, b int)`, field.Names is [\"a\", \"b\"].\n\t\t\t// For `func(int)`, field.Names is empty, but there's one field.\n\t\t\tif len(field.Names) > 0 {\n\t\t\t\tparamCount += len(field.Names)\n\t\t\t} else {\n\t\t\t\t// This handles unnamed parameters, which appear one per field.\n\t\t\t\t// It also correctly handles the `...T` in a variadic function,\n\t\t\t\t// which also appears as a single field with no name.\n\t\t\t\tparamCount++\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check argument count\n\tif function.IsVariadic() {\n\t\t// For a variadic function, we need at least (paramCount - 1) arguments.\n\t\t// The `paramCount` includes the variadic `...T` parameter itself.\n\t\tif len(args) < paramCount-1 {\n\t\t\treturn e.newError(callPos, \"wrong number of arguments for variadic function. got=%d, want at least %d\", len(args), paramCount-1)\n\t\t}\n\t} else {\n\t\tif paramCount != len(args) {\n\t\t\treturn e.newError(callPos, \"wrong number of arguments. got=%d, want=%d\", len(args), paramCount)\n\t\t}\n\t}\n\n\t// Check type argument count for generic functions\n\tif function.TypeParams != nil && len(function.TypeParams.List) > 0 {\n\t\tif len(typeArgs) != len(function.TypeParams.List) {\n\t\t\treturn e.newError(callPos, \"wrong number of type arguments. got=%d, want=%d\", len(typeArgs), len(function.TypeParams.List))\n\t\t}\n\t}\n\n\t// Check type constraints before setting up the environment.\n\tif function.TypeParams != nil {\n\t\t// We need an environment to evaluate the constraint expressions.\n\t\t// It should be based on the function's definition environment...\n\t\tvar baseConstraintEnv *object.Environment\n\t\tif function.Env != nil {\n\t\t\tbaseConstraintEnv = function.Env\n\t\t} else {\n\t\t\tbaseConstraintEnv = env\t// Fallback to the calling environment\n\t\t}\n\t\t// ... and it must also contain the type parameters themselves, since a\n\t\t// constraint for one parameter might refer to another (e.g., S ~[]E).\n\t\tconstraintEnv := object.NewEnclosedEnvironment(baseConstraintEnv)\n\t\te.bindTypeParams(constraintEnv, function.TypeParams, typeArgs)\n\n\t\t// This loop needs to be careful with multi-name fields.\n\t\ttypeArgIndex := 0\n\t\tfor _, param := range function.TypeParams.List {\n\t\t\tfor range param.Names {\n\t\t\t\tif typeArgIndex < len(typeArgs) {\n\t\t\t\t\tconcreteType := typeArgs[typeArgIndex]\n\t\t\t\t\tconstraintExpr := param.Type\n\n\t\t\t\t\tconstraintObj := e.Eval(constraintExpr, constraintEnv, function.FScope)\n\t\t\t\t\tif isError(constraintObj) {\n\t\t\t\t\t\treturn constraintObj\n\t\t\t\t\t}\n\n\t\t\t\t\tif err := e.checkTypeConstraint(param.Pos(), concreteType, constraintObj, constraintEnv, function.FScope); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\ttypeArgIndex++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set up call stack\n\tfuncName := \"<anonymous>\"\n\t// If the call expression is not directly a func literal (i.e., not an IIFE),\n\t// and the function object has a name (from a declaration or assignment), use it.\n\tif call != nil {\n\t\tif _, ok := call.Fun.(*ast.FuncLit); !ok {\n\t\t\tif function.Name != nil {\n\t\t\t\tfuncName = function.Name.Name\n\t\t\t}\n\t\t}\n\t} else if function.Name != nil {\n\t\tfuncName = function.Name.Name\n\t}\n\tframe := &object.CallFrame{\n\t\tPos:\t\tcallPos,\n\t\tFunction:\tfuncName,\n\t\tFn:\t\tfunction,\n\t\tDefers:\t\tmake([]*object.DeferredCall, 0),\n\t}\n\te.callStack = append(e.callStack, frame)\n\t// Ensure the stack is popped even if a Go panic occurs within the evaluator.\n\tdefer func() { e.callStack = e.callStack[:len(e.callStack)-1] }()\n\n\t// --- Environment Setup ---\n\tvar baseEnv *object.Environment\n\tif receiver != nil {\n\t\tboundMethod := &object.BoundMethod{Fn: function, Receiver: receiver}\n\t\tbaseEnv = e.extendMethodEnv(boundMethod, args)\n\t} else {\n\t\tbaseEnv = object.NewEnclosedEnvironment(function.Env)\n\t\te.extendFunctionEnv(baseEnv, function, args, typeArgs)\n\t}\n\n\tbodyEnv := baseEnv\n\tif function.HasNamedReturns() {\n\t\tnamedReturnsEnv := object.NewEnclosedEnvironment(baseEnv)\n\t\tfor _, field := range function.Results.List {\n\t\t\tfor _, name := range field.Names {\n\t\t\t\tzeroVal := e.getZeroValueForType(field.Type, namedReturnsEnv, fscope)\n\t\t\t\tnamedReturnsEnv.Set(name.Name, zeroVal)\n\t\t\t}\n\t\t}\n\t\tframe.NamedReturns = namedReturnsEnv\n\t\tbodyEnv = namedReturnsEnv\n\t}\n\n\t// Evaluate the function body. This will return a ReturnValue on `return`.\n\tevalFScope := fscope\n\tif function.FScope != nil {\n\t\tevalFScope = function.FScope\n\t}\n\tevaluated := e.Eval(function.Body, bodyEnv, evalFScope)\n\n\t// Check if the evaluation resulted in a panic.\n\tisPanic := false\n\tif p, ok := evaluated.(*object.Panic); ok {\n\t\tisPanic = true\n\t\te.currentPanic = p\n\t}\n\n\t// Now, *after* the body has run, execute the defers. This happens even if a panic occurred.\n\tfor i := len(frame.Defers) - 1; i >= 0; i-- {\n\t\te.executeDeferredCall(frame.Defers[i], fscope)\n\t}\n\n\t// If a panic was active and was not cleared by a recover() in a defer,\n\t// then it should be propagated up the call stack.\n\tif e.currentPanic != nil {\n\t\treturn e.currentPanic\n\t}\n\n\t// If a panic occurred but was recovered, the function's normal execution\n\t// was aborted. It should return NIL, not continue processing the original\n\t// panic object as a return value.\n\tif isPanic {\n\t\treturn object.NIL\n\t}\n\n\t// --- Return Value Handling ---\n\t// After defers have run, construct the final return value if necessary.\n\tif ret, ok := evaluated.(*object.ReturnValue); ok && ret.Value == nil {\n\t\tif frame.NamedReturns != nil {\n\t\t\t// This now happens *after* defers, so it will see modified values.\n\t\t\treturn e.constructNamedReturnValue(function, frame.NamedReturns)\n\t\t}\n\t\treturn &object.ReturnValue{Value: object.NIL}\n\t}\n\n\t// For regular returns, unwrap the value.\n\treturn e.unwrapReturnValue(evaluated)\n}\n\n// constructNamedReturnValue collects the values from the named return environment\n// and packages them into a single return value (or a tuple for multiple returns).\nfunc (e *Evaluator) typesAreCompatible(concrete, constraint object.Object, approximate bool) bool {\n\t// A simple inspect comparison works for basic types and struct definitions.\n\t// e.g., \"int\" == \"int\" or \"struct MyStruct\" == \"struct MyStruct\"\n\tif concrete.Inspect() == constraint.Inspect() {\n\t\treturn true\n\t}\n\n\t// TODO: A more robust implementation is needed here, especially for the 'approximate' (`~`) case.\n\t// For `~T`, we would need to check the underlying type of `concrete`.\n\t// Our current object system doesn't retain alias information after resolution,\n\t// which makes checking underlying types difficult.\n\t// For now, this simple comparison is enough to pass tests for built-in types.\n\tif approximate {\n\t\t// This is a placeholder. A real implementation would look at the underlying type.\n\t\t// For now, we'll just re-check equality, which is incorrect but safe.\n\t\tif concrete.Inspect() == constraint.Inspect() {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// checkTypeConstraint verifies that a concrete type satisfies a given constraint.\nfunc (e *Evaluator) checkTypeConstraint(pos token.Pos, concreteType, constraint object.Object, env *object.Environment, fscope *object.FileScope) *object.Error {\n\tresolvedConstraint := e.resolveType(constraint, env, fscope)\n\tif isError(resolvedConstraint) {\n\t\treturn resolvedConstraint.(*object.Error)\n\t}\n\n\tifaceDef, ok := resolvedConstraint.(*object.InterfaceDefinition)\n\tif !ok {\n\t\t// Not an interface constraint, or not one we need to check yet (e.g. method sets).\n\t\t// For now, we only care about type list interfaces.\n\t\treturn nil\n\t}\n\n\t// It is an interface. Check if it's a type list constraint.\n\tif len(ifaceDef.TypeList) > 0 {\n\t\tfor _, typeExpr := range ifaceDef.TypeList {\n\t\t\tisApproximate := false\n\t\t\tif unary, ok := typeExpr.(*ast.UnaryExpr); ok && unary.Op == token.TILDE {\n\t\t\t\tisApproximate = true\n\t\t\t\ttypeExpr = unary.X\n\t\t\t}\n\n\t\t\t// We need a new environment for this evaluation so it doesn't pollute the function's env.\n\t\t\tconstraintTypeObj := e.Eval(typeExpr, env, fscope)\n\t\t\tif isError(constraintTypeObj) {\n\t\t\t\treturn constraintTypeObj.(*object.Error)\n\t\t\t}\n\n\t\t\t// Now compare concreteType with constraintTypeObj\n\t\t\tif e.typesAreCompatible(concreteType, constraintTypeObj, isApproximate) {\n\t\t\t\treturn nil\t// Match found, constraint satisfied.\n\t\t\t}\n\t\t}\n\n\t\t// No match found in the type list.\n\t\treturn e.newError(pos, \"type %s does not satisfy interface constraint %s\", concreteType.Inspect(), ifaceDef.Name.Name)\n\t}\n\n\t// TODO: Handle traditional interface constraints (method sets).\n\t// For now, we assume it's satisfied if it's not a type list.\n\treturn nil\n}\n\n// constructNamedReturnValue collects the values from the named return environment\n// and packages them into a single return value (or a tuple for multiple returns).\nfunc (e *Evaluator) constructNamedReturnValue(fn *object.Function, env *object.Environment) object.Object {\n\tnumReturns := len(fn.Results.List)\n\tif numReturns == 0 {\n\t\treturn &object.ReturnValue{Value: object.NIL}\n\t}\n\n\tvalues := make([]object.Object, 0, numReturns)\n\tfor _, field := range fn.Results.List {\n\t\tfor _, name := range field.Names {\n\t\t\tval, _ := env.Get(name.Name)\t// We can ignore 'ok' because we initialized them.\n\t\t\tvalues = append(values, val)\n\t\t}\n\t}\n\n\tif len(values) == 1 {\n\t\treturn &object.ReturnValue{Value: values[0]}\n\t}\n\treturn &object.ReturnValue{Value: &object.Tuple{Elements: values}}\n}\n\n// ApplyFunction is a public wrapper for the internal applyFunction, allowing it to be called from other packages.\nfunc (e *Evaluator) ApplyFunction(call *ast.CallExpr, fn object.Object, args []object.Object, fscope *object.FileScope) object.Object {\n\t// This is a simplification. A real implementation would need to determine the correct environment.\n\t// For now, we'll use a new top-level environment, which will work for pure functions\n\t// but not for closures that capture variables.\n\tenv := object.NewEnvironment()\n\treturn e.applyFunction(call, fn, args, env, fscope)\n}\n\nfunc (e *Evaluator) extendMethodEnv(method *object.BoundMethod, args []object.Object) *object.Environment {\n\tenv := object.NewEnclosedEnvironment(method.Fn.Env)\n\n\t// Bind type parameters from the generic struct instance to the environment.\n\tif instance, ok := method.Receiver.(*object.StructInstance); ok {\n\t\te.bindTypeParams(env, instance.Def.TypeParams, instance.TypeArgs)\n\t}\n\n\t// Bind the receiver variable (e.g., 's' in 'func (s MyType) ...')\n\tif method.Fn.Recv != nil && len(method.Fn.Recv.List) == 1 {\n\t\trecvField := method.Fn.Recv.List[0]\n\t\tif len(recvField.Names) > 0 {\n\t\t\tenv.Set(recvField.Names[0].Name, method.Receiver)\n\t\t}\n\t}\n\n\t// Bind the method arguments (handles variadic)\n\tfn := method.Fn\n\tif fn.Parameters == nil {\n\t\treturn env\n\t}\n\n\tif fn.IsVariadic() {\n\t\t// Bind non-variadic parameters\n\t\tfor i, param := range fn.Parameters.List[:len(fn.Parameters.List)-1] {\n\t\t\tfor _, paramName := range param.Names {\n\t\t\t\tenv.Set(paramName.Name, args[i])\n\t\t\t}\n\t\t}\n\n\t\t// Bind variadic parameter\n\t\tlastParam := fn.Parameters.List[len(fn.Parameters.List)-1]\n\t\tvariadicArgs := args[len(fn.Parameters.List)-1:]\n\t\tarr := &object.Array{Elements: make([]object.Object, len(variadicArgs))}\n\t\tfor i, arg := range variadicArgs {\n\t\t\tarr.Elements[i] = arg\n\t\t}\n\t\tenv.Set(lastParam.Names[0].Name, arr)\n\t} else {\n\t\t// Bind regular parameters\n\t\targIndex := 0\n\t\tfor _, param := range fn.Parameters.List {\n\t\t\tif len(param.Names) > 0 {\n\t\t\t\tfor _, paramName := range param.Names {\n\t\t\t\t\tif argIndex < len(args) {\n\t\t\t\t\t\tenv.Set(paramName.Name, args[argIndex])\n\t\t\t\t\t\targIndex++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// This handles unnamed parameters, which appear one per field.\n\t\t\t\t// We don't bind a name, but we still consume an argument.\n\t\t\t\targIndex++\n\t\t\t}\n\t\t}\n\t}\n\n\treturn env\n}\n\nfunc (e *Evaluator) bindTypeParams(env *object.Environment, typeParams *ast.FieldList, typeArgs []object.Object) {\n\tif typeParams == nil || len(typeParams.List) == 0 {\n\t\treturn\n\t}\n\ttypeArgIndex := 0\n\tfor _, param := range typeParams.List {\n\t\tfor _, paramName := range param.Names {\n\t\t\tif typeArgIndex < len(typeArgs) {\n\t\t\t\tenv.SetType(paramName.Name, typeArgs[typeArgIndex])\n\t\t\t\ttypeArgIndex++\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (e *Evaluator) extendFunctionEnv(env *object.Environment, fn *object.Function, args []object.Object, typeArgs []object.Object) {\n\t// Bind type parameters from the generic function call to the environment.\n\te.bindTypeParams(env, fn.TypeParams, typeArgs)\n\n\tif fn.Parameters == nil {\n\t\treturn\n\t}\n\n\tif fn.IsVariadic() {\n\t\t// Bind non-variadic parameters\n\t\tfor i, param := range fn.Parameters.List[:len(fn.Parameters.List)-1] {\n\t\t\t// A single parameter can have multiple names (e.g., `a, b int`).\n\t\t\tfor _, paramName := range param.Names {\n\t\t\t\tenv.Set(paramName.Name, args[i])\n\t\t\t}\n\t\t}\n\n\t\t// Bind variadic parameter\n\t\tlastParam := fn.Parameters.List[len(fn.Parameters.List)-1]\n\t\tvariadicArgs := args[len(fn.Parameters.List)-1:]\n\t\tarr := &object.Array{Elements: make([]object.Object, len(variadicArgs))}\n\t\tfor i, arg := range variadicArgs {\n\t\t\tarr.Elements[i] = arg\n\t\t}\n\t\t// The variadic parameter has only one name.\n\t\tenv.Set(lastParam.Names[0].Name, arr)\n\n\t} else {\n\t\t// Bind regular parameters\n\t\targIndex := 0\n\t\tfor _, param := range fn.Parameters.List {\n\t\t\tif len(param.Names) > 0 {\n\t\t\t\tfor _, paramName := range param.Names {\n\t\t\t\t\tif argIndex < len(args) {\n\t\t\t\t\t\tenv.Set(paramName.Name, args[argIndex])\n\t\t\t\t\t\targIndex++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// This handles unnamed parameters, which appear one per field.\n\t\t\t\t// We don't bind a name, but we still consume an argument.\n\t\t\t\targIndex++\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nfunc (e *Evaluator) executeDeferredCall(deferred *object.DeferredCall, fscope *object.FileScope) {\n\te.isExecutingDefer = true\n\tdefer func() { e.isExecutingDefer = false }()\n\n\tvar evaluated object.Object\n\n\tswitch fn := deferred.Fn.(type) {\n\tcase *object.Function:\n\t\t// A deferred function call creates its own scope, enclosed by the function's definition environment.\n\t\textendedEnv := object.NewEnclosedEnvironment(fn.Env)\n\t\te.extendFunctionEnv(extendedEnv, fn, deferred.Args, nil)\t// typeArgs are nil for defers for now.\n\n\t\t// Use the function's own file scope for evaluation.\n\t\tevalFScope := fscope\n\t\tif fn.FScope != nil {\n\t\t\tevalFScope = fn.FScope\n\t\t}\n\t\tevaluated = e.Eval(fn.Body, extendedEnv, evalFScope)\n\n\tcase *object.BoundMethod:\n\t\textendedEnv := e.extendMethodEnv(fn, deferred.Args)\n\t\tevalFScope := fscope\n\t\tif fn.Fn.FScope != nil {\n\t\t\tevalFScope = fn.Fn.FScope\n\t\t}\n\t\tevaluated = e.Eval(fn.Fn.Body, extendedEnv, evalFScope)\n\n\tcase *object.Builtin:\n\t\t// Builtins run in the context of the *defer statement's* environment.\n\t\te.BuiltinContext.Env = deferred.Env\n\t\te.BuiltinContext.FScope = fscope\n\t\tevaluated = fn.Fn(&e.BuiltinContext, deferred.Pos, deferred.Args...)\n\n\tdefault:\n\t\t// This should have been caught when the defer was created, but as a safeguard:\n\t\te.currentPanic = &object.Panic{Value: e.newError(deferred.Pos, \"not a function: %s\", deferred.Fn.Type())}\n\t\treturn\n\t}\n\n\t// If the deferred function itself panics, it replaces the current panic.\n\tif p, isPanic := evaluated.(*object.Panic); isPanic {\n\t\te.currentPanic = p\n\t}\n\t// Other return values (return, break, continue, error) are ignored in a deferred call.\n}\n\nfunc (e *Evaluator) unwrapReturnValue(obj object.Object) object.Object {\n\tif returnValue, ok := obj.(*object.ReturnValue); ok {\n\t\treturn returnValue.Value\n\t}\n\treturn obj\n}\n\nfunc (e *Evaluator) instantiateTypeAlias(pos token.Pos, alias *object.TypeAlias, typeArgs []object.Object) object.Object {\n\tif alias.TypeParams == nil || len(alias.TypeParams.List) == 0 {\n\t\treturn e.newError(pos, \"type %s is not generic\", alias.Name.Name)\n\t}\n\n\tif len(alias.TypeParams.List) != len(typeArgs) {\n\t\treturn e.newError(pos, \"wrong number of type arguments for %s: got %d, want %d\", alias.Name.Name, len(typeArgs), len(alias.TypeParams.List))\n\t}\n\n\t// Create a new environment for evaluating the underlying type expression.\n\t// This environment is enclosed by the one where the alias was defined.\n\tevalEnv := object.NewEnclosedEnvironment(alias.Env)\n\n\t// Bind the type parameters (e.g., T, K) to the provided type arguments (e.g., int, string).\n\tfor i, param := range alias.TypeParams.List {\n\t\tfor _, paramName := range param.Names {\n\t\t\tevalEnv.SetType(paramName.Name, typeArgs[i])\n\t\t}\n\t}\n\n\t// Evaluate the underlying type expression (e.g., `[]T`) in the new environment.\n\t// The result will be the concrete type object (e.g., an Array object).\n\t// We pass fscope as nil because type resolution within the alias should\n\t// be self-contained within its definition environment.\n\treturn e.Eval(alias.Underlying, evalEnv, nil)\n}\n\nfunc (e *Evaluator) resolveType(typeObj object.Object, env *object.Environment, fscope *object.FileScope) object.Object {\n\talias, ok := typeObj.(*object.TypeAlias)\n\tif !ok {\n\t\treturn typeObj\t// Not an alias, return as is.\n\t}\n\n\t// 1. Check cache\n\tif alias.ResolvedType != nil {\n\t\treturn alias.ResolvedType\n\t}\n\n\t// It is an alias, so we need to resolve it.\n\t// Keep track of the top-level alias name to name anonymous structs.\n\toriginalName := alias.Name\n\tcurrentAlias := alias\n\n\t// Loop to resolve nested aliases (e.g., type A = B; type B = C; type C = int)\n\tfor {\n\t\tif currentAlias.TypeParams != nil && len(currentAlias.TypeParams.List) > 0 {\n\t\t\treturn e.newError(currentAlias.Name.Pos(), \"cannot use generic type %s without instantiation\", currentAlias.Name.Name)\n\t\t}\n\n\t\t// Evaluate the underlying type of the current alias.\n\t\tresolved := e.Eval(currentAlias.Underlying, currentAlias.Env, fscope)\n\t\tif isError(resolved) {\n\t\t\treturn resolved\n\t\t}\n\n\t\t// Check if the resolved type is another alias.\n\t\tnextAlias, isAlias := resolved.(*object.TypeAlias)\n\t\tif !isAlias {\n\t\t\t// Resolution finished. `resolved` is the base type object.\n\t\t\t// If it's a struct def that was defined anonymously, give it the original alias's name.\n\t\t\tif sd, ok := resolved.(*object.StructDefinition); ok {\n\t\t\t\tif sd.Name == nil {\n\t\t\t\t\tsd.Name = originalName\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 2. Write to cache before returning\n\t\t\talias.ResolvedType = resolved\n\t\t\treturn resolved\n\t\t}\n\t\t// Continue the loop with the next alias in the chain.\n\t\tcurrentAlias = nextAlias\n\t}\n}\n\nfunc (e *Evaluator) evalBranchStmt(bs *ast.BranchStmt, env *object.Environment, fscope *object.FileScope) object.Object {\n\tif bs.Label != nil {\n\t\treturn e.newError(bs.Pos(), \"labels are not supported\")\n\t}\n\tswitch bs.Tok {\n\tcase token.BREAK:\n\t\treturn object.BREAK\n\tcase token.CONTINUE:\n\t\treturn object.CONTINUE\n\tdefault:\n\t\treturn e.newError(bs.Pos(), \"unsupported branch statement: %s\", bs.Tok)\n\t}\n}\n\n// EvalToplevel orchestrates the two-pass evaluation for a set of declarations\n// from one or more files.\nfunc (e *Evaluator) EvalToplevel(decls []object.DeclWithScope, env *object.Environment) object.Object {\n\t// Pass 1: Register all types and functions first.\n\t// This pass does not evaluate any variable or constant initializers.\n\tvarDecls, constDecls := e.registerDecls(decls, env)\n\n\t// Pass 2: Evaluate the initializers for variables and constants.\n\t// Now that all functions and types are known, these initializers can refer to them.\n\tresult := e.evalInitializers(append(varDecls, constDecls...), env)\n\tif isError(result) {\n\t\treturn result\n\t}\n\n\treturn result\n}\n\n// registerDecls is the first pass of the evaluation. It scans for all top-level\n// type and function declarations and adds them to the environment. It returns\n// slices of the variable and constant declarations to be processed in the second pass.\nfunc (e *Evaluator) registerDecls(decls []object.DeclWithScope, env *object.Environment) (varDecls, constDecls []object.DeclWithScope) {\n\tfor _, item := range decls {\n\t\tswitch d := item.Decl.(type) {\n\t\tcase *ast.FuncDecl:\n\t\t\t// Just register the function definition. The body will be evaluated on call.\n\t\t\t// The existing Eval logic for FuncDecl is sufficient for this pass.\n\t\t\te.Eval(d, env, item.Scope)\n\t\tcase *ast.GenDecl:\n\t\t\tswitch d.Tok {\n\t\t\tcase token.TYPE, token.IMPORT:\n\t\t\t\t// Register type and import definitions.\n\t\t\t\t// The existing Eval logic for these GenDecls is sufficient.\n\t\t\t\te.Eval(d, env, item.Scope)\n\t\t\tcase token.VAR:\n\t\t\t\tvarDecls = append(varDecls, item)\n\t\t\tcase token.CONST:\n\t\t\t\tconstDecls = append(constDecls, item)\n\t\t\t}\n\t\t}\n\t}\n\treturn varDecls, constDecls\n}\n\n// evalInitializers is the second pass of the evaluation. It evaluates the\n// expressions for all variable and constant declarations.\nfunc (e *Evaluator) evalInitializers(decls []object.DeclWithScope, env *object.Environment) object.Object {\n\tvar result object.Object\n\tfor _, item := range decls {\n\t\t// The existing Eval logic for VAR and CONST GenDecls performs the initialization.\n\t\tresult = e.Eval(item.Decl, env, item.Scope)\n\t\tif isError(result) {\n\t\t\treturn result\n\t\t}\n\t}\n\treturn result\n}\n\nfunc (e *Evaluator) evalTypeConversion(call *ast.CallExpr, typeObj object.Object, args []object.Object) object.Object {\n\tif len(args) != 1 {\n\t\treturn e.newError(call.Pos(), \"wrong number of arguments for type conversion: got=%d, want=1\", len(args))\n\t}\n\targ := args[0]\n\n\tswitch t := typeObj.(type) {\n\tcase *object.PointerType:\n\t\tif arg == object.NIL {\n\t\t\treturn &object.TypedNil{TypeObject: t}\n\t\t}\n\t\treturn e.newError(call.Pos(), \"cannot convert non-nil value to pointer type %s\", typeObj.Inspect())\n\tcase *object.ArrayType:\n\t\t// Handle []byte(\"a string\")\n\t\teltType, ok := t.ElementType.(*object.Type)\n\t\tif !ok || eltType.Name != \"byte\" {\n\t\t\treturn e.newError(call.Pos(), \"unsupported array type conversion to %s\", typeObj.Inspect())\n\t\t}\n\n\t\tstr, ok := arg.(*object.String)\n\t\tif !ok {\n\t\t\treturn e.newError(call.Pos(), \"cannot convert %s to type %s\", arg.Type(), typeObj.Inspect())\n\t\t}\n\n\t\tbytes := []byte(str.Value)\n\t\telements := make([]object.Object, len(bytes))\n\t\tfor i, b := range bytes {\n\t\t\telements[i] = &object.Integer{Value: int64(b)}\n\t\t}\n\t\treturn &object.Array{Elements: elements}\n\n\tcase *object.Type:\n\t\ttypeName := t.Name\n\t\tswitch typeName {\n\t\tcase \"int\", \"uint\", \"uint64\":\t// For now, treat uint as int.\n\t\t\tswitch input := arg.(type) {\n\t\t\tcase *object.Integer:\n\t\t\t\treturn input\t// It's already an integer, no-op.\n\t\t\tcase *object.Float:\n\t\t\t\treturn &object.Integer{Value: int64(input.Value)}\n\t\t\tdefault:\n\t\t\t\treturn e.newError(call.Pos(), \"cannot convert %s to type %s\", arg.Type(), typeName)\n\t\t\t}\n\t\tcase \"string\":\n\t\t\t// Handle string([]byte{...})\n\t\t\tif arr, ok := arg.(*object.Array); ok {\n\t\t\t\tbytes := make([]byte, len(arr.Elements))\n\t\t\t\tfor i, el := range arr.Elements {\n\t\t\t\t\tinteger, ok := el.(*object.Integer)\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn e.newError(call.Pos(), \"cannot convert non-integer element in array to byte for string conversion\")\n\t\t\t\t\t}\n\t\t\t\t\tif integer.Value < 0 || integer.Value > 255 {\n\t\t\t\t\t\treturn e.newError(call.Pos(), \"byte value out of range for string conversion: %d\", integer.Value)\n\t\t\t\t\t}\n\t\t\t\t\tbytes[i] = byte(integer.Value)\n\t\t\t\t}\n\t\t\t\treturn &object.String{Value: string(bytes)}\n\t\t\t}\n\n\t\t\t// In a real implementation, you might convert integers, etc.\n\t\t\t// For now, we only support string(string) which is a no-op.\n\t\t\tif str, ok := arg.(*object.String); ok {\n\t\t\t\treturn str\n\t\t\t}\n\t\t\treturn e.newError(call.Pos(), \"cannot convert %s to type string\", arg.Type())\n\t\tdefault:\n\t\t\treturn e.newError(call.Pos(), \"unsupported type conversion: %s\", typeName)\n\t\t}\n\n\tdefault:\n\t\treturn e.newError(call.Pos(), \"invalid type for conversion: %s\", typeObj.Type())\n\t}\n}\n\n// evalFuncType evaluates an ast.FuncType node and returns an object.FuncType.\nfunc (e *Evaluator) evalFuncType(n *ast.FuncType, env *object.Environment, fscope *object.FileScope) object.Object {\n\tparams := []object.Object{}\n\tif n.Params != nil {\n\t\tfor _, p := range n.Params.List {\n\t\t\tpType := e.Eval(p.Type, env, fscope)\n\t\t\tif isError(pType) {\n\t\t\t\treturn pType\n\t\t\t}\n\t\t\t// For `func(a, b int)`, there are two names but one type.\n\t\t\tif len(p.Names) > 0 {\n\t\t\t\tfor i := 0; i < len(p.Names); i++ {\n\t\t\t\t\tparams = append(params, pType)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// For `func(int)`, there are no names, but one type.\n\t\t\t\tparams = append(params, pType)\n\t\t\t}\n\t\t}\n\t}\n\n\tresults := []object.Object{}\n\tif n.Results != nil {\n\t\tfor _, r := range n.Results.List {\n\t\t\trType := e.Eval(r.Type, env, fscope)\n\t\t\tif isError(rType) {\n\t\t\t\treturn rType\n\t\t\t}\n\t\t\tif len(r.Names) > 0 {\n\t\t\t\tfor i := 0; i < len(r.Names); i++ {\n\t\t\t\t\tresults = append(results, rType)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresults = append(results, rType)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn &object.FuncType{Parameters: params, Results: results}\n}\n\n// flattenTypeUnion takes a type expression from an interface definition and flattens it\n// into a list of individual type expressions. This is used to handle union types\n// like `int | string | MyType`. The AST represents this as a binary tree of `|` operations.\nfunc (e *Evaluator) flattenTypeUnion(expr ast.Expr) []ast.Expr {\n\tif be, ok := expr.(*ast.BinaryExpr); ok && be.Op == token.OR {\n\t\t// It's a union, so recursively flatten both sides.\n\t\tleft := e.flattenTypeUnion(be.X)\n\t\tright := e.flattenTypeUnion(be.Y)\n\t\treturn append(left, right...)\n\t}\n\t// It's a single type, not a union.\n\treturn []ast.Expr{expr}\n}\n\nfunc (e *Evaluator) evalProgram(program *ast.File, env *object.Environment, fscope *object.FileScope) object.Object {\n\t// Use the new two-pass evaluation for the program's declarations.\n\tvar decls []object.DeclWithScope\n\tfor _, decl := range program.Decls {\n\t\tdecls = append(decls, object.DeclWithScope{Decl: decl, Scope: fscope})\n\t}\n\tresult := e.EvalToplevel(decls, env)\n\tif isError(result) {\n\t\treturn result\n\t}\n\n\t// After all declarations are processed, find and execute the main function.\n\tmainObj, ok := env.Get(\"main\")\n\tif !ok {\n\t\treturn object.NIL\t// No main function, not an error\n\t}\n\n\tmainFn, ok := mainObj.(*object.Function)\n\tif !ok {\n\t\treturn e.newError(program.Pos(), \"main is not a function, but %s\", mainObj.Type())\n\t}\n\n\t// Call the main function with no arguments.\n\treturn e.applyFunction(nil, mainFn, []object.Object{}, env, fscope)\n}\n\nfunc (e *Evaluator) Eval(node ast.Node, env *object.Environment, fscope *object.FileScope) object.Object {\n\tswitch n := node.(type) {\n\t// Statements\n\tcase *ast.File:\n\t\treturn e.evalProgram(n, env, fscope)\n\tcase *ast.BlockStmt:\n\t\treturn e.evalBlockStatement(n, env, fscope)\n\tcase *ast.ExprStmt:\n\t\treturn e.Eval(n.X, env, fscope)\n\tcase *ast.IfStmt:\n\t\treturn e.evalIfElseExpression(n, env, fscope)\n\tcase *ast.SwitchStmt:\n\t\treturn e.evalSwitchStmt(n, env, fscope)\n\tcase *ast.ForStmt:\n\t\treturn e.evalForStmt(n, env, fscope)\n\tcase *ast.RangeStmt:\n\t\treturn e.evalForRangeStmt(n, env, fscope)\n\tcase *ast.BranchStmt:\n\t\treturn e.evalBranchStmt(n, env, fscope)\n\tcase *ast.DeclStmt:\n\t\treturn e.Eval(n.Decl, env, fscope)\n\tcase *ast.FuncDecl:\n\t\t// Regular function declaration\n\t\tif n.Recv == nil {\n\t\t\tfn := &object.Function{\n\t\t\t\tName:\t\tn.Name,\n\t\t\t\tTypeParams:\tn.Type.TypeParams,\n\t\t\t\tParameters:\tn.Type.Params,\n\t\t\t\tResults:\tn.Type.Results,\n\t\t\t\tBody:\t\tn.Body,\n\t\t\t\tEnv:\t\tenv,\n\t\t\t}\n\t\t\tenv.Set(n.Name.Name, fn)\n\t\t\treturn nil\n\t\t}\n\n\t\t// Method declaration\n\t\tif len(n.Recv.List) != 1 {\n\t\t\treturn e.newError(n.Pos(), \"method receiver must have exactly one argument\")\n\t\t}\n\t\trecvField := n.Recv.List[0]\n\n\t\tvar typeName string\n\t\tswitch recvType := recvField.Type.(type) {\n\t\tcase *ast.Ident:\n\t\t\ttypeName = recvType.Name\n\t\tcase *ast.StarExpr:\n\t\t\tif ident, ok := recvType.X.(*ast.Ident); ok {\n\t\t\t\ttypeName = ident.Name\n\t\t\t} else {\n\t\t\t\treturn e.newError(recvType.Pos(), \"invalid receiver type: expected identifier\")\n\t\t\t}\n\t\tcase *ast.IndexExpr:\t// For generic receivers like `Box[T]`\n\t\t\tif ident, ok := recvType.X.(*ast.Ident); ok {\n\t\t\t\ttypeName = ident.Name\n\t\t\t} else {\n\t\t\t\treturn e.newError(recvType.Pos(), \"invalid receiver type: expected identifier for generic type base\")\n\t\t\t}\n\t\tdefault:\n\t\t\treturn e.newError(recvField.Type.Pos(), \"unsupported receiver type: %T\", recvField.Type)\n\t\t}\n\n\t\tobj, ok := env.Get(typeName)\n\t\tif !ok {\n\t\t\treturn e.newError(n.Pos(), \"type '%s' not defined for method receiver\", typeName)\n\t\t}\n\n\t\t// Resolve the type in case it's an alias.\n\t\tresolvedObj := e.resolveType(obj, env, fscope)\n\t\tif isError(resolvedObj) {\n\t\t\treturn resolvedObj\n\t\t}\n\n\t\tdef, ok := resolvedObj.(*object.StructDefinition)\n\t\tif !ok {\n\t\t\treturn e.newError(n.Pos(), \"receiver for method '%s' is not a struct type\", n.Name.Name)\n\t\t}\n\n\t\tfn := &object.Function{\n\t\t\tName:\t\tn.Name,\n\t\t\tRecv:\t\tn.Recv,\t// Store receiver info\n\t\t\tTypeParams:\tn.Type.TypeParams,\n\t\t\tParameters:\tn.Type.Params,\n\t\t\tResults:\tn.Type.Results,\n\t\t\tBody:\t\tn.Body,\n\t\t\tEnv:\t\tenv,\t// The environment where the method is defined.\n\t\t}\n\n\t\tdef.Methods[n.Name.Name] = fn\n\t\treturn nil\n\tcase *ast.DeferStmt:\n\t\tif len(e.callStack) == 0 {\n\t\t\treturn e.newError(n.Pos(), \"defer is not allowed outside of a function\")\n\t\t}\n\n\t\t// Evaluate the function to be deferred.\n\t\tfn := e.Eval(n.Call.Fun, env, fscope)\n\t\tif isError(fn) {\n\t\t\treturn fn\n\t\t}\n\n\t\t// Evaluate the arguments at the time of the defer statement.\n\t\targs := e.evalExpressions(n.Call.Args, env, fscope, nil)\n\t\tif len(args) > 0 && isError(args[len(args)-1]) {\n\t\t\treturn args[len(args)-1]\n\t\t}\n\n\t\tdeferred := &object.DeferredCall{\n\t\t\tFn:\tfn,\n\t\t\tArgs:\targs,\n\t\t\tEnv:\tenv,\n\t\t\tPos:\tn.Pos(),\n\t\t}\n\n\t\tcurrentFrame := e.callStack[len(e.callStack)-1]\n\t\tcurrentFrame.Defers = append(currentFrame.Defers, deferred)\n\t\treturn nil\n\tcase *ast.ReturnStmt:\n\t\t// Check if we are in a function with named returns.\n\t\tvar currentFrame *object.CallFrame\n\t\tif len(e.callStack) > 0 {\n\t\t\tcurrentFrame = e.callStack[len(e.callStack)-1]\n\t\t}\n\n\t\t// --- Logic for Named Returns ---\n\t\tif currentFrame != nil && currentFrame.NamedReturns != nil {\n\t\t\tif len(n.Results) > 0 {\n\t\t\t\t// Case: return x, y\n\t\t\t\t// Evaluate the expressions and assign them to the named return variables.\n\t\t\t\tvalues := e.evalExpressions(n.Results, env, fscope, nil)\n\t\t\t\tif len(values) == 1 && isError(values[0]) {\n\t\t\t\t\treturn values[0]\n\t\t\t\t}\n\n\t\t\t\t// This is a simplified assignment; it assumes the number of return\n\t\t\t\t// expressions matches the number of named return variables.\n\t\t\t\ti := 0\n\t\t\t\tfor _, field := range currentFrame.Fn.Results.List {\n\t\t\t\t\tfor _, name := range field.Names {\n\t\t\t\t\t\tif i < len(values) {\n\t\t\t\t\t\t\t// Use Assign, not Set, to update the existing variable.\n\t\t\t\t\t\t\tcurrentFrame.NamedReturns.Assign(name.Name, values[i])\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// For both `return x` and a bare `return`, we signal to `applyFunction`\n\t\t\t// that it needs to construct the final return value from the environment.\n\t\t\t// We use a ReturnValue with a nil `Value` for this.\n\t\t\treturn &object.ReturnValue{Value: nil}\n\t\t}\n\n\t\t// --- Logic for Regular (non-named) Returns ---\n\t\tif len(n.Results) == 0 {\n\t\t\treturn &object.ReturnValue{Value: object.NIL}\n\t\t}\n\t\tif len(n.Results) == 1 {\n\t\t\tval := e.Eval(n.Results[0], env, fscope)\n\t\t\tif isError(val) {\n\t\t\t\treturn val\n\t\t\t}\n\t\t\t// If the expression is already a return value (e.g. from a function call),\n\t\t\t// don't wrap it again.\n\t\t\tif ret, ok := val.(*object.ReturnValue); ok {\n\t\t\t\treturn ret\n\t\t\t}\n\t\t\treturn &object.ReturnValue{Value: val}\n\t\t}\n\t\tresults := e.evalExpressions(n.Results, env, fscope, nil)\n\t\tif len(results) > 0 && isError(results[0]) {\n\t\t\treturn results[0]\n\t\t}\n\t\treturn &object.ReturnValue{Value: &object.Tuple{Elements: results}}\n\tcase *ast.GenDecl:\n\t\treturn e.evalGenDecl(n, env, fscope)\n\tcase *ast.AssignStmt:\n\t\treturn e.evalAssignStmt(n, env, fscope)\n\tcase *ast.IncDecStmt:\n\t\treturn e.evalIncDecStmt(n, env, fscope)\n\n\t// Expressions\n\tcase *ast.ParenExpr:\n\t\treturn e.Eval(n.X, env, fscope)\n\n\tcase *ast.IndexExpr:\t// MyType[T]\n\t\tleft := e.Eval(n.X, env, fscope)\n\t\tif isError(left) {\n\t\t\treturn left\n\t\t}\n\t\tindex := e.Eval(n.Index, env, fscope)\n\t\tif isError(index) {\n\t\t\treturn index\n\t\t}\n\t\t// Check if this is a generic type instantiation or a regular index access.\n\t\tswitch l := left.(type) {\n\t\tcase *object.StructDefinition, *object.Function:\n\t\t\treturn &object.InstantiatedType{GenericDef: left, TypeArgs: []object.Object{index}}\n\t\tcase *object.TypeAlias:\n\t\t\t// This is a generic alias instantiation, e.g., List[int]\n\t\t\treturn e.instantiateTypeAlias(n.Pos(), l, []object.Object{index})\n\t\tdefault:\n\t\t\t// It's a regular index expression like array[i].\n\t\t\treturn e.evalIndexExpression(n, left, index)\n\t\t}\n\n\tcase *ast.IndexListExpr:\t// MyType[T, K]\n\t\tleft := e.Eval(n.X, env, fscope)\n\t\tif isError(left) {\n\t\t\treturn left\n\t\t}\n\t\tindices := e.evalExpressions(n.Indices, env, fscope, nil)\n\t\tif len(indices) == 1 && isError(indices[0]) {\n\t\t\treturn indices[0]\n\t\t}\n\t\tswitch l := left.(type) {\n\t\tcase *object.StructDefinition, *object.Function:\n\t\t\treturn &object.InstantiatedType{GenericDef: left, TypeArgs: indices}\n\t\tcase *object.TypeAlias:\n\t\t\t// This is a generic alias instantiation, e.g., Pair[int, string]\n\t\t\treturn e.instantiateTypeAlias(n.Pos(), l, indices)\n\t\tdefault:\n\t\t\treturn e.newError(n.Pos(), \"index list operator not supported for %s\", left.Type())\n\t\t}\n\n\tcase *ast.FuncLit:\n\t\treturn &object.Function{\n\t\t\tParameters:\tn.Type.Params,\n\t\t\tBody:\t\tn.Body,\n\t\t\tEnv:\t\tenv,\n\t\t}\n\tcase *ast.CallExpr:\n\t\t// Special form handling: check if the function is a registered special form.\n\t\t// Special forms receive the AST of their arguments without evaluation.\n\t\tswitch fun := n.Fun.(type) {\n\t\tcase *ast.Ident:\n\t\t\tif sf, isSpecial := e.specialForms[fun.Name]; isSpecial {\n\t\t\t\treturn sf.Fn(e, fscope, n.Pos(), n.Args)\n\t\t\t}\n\t\tcase *ast.SelectorExpr:\n\t\t\tif pkgIdent, ok := fun.X.(*ast.Ident); ok && fscope != nil {\n\t\t\t\tif path, isAlias := fscope.Aliases[pkgIdent.Name]; isAlias {\n\t\t\t\t\tqualifiedName := fmt.Sprintf(\"%s.%s\", path, fun.Sel.Name)\n\t\t\t\t\tif sf, isSpecial := e.specialForms[qualifiedName]; isSpecial {\n\t\t\t\t\t\treturn sf.Fn(e, fscope, n.Pos(), n.Args)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction := e.Eval(n.Fun, env, fscope)\n\t\tif isError(function) {\n\t\t\treturn function\n\t\t}\n\n\t\t// Check if the \"function\" is actually a type, indicating a type conversion.\n\t\tswitch function.(type) {\n\t\tcase *object.Type, *object.ArrayType, *object.PointerType:\n\t\t\targs := e.evalExpressions(n.Args, env, fscope, nil)\n\t\t\tif len(args) == 1 && isError(args[0]) {\n\t\t\t\treturn args[0]\n\t\t\t}\n\t\t\treturn e.evalTypeConversion(n, function, args)\n\t\t}\n\n\t\t// Check if the resolved function is a special form object. This can happen\n\t\t// if it was passed as an argument or returned from another function.\n\t\tif sf, ok := function.(*SpecialForm); ok {\n\t\t\treturn sf.Fn(e, fscope, n.Pos(), n.Args)\n\t\t}\n\n\t\tvar args []object.Object\n\t\tif n.Ellipsis.IsValid() {\n\t\t\t// Handle variadic call, e.g., fn(a, b, c...)\n\t\t\tif len(n.Args) == 0 {\n\t\t\t\treturn e.newError(n.Pos(), \"cannot use ... on empty argument list\")\n\t\t\t}\n\n\t\t\t// Evaluate all but the last argument normally.\n\t\t\targs = e.evalExpressions(n.Args[:len(n.Args)-1], env, fscope, nil)\n\t\t\tif len(args) > 0 && isError(args[len(args)-1]) {\n\t\t\t\treturn args[len(args)-1]\n\t\t\t}\n\n\t\t\t// Evaluate the last argument, which is the slice to be spread.\n\t\t\tlastArg := n.Args[len(n.Args)-1]\n\t\t\tsliceToSpread := e.Eval(lastArg, env, fscope)\n\t\t\tif isError(sliceToSpread) {\n\t\t\t\treturn sliceToSpread\n\t\t\t}\n\n\t\t\t// Spread the elements of the slice.\n\t\t\tswitch s := sliceToSpread.(type) {\n\t\t\tcase *object.Array:\n\t\t\t\targs = append(args, s.Elements...)\n\t\t\tdefault:\n\t\t\t\treturn e.newError(lastArg.Pos(), \"cannot use ... on non-slice type %s\", sliceToSpread.Type())\n\t\t\t}\n\t\t} else {\n\t\t\t// Regular function call.\n\t\t\targs = e.evalExpressions(n.Args, env, fscope, nil)\n\t\t\tif len(args) > 0 && isError(args[len(args)-1]) {\n\t\t\t\treturn args[len(args)-1]\n\t\t\t}\n\t\t}\n\t\treturn e.applyFunction(n, function, args, env, fscope)\n\tcase *ast.SelectorExpr:\n\t\treturn e.evalSelectorExpr(n, env, fscope)\n\tcase *ast.CompositeLit:\n\t\treturn e.evalCompositeLit(n, env, fscope)\n\tcase *ast.StarExpr:\n\t\t// This can be a dereference operation (*p) or a pointer type (*T).\n\t\t// We can differentiate based on the context, but a simpler heuristic\n\t\t// is to check if the operand evaluates to a type object.\n\t\toperand := e.Eval(n.X, env, fscope)\n\t\tif isError(operand) {\n\t\t\treturn operand\n\t\t}\n\t\tswitch operand.(type) {\n\t\tcase *object.StructDefinition, *object.Type, *object.PointerType, *object.ArrayType, *object.MapType, *object.InterfaceDefinition:\n\t\t\t// It's a pointer type expression, like `*MyStruct`.\n\t\t\treturn &object.PointerType{ElementType: operand}\n\t\tdefault:\n\t\t\t// It's a dereference operation, like `*myPointer`.\n\t\t\treturn e.evalDereferenceExpression(n, operand)\n\t\t}\n\tcase *ast.UnaryExpr:\n\t\t// Special case for address-of operator, as we don't evaluate the operand.\n\t\tif n.Op == token.AND {\n\t\t\treturn e.evalAddressOfExpression(n, env, fscope)\n\t\t}\n\t\tright := e.Eval(n.X, env, fscope)\n\t\tif isError(right) {\n\t\t\treturn right\n\t\t}\n\t\treturn e.evalPrefixExpression(n, n.Op.String(), right)\n\tcase *ast.BinaryExpr:\n\t\t// Handle logical AND and OR with short-circuiting.\n\t\tswitch n.Op {\n\t\tcase token.LAND:\n\t\t\tleft := e.Eval(n.X, env, fscope)\n\t\t\tif isError(left) {\n\t\t\t\treturn left\n\t\t\t}\n\t\t\tif !e.isTruthy(left) {\n\t\t\t\treturn object.FALSE\n\t\t\t}\n\t\t\tright := e.Eval(n.Y, env, fscope)\n\t\t\tif isError(right) {\n\t\t\t\treturn right\n\t\t\t}\n\t\t\treturn e.nativeBoolToBooleanObject(e.isTruthy(right))\n\t\tcase token.LOR:\n\t\t\tleft := e.Eval(n.X, env, fscope)\n\t\t\tif isError(left) {\n\t\t\t\treturn left\n\t\t\t}\n\t\t\tif e.isTruthy(left) {\n\t\t\t\treturn object.TRUE\n\t\t\t}\n\t\t\tright := e.Eval(n.Y, env, fscope)\n\t\t\tif isError(right) {\n\t\t\t\treturn right\n\t\t\t}\n\t\t\treturn e.nativeBoolToBooleanObject(e.isTruthy(right))\n\t\t}\n\n\t\t// Fallback to standard infix evaluation for other operators.\n\t\tleft := e.Eval(n.X, env, fscope)\n\t\tif isError(left) {\n\t\t\treturn left\n\t\t}\n\t\tright := e.Eval(n.Y, env, fscope)\n\t\tif isError(right) {\n\t\t\treturn right\n\t\t}\n\t\treturn e.evalInfixExpression(n, n.Op.String(), left, right)\n\n\t// Literals\n\tcase *ast.Ident:\n\t\treturn e.evalIdent(n, env, fscope)\n\tcase *ast.BasicLit:\n\t\treturn e.evalBasicLit(n)\n\n\t// Type Expressions\n\tcase *ast.FuncType:\n\t\treturn e.evalFuncType(n, env, fscope)\n\tcase *ast.ArrayType:\n\t\teltType := e.Eval(n.Elt, env, fscope)\n\t\tif isError(eltType) {\n\t\t\treturn eltType\n\t\t}\n\t\treturn &object.ArrayType{ElementType: eltType}\n\tcase *ast.MapType:\n\t\tkeyType := e.Eval(n.Key, env, fscope)\n\t\tif isError(keyType) {\n\t\t\treturn keyType\n\t\t}\n\t\tvalueType := e.Eval(n.Value, env, fscope)\n\t\tif isError(valueType) {\n\t\t\treturn valueType\n\t\t}\n\t\treturn &object.MapType{KeyType: keyType, ValueType: valueType}\n\tcase *ast.StructType:\n\t\t// This creates a definition for an anonymous struct type.\n\t\treturn &object.StructDefinition{\n\t\t\tName:\t\tnil,\t// Anonymous\n\t\t\tFields:\t\tn.Fields.List,\n\t\t\tMethods:\tmake(map[string]*object.Function),\n\t\t}\n\tcase *ast.SliceExpr:\n\t\treturn e.evalSliceExpr(n, env, fscope)\n\t}\n\n\treturn e.newError(node.Pos(), \"evaluation not implemented for %T\", node)\n}\n\nfunc (e *Evaluator) evalSliceExpr(node *ast.SliceExpr, env *object.Environment, fscope *object.FileScope) object.Object {\n\tleft := e.Eval(node.X, env, fscope)\n\tif isError(left) {\n\t\treturn left\n\t}\n\n\tevalIndex := func(expr ast.Expr, defaultVal int64) (int64, object.Object) {\n\t\tif expr == nil {\n\t\t\treturn defaultVal, nil\n\t\t}\n\t\tval := e.Eval(expr, env, fscope)\n\t\tif isError(val) {\n\t\t\treturn 0, val\n\t\t}\n\t\tintVal, ok := val.(*object.Integer)\n\t\tif !ok {\n\t\t\treturn 0, e.newError(expr.Pos(), \"slice index must be an integer, got %s\", val.Type())\n\t\t}\n\t\treturn intVal.Value, nil\n\t}\n\n\tswitch l := left.(type) {\n\tcase *object.Array:\n\t\tcapacity := int64(cap(l.Elements))\n\t\tlength := int64(len(l.Elements))\n\n\t\tvar err object.Object\n\t\tvar low, high, max int64\n\n\t\tlow, err = evalIndex(node.Low, 0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\thigh, err = evalIndex(node.High, length)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif node.Slice3 {\n\t\t\tmax, err = evalIndex(node.Max, capacity)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tmax = capacity\n\t\t}\n\n\t\tif low < 0 || high < low || max < high || high > capacity || max > capacity {\n\t\t\treturn e.newError(node.Pos(), \"slice bounds out of range: low=%d, high=%d, max=%d, cap=%d\", low, high, max, capacity)\n\t\t}\n\n\t\t// The Go equivalent of a[low:high:max] is (a[low:max])[:high-low]\n\t\tsubSlice := l.Elements[low:max]\n\t\tfinalSlice := subSlice[:high-low]\n\t\treturn &object.Array{Elements: finalSlice}\n\n\tcase *object.String:\n\t\tlength := int64(len(l.Value))\n\t\tvar err object.Object\n\t\tvar low, high int64\n\n\t\tlow, err = evalIndex(node.Low, 0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thigh, err = evalIndex(node.High, length)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif node.Slice3 {\n\t\t\treturn e.newError(node.Pos(), \"full slice expression not supported for strings\")\n\t\t}\n\n\t\tif low < 0 || high < low || high > length {\n\t\t\treturn e.newError(node.Pos(), \"slice bounds out of range: low=%d, high=%d, len=%d\", low, high, length)\n\t\t}\n\n\t\treturn &object.String{Value: l.Value[low:high]}\n\n\tcase *object.GoValue:\n\t\tv := l.Value\n\t\tswitch v.Kind() {\n\t\tcase reflect.Array, reflect.Slice:\n\t\t\t// Slicing an array requires it to be addressable. If it's not,\n\t\t\t// we create a new addressable array and copy the data.\n\t\t\tif v.Kind() == reflect.Array && !v.CanAddr() {\n\t\t\t\tnewVal := reflect.New(v.Type()).Elem()\n\t\t\t\treflect.Copy(newVal, v)\n\t\t\t\tv = newVal\n\t\t\t}\n\n\t\t\tcapacity := int64(v.Cap())\n\t\t\tlength := int64(v.Len())\n\n\t\t\tvar err object.Object\n\t\t\tvar low, high, max int64\n\n\t\t\tlow, err = evalIndex(node.Low, 0)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\thigh, err = evalIndex(node.High, length)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif node.Slice3 {\n\t\t\t\tmax, err = evalIndex(node.Max, capacity)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmax = -1\t// Use -1 to indicate not set, similar to reflect.Value.Slice3\n\t\t\t}\n\n\t\t\t// Basic bounds check\n\t\t\tif low < 0 || high < low || high > length {\n\t\t\t\treturn e.newError(node.Pos(), \"slice bounds out of range: low=%d, high=%d, len=%d\", low, high, length)\n\t\t\t}\n\t\t\tif node.Slice3 {\n\t\t\t\tif max < high {\n\t\t\t\t\treturn e.newError(node.Pos(), \"slice bounds out of range: max < high\")\n\t\t\t\t}\n\t\t\t\treturn &object.GoValue{Value: v.Slice3(int(low), int(high), int(max))}\n\t\t\t}\n\t\t\treturn &object.GoValue{Value: v.Slice(int(low), int(high))}\n\t\tdefault:\n\t\t\treturn e.newError(node.Pos(), \"slice operator not supported for GO_VALUE of kind %s\", v.Kind())\n\t\t}\n\n\tdefault:\n\t\treturn e.newError(node.Pos(), \"slice operator not supported for %s\", left.Type())\n\t}\n}\n\nfunc (e *Evaluator) evalGenDecl(n *ast.GenDecl, env *object.Environment, fscope *object.FileScope) object.Object {\n\tvar lastVal object.Object\n\tswitch n.Tok {\n\tcase token.IMPORT:\n\t\tif fscope == nil {\n\t\t\treturn e.newError(n.Pos(), \"imports are only allowed at the file level\")\n\t\t}\n\t\tfor _, spec := range n.Specs {\n\t\t\timportSpec := spec.(*ast.ImportSpec)\n\t\t\tpath, err := strconv.Unquote(importSpec.Path.Value)\n\t\t\tif err != nil {\n\t\t\t\treturn e.newError(importSpec.Path.Pos(), \"invalid import path: %v\", err)\n\t\t\t}\n\n\t\t\tvar alias string\n\t\t\tif importSpec.Name != nil {\n\t\t\t\talias = importSpec.Name.Name\n\t\t\t} else {\n\t\t\t\tparts := strings.Split(path, \"/\")\n\t\t\t\talias = parts[len(parts)-1]\n\t\t\t}\n\n\t\t\tswitch alias {\n\t\t\tcase \"_\":\n\t\t\t\t// Blank imports are ignored for now, but we could run init functions here in the future.\n\t\t\t\tcontinue\n\t\t\tcase \".\":\n\t\t\t\t// Dot import: add the path to the file scope's dot import list.\n\t\t\t\tfscope.DotImports = append(fscope.DotImports, path)\n\t\t\tdefault:\n\t\t\t\t// Regular import with an alias.\n\t\t\t\tfscope.Aliases[alias] = path\n\t\t\t}\n\t\t}\n\t\treturn nil\n\n\tcase token.CONST, token.VAR:\n\t\tvar lastValues []ast.Expr\t// For const value carry-over\n\t\tfor iotaValue, spec := range n.Specs {\n\t\t\tvalueSpec := spec.(*ast.ValueSpec)\n\n\t\t\t// Handle multi-return assignment: var a, b = f()\n\t\t\tif n.Tok == token.VAR && len(valueSpec.Names) > 1 && len(valueSpec.Values) == 1 {\n\t\t\t\tval := e.Eval(valueSpec.Values[0], env, fscope)\n\t\t\t\tif isError(val) {\n\t\t\t\t\treturn val\n\t\t\t\t}\n\t\t\t\ttuple, ok := val.(*object.Tuple)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn e.newError(valueSpec.Pos(), \"multi-value assignment requires a multi-value return, but got %s\", val.Type())\n\t\t\t\t}\n\t\t\t\tif len(valueSpec.Names) != len(tuple.Elements) {\n\t\t\t\t\treturn e.newError(valueSpec.Pos(), \"assignment mismatch: %d variables but %d values\", len(valueSpec.Names), len(tuple.Elements))\n\t\t\t\t}\n\t\t\t\tfor i, name := range valueSpec.Names {\n\t\t\t\t\tif name.Name == \"_\" {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tenv.Set(name.Name, tuple.Elements[i])\n\t\t\t\t}\n\t\t\t\tcontinue\t// Move to the next spec in the GenDecl\n\t\t\t}\n\n\t\t\t// Handle const value carry-over\n\t\t\tif n.Tok == token.CONST {\n\t\t\t\tif len(valueSpec.Values) == 0 {\n\t\t\t\t\tvalueSpec.Values = lastValues\n\t\t\t\t} else {\n\t\t\t\t\tlastValues = valueSpec.Values\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor i, name := range valueSpec.Names {\n\t\t\t\t// Handle explicit type declarations, especially for interfaces.\n\t\t\t\tif valueSpec.Type != nil {\n\t\t\t\t\ttypeObj := e.Eval(valueSpec.Type, env, fscope)\n\t\t\t\t\tif isError(typeObj) {\n\t\t\t\t\t\treturn typeObj\n\t\t\t\t\t}\n\n\t\t\t\t\tif ifaceDef, ok := typeObj.(*object.InterfaceDefinition); ok {\n\t\t\t\t\t\tvar concreteVal object.Object\n\t\t\t\t\t\tif len(valueSpec.Values) > i {\n\t\t\t\t\t\t\t// Case: var w Writer = myStruct\n\t\t\t\t\t\t\tconcreteVal = e.Eval(valueSpec.Values[i], env, fscope)\n\t\t\t\t\t\t\tif isError(concreteVal) {\n\t\t\t\t\t\t\t\treturn concreteVal\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// A nil value can be assigned to an interface without checks.\n\t\t\t\t\t\t\tif concreteVal.Type() != object.NIL_OBJ {\n\t\t\t\t\t\t\t\tif errObj := e.checkImplements(valueSpec.Pos(), concreteVal, ifaceDef); errObj != nil {\n\t\t\t\t\t\t\t\t\treturn errObj\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Case: var w Writer (no initial value)\n\t\t\t\t\t\t\tconcreteVal = object.NIL\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Wrap the concrete value in an InterfaceInstance to track its interface type.\n\t\t\t\t\t\tenv.Set(name.Name, &object.InterfaceInstance{Def: ifaceDef, Value: concreteVal})\n\t\t\t\t\t\tcontinue\t// Move to the next name in the spec (e.g., var a, b, c Writer)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Fallback to existing logic for non-interface types or untyped vars.\n\t\t\t\tvar val object.Object\n\t\t\t\tif len(valueSpec.Values) > i {\n\t\t\t\t\t// Create a temporary environment for iota evaluation.\n\t\t\t\t\tiotaEnv := object.NewEnclosedEnvironment(env)\n\t\t\t\t\tiotaEnv.SetConstant(\"iota\", &object.Integer{Value: int64(iotaValue)})\n\t\t\t\t\tval = e.Eval(valueSpec.Values[i], iotaEnv, fscope)\n\t\t\t\t} else if n.Tok == token.VAR {\n\t\t\t\t\t// Handle `var x T` (no initial value)\n\t\t\t\t\tif valueSpec.Type != nil {\n\t\t\t\t\t\ttypeObj := e.Eval(valueSpec.Type, env, fscope)\n\t\t\t\t\t\tif isError(typeObj) {\n\t\t\t\t\t\t\treturn typeObj\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolvedType := e.resolveType(typeObj, env, fscope)\n\t\t\t\t\t\tif isError(resolvedType) {\n\t\t\t\t\t\t\treturn resolvedType\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tswitch rt := resolvedType.(type) {\n\t\t\t\t\t\tcase *object.GoType:\n\t\t\t\t\t\t\t// The type is a registered Go type. Instantiate its zero value.\n\t\t\t\t\t\t\t// We create a pointer to a new value, then get the element it points to.\n\t\t\t\t\t\t\t// This ensures the resulting reflect.Value is addressable, which is crucial\n\t\t\t\t\t\t\t// for calling pointer-receiver methods on it later.\n\t\t\t\t\t\t\tptr := reflect.New(rt.GoType)\n\t\t\t\t\t\t\tval = &object.GoValue{Value: ptr.Elem()}\n\t\t\t\t\t\tcase *object.StructDefinition:\n\t\t\t\t\t\t\t// It's a minigo-defined struct, so initialize a zero-valued instance.\n\t\t\t\t\t\t\tinstance := &object.StructInstance{Def: rt, Fields: make(map[string]object.Object)}\n\t\t\t\t\t\t\tfor _, field := range rt.Fields {\n\t\t\t\t\t\t\t\tzeroVal := e.getZeroValueForType(field.Type, env, fscope)\n\t\t\t\t\t\t\t\tfor _, name := range field.Names {\n\t\t\t\t\t\t\t\t\tinstance.Fields[name.Name] = zeroVal\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tval = instance\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// For other types (slices, maps, pointers, interfaces), the zero value is a typed nil.\n\t\t\t\t\t\t\tval = &object.TypedNil{TypeObject: resolvedType}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tval = object.NIL\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn e.newError(name.Pos(), \"missing value in declaration for %s\", name.Name)\n\t\t\t\t}\n\n\t\t\t\tif isError(val) {\n\t\t\t\t\treturn val\n\t\t\t\t}\n\n\t\t\t\tif n.Tok == token.CONST {\n\t\t\t\t\tenv.SetConstant(name.Name, val)\n\t\t\t\t} else {\t// token.VAR\n\t\t\t\t\tif fn, ok := val.(*object.Function); ok {\n\t\t\t\t\t\tfn.Name = name\n\t\t\t\t\t}\n\t\t\t\t\tenv.Set(name.Name, val)\n\t\t\t\t}\n\t\t\t\tlastVal = val\n\t\t\t}\n\t\t}\n\t\treturn lastVal\n\n\tcase token.TYPE:\n\t\tfor _, spec := range n.Specs {\n\t\t\ttypeSpec, ok := spec.(*ast.TypeSpec)\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Check for type alias: type T = some.Type\n\t\t\tif typeSpec.Assign.IsValid() {\n\t\t\t\talias := &object.TypeAlias{\n\t\t\t\t\tName:\t\ttypeSpec.Name,\n\t\t\t\t\tTypeParams:\ttypeSpec.TypeParams,\n\t\t\t\t\tUnderlying:\ttypeSpec.Type,\n\t\t\t\t\tEnv:\t\tenv,\n\t\t\t\t}\n\t\t\t\tenv.Set(typeSpec.Name.Name, alias)\n\t\t\t} else {\n\t\t\t\t// Regular type definition: type T struct { ... }\n\t\t\t\tswitch t := typeSpec.Type.(type) {\n\t\t\t\tcase *ast.StructType:\n\t\t\t\t\tfieldTags := make(map[string]string)\n\t\t\t\t\tfor _, field := range t.Fields.List {\n\t\t\t\t\t\tif field.Tag == nil {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttag := reflect.StructTag(strings.Trim(field.Tag.Value, \"`\"))\n\t\t\t\t\t\tjsonTag := tag.Get(\"json\")\n\n\t\t\t\t\t\t// The parser gives us one Field with multiple Names for `X, Y int`.\n\t\t\t\t\t\tfor _, name := range field.Names {\n\t\t\t\t\t\t\tfieldTags[name.Name] = jsonTag\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdef := &object.StructDefinition{\n\t\t\t\t\t\tName:\t\ttypeSpec.Name,\n\t\t\t\t\t\tTypeParams:\ttypeSpec.TypeParams,\n\t\t\t\t\t\tFields:\t\tt.Fields.List,\n\t\t\t\t\t\tMethods:\tmake(map[string]*object.Function),\n\t\t\t\t\t\tFieldTags:\tfieldTags,\n\t\t\t\t\t\tEnv:\t\tenv,\n\t\t\t\t\t}\n\t\t\t\t\tenv.Set(typeSpec.Name.Name, def)\n\n\t\t\t\tcase *ast.InterfaceType:\n\t\t\t\t\tdef := &object.InterfaceDefinition{\n\t\t\t\t\t\tName:\t\ttypeSpec.Name,\n\t\t\t\t\t\tMethods:\t&ast.FieldList{},\t// Initialize as empty\n\t\t\t\t\t\tTypeList:\tmake([]ast.Expr, 0),\n\t\t\t\t\t}\n\n\t\t\t\t\tif t.Methods != nil {\n\t\t\t\t\t\tfor _, field := range t.Methods.List {\n\t\t\t\t\t\t\t// A field with names is a method.\n\t\t\t\t\t\t\tif len(field.Names) > 0 {\n\t\t\t\t\t\t\t\tdef.Methods.List = append(def.Methods.List, field)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// A field without names is a type constraint (embedded type or union).\n\t\t\t\t\t\t\t\tdef.TypeList = append(def.TypeList, e.flattenTypeUnion(field.Type)...)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tenv.Set(typeSpec.Name.Name, def)\n\n\t\t\t\tdefault:\n\t\t\t\t\t// This could be a type definition like `type MyInt int`.\n\t\t\t\t\t// We can treat this as a non-generic type alias for now.\n\t\t\t\t\talias := &object.TypeAlias{\n\t\t\t\t\t\tName:\t\ttypeSpec.Name,\n\t\t\t\t\t\tTypeParams:\tnil,\t// No type params for this form\n\t\t\t\t\t\tUnderlying:\ttypeSpec.Type,\n\t\t\t\t\t\tEnv:\t\tenv,\n\t\t\t\t\t}\n\t\t\t\t\tenv.Set(typeSpec.Name.Name, alias)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\treturn nil\t// Should be unreachable\n}\n\nfunc (e *Evaluator) evalIndexExpression(node ast.Node, left, index object.Object) object.Object {\n\t// Handle generic type instantiation, e.g. MyType[int]\n\tswitch l := left.(type) {\n\tcase *object.StructDefinition:\n\t\tif l.TypeParams != nil && len(l.TypeParams.List) > 0 {\n\t\t\t// TODO: This currently only handles a single type argument.\n\t\t\t// To support multiple (e.g., map[K, V]), we would need to inspect\n\t\t\t// the original ast.IndexListExpr.\n\t\t\treturn &object.InstantiatedType{GenericDef: l, TypeArgs: []object.Object{index}}\n\t\t}\n\tcase *object.Function:\n\t\tif l.TypeParams != nil && len(l.TypeParams.List) > 0 {\n\t\t\treturn &object.InstantiatedType{GenericDef: l, TypeArgs: []object.Object{index}}\n\t\t}\n\t}\n\n\tswitch {\n\tcase left.Type() == object.ARRAY_OBJ:\n\t\treturn e.evalArrayIndexExpression(node, left, index)\n\tcase left.Type() == object.STRING_OBJ:\n\t\treturn e.evalStringIndexExpression(node, left, index)\n\tcase left.Type() == object.MAP_OBJ:\n\t\treturn e.evalMapIndexExpression(node, left, index)\n\tcase left.Type() == object.GO_VALUE_OBJ:\n\t\treturn e.evalGoValueIndexExpression(node, left.(*object.GoValue), index)\n\tdefault:\n\t\treturn e.newError(node.Pos(), \"index operator not supported for %s\", left.Type())\n\t}\n}\n\nfunc (e *Evaluator) evalGoValueIndexExpression(node ast.Node, goVal *object.GoValue, index object.Object) object.Object {\n\tval := goVal.Value\n\tswitch val.Kind() {\n\tcase reflect.Slice, reflect.Array:\n\t\tintIndex, ok := index.(*object.Integer)\n\t\tif !ok {\n\t\t\treturn e.newError(node.Pos(), \"index into Go slice/array must be an integer, got %s\", index.Type())\n\t\t}\n\t\tidx := int(intIndex.Value)\n\t\tif idx < 0 || idx >= val.Len() {\n\t\t\t// Panic for out-of-bounds access, similar to Go.\n\t\t\treturn e.newError(node.Pos(), \"runtime error: index out of range [%d] with length %d\", idx, val.Len())\n\t\t}\n\t\tresultVal := val.Index(idx)\n\t\treturn e.nativeToValue(resultVal)\n\n\tcase reflect.Map:\n\t\t// Convert the minigo index object to a reflect.Value that can be used as a map key.\n\t\tkeyVal, err := e.objectToReflectValue(index, val.Type().Key())\n\t\tif err != nil {\n\t\t\treturn e.newError(node.Pos(), \"cannot use %s as type %s in map index: %v\", index.Type(), val.Type().Key(), err)\n\t\t}\n\t\tresultVal := val.MapIndex(keyVal)\n\t\tif !resultVal.IsValid() {\n\t\t\t// Key not found in map. Go would return the zero value.\n\t\t\t// Let's return NIL for simplicity, as creating a zero value for any type is complex.\n\t\t\treturn object.NIL\n\t\t}\n\t\treturn e.nativeToValue(resultVal)\n\n\tdefault:\n\t\treturn e.newError(node.Pos(), \"index operator not supported for Go value of type %s\", val.Kind())\n\t}\n}\n\nfunc (e *Evaluator) evalArrayIndexExpression(node ast.Node, array, index object.Object) object.Object {\n\tarrayObject := array.(*object.Array)\n\tidx, ok := index.(*object.Integer)\n\tif !ok {\n\t\treturn e.newError(node.Pos(), \"index into array is not an integer\")\n\t}\n\n\ti := idx.Value\n\tmax := int64(len(arrayObject.Elements) - 1)\n\n\tif i < 0 || i > max {\n\t\treturn object.NIL\t// Go returns nil for out-of-bounds access, so we do too.\n\t}\n\n\treturn arrayObject.Elements[i]\n}\n\nfunc (e *Evaluator) evalStringIndexExpression(node ast.Node, str, index object.Object) object.Object {\n\tstringObject := str.(*object.String)\n\tidx, ok := index.(*object.Integer)\n\tif !ok {\n\t\treturn e.newError(node.Pos(), \"index into string is not an integer\")\n\t}\n\n\ti := idx.Value\n\tmax := int64(len(stringObject.Value) - 1)\n\n\tif i < 0 || i > max {\n\t\treturn e.newError(node.Pos(), \"runtime error: index out of range [%d] with length %d\", i, len(stringObject.Value))\n\t}\n\n\treturn &object.Integer{Value: int64(stringObject.Value[i])}\n}\n\nfunc (e *Evaluator) evalMapIndexExpression(node ast.Node, m, index object.Object) object.Object {\n\tmapObject := m.(*object.Map)\n\n\tkey, ok := index.(object.Hashable)\n\tif !ok {\n\t\treturn e.newError(node.Pos(), \"unusable as map key: %s\", index.Type())\n\t}\n\n\tpair, ok := mapObject.Pairs[key.HashKey()]\n\tif !ok {\n\t\treturn object.NIL\n\t}\n\n\treturn pair.Value\n}\n\nfunc (e *Evaluator) evalIncDecStmt(n *ast.IncDecStmt, env *object.Environment, fscope *object.FileScope) object.Object {\n\t// 1. Evaluate the left-hand side to get the current value.\n\t// This re-uses the logic for evaluating identifiers, selectors, etc.\n\tcurrentVal := e.Eval(n.X, env, fscope)\n\tif isError(currentVal) {\n\t\treturn currentVal\n\t}\n\n\t// 2. Ensure the value is an integer.\n\tinteger, ok := currentVal.(*object.Integer)\n\tif !ok {\n\t\treturn e.newError(n.Pos(), \"cannot %s non-integer type %s\", n.Tok, currentVal.Type())\n\t}\n\n\t// 3. Calculate the new value.\n\tvar newVal int64\n\tif n.Tok == token.INC {\n\t\tnewVal = integer.Value + 1\n\t} else {\n\t\tnewVal = integer.Value - 1\n\t}\n\n\t// 4. Assign the new value back to the variable.\n\t// We can reuse the `assignValue` logic.\n\treturn e.assignValue(n.X, &object.Integer{Value: newVal}, env, fscope)\n}\n\nfunc (e *Evaluator) evalAssignStmt(n *ast.AssignStmt, env *object.Environment, fscope *object.FileScope) object.Object {\n\tif len(n.Lhs) == 1 && len(n.Rhs) == 1 {\n\t\t// Single assignment: a = 1 or a := 1\n\t\treturn e.evalSingleAssign(n, env, fscope)\n\t}\n\n\tif len(n.Lhs) > 1 && len(n.Rhs) == 1 {\n\t\t// Multi-assignment from single function call: a, b = f() or a, b := f()\n\t\treturn e.evalMultiAssign(n, env, fscope)\n\t}\n\n\tif len(n.Lhs) > 0 && len(n.Lhs) == len(n.Rhs) {\n\t\t// Destructuring assignment: a, b = 1, 2 or a, b = b, a\n\t\treturn e.evalDestructuringAssign(n, env, fscope)\n\t}\n\n\treturn e.newError(n.Pos(), \"assignment mismatch: %d variables but %d values\", len(n.Lhs), len(n.Rhs))\n}\n\nfunc (e *Evaluator) evalDestructuringAssign(n *ast.AssignStmt, env *object.Environment, fscope *object.FileScope) object.Object {\n\t// Evaluate all RHS expressions first and store them temporarily.\n\t// This is crucial for `a, b = b, a` to work correctly.\n\tvalues := make([]object.Object, len(n.Rhs))\n\tfor i, rhsExpr := range n.Rhs {\n\t\tval := e.Eval(rhsExpr, env, fscope)\n\t\tif isError(val) {\n\t\t\treturn val\n\t\t}\n\t\tvalues[i] = val\n\t}\n\n\t// Now, assign the evaluated values to the LHS variables.\n\tswitch n.Tok {\n\tcase token.ASSIGN:\t// =\n\t\tfor i, lhsExpr := range n.Lhs {\n\t\t\tres := e.assignValue(lhsExpr, values[i], env, fscope)\n\t\t\tif isError(res) {\n\t\t\t\treturn res\n\t\t\t}\n\t\t}\n\tcase token.DEFINE:\t// :=\n\t\tfor i, lhsExpr := range n.Lhs {\n\t\t\tident, ok := lhsExpr.(*ast.Ident)\n\t\t\tif !ok {\n\t\t\t\treturn e.newError(lhsExpr.Pos(), \"non-identifier on left side of :=\")\n\t\t\t}\n\t\t\tif ident.Name == \"_\" {\n\t\t\t\tcontinue\t// Discard value\n\t\t\t}\n\t\t\tif fn, ok := values[i].(*object.Function); ok {\n\t\t\t\tfn.Name = ident\n\t\t\t}\n\t\t\tenv.Set(ident.Name, values[i])\n\t\t}\n\tdefault:\n\t\treturn e.newError(n.Pos(), \"unsupported assignment token: %s\", n.Tok)\n\t}\n\n\treturn nil\t// Assignment statements don't produce a value.\n}\n\nfunc (e *Evaluator) evalSingleAssign(n *ast.AssignStmt, env *object.Environment, fscope *object.FileScope) object.Object {\n\tval := e.Eval(n.Rhs[0], env, fscope)\n\tif isError(val) {\n\t\treturn val\n\t}\n\n\t// Unwrap return value from function calls\n\tif ret, ok := val.(*object.ReturnValue); ok {\n\t\tval = ret.Value\n\t}\n\n\t// Calling a multi-return function in a single-value context is an error.\n\tif _, ok := val.(*object.Tuple); ok {\n\t\treturn e.newError(n.Rhs[0].Pos(), \"multi-value function call in single-value context\")\n\t}\n\n\tlhs := n.Lhs[0]\n\tswitch n.Tok {\n\tcase token.ASSIGN:\t// =\n\t\treturn e.assignValue(lhs, val, env, fscope)\n\tcase token.DEFINE:\t// :=\n\t\tident, ok := lhs.(*ast.Ident)\n\t\tif !ok {\n\t\t\treturn e.newError(lhs.Pos(), \"non-identifier on left side of :=\")\n\t\t}\n\t\tif ident.Name == \"_\" {\n\t\t\treturn nil\t// Assignment to blank identifier does nothing.\n\t\t}\n\t\tif fn, ok := val.(*object.Function); ok {\n\t\t\tfn.Name = ident\n\t\t}\n\t\tenv.Set(ident.Name, val)\n\t\treturn val\n\tdefault:\n\t\treturn e.newError(n.Pos(), \"unsupported assignment token: %s\", n.Tok)\n\t}\n}\n\nfunc (e *Evaluator) assignValue(lhs ast.Expr, val object.Object, env *object.Environment, fscope *object.FileScope) object.Object {\n\tswitch lhsNode := lhs.(type) {\n\tcase *ast.Ident:\n\t\tif lhsNode.Name == \"_\" {\n\t\t\treturn nil\t// Assignment to blank identifier does nothing.\n\t\t}\n\t\t// Check if we are assigning to an existing interface variable.\n\t\tif existing, ok := env.Get(lhsNode.Name); ok {\n\t\t\tif iface, isIface := existing.(*object.InterfaceInstance); isIface {\n\t\t\t\t// Allow assigning nil to any interface.\n\t\t\t\tif val.Type() != object.NIL_OBJ {\n\t\t\t\t\t// Check if the new value implements the interface.\n\t\t\t\t\tif errObj := e.checkImplements(lhsNode.Pos(), val, iface.Def); errObj != nil {\n\t\t\t\t\t\treturn errObj\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Update the concrete value held by the interface.\n\t\t\t\tiface.Value = val\n\t\t\t\treturn val\n\t\t\t}\n\t\t}\n\n\t\tif _, ok := env.GetConstant(lhsNode.Name); ok {\n\t\t\treturn e.newError(lhsNode.Pos(), \"cannot assign to constant %s\", lhsNode.Name)\n\t\t}\n\t\tif !env.Assign(lhsNode.Name, val) {\n\t\t\treturn e.newError(lhsNode.Pos(), \"undeclared variable: %s\", lhsNode.Name)\n\t\t}\n\t\treturn val\n\tcase *ast.SelectorExpr:\n\t\tobj := e.Eval(lhsNode.X, env, fscope)\n\t\tif isError(obj) {\n\t\t\treturn obj\n\t\t}\n\n\t\tvar underlying object.Object\n\t\tif ptr, isPtr := obj.(*object.Pointer); isPtr {\n\t\t\tif ptr.Element == nil || *ptr.Element == nil {\n\t\t\t\treturn e.newError(lhsNode.Pos(), \"nil pointer dereference on assignment\")\n\t\t\t}\n\t\t\tunderlying = *ptr.Element\n\t\t} else {\n\t\t\tunderlying = obj\n\t\t}\n\n\t\tswitch base := underlying.(type) {\n\t\tcase *object.StructInstance:\n\t\t\tbase.Fields[lhsNode.Sel.Name] = val\n\t\t\treturn val\n\t\tcase *object.GoValue:\n\t\t\tstructVal := base.Value\n\t\t\tif structVal.Kind() == reflect.Ptr {\n\t\t\t\tstructVal = structVal.Elem()\n\t\t\t}\n\t\t\tif structVal.Kind() != reflect.Struct {\n\t\t\t\treturn e.newError(lhsNode.Pos(), \"assignment to field of non-struct Go value\")\n\t\t\t}\n\t\t\tfield := structVal.FieldByName(lhsNode.Sel.Name)\n\t\t\tif !field.IsValid() {\n\t\t\t\treturn e.newError(lhsNode.Pos(), \"no such field: %s in type %s\", lhsNode.Sel.Name, structVal.Type())\n\t\t\t}\n\t\t\tif !field.CanSet() {\n\t\t\t\treturn e.newError(lhsNode.Pos(), \"cannot set field %s\", lhsNode.Sel.Name)\n\t\t\t}\n\t\t\tgoVal, err := e.objectToReflectValue(val, field.Type())\n\t\t\tif err != nil {\n\t\t\t\treturn e.newError(lhsNode.Pos(), \"type mismatch on assignment: %v\", err)\n\t\t\t}\n\t\t\tfield.Set(goVal)\n\t\t\treturn val\n\t\tdefault:\n\t\t\treturn e.newError(lhsNode.Pos(), \"assignment to non-struct or non-Go-value field\")\n\t\t}\n\tcase *ast.StarExpr:\n\t\tptrObj := e.Eval(lhsNode.X, env, fscope)\n\t\tif isError(ptrObj) {\n\t\t\treturn ptrObj\n\t\t}\n\t\tptr, ok := ptrObj.(*object.Pointer)\n\t\tif !ok {\n\t\t\treturn e.newError(lhsNode.Pos(), \"cannot assign to non-pointer\")\n\t\t}\n\t\t*ptr.Element = val\n\t\treturn val\n\tcase *ast.IndexExpr:\n\t\tindexed := e.Eval(lhsNode.X, env, fscope)\n\t\tif isError(indexed) {\n\t\t\treturn indexed\n\t\t}\n\t\tindex := e.Eval(lhsNode.Index, env, fscope)\n\t\tif isError(index) {\n\t\t\treturn index\n\t\t}\n\t\tswitch obj := indexed.(type) {\n\t\tcase *object.Array:\n\t\t\tintIndex, ok := index.(*object.Integer)\n\t\t\tif !ok {\n\t\t\t\treturn e.newError(lhsNode.Index.Pos(), \"index into array is not an integer\")\n\t\t\t}\n\t\t\tidx := intIndex.Value\n\t\t\tif idx < 0 || idx >= int64(len(obj.Elements)) {\n\t\t\t\treturn e.newError(lhsNode.Index.Pos(), \"runtime error: index out of range\")\n\t\t\t}\n\t\t\tobj.Elements[idx] = val\n\t\t\treturn val\n\t\tcase *object.Map:\n\t\t\tkey, ok := index.(object.Hashable)\n\t\t\tif !ok {\n\t\t\t\treturn e.newError(lhsNode.Index.Pos(), \"unusable as map key: %s\", index.Type())\n\t\t\t}\n\t\t\thashKey := key.HashKey()\n\t\t\tobj.Pairs[hashKey] = object.MapPair{Key: index, Value: val}\n\t\t\treturn val\n\t\tdefault:\n\t\t\treturn e.newError(lhsNode.X.Pos(), \"index assignment not supported for %s\", indexed.Type())\n\t\t}\n\tdefault:\n\t\treturn e.newError(lhs.Pos(), \"unsupported assignment target\")\n\t}\n}\n\nfunc (e *Evaluator) evalMultiAssign(n *ast.AssignStmt, env *object.Environment, fscope *object.FileScope) object.Object {\n\tval := e.Eval(n.Rhs[0], env, fscope)\n\tif isError(val) {\n\t\treturn val\n\t}\n\n\t// Unwrap return value from function calls\n\tif ret, ok := val.(*object.ReturnValue); ok {\n\t\tval = ret.Value\n\t}\n\n\ttuple, ok := val.(*object.Tuple)\n\tif !ok {\n\t\treturn e.newError(n.Rhs[0].Pos(), \"multi-assignment requires a multi-value return, got %s\", val.Type())\n\t}\n\n\tif len(n.Lhs) != len(tuple.Elements) {\n\t\treturn e.newError(n.Pos(), \"assignment mismatch: %d variables but %d values\", len(n.Lhs), len(tuple.Elements))\n\t}\n\n\tswitch n.Tok {\n\tcase token.ASSIGN:\t// =\n\t\tfor i, lhsExpr := range n.Lhs {\n\t\t\tres := e.assignValue(lhsExpr, tuple.Elements[i], env, fscope)\n\t\t\tif isError(res) {\n\t\t\t\treturn res\n\t\t\t}\n\t\t}\n\tcase token.DEFINE:\t// :=\n\t\tfor i, lhsExpr := range n.Lhs {\n\t\t\tident, ok := lhsExpr.(*ast.Ident)\n\t\t\tif !ok {\n\t\t\t\treturn e.newError(lhsExpr.Pos(), \"non-identifier on left side of :=\")\n\t\t\t}\n\t\t\tenv.Set(ident.Name, tuple.Elements[i])\n\t\t}\n\tdefault:\n\t\treturn e.newError(n.Pos(), \"unsupported assignment token: %s\", n.Tok)\n\t}\n\n\treturn nil\t// Assignment statements don't produce a value.\n}\n\n// findFieldInStruct recursively searches for a field within a struct instance,\n// including its embedded structs. It returns the found object and a boolean indicating success.\nfunc (e *Evaluator) findFieldInStruct(instance *object.StructInstance, fieldName string) (object.Object, bool) {\n\t// 1. Check direct fields first. This handles explicit fields and field shadowing.\n\tif val, ok := instance.Fields[fieldName]; ok {\n\t\treturn val, true\n\t}\n\n\t// 2. If not found, search in embedded structs in the order they are defined.\n\tfor _, fieldDef := range instance.Def.Fields {\n\t\t// An embedded field in Go's AST has no names.\n\t\tif len(fieldDef.Names) == 0 {\n\t\t\t// The type of the embedded field, e.g., 'T' in 'struct { T }'.\n\t\t\t// We need to resolve this type name to an object in the instance's fields.\n\t\t\tvar typeName string\n\t\t\tswitch t := fieldDef.Type.(type) {\n\t\t\tcase *ast.Ident:\n\t\t\t\ttypeName = t.Name\n\t\t\t// Handle pointer to embedded type, e.g., struct { *T }\n\t\t\tcase *ast.StarExpr:\n\t\t\t\tif ident, ok := t.X.(*ast.Ident); ok {\n\t\t\t\t\ttypeName = ident.Name\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif typeName == \"\" {\n\t\t\t\tcontinue\t// Unsupported embedded field type, e.g. struct { io.Writer }\n\t\t\t}\n\n\t\t\t// The embedded struct instance is stored in the parent's fields map under its type name.\n\t\t\tembeddedObj, ok := instance.Fields[typeName]\n\t\t\tif !ok {\n\t\t\t\t// This can happen if an embedded field is nil.\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Automatically dereference if the embedded field is a pointer.\n\t\t\tif ptr, ok := embeddedObj.(*object.Pointer); ok {\n\t\t\t\t// If the pointer is nil, we can't search its fields.\n\t\t\t\tif ptr.Element == nil || *ptr.Element == nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tembeddedObj = *ptr.Element\n\t\t\t}\n\n\t\t\tembeddedInstance, ok := embeddedObj.(*object.StructInstance)\n\t\t\tif !ok {\n\t\t\t\t// It's an embedded field but the value isn't a struct instance.\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Recursively search in the embedded struct.\n\t\t\tif val, found := e.findFieldInStruct(embeddedInstance, fieldName); found {\n\t\t\t\treturn val, true\t// First match wins.\n\t\t\t}\n\t\t}\n\t}\n\n\t// 3. Field not found anywhere in the hierarchy.\n\treturn nil, false\n}\n\n// constantInfoToObject converts a goscan.ConstantInfo into a minigo object.\n// This is how the interpreter understands constants from imported Go packages.\nfunc (e *Evaluator) constantInfoToObject(c *goscan.ConstantInfo) (object.Object, error) {\n\t// HACK: Workaround for computed constants like `math/bits.UintSize` that go-scan\n\t// may not be able to resolve statically.\n\tif c.Name == \"UintSize\" && c.Value == \"\" {\n\t\t// For the interpreter's purposes, we can assume a 64-bit architecture.\n\t\treturn &object.Integer{Value: 64}, nil\n\t}\n\n\t// simplified inference\n\tif c.ConstVal != nil {\n\t\tswitch c.ConstVal.Kind() {\n\t\tcase constant.String:\n\t\t\t// Prefer RawValue if available, as it's the direct unquoted value.\n\t\t\tif c.RawValue != \"\" {\n\t\t\t\treturn &object.String{Value: c.RawValue}, nil\n\t\t\t}\n\t\t\t// Fallback to unquoting the literal representation from .Value\n\t\t\tif s, err := strconv.Unquote(c.Value); err == nil {\n\t\t\t\treturn &object.String{Value: s}, nil\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"could not unquote string constant value: %q\", c.Value)\n\t\tcase constant.Int:\n\t\t\tif i, err := strconv.ParseInt(c.Value, 0, 64); err == nil {\n\t\t\t\treturn &object.Integer{Value: i}, nil\n\t\t\t}\n\t\tcase constant.Bool:\n\t\t\tif b, err := strconv.ParseBool(c.Value); err == nil {\n\t\t\t\treturn e.nativeBoolToBooleanObject(b), nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback for when c.ConstVal is nil or for unhandled kinds.\n\t// This maintains the old behavior.\n\tif i, err := strconv.ParseInt(c.Value, 0, 64); err == nil {\n\t\treturn &object.Integer{Value: i}, nil\n\t}\n\tif s, err := strconv.Unquote(c.Value); err == nil {\n\t\treturn &object.String{Value: s}, nil\n\t}\n\tif b, err := strconv.ParseBool(c.Value); err == nil {\n\t\treturn e.nativeBoolToBooleanObject(b), nil\n\t}\n\treturn nil, fmt.Errorf(\"unsupported or malformed constant value: %q\", c.Value)\n}\n\n// findSymbolInPackageInfo searches for a symbol within a pre-loaded PackageInfo.\n// It does not trigger new scans. It returns the found object and a boolean.\n// NOTE: This resolves constants, struct type definitions, and function declarations from AST.\nfunc (e *Evaluator) findSymbolInPackageInfo(pkgInfo *goscan.Package, symbolName string, pkgEnv *object.Environment, fscope *object.FileScope) (object.Object, bool) {\n\t// Check for FFI types first\n\tif t, ok := e.registry.LookupType(pkgInfo.Path, symbolName); ok {\n\t\treturn &object.GoType{GoType: t}, true\n\t}\n\n\t// Look in constants\n\tfor _, c := range pkgInfo.Constants {\n\t\tif c.Name == symbolName {\n\t\t\tobj, err := e.constantInfoToObject(c)\n\t\t\tif err != nil {\n\t\t\t\treturn e.newError(token.NoPos, \"could not convert constant %q: %v\", symbolName, err), true\n\t\t\t}\n\t\t\treturn obj, true\n\t\t}\n\t}\n\n\t// Look in types (for struct definitions)\n\tfor _, t := range pkgInfo.Types {\n\t\tif t.Name == symbolName {\n\t\t\tswitch t.Kind {\n\t\t\tcase goscan.StructKind:\n\t\t\t\t// The Node on TypeInfo is an ast.Spec, which should be a *ast.TypeSpec.\n\t\t\t\ttypeSpec, ok := t.Node.(*ast.TypeSpec)\n\t\t\t\tif !ok {\n\t\t\t\t\tcontinue\t// Should not happen for valid structs\n\t\t\t\t}\n\t\t\t\tstructType, ok := typeSpec.Type.(*ast.StructType)\n\t\t\t\tif !ok {\n\t\t\t\t\tcontinue\t// Should not happen for a StructKind\n\t\t\t\t}\n\n\t\t\t\t// Convert scanner.TypeInfo to object.StructDefinition\n\t\t\t\tdef := &object.StructDefinition{\n\t\t\t\t\tName:\t\ttypeSpec.Name,\n\t\t\t\t\tFields:\t\tstructType.Fields.List,\n\t\t\t\t\tMethods:\tmake(map[string]*object.Function),\n\t\t\t\t\tPkgPath:\tpkgInfo.Path,\n\t\t\t\t\tModulePath:\te.scanner.ModulePath(),\n\t\t\t\t\tModuleDir:\te.scanner.RootDir(),\n\t\t\t\t\tEnv:\t\tpkgEnv,\t// Associate with the package's environment\n\t\t\t\t}\n\n\t\t\t\t// Proactively find and attach all methods for this struct from the same package info.\n\t\t\t\tfor _, f := range pkgInfo.Functions {\n\t\t\t\t\tif f.Receiver != nil {\n\t\t\t\t\t\t// It's a method.\n\t\t\t\t\t\tvar recvTypeName string\n\t\t\t\t\t\trecvType := f.Receiver.Type\n\t\t\t\t\t\tif recvType.IsPointer && recvType.Elem != nil {\n\t\t\t\t\t\t\trecvTypeName = recvType.Elem.Name\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trecvTypeName = recvType.Name\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif recvTypeName == def.Name.Name {\n\t\t\t\t\t\t\t// This method belongs to our struct. Attach it.\n\t\t\t\t\t\t\tmethodFn := &object.Function{\n\t\t\t\t\t\t\t\tName:\t\tf.AstDecl.Name,\n\t\t\t\t\t\t\t\tRecv:\t\tf.AstDecl.Recv,\n\t\t\t\t\t\t\t\tTypeParams:\tf.AstDecl.Type.TypeParams,\n\t\t\t\t\t\t\t\tParameters:\tf.AstDecl.Type.Params,\n\t\t\t\t\t\t\t\tResults:\tf.AstDecl.Type.Results,\n\t\t\t\t\t\t\t\tBody:\t\tf.AstDecl.Body,\n\t\t\t\t\t\t\t\tEnv:\t\tpkgEnv,\t// The package's environment\n\t\t\t\t\t\t\t\tFScope:\t\tfscope,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdef.Methods[f.Name] = methodFn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn def, true\n\n\t\t\tcase goscan.InterfaceKind:\n\t\t\t\ttypeSpec, ok := t.Node.(*ast.TypeSpec)\n\t\t\t\tif !ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tifaceType, ok := typeSpec.Type.(*ast.InterfaceType)\n\t\t\t\tif !ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tdef := &object.InterfaceDefinition{\n\t\t\t\t\tName:\t\ttypeSpec.Name,\n\t\t\t\t\tMethods:\t&ast.FieldList{},\n\t\t\t\t\tTypeList:\tmake([]ast.Expr, 0),\n\t\t\t\t}\n\t\t\t\tif ifaceType.Methods != nil {\n\t\t\t\t\tfor _, field := range ifaceType.Methods.List {\n\t\t\t\t\t\tif len(field.Names) > 0 {\n\t\t\t\t\t\t\tdef.Methods.List = append(def.Methods.List, field)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdef.TypeList = append(def.TypeList, e.flattenTypeUnion(field.Type)...)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn def, true\n\t\t\t}\n\t\t}\n\t}\n\n\t// Look in functions\n\tfor _, f := range pkgInfo.Functions {\n\t\tif f.Name == symbolName {\n\t\t\tif f.AstDecl == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// When resolving a function from source, create a GoSourceFunction\n\t\t\t// that captures the function's metadata and its definition environment.\n\t\t\treturn &object.GoSourceFunction{\n\t\t\t\tFn:\t\tf,\n\t\t\t\tPkgPath:\tpkgInfo.Path,\n\t\t\t\tDefEnv:\t\tpkgEnv,\n\t\t\t\tFScope:\t\tfscope,\n\t\t\t\tModulePath:\te.scanner.ModulePath(),\n\t\t\t\tModuleDir:\te.scanner.RootDir(),\n\t\t\t}, true\n\t\t}\n\t}\n\n\treturn nil, false\n}\n\nfunc (e *Evaluator) updateMiniGoStructFromNative(ctx *object.BuiltinContext, src map[string]any, dst *object.StructInstance, visited map[uintptr]object.Object) object.Object {\n\t// Use pointer address of the destination struct to detect cycles.\n\tdstPtr := reflect.ValueOf(dst).Pointer()\n\tif _, ok := visited[dstPtr]; ok {\n\t\treturn nil\t// Cycle detected\n\t}\n\tvisited[dstPtr] = dst\n\n\t// This map is useful if the minigo struct uses `json` tags.\n\tjsonToFieldName := make(map[string]string)\n\tfor fieldName, tag := range dst.Def.FieldTags {\n\t\ttagName := strings.Split(tag, \",\")[0]\n\t\tif tagName != \"\" && tagName != \"-\" {\n\t\t\tjsonToFieldName[tagName] = fieldName\n\t\t}\n\t}\n\n\tfor jsonKey, nativeValue := range src {\n\t\tfieldName, ok := jsonToFieldName[jsonKey]\n\t\tif !ok {\n\t\t\t// If no tag, default to matching the field name directly (case-insensitive).\n\t\t\t// This is a simplification; Go's json is case-sensitive but we are flexible.\n\t\t\tfound := false\n\t\t\tfor fldName := range dst.Def.FieldTags {\n\t\t\t\tif strings.EqualFold(fldName, jsonKey) {\n\t\t\t\t\tfieldName = fldName\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !found {\n\t\t\t\tfieldName = jsonKey\n\t\t\t}\n\t\t}\n\n\t\tvar astField *ast.Field\n\t\tfor _, f := range dst.Def.Fields {\n\t\t\tfor _, name := range f.Names {\n\t\t\t\tif name.Name == fieldName {\n\t\t\t\t\tastField = f\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif astField != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif astField == nil {\n\t\t\tcontinue\t// Ignore fields in JSON not present in the struct\n\t\t}\n\n\t\t// Resolve the expected type of the minigo struct field.\n\t\t// We must use the FFI call-site environment (ctx.Env) and scope (fscope)\n\t\t// to ensure that imported package types can be resolved correctly.\n\t\texpectedTypeObj := e.resolveType(e.Eval(astField.Type, ctx.Env, ctx.FScope), ctx.Env, ctx.FScope)\n\t\tif isError(expectedTypeObj) {\n\t\t\treturn expectedTypeObj\n\t\t}\n\n\t\tvar newFieldValue object.Object\n\t\tif nativeValue == nil {\n\t\t\tnewFieldValue = object.NIL\n\t\t} else {\n\t\t\tnativeType := reflect.TypeOf(nativeValue)\n\t\t\tvar err error\n\t\t\tnewFieldValue, err = e.convertNativeToMiniGo(nativeValue, nativeType, expectedTypeObj, ctx, visited)\n\t\t\tif err != nil {\n\t\t\t\treturn ctx.NewError(astField.Pos(), \"json: cannot unmarshal %s into Go value of type %s\", nativeType.Kind(), expectedTypeObj.Inspect())\n\t\t\t}\n\t\t}\n\t\tdst.Fields[fieldName] = newFieldValue\n\t}\n\treturn nil\n}\n\n// convertNativeToMiniGo performs the type-checked conversion from a native Go value\n// (from json.Unmarshal) to a minigo object, based on the expected minigo type.\nfunc (e *Evaluator) convertNativeToMiniGo(\n\tnativeValue any,\n\tnativeType reflect.Type,\n\texpectedType object.Object,\n\tctx *object.BuiltinContext,\n\tvisited map[uintptr]object.Object,\n) (object.Object, error) {\n\n\tswitch t := expectedType.(type) {\n\tcase *object.Type:\n\t\tswitch t.Name {\n\t\tcase \"int\", \"int64\", \"int32\", \"int16\", \"int8\":\n\t\t\tif nativeType.Kind() != reflect.Float64 {\n\t\t\t\treturn nil, fmt.Errorf(\"type mismatch\")\n\t\t\t}\n\t\t\treturn &object.Integer{Value: int64(nativeValue.(float64))}, nil\n\t\tcase \"string\":\n\t\t\tif nativeType.Kind() != reflect.String {\n\t\t\t\treturn nil, fmt.Errorf(\"type mismatch\")\n\t\t\t}\n\t\t\treturn &object.String{Value: nativeValue.(string)}, nil\n\t\tcase \"bool\":\n\t\t\tif nativeType.Kind() != reflect.Bool {\n\t\t\t\treturn nil, fmt.Errorf(\"type mismatch\")\n\t\t\t}\n\t\t\treturn e.nativeBoolToBooleanObject(nativeValue.(bool)), nil\n\t\tdefault:\n\t\t\t// For other built-in types, do a simple conversion for now.\n\t\t\treturn e.nativeToValue(reflect.ValueOf(nativeValue)), nil\n\t\t}\n\tcase *object.StructDefinition:\n\t\tnestedMap, ok := nativeValue.(map[string]any)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"type mismatch\")\n\t\t}\n\t\t// The destination field might already have a struct instance, or it could be nil.\n\t\t// We create a new one to be safe and populate it.\n\t\tnestedInstance := &object.StructInstance{Def: t, Fields: make(map[string]object.Object)}\n\t\tif err := e.updateMiniGoStructFromNative(ctx, nestedMap, nestedInstance, visited); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"nested struct update failed\")\n\t\t}\n\t\treturn nestedInstance, nil\n\tcase *object.PointerType:\n\t\tif nestedStructDef, ok := t.ElementType.(*object.StructDefinition); ok {\n\t\t\tnestedMap, isMap := nativeValue.(map[string]any)\n\t\t\tif !isMap {\n\t\t\t\treturn nil, fmt.Errorf(\"type mismatch\")\n\t\t\t}\n\t\t\tnewInstance := &object.StructInstance{Def: nestedStructDef, Fields: make(map[string]object.Object)}\n\t\t\tif err := e.updateMiniGoStructFromNative(ctx, nestedMap, newInstance, visited); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"nested pointer to-struct update failed\")\n\t\t\t}\n\t\t\tvar obj object.Object = newInstance\n\t\t\treturn &object.Pointer{Element: &obj}, nil\n\t\t}\n\t\t// Fallback for other pointer types\n\t\treturn e.nativeToValue(reflect.ValueOf(nativeValue)), nil\n\tdefault:\n\t\t// Fallback for other types (arrays, etc.)\n\t\treturn e.nativeToValue(reflect.ValueOf(nativeValue)), nil\n\t}\n}\n\n// WrapGoFunction is a public method to wrap a native Go function into a minigo object.\nfunc (e *Evaluator) WrapGoFunction(pos token.Pos, funcVal reflect.Value) object.Object {\n\tfuncType := funcVal.Type()\n\treturn &object.Builtin{\n\t\tFn: func(ctx *object.BuiltinContext, callPos token.Pos, args ...object.Object) (ret object.Object) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tpanicValue := &object.String{Value: fmt.Sprintf(\"%v\", r)}\n\t\t\t\t\tret = &object.Panic{Value: panicValue}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tnumIn := funcType.NumIn()\n\t\t\tisVariadic := funcType.IsVariadic()\n\t\t\tif isVariadic {\n\t\t\t\tif len(args) < numIn-1 {\n\t\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments for variadic function: got %d, want at least %d\", len(args), numIn-1)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif len(args) != numIn {\n\t\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments: got %d, want %d\", len(args), numIn)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tin := make([]reflect.Value, len(args))\n\t\t\tvar ptrBridges []*ffibridge.Pointer\n\t\t\tfor i, arg := range args {\n\t\t\t\tvar targetType reflect.Type\n\t\t\t\tif isVariadic && i >= funcType.NumIn()-1 {\n\t\t\t\t\ttargetType = funcType.In(funcType.NumIn() - 1).Elem()\n\t\t\t\t} else {\n\t\t\t\t\ttargetType = funcType.In(i)\n\t\t\t\t}\n\n\t\t\t\tif ptr, isPtr := arg.(*object.Pointer); isPtr && targetType.Kind() == reflect.Interface {\n\t\t\t\t\tvar nativePtr any\n\t\t\t\t\tunderlying := *ptr.Element\n\t\t\t\t\tif _, ok := underlying.(*object.StructInstance); ok {\n\t\t\t\t\t\tvar m map[string]any\n\t\t\t\t\t\tnativePtr = &m\n\t\t\t\t\t} else if underlying == object.NIL {\n\t\t\t\t\t\t// This is the case for `var p Person; Unmarshal(..., &p)` where p starts as nil.\n\t\t\t\t\t\t// The var initialization change should handle this, but as a fallback,\n\t\t\t\t\t\t// we create the map anyway, and the post-call update will populate the struct.\n\t\t\t\t\t\tvar m map[string]any\n\t\t\t\t\t\tnativePtr = &m\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn ctx.NewError(pos, \"passing pointers to Go functions is only supported for struct types, got %s\", underlying.Type())\n\t\t\t\t\t}\n\t\t\t\t\tbridge := &ffibridge.Pointer{Source: ptr, Dest: reflect.ValueOf(nativePtr)}\n\t\t\t\t\tptrBridges = append(ptrBridges, bridge)\n\t\t\t\t\tin[i] = bridge.Dest\n\t\t\t\t} else {\n\t\t\t\t\tval, err := e.objectToReflectValue(arg, targetType)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn ctx.NewError(pos, \"argument %d type mismatch: %v\", i+1, err)\n\t\t\t\t\t}\n\t\t\t\t\tin[i] = val\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresults := funcVal.Call(in)\n\n\t\t\t// After the call, check for in-place modifications to slice arguments.\n\t\t\tfor i, arg := range args {\n\t\t\t\tif arr, ok := arg.(*object.Array); ok {\n\t\t\t\t\t// `in[i]` holds the `reflect.Value` of the Go slice that was passed.\n\t\t\t\t\tgoSlice := in[i]\n\t\t\t\t\tif goSlice.Kind() == reflect.Slice {\n\t\t\t\t\t\t// Copy the (potentially modified) elements from the Go slice\n\t\t\t\t\t\t// back into our minigo Array object.\n\t\t\t\t\t\tfor j := 0; j < goSlice.Len(); j++ {\n\t\t\t\t\t\t\tif j < len(arr.Elements) {\n\t\t\t\t\t\t\t\tgoElement := goSlice.Index(j)\n\t\t\t\t\t\t\t\tobjElement := e.nativeToValue(goElement)\n\t\t\t\t\t\t\t\tarr.Elements[j] = objElement\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor _, bridge := range ptrBridges {\n\t\t\t\tnativeValue := bridge.Dest.Elem().Interface()\n\t\t\t\ttargetObj := *bridge.Source.Element\n\n\t\t\t\tif dst, ok := targetObj.(*object.StructInstance); ok {\n\t\t\t\t\tif src, ok := nativeValue.(map[string]any); ok {\n\t\t\t\t\t\tif errObj := e.updateMiniGoStructFromNative(ctx, src, dst, make(map[uintptr]object.Object)); errObj != nil {\n\t\t\t\t\t\t\t// The error from updateMiniGoStructFromNative is already an *object.Error\n\t\t\t\t\t\t\treturn errObj\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnumOut := funcType.NumOut()\n\t\t\tif numOut == 0 {\n\t\t\t\treturn object.NIL\n\t\t\t}\n\n\t\t\t// Convert all results to minigo objects.\n\t\t\t// This new logic correctly handles the `(value, error)` pattern by\n\t\t\t// wrapping the non-nil error in a GoValue, instead of halting execution.\n\t\t\t// The minigo script is then responsible for checking if the error is nil.\n\t\t\tresultObjects := make([]object.Object, numOut)\n\t\t\tfor i := 0; i < numOut; i++ {\n\t\t\t\tresultObjects[i] = e.nativeToValue(results[i])\n\t\t\t}\n\n\t\t\tif numOut == 1 {\n\t\t\t\treturn resultObjects[0]\n\t\t\t}\n\t\t\treturn &object.Tuple{Elements: resultObjects}\n\t\t},\n\t}\n}\n\n// evalMethodCall handles resolving and binding a method to a receiver.\n// The receiver can be a struct instance or a pointer to a struct instance.\nfunc (e *Evaluator) evalMethodCall(n *ast.SelectorExpr, receiver object.Object, def *object.StructDefinition) object.Object {\n\tmethod, ok := def.Methods[n.Sel.Name]\n\tif !ok {\n\t\treturn nil\t// Not a method, signal to caller to check for fields.\n\t}\n\n\t// Determine if the method requires a pointer receiver.\n\tisPointerReceiver := false\n\tif method.Recv != nil && len(method.Recv.List) > 0 {\n\t\tif _, ok := method.Recv.List[0].Type.(*ast.StarExpr); ok {\n\t\t\tisPointerReceiver = true\n\t\t}\n\t}\n\n\t// Check if the receiver is compatible.\n\tif isPointerReceiver {\n\t\tif _, isPointer := receiver.(*object.Pointer); !isPointer {\n\t\t\t// This is a limitation of minigo: it doesn't automatically take the address.\n\t\t\t// e.g., `var c Counter; c.Inc()` where Inc has a pointer receiver.\n\t\t\t// A real Go compiler would implicitly convert `c` to `&c`.\n\t\t\treturn e.newError(n.Pos(), \"cannot call pointer method %s on value %s\", n.Sel.Name, def.Name.Name)\n\t\t}\n\t\t// Receiver is a pointer, and method wants a pointer. This is correct.\n\t\treturn &object.BoundMethod{Fn: method, Receiver: receiver}\n\t}\n\n\t// Method has a value receiver.\n\tif ptr, isPointer := receiver.(*object.Pointer); isPointer {\n\t\t// If receiver is a pointer, dereference it for the method call.\n\t\treturn &object.BoundMethod{Fn: method, Receiver: *ptr.Element}\n\t}\n\n\t// Receiver is a value, and method wants a value. This is correct.\n\t// We pass a copy to prevent the method from modifying the original struct.\n\tinstance := receiver.(*object.StructInstance)\n\treturn &object.BoundMethod{Fn: method, Receiver: instance.Copy()}\n}\n\nfunc (e *Evaluator) evalSelectorExpr(n *ast.SelectorExpr, env *object.Environment, fscope *object.FileScope) object.Object {\n\tleft := e.Eval(n.X, env, fscope)\n\tif isError(left) {\n\t\treturn left\n\t}\n\n\tswitch l := left.(type) {\n\tcase *object.InterfaceInstance:\n\t\tif l.Value == nil || l.Value.Type() == object.NIL_OBJ {\n\t\t\treturn e.newError(n.Pos(), \"nil pointer dereference (interface is nil)\")\n\t\t}\n\t\t// Dispatch the selector to the concrete value held by the interface.\n\t\t// This is effectively a re-dispatch of evalSelectorExpr's logic.\n\t\tswitch concrete := l.Value.(type) {\n\t\tcase *object.StructInstance:\n\t\t\t// Re-run the logic for StructInstance\n\t\t\tif method := e.evalMethodCall(n, concrete, concrete.Def); method != nil {\n\t\t\t\tif err, isErr := method.(*object.Error); isErr {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn method\n\t\t\t}\n\t\t\tif val, found := e.findFieldInStruct(concrete, n.Sel.Name); found {\n\t\t\t\treturn val\n\t\t\t}\n\t\t\treturn e.newError(n.Pos(), \"undefined field or method '%s' on struct '%s' held by interface\", n.Sel.Name, concrete.Def.Name.Name)\n\t\tcase *object.Pointer:\n\t\t\t// Re-run the logic for Pointer\n\t\t\tif concrete.Element == nil || *concrete.Element == nil {\n\t\t\t\treturn e.newError(n.Pos(), \"nil pointer dereference in interface\")\n\t\t\t}\n\t\t\tinstance, ok := (*concrete.Element).(*object.StructInstance)\n\t\t\tif !ok {\n\t\t\t\treturn e.newError(n.Pos(), \"interface holds pointer to non-struct\")\n\t\t\t}\n\t\t\tif method := e.evalMethodCall(n, concrete, instance.Def); method != nil {\n\t\t\t\tif err, isErr := method.(*object.Error); isErr {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn method\n\t\t\t}\n\t\t\tif val, found := e.findFieldInStruct(instance, n.Sel.Name); found {\n\t\t\t\treturn val\n\t\t\t}\n\t\t\treturn e.newError(n.Pos(), \"undefined field or method '%s' on pointer to struct '%s' held by interface\", n.Sel.Name, instance.Def.Name.Name)\n\t\tdefault:\n\t\t\treturn e.newError(n.Pos(), \"type %s held by interface does not support method or field access\", concrete.Type())\n\t\t}\n\n\tcase *object.Package:\n\t\treturn e.findSymbolInPackage(l, n.Sel, n.Pos())\n\n\tcase *object.StructInstance:\n\t\t// 1. Look for a method.\n\t\tif method := e.evalMethodCall(n, l, l.Def); method != nil {\n\t\t\tif err, isErr := method.(*object.Error); isErr {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn method\n\t\t}\n\t\t// 2. If not a method, look for a field.\n\t\tif val, found := e.findFieldInStruct(l, n.Sel.Name); found {\n\t\t\treturn val\n\t\t}\n\t\treturn e.newError(n.Pos(), \"undefined field or method '%s' on struct '%s'\", n.Sel.Name, l.Def.Name.Name)\n\n\tcase *object.TypedNil:\n\t\tptrType, ok := l.TypeObject.(*object.PointerType)\n\t\tif !ok {\n\t\t\treturn e.newError(n.Pos(), \"internal error: TypedNil does not contain a pointer type\")\n\t\t}\n\t\tstructDef, ok := ptrType.ElementType.(*object.StructDefinition)\n\t\tif !ok {\n\t\t\treturn e.newError(n.Pos(), \"cannot get method from nil pointer to non-struct type %s\", ptrType.ElementType.Inspect())\n\t\t}\n\t\tmethod, ok := structDef.Methods[n.Sel.Name]\n\t\tif !ok {\n\t\t\treturn e.newError(n.Pos(), \"undefined method %s for type %s\", n.Sel.Name, structDef.Name.Name)\n\t\t}\n\t\treturn &object.GoMethodValue{Fn: method, RecvDef: structDef}\n\n\tcase *object.Pointer:\n\t\tif l.Element == nil || *l.Element == nil {\n\t\t\treturn e.newError(n.Pos(), \"nil pointer dereference\")\n\t\t}\n\n\t\t// Handle pointers to both minigo structs and Go values\n\t\tswitch elem := (*l.Element).(type) {\n\t\tcase *object.StructInstance:\n\t\t\t// This is a pointer to a minigo-defined struct.\n\t\t\t// 1. Look for a method. Pass the pointer `l` as the receiver.\n\t\t\tif method := e.evalMethodCall(n, l, elem.Def); method != nil {\n\t\t\t\tif err, isErr := method.(*object.Error); isErr {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn method\n\t\t\t}\n\t\t\t// 2. If not a method, look for a field on the dereferenced struct.\n\t\t\tif val, found := e.findFieldInStruct(elem, n.Sel.Name); found {\n\t\t\t\treturn val\n\t\t\t}\n\t\t\treturn e.newError(n.Pos(), \"undefined field or method '%s' on pointer to struct '%s'\", n.Sel.Name, elem.Def.Name.Name)\n\n\t\tcase *object.GoValue:\n\t\t\t// This is a pointer to a Go value. Delegate to the Go value selector logic.\n\t\t\treturn e.evalGoValueSelectorExpr(n, elem, n.Sel.Name)\n\n\t\tdefault:\n\t\t\treturn e.newError(n.Pos(), \"base of selector expression is not a pointer to a struct or Go value\")\n\t\t}\n\n\tcase *object.GoValue:\n\t\treturn e.evalGoValueSelectorExpr(n, l, n.Sel.Name)\n\tdefault:\n\t\treturn e.newError(n.Pos(), \"base of selector expression is not a package or struct\")\n\t}\n}\n\n// findSymbolInPackage resolves a symbol within a given package. It handles caching,\n// consulting the symbol registry, and triggering on-demand scanning.\nfunc (e *Evaluator) findSymbolInPackage(pkg *object.Package, symbolName *ast.Ident, pos token.Pos) object.Object {\n\t// 1. Check member cache first.\n\tif member, ok := pkg.Members[symbolName.Name]; ok {\n\t\treturn member\n\t}\n\n\t// 2. Check the registry for pre-registered symbols (values and types).\n\tif symbol, ok := e.registry.Lookup(pkg.Path, symbolName.Name); ok {\n\t\tvar member object.Object\n\t\tval := reflect.ValueOf(symbol)\n\t\tif val.Kind() == reflect.Func {\n\t\t\tmember = e.WrapGoFunction(pos, val)\n\t\t} else {\n\t\t\tmember = &object.GoValue{Value: val}\n\t\t}\n\t\tpkg.Members[symbolName.Name] = member\t// Cache it\n\t\treturn member\n\t}\n\tif t, ok := e.registry.LookupType(pkg.Path, symbolName.Name); ok {\n\t\tmember := &object.GoType{GoType: t}\n\t\tpkg.Members[symbolName.Name] = member\t// Cache it\n\t\treturn member\n\t}\n\n\t// 3. If the package's environment is empty, it means we haven't scanned it yet.\n\t// This is the main entry point for on-demand, lazy loading of a package's source.\n\tif pkg.Env.IsEmpty() {\n\t\tcumulativePkgInfo, err := e.scanner.FindSymbolInPackage(context.Background(), pkg.Path, symbolName.Name)\n\t\tif err != nil {\n\t\t\t// Not found in any unscanned files either.\n\t\t\treturn e.newError(pos, \"undefined: %s.%s (package scan failed: %v)\", pkg.Name, symbolName.Name, err)\n\t\t}\n\n\t\t// Update the package object with the richer info from the scan.\n\t\tpkg.Info = cumulativePkgInfo\n\n\t\t// Create a new, unified FileScope for the entire package from all its files.\n\t\tif cumulativePkgInfo != nil && len(cumulativePkgInfo.AstFiles) > 0 {\n\t\t\tvar representativeAST *ast.File\n\t\t\tfor _, astFile := range cumulativePkgInfo.AstFiles {\n\t\t\t\tif representativeAST == nil {\n\t\t\t\t\trepresentativeAST = astFile\n\t\t\t\t}\n\t\t\t}\n\t\t\tunifiedFScope := object.NewFileScope(representativeAST)\n\t\t\tfor _, astFile := range cumulativePkgInfo.AstFiles {\n\t\t\t\tfor _, importSpec := range astFile.Imports {\n\t\t\t\t\tpath, err := strconv.Unquote(importSpec.Path.Value)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn e.newError(importSpec.Path.Pos(), \"invalid import path: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t\tvar alias string\n\t\t\t\t\tvar aliasIdent *ast.Ident\n\t\t\t\t\tif importSpec.Name != nil {\n\t\t\t\t\t\talias = importSpec.Name.Name\n\t\t\t\t\t\taliasIdent = importSpec.Name\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparts := strings.Split(path, \"/\")\n\t\t\t\t\t\talias = parts[len(parts)-1]\n\t\t\t\t\t\taliasIdent = &ast.Ident{Name: alias, NamePos: importSpec.Path.Pos()}\n\t\t\t\t\t}\n\t\t\t\t\te.resolvePackage(aliasIdent, path)\n\t\t\t\t\tswitch alias {\n\t\t\t\t\tcase \"_\":\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tcase \".\":\n\t\t\t\t\t\tunifiedFScope.DotImports = append(unifiedFScope.DotImports, path)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tunifiedFScope.Aliases[alias] = path\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpkg.FScope = unifiedFScope\n\t\t}\n\n\t\t// Proactively populate all symbols from the package info into the package's environment.\n\t\t// This acts as the \"second pass\" to resolve all top-level declarations before execution.\n\t\tif pkg.Info != nil {\n\t\t\tfor _, t := range pkg.Info.Types {\n\t\t\t\tif _, ok := pkg.Env.Get(t.Name); !ok {\n\t\t\t\t\ttypeObj, _ := e.findSymbolInPackageInfo(pkg.Info, t.Name, pkg.Env, pkg.FScope)\n\t\t\t\t\tif typeObj != nil {\n\t\t\t\t\t\tpkg.Env.Set(t.Name, typeObj)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor _, c := range pkg.Info.Constants {\n\t\t\t\tif _, ok := pkg.Env.GetConstant(c.Name); !ok {\n\t\t\t\t\tconstObj, _ := e.findSymbolInPackageInfo(pkg.Info, c.Name, pkg.Env, pkg.FScope)\n\t\t\t\t\tif constObj != nil {\n\t\t\t\t\t\tpkg.Env.SetConstant(c.Name, constObj)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor _, f := range pkg.Info.Functions {\n\t\t\t\tif _, ok := pkg.Env.Get(f.Name); !ok {\n\t\t\t\t\tfnObj, _ := e.findSymbolInPackageInfo(pkg.Info, f.Name, pkg.Env, pkg.FScope)\n\t\t\t\t\tif fnObj != nil {\n\t\t\t\t\t\tpkg.Env.Set(f.Name, fnObj)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 4. Now that the package environment is populated, retrieve the symbol and cache it in Members.\n\tif member, ok := pkg.Env.Get(symbolName.Name); ok {\n\t\tpkg.Members[symbolName.Name] = member\n\t\treturn member\n\t}\n\n\treturn e.newError(pos, \"undefined: %s.%s\", pkg.Name, symbolName.Name)\n}\n\nfunc (e *Evaluator) evalGoValueSelectorExpr(node ast.Node, goVal *object.GoValue, sel string) object.Object {\n\tval := goVal.Value\n\n\t// --- 1. Method Resolution ---\n\t// Try to find the method on the value itself, or on a pointer to the value.\n\tvar method reflect.Value\n\n\t// a) Check value receiver\n\tmethod = val.MethodByName(sel)\n\n\t// b) If not found, and the value is addressable, check pointer receiver.\n\t// This is crucial for methods like `(*bytes.Buffer).Write`.\n\tif !method.IsValid() && val.CanAddr() {\n\t\tmethod = val.Addr().MethodByName(sel)\n\t}\n\n\t// --- 2. Method Invocation ---\n\t// If a method was found, return a callable Builtin object that wraps the Go method.\n\tif method.IsValid() {\n\t\tfuncType := method.Type()\n\t\treturn &object.Builtin{\n\t\t\tFn: func(ctx *object.BuiltinContext, callPos token.Pos, args ...object.Object) (ret object.Object) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t\tret = ctx.NewError(callPos, \"panic in Go method call '%s': %v\", sel, r)\n\t\t\t\t\t}\n\t\t\t\t}()\n\n\t\t\t\tnumIn := funcType.NumIn()\n\t\t\t\tisVariadic := funcType.IsVariadic()\n\n\t\t\t\t// Check argument count against the Go method's signature.\n\t\t\t\tif isVariadic {\n\t\t\t\t\tif len(args) < numIn-1 {\n\t\t\t\t\t\treturn ctx.NewError(callPos, \"wrong number of arguments for variadic method %s: got %d, want at least %d\", sel, len(args), numIn-1)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif len(args) != numIn {\n\t\t\t\t\t\treturn ctx.NewError(callPos, \"wrong number of arguments for method %s: got %d, want %d\", sel, len(args), numIn)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Prepare arguments for reflection call.\n\t\t\t\tin := make([]reflect.Value, len(args))\n\t\t\t\tfor i, arg := range args {\n\t\t\t\t\tvar targetType reflect.Type\n\t\t\t\t\tif isVariadic && i >= numIn-1 {\n\t\t\t\t\t\ttargetType = funcType.In(numIn - 1).Elem()\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttargetType = funcType.In(i)\n\t\t\t\t\t}\n\n\t\t\t\t\t// Use the evaluator's conversion helper.\n\t\t\t\t\tval, err := e.objectToReflectValue(arg, targetType)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn ctx.NewError(callPos, \"argument %d type mismatch for method %s: %v\", i+1, sel, err)\n\t\t\t\t\t}\n\t\t\t\t\tin[i] = val\n\t\t\t\t}\n\n\t\t\t\t// Call the method.\n\t\t\t\tresults := method.Call(in)\n\n\t\t\t\t// Process results.\n\t\t\t\tnumOut := funcType.NumOut()\n\t\t\t\tif numOut == 0 {\n\t\t\t\t\treturn object.NIL\n\t\t\t\t}\n\n\t\t\t\t// Convert all results to minigo objects.\n\t\t\t\t// This new logic correctly handles the `(value, error)` pattern by\n\t\t\t\t// wrapping the non-nil error in a GoValue, instead of halting execution.\n\t\t\t\t// The minigo script is then responsible for checking if the error is nil.\n\t\t\t\tresultObjects := make([]object.Object, numOut)\n\t\t\t\tfor i := 0; i < numOut; i++ {\n\t\t\t\t\tresultObjects[i] = e.nativeToValue(results[i])\n\t\t\t\t}\n\n\t\t\t\tif numOut == 1 {\n\t\t\t\t\treturn resultObjects[0]\n\t\t\t\t}\n\t\t\t\treturn &object.Tuple{Elements: resultObjects}\n\t\t\t},\n\t\t}\n\t}\n\n\t// --- 3. Field Access ---\n\t// If no method was found, try to access a field on the struct.\n\tobjToInspect := val\n\tif objToInspect.Kind() == reflect.Ptr {\n\t\tif objToInspect.IsNil() {\n\t\t\treturn e.newError(node.Pos(), \"nil pointer dereference\")\n\t\t}\n\t\tobjToInspect = objToInspect.Elem()\n\t}\n\n\tif objToInspect.Kind() == reflect.Struct {\n\t\tfield := objToInspect.FieldByName(sel)\n\t\tif field.IsValid() {\n\t\t\tif !field.CanInterface() {\n\t\t\t\treturn e.newError(node.Pos(), \"cannot access unexported field '%s' on Go struct %s\", sel, objToInspect.Type())\n\t\t\t}\n\t\t\treturn e.nativeToValue(field)\n\t\t}\n\t}\n\n\t// --- 4. Not Found ---\n\t// If neither a method nor a field was found, it's an error.\n\treturn e.newError(node.Pos(), \"undefined field or method '%s' on Go object of type %s\", sel, val.Type())\n}\n\nfunc (e *Evaluator) evalCompositeLit(n *ast.CompositeLit, env *object.Environment, fscope *object.FileScope) object.Object {\n\tif n.Type == nil {\n\t\treturn e.newError(n.Pos(), \"untyped composite literal in context where type cannot be inferred\")\n\t}\n\t// First, evaluate the type expression itself. This could be an identifier (MyStruct),\n\t// a selector (pkg.MyStruct), an index expression (MyGeneric[int]), or a type literal ([]int).\n\ttypeObj := e.Eval(n.Type, env, fscope)\n\tif isError(typeObj) {\n\t\treturn typeObj\n\t}\n\treturn e.evalCompositeLitWithType(n, typeObj, env, fscope)\n}\n\n// evalCompositeLitWithType evaluates a composite literal against a given, already-evaluated type object.\nfunc (e *Evaluator) evalCompositeLitWithType(n *ast.CompositeLit, typeObj object.Object, env *object.Environment, fscope *object.FileScope) object.Object {\n\t// Now, resolve the evaluated type object. This handles non-generic aliases.\n\t// For generic types, `typeObj` will already be the instantiated type object\n\t// (e.g., a StructDefinition or an ArrayType from `instantiateTypeAlias`).\n\tresolvedType := e.resolveType(typeObj, env, fscope)\n\tif isError(resolvedType) {\n\t\treturn resolvedType\n\t}\n\n\tswitch def := resolvedType.(type) {\n\tcase *object.InstantiatedType:\n\t\t// Handle composite literals for instantiated generic types, e.g., Box[int]{...}\n\t\tstructDef, ok := def.GenericDef.(*object.StructDefinition)\n\t\tif !ok {\n\t\t\treturn e.newError(n.Pos(), \"cannot create composite literal of non-struct generic type %s\", def.GenericDef.Type())\n\t\t}\n\t\tinstanceObj := e.evalStructLiteral(n, structDef, env, fscope)\n\t\tif si, ok := instanceObj.(*object.StructInstance); ok {\n\t\t\tsi.TypeArgs = def.TypeArgs\t// Attach the type arguments from the instantiation\n\t\t}\n\t\treturn instanceObj\n\n\tcase *object.StructDefinition:\n\t\tinstanceObj := e.evalStructLiteral(n, def, env, fscope)\n\t\t// If the original type was a generic instantiation, we need to attach the type arguments.\n\t\tif instType, ok := typeObj.(*object.InstantiatedType); ok {\n\t\t\tif si, ok := instanceObj.(*object.StructInstance); ok {\n\t\t\t\tsi.TypeArgs = instType.TypeArgs\n\t\t\t}\n\t\t}\n\t\treturn instanceObj\n\n\tcase *object.ArrayType:\n\t\telements := e.evalExpressions(n.Elts, env, fscope, def.ElementType)\n\t\tif len(elements) == 1 && isError(elements[0]) {\n\t\t\treturn elements[0]\n\t\t}\n\t\t// Create a new slice with capacity equal to length to mimic Go's behavior for literals.\n\t\tfinalElements := make([]object.Object, len(elements))\n\t\tcopy(finalElements, elements)\n\t\treturn &object.Array{SliceType: def, Elements: finalElements}\n\n\tcase *object.MapType:\n\t\treturn e.evalMapLiteral(n, def, env, fscope)\n\n\tdefault:\n\t\treturn e.newError(n.Pos(), \"cannot create composite literal for type %s\", resolvedType.Type())\n\t}\n}\n\n// checkImplements verifies that a concrete object satisfies an interface definition.\n// It returns nil on success or an *object.Error on failure.\nfunc (e *Evaluator) checkImplements(pos token.Pos, concrete object.Object, iface *object.InterfaceDefinition) object.Object {\n\tvar concreteMethods map[string]*object.Function\n\tvar concreteTypeName string\n\n\t// Determine the method set and type name from the concrete object.\n\t// This handles both value receivers (StructInstance) and pointer receivers (*Pointer to StructInstance).\n\tswitch c := concrete.(type) {\n\tcase *object.StructInstance:\n\t\tconcreteMethods = c.Def.Methods\n\t\tconcreteTypeName = c.Def.Name.Name\n\tcase *object.Pointer:\n\t\tif s, ok := (*c.Element).(*object.StructInstance); ok {\n\t\t\tconcreteMethods = s.Def.Methods\n\t\t\tconcreteTypeName = s.Def.Name.Name\n\t\t} else {\n\t\t\t// A pointer to a non-struct cannot have methods.\n\t\t\tif len(iface.Methods.List) > 0 {\n\t\t\t\treturn e.newError(pos, \"type %s cannot implement non-empty interface %s\", (*c.Element).Type(), iface.Name.Name)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\tdefault:\n\t\t// Any other type cannot have methods.\n\t\tif len(iface.Methods.List) > 0 {\n\t\t\treturn e.newError(pos, \"type %s cannot implement non-empty interface %s\", concrete.Type(), iface.Name.Name)\n\t\t}\n\t\treturn nil\t// Type can implement an empty interface.\n\t}\n\n\t// Now check each method required by the interface.\n\tfor _, ifaceMethodField := range iface.Methods.List {\n\t\tif len(ifaceMethodField.Names) == 0 {\n\t\t\tcontinue\t// Should not happen in a valid interface AST.\n\t\t}\n\t\tmethodName := ifaceMethodField.Names[0].Name\n\t\tifaceFuncType, ok := ifaceMethodField.Type.(*ast.FuncType)\n\t\tif !ok {\n\t\t\tcontinue\t// Also should not happen.\n\t\t}\n\n\t\tconcreteMethod, ok := concreteMethods[methodName]\n\t\tif !ok {\n\t\t\treturn e.newError(pos, \"type %s does not implement %s (missing method %s)\", concreteTypeName, iface.Name.Name, methodName)\n\t\t}\n\n\t\t// Compare parameter counts.\n\t\tifaceParamCount := 0\n\t\tif ifaceFuncType.Params != nil {\n\t\t\tifaceParamCount = len(ifaceFuncType.Params.List)\n\t\t}\n\t\tconcreteParamCount := 0\n\t\tif concreteMethod.Parameters != nil {\n\t\t\tconcreteParamCount = len(concreteMethod.Parameters.List)\n\t\t}\n\t\tif ifaceParamCount != concreteParamCount {\n\t\t\treturn e.newError(pos, \"cannot use %s as %s value in assignment: method %s has wrong number of parameters (got %d, want %d)\",\n\t\t\t\tconcreteTypeName, iface.Name.Name, methodName, concreteParamCount, ifaceParamCount)\n\t\t}\n\n\t\t// Compare result counts.\n\t\tifaceResultCount := 0\n\t\tif ifaceFuncType.Results != nil {\n\t\t\tifaceResultCount = len(ifaceFuncType.Results.List)\n\t\t}\n\t\tconcreteResultCount := 0\n\t\tif concreteMethod.Results != nil {\n\t\t\tconcreteResultCount = len(concreteMethod.Results.List)\n\t\t}\n\t\tif ifaceResultCount != concreteResultCount {\n\t\t\treturn e.newError(pos, \"cannot use %s as %s value in assignment: method %s has wrong number of return values (got %d, want %d)\",\n\t\t\t\tconcreteTypeName, iface.Name.Name, methodName, concreteResultCount, ifaceResultCount)\n\t\t}\n\n\t\t// NOTE: A full implementation would also compare the types of parameters and results.\n\t\t// This is complex as it requires resolving type identifiers from the AST.\n\t\t// For now, we only check the counts, which covers many cases.\n\t}\n\n\treturn nil\n}\n\nfunc (e *Evaluator) evalStructLiteral(n *ast.CompositeLit, def *object.StructDefinition, env *object.Environment, fscope *object.FileScope) object.Object {\n\tinstance := &object.StructInstance{Def: def, Fields: make(map[string]object.Object)}\n\n\t// Initialize all fields to their zero value (nil) first.\n\t// This ensures that even uninitialized fields exist in the Fields map.\n\tfor _, field := range def.Fields {\n\t\tfor _, name := range field.Names {\n\t\t\tinstance.Fields[name.Name] = object.NIL\n\t\t}\n\t}\n\n\tfor _, elt := range n.Elts {\n\t\tswitch node := elt.(type) {\n\t\tcase *ast.KeyValueExpr:\n\t\t\tkey, ok := node.Key.(*ast.Ident)\n\t\t\tif !ok {\n\t\t\t\treturn e.newError(node.Key.Pos(), \"field name is not an identifier\")\n\t\t\t}\n\t\t\tvalue := e.Eval(node.Value, env, fscope)\n\t\t\tif isError(value) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tinstance.Fields[key.Name] = value\n\t\tcase *ast.Ident:\n\t\t\t// This handles shorthand struct literals, e.g., `MyStruct{Field}`\n\t\t\t// which is equivalent to `MyStruct{Field: Field}`.\n\t\t\tfieldName := node.Name\n\t\t\tvalue := e.Eval(node, env, fscope)\t// Evaluate the identifier in the current env\n\t\t\tif isError(value) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tinstance.Fields[fieldName] = value\n\t\tdefault:\n\t\t\treturn e.newError(elt.Pos(), \"unsupported literal element in struct literal: %T\", elt)\n\t\t}\n\t}\n\treturn instance\n}\n\nfunc (e *Evaluator) evalMapLiteral(n *ast.CompositeLit, def *object.MapType, env *object.Environment, fscope *object.FileScope) object.Object {\n\tpairs := make(map[object.HashKey]object.MapPair)\n\n\tfor _, elt := range n.Elts {\n\t\tkv, ok := elt.(*ast.KeyValueExpr)\n\t\tif !ok {\n\t\t\treturn e.newError(elt.Pos(), \"non-key-value element in map literal\")\n\t\t}\n\n\t\tkey := e.Eval(kv.Key, env, fscope)\n\t\tif isError(key) {\n\t\t\treturn key\n\t\t}\n\n\t\thashable, ok := key.(object.Hashable)\n\t\tif !ok {\n\t\t\treturn e.newError(kv.Key.Pos(), \"unusable as map key: %s\", key.Type())\n\t\t}\n\n\t\tvalue := e.Eval(kv.Value, env, fscope)\n\t\tif isError(value) {\n\t\t\treturn value\n\t\t}\n\n\t\thashed := hashable.HashKey()\n\t\tpairs[hashed] = object.MapPair{Key: key, Value: value}\n\t}\n\n\treturn &object.Map{MapType: def, Pairs: pairs}\n}\n\nfunc (e *Evaluator) resolvePackage(ident *ast.Ident, path string) *object.Package {\n\t// Check if the package is already in the central cache.\n\tif pkg, ok := e.packages[path]; ok {\n\t\treturn pkg\n\t}\n\t// If not, create a new proxy object and cache it.\n\tpkgObj := &object.Package{\n\t\tName:\t\tident.Name,\n\t\tPath:\t\tpath,\n\t\tEnv:\t\tobject.NewEnvironment(),\t// Create a new environment for the package.\n\t\tInfo:\t\tnil,\t\t\t\t// Mark as not loaded yet\n\t\tMembers:\tmake(map[string]object.Object),\n\t}\n\te.packages[path] = pkgObj\n\treturn pkgObj\n}\n\nfunc (e *Evaluator) evalIdent(n *ast.Ident, env *object.Environment, fscope *object.FileScope) object.Object {\n\tif val, ok := env.Get(n.Name); ok {\n\t\treturn val\n\t}\n\tif builtin, ok := builtins[n.Name]; ok {\n\t\treturn builtin\n\t}\n\tif sf, ok := e.specialForms[n.Name]; ok {\n\t\treturn sf\n\t}\n\t// Handle built-in type identifiers. These don't have a first-class object\n\t// representation in our interpreter, but they shouldn't cause an \"identifier\n\t// not found\" error when used in declarations like `var x int`.\n\tswitch n.Name {\n\tcase \"int\", \"int8\", \"int16\", \"int32\", \"int64\":\n\t\treturn &object.Type{Name: n.Name}\n\tcase \"uint\", \"uint8\", \"uint16\", \"uint32\", \"uint64\", \"uintptr\":\n\t\treturn &object.Type{Name: n.Name}\n\tcase \"float32\", \"float64\":\n\t\treturn &object.Type{Name: n.Name}\n\tcase \"string\", \"bool\", \"byte\", \"rune\", \"any\", \"comparable\":\n\t\treturn &object.Type{Name: n.Name}\n\t}\n\n\t// Check if it's a package alias or a symbol from a dot import.\n\tif fscope != nil {\n\t\t// Check dot imports first.\n\t\tfor _, path := range fscope.DotImports {\n\t\t\t// We need a dummy identifier for resolvePackage, as the package itself isn't named in a dot import.\n\t\t\tdummyIdent := &ast.Ident{Name: \"_\"}\n\t\t\tpkg := e.resolvePackage(dummyIdent, path)\n\n\t\t\t// Now, try to find the symbol `n` within this package.\n\t\t\tval := e.findSymbolInPackage(pkg, n, n.Pos())\n\n\t\t\t// If the symbol is found, return it.\n\t\t\t// We check for \"undefined\" specifically, because other errors\n\t\t\t// (like a real error from a function call) should be propagated.\n\t\t\t// If it's an \"undefined\" error, we just continue to the next dot-imported package.\n\t\t\tif err, ok := val.(*object.Error); ok {\n\t\t\t\tif strings.Contains(err.Message, \"undefined:\") {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If it's not an \"undefined\" error, we found it or encountered a different error.\n\t\t\treturn val\n\t\t}\n\n\t\t// If not in a dot import, check for a regular package alias.\n\t\tif path, ok := fscope.Aliases[n.Name]; ok {\n\t\t\treturn e.resolvePackage(n, path)\n\t\t}\n\t}\n\n\tswitch n.Name {\n\tcase \"true\":\n\t\treturn object.TRUE\n\tcase \"false\":\n\t\treturn object.FALSE\n\tcase \"nil\":\n\t\treturn object.NIL\n\t}\n\treturn e.newError(n.Pos(), \"identifier not found: %s\", n.Name)\n}\n\nfunc (e *Evaluator) evalBasicLit(n *ast.BasicLit) object.Object {\n\tswitch n.Kind {\n\tcase token.INT:\n\t\ti, err := strconv.ParseInt(n.Value, 0, 64)\n\t\tif err != nil {\n\t\t\treturn e.newError(n.Pos(), \"could not parse %q as integer\", n.Value)\n\t\t}\n\t\treturn &object.Integer{Value: i}\n\tcase token.FLOAT:\n\t\tf, err := strconv.ParseFloat(n.Value, 64)\n\t\tif err != nil {\n\t\t\treturn e.newError(n.Pos(), \"could not parse %q as float\", n.Value)\n\t\t}\n\t\treturn &object.Float{Value: f}\n\tcase token.STRING:\n\t\ts, err := strconv.Unquote(n.Value)\n\t\tif err != nil {\n\t\t\treturn e.newError(n.Pos(), \"could not unquote string %q\", n.Value)\n\t\t}\n\t\treturn &object.String{Value: s}\n\tcase token.CHAR:\n\t\t// Unquote the char literal (e.g., \"'a'\" -> \"a\")\n\t\ts, err := strconv.Unquote(n.Value)\n\t\tif err != nil {\n\t\t\treturn e.newError(n.Pos(), \"could not unquote char literal %q\", n.Value)\n\t\t}\n\t\t// A char literal in Go is a rune, which is an alias for int32.\n\t\t// We represent it as our standard Integer object.\n\t\treturn &object.Integer{Value: int64(rune(s[0]))}\n\tdefault:\n\t\treturn e.newError(n.Pos(), \"unsupported literal type: %s\", n.Kind)\n\t}\n}\n\n// Scanner returns the underlying goscan.Scanner instance.\nfunc (e *Evaluator) Scanner() *goscan.Scanner {\n\treturn e.scanner\n}\n"
time=2025-09-18T09:43:11.521Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.521Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.521Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.521Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/minigo/evaluator types=4
time=2025-09-18T09:43:11.521Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.521Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.521Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.524Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:34:16 source="map[string]*object.Builtin{\n\t\"readln\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 0 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=0, want=0\")\n\t\t\t}\n\t\t\treader := bufio.NewReader(ctx.Stdin)\n\t\t\tline, err := reader.ReadString('\\n')\n\t\t\tif err != nil && err != io.EOF {\n\t\t\t\treturn ctx.NewError(pos, \"error reading from stdin: %v\", err)\n\t\t\t}\n\t\t\treturn &object.String{Value: strings.TrimSpace(line)}\n\t\t},\n\t},\n\t\"len\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 1 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t\t}\n\t\t\tswitch arg := args[0].(type) {\n\t\t\tcase *object.Array:\n\t\t\t\treturn &object.Integer{Value: int64(len(arg.Elements))}\n\t\t\tcase *object.String:\n\t\t\t\treturn &object.Integer{Value: int64(len(arg.Value))}\n\t\t\tcase *object.Map:\n\t\t\t\treturn &object.Integer{Value: int64(len(arg.Pairs))}\n\t\t\tcase *object.GoValue:\n\t\t\t\tval := arg.Value\n\t\t\t\tswitch val.Kind() {\n\t\t\t\tcase reflect.Array, reflect.Slice, reflect.Map, reflect.String:\n\t\t\t\t\treturn &object.Integer{Value: int64(val.Len())}\n\t\t\t\tdefault:\n\t\t\t\t\treturn ctx.NewError(pos, \"argument to `len` not supported, got Go value of type %s\", val.Kind())\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn ctx.NewError(pos, \"argument to `len` not supported, got %s\", args[0].Type())\n\t\t\t}\n\t\t},\n\t},\n\t\"cap\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 1 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t\t}\n\t\t\tswitch arg := args[0].(type) {\n\t\t\tcase *object.Array:\n\t\t\t\treturn &object.Integer{Value: int64(cap(arg.Elements))}\n\t\t\tcase *object.GoValue:\n\t\t\t\tval := arg.Value\n\t\t\t\tswitch val.Kind() {\n\t\t\t\tcase reflect.Array, reflect.Slice:\n\t\t\t\t\treturn &object.Integer{Value: int64(val.Cap())}\n\t\t\t\tdefault:\n\t\t\t\t\treturn ctx.NewError(pos, \"argument to `cap` not supported, got Go value of type %s\", val.Kind())\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn ctx.NewError(pos, \"argument to `cap` not supported, got %s\", args[0].Type())\n\t\t\t}\n\t\t},\n\t},\n\t\"copy\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 2 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=2\", len(args))\n\t\t\t}\n\t\t\tdst, ok := args[0].(*object.Array)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"argument 1 to `copy` must be array, got %s\", args[0].Type())\n\t\t\t}\n\t\t\tsrc, ok := args[1].(*object.Array)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"argument 2 to `copy` must be array, got %s\", args[1].Type())\n\t\t\t}\n\n\t\t\tn := copy(dst.Elements, src.Elements)\n\t\t\treturn &object.Integer{Value: int64(n)}\n\t\t},\n\t},\n\t\"delete\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 2 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=2\", len(args))\n\t\t\t}\n\t\t\tm, ok := args[0].(*object.Map)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"argument to `delete` must be a map, got %s\", args[0].Type())\n\t\t\t}\n\t\t\tkey, ok := args[1].(object.Hashable)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"unusable as map key: %s\", args[1].Type())\n\t\t\t}\n\t\t\tdelete(m.Pairs, key.HashKey())\n\t\t\treturn object.NIL\n\t\t},\n\t},\n\t\"make\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) == 0 {\n\t\t\t\treturn ctx.NewError(pos, \"missing argument to make\")\n\t\t\t}\n\n\t\t\tswitch typeArg := args[0].(type) {\n\t\t\tcase *object.MapType:\n\t\t\t\tif len(args) > 2 {\n\t\t\t\t\treturn ctx.NewError(pos, \"make(map) takes at most 1 size argument\")\n\t\t\t\t}\n\n\t\t\t\treturn &object.Map{Pairs: make(map[object.HashKey]object.MapPair)}\n\n\t\t\tcase *object.ArrayType:\n\t\t\t\tif len(args) < 2 || len(args) > 3 {\n\t\t\t\t\treturn ctx.NewError(pos, \"make([]T) requires len and optional cap arguments\")\n\t\t\t\t}\n\t\t\t\tlenArg, ok := args[1].(*object.Integer)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn ctx.NewError(pos, \"argument 2 to `make` must be an integer, got %s\", args[1].Type())\n\t\t\t\t}\n\t\t\t\tlength := lenArg.Value\n\n\t\t\t\tvar capacity int64\n\t\t\t\tif len(args) == 3 {\n\t\t\t\t\tcapArg, ok := args[2].(*object.Integer)\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn ctx.NewError(pos, \"argument 3 to `make` must be an integer, got %s\", args[2].Type())\n\t\t\t\t\t}\n\t\t\t\t\tcapacity = capArg.Value\n\t\t\t\t} else {\n\t\t\t\t\tcapacity = length\n\t\t\t\t}\n\n\t\t\t\tif length < 0 || capacity < 0 || length > capacity {\n\t\t\t\t\treturn ctx.NewError(pos, \"invalid arguments: len=%d, cap=%d\", length, capacity)\n\t\t\t\t}\n\n\t\t\t\telements := make([]object.Object, length, capacity)\n\t\t\t\tfor i := range elements {\n\t\t\t\t\telements[i] = object.NIL\n\t\t\t\t}\n\t\t\t\treturn &object.Array{Elements: elements}\n\t\t\tdefault:\n\t\t\t\treturn ctx.NewError(pos, \"argument 1 to `make` must be a slice or map type, got %s\", typeArg.Type())\n\t\t\t}\n\t\t},\n\t},\n\t\"clear\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 1 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t\t}\n\t\t\tswitch arg := args[0].(type) {\n\t\t\tcase *object.Map:\n\t\t\t\targ.Pairs = make(map[object.HashKey]object.MapPair)\n\t\t\t\treturn object.NIL\n\t\t\tcase *object.Array:\n\t\t\t\tfor i := range arg.Elements {\n\t\t\t\t\targ.Elements[i] = object.NIL\n\t\t\t\t}\n\t\t\t\treturn object.NIL\n\t\t\tdefault:\n\t\t\t\treturn ctx.NewError(pos, \"argument to `clear` must be map or slice, got %s\", arg.Type())\n\t\t\t}\n\t\t},\n\t},\n\t\"complex\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 2 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=2\", len(args))\n\t\t\t}\n\n\t\t\tgetNumberAsFloat := func(arg object.Object) (float64, bool) {\n\t\t\t\tswitch n := arg.(type) {\n\t\t\t\tcase *object.Integer:\n\t\t\t\t\treturn float64(n.Value), true\n\t\t\t\tcase *object.Float:\n\t\t\t\t\treturn n.Value, true\n\t\t\t\tdefault:\n\t\t\t\t\treturn 0, false\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tr, ok := getNumberAsFloat(args[0])\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"argument 1 to `complex` must be a number, got %s\", args[0].Type())\n\t\t\t}\n\t\t\ti, ok := getNumberAsFloat(args[1])\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"argument 2 to `complex` must be a number, got %s\", args[1].Type())\n\t\t\t}\n\n\t\t\treturn &object.Complex{Real: r, Imag: i}\n\t\t},\n\t},\n\t\"real\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 1 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t\t}\n\t\t\tc, ok := args[0].(*object.Complex)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"argument to `real` must be a complex number, got %s\", args[0].Type())\n\t\t\t}\n\t\t\treturn &object.Float{Value: c.Real}\n\t\t},\n\t},\n\t\"imag\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 1 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t\t}\n\t\t\tc, ok := args[0].(*object.Complex)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"argument to `imag` must be a complex number, got %s\", args[0].Type())\n\t\t\t}\n\t\t\treturn &object.Float{Value: c.Imag}\n\t\t},\n\t},\n\t\"append\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) < 2 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want at least 2\", len(args))\n\t\t\t}\n\n\t\t\tvar elements []object.Object\n\t\t\tif arr, ok := args[0].(*object.Array); ok {\n\t\t\t\telements = arr.Elements\n\t\t\t} else if args[0] == object.NIL || args[0].Type() == object.TYPED_NIL_OBJ {\n\t\t\t\telements = []object.Object{}\n\t\t\t} else {\n\t\t\t\treturn ctx.NewError(pos, \"argument to `append` must be array or nil, got %s\", args[0].Type())\n\t\t\t}\n\n\t\t\tnewElements := make([]object.Object, len(elements), len(elements)+len(args)-1)\n\t\t\tcopy(newElements, elements)\n\t\t\tnewElements = append(newElements, args[1:]...)\n\n\t\t\treturn &object.Array{Elements: newElements}\n\t\t},\n\t},\n\t\"max\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) == 0 {\n\t\t\t\treturn ctx.NewError(pos, \"max() requires at least one argument\")\n\t\t\t}\n\t\t\tmaxVal, ok := args[0].(*object.Integer)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"all arguments to max() must be integers\")\n\t\t\t}\n\t\t\tfor i := 1; i < len(args); i++ {\n\t\t\t\tval, ok := args[i].(*object.Integer)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn ctx.NewError(pos, \"all arguments to max() must be integers\")\n\t\t\t\t}\n\t\t\t\tif val.Value > maxVal.Value {\n\t\t\t\t\tmaxVal = val\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn maxVal\n\t\t},\n\t},\n\t\"min\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) == 0 {\n\t\t\t\treturn ctx.NewError(pos, \"min() requires at least one argument\")\n\t\t\t}\n\t\t\tminVal, ok := args[0].(*object.Integer)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"all arguments to min() must be integers\")\n\t\t\t}\n\t\t\tfor i := 1; i < len(args); i++ {\n\t\t\t\tval, ok := args[i].(*object.Integer)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn ctx.NewError(pos, \"all arguments to min() must be integers\")\n\t\t\t\t}\n\t\t\t\tif val.Value < minVal.Value {\n\t\t\t\t\tminVal = val\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn minVal\n\t\t},\n\t},\n\t\"new\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 1 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t\t}\n\n\t\t\tdef, ok := args[0].(*object.StructDefinition)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"argument to `new` must be a struct type, got %s\", args[0].Type())\n\t\t\t}\n\n\t\t\tinstance := &object.StructInstance{\n\t\t\t\tDef:\tdef,\n\t\t\t\tFields:\tmake(map[string]object.Object),\n\t\t\t}\n\t\t\tfor _, field := range def.Fields {\n\n\t\t\t\tinstance.Fields[field.Names[0].Name] = object.NIL\n\t\t\t}\n\n\t\t\tvar obj object.Object = instance\n\t\t\treturn &object.Pointer{Element: &obj}\n\t\t},\n\t},\n\t\"panic\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 1 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t\t}\n\t\t\treturn &object.Panic{Value: args[0]}\n\t\t},\n\t},\n\t\"recover\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 0 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=0\", len(args))\n\t\t\t}\n\n\t\t\tif !ctx.IsExecutingDefer() {\n\t\t\t\treturn object.NIL\n\t\t\t}\n\t\t\tif p := ctx.GetPanic(); p != nil {\n\t\t\t\tctx.ClearPanic()\n\t\t\t\treturn p.Value\n\t\t\t}\n\t\t\treturn object.NIL\n\t\t},\n\t},\n\t\"close\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tif len(args) != 1 {\n\t\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t\t}\n\n\t\t\treturn ctx.NewError(pos, \"argument to `close` must be a channel, got %s\", args[0].Type())\n\t\t},\n\t},\n\t\"print\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tfor i, arg := range args {\n\t\t\t\tif i > 0 {\n\t\t\t\t\tfmt.Fprint(ctx.Stdout, \" \")\n\t\t\t\t}\n\t\t\t\tfmt.Fprint(ctx.Stdout, arg.Inspect())\n\t\t\t}\n\t\t\treturn object.NIL\n\t\t},\n\t},\n\t\"println\": {\n\t\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\t\tfor i, arg := range args {\n\t\t\t\tif i > 0 {\n\t\t\t\t\tfmt.Fprint(ctx.Stdout, \" \")\n\t\t\t\t}\n\t\t\t\tfmt.Fprint(ctx.Stdout, arg.Inspect())\n\t\t\t}\n\t\t\tfmt.Fprintln(ctx.Stdout)\n\t\t\treturn object.NIL\n\t\t},\n\t},\n}"
time=2025-09-18T09:43:11.525Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:35:12 source="{\n\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\tif len(args) != 0 {\n\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=0, want=0\")\n\t\t}\n\t\treader := bufio.NewReader(ctx.Stdin)\n\t\tline, err := reader.ReadString('\\n')\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn ctx.NewError(pos, \"error reading from stdin: %v\", err)\n\t\t}\n\t\treturn &object.String{Value: strings.TrimSpace(line)}\n\t},\n}"
time=2025-09-18T09:43:11.525Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.FuncLit pos=/app/minigo/evaluator/evaluator.go:36:7 source="func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\tif len(args) != 0 {\n\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=0, want=0\")\n\t}\n\treader := bufio.NewReader(ctx.Stdin)\n\tline, err := reader.ReadString('\\n')\n\tif err != nil && err != io.EOF {\n\t\treturn ctx.NewError(pos, \"error reading from stdin: %v\", err)\n\t}\n\treturn &object.String{Value: strings.TrimSpace(line)}\n}"
time=2025-09-18T09:43:11.525Z level=DEBUG source=/app/symgo/evaluator/resolver.go:54 msg="type resolution failed, returning placeholder" type=untyped_nil_expr error="type \"untyped_nil_expr\" cannot be resolved: no resolver available"
time=2025-09-18T09:43:11.525Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/minigo/evaluator/evaluator.go:35:2 source="\"readln\""
time=2025-09-18T09:43:11.525Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:48:9 source="{\n\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\tif len(args) != 1 {\n\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t}\n\t\tswitch arg := args[0].(type) {\n\t\tcase *object.Array:\n\t\t\treturn &object.Integer{Value: int64(len(arg.Elements))}\n\t\tcase *object.String:\n\t\t\treturn &object.Integer{Value: int64(len(arg.Value))}\n\t\tcase *object.Map:\n\t\t\treturn &object.Integer{Value: int64(len(arg.Pairs))}\n\t\tcase *object.GoValue:\n\t\t\tval := arg.Value\n\t\t\tswitch val.Kind() {\n\t\t\tcase reflect.Array, reflect.Slice, reflect.Map, reflect.String:\n\t\t\t\treturn &object.Integer{Value: int64(val.Len())}\n\t\t\tdefault:\n\t\t\t\treturn ctx.NewError(pos, \"argument to `len` not supported, got Go value of type %s\", val.Kind())\n\t\t\t}\n\t\tdefault:\n\t\t\treturn ctx.NewError(pos, \"argument to `len` not supported, got %s\", args[0].Type())\n\t\t}\n\t},\n}"
time=2025-09-18T09:43:11.525Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.FuncLit pos=/app/minigo/evaluator/evaluator.go:49:7 source="func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\tif len(args) != 1 {\n\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t}\n\tswitch arg := args[0].(type) {\n\tcase *object.Array:\n\t\treturn &object.Integer{Value: int64(len(arg.Elements))}\n\tcase *object.String:\n\t\treturn &object.Integer{Value: int64(len(arg.Value))}\n\tcase *object.Map:\n\t\treturn &object.Integer{Value: int64(len(arg.Pairs))}\n\tcase *object.GoValue:\n\t\tval := arg.Value\n\t\tswitch val.Kind() {\n\t\tcase reflect.Array, reflect.Slice, reflect.Map, reflect.String:\n\t\t\treturn &object.Integer{Value: int64(val.Len())}\n\t\tdefault:\n\t\t\treturn ctx.NewError(pos, \"argument to `len` not supported, got Go value of type %s\", val.Kind())\n\t\t}\n\tdefault:\n\t\treturn ctx.NewError(pos, \"argument to `len` not supported, got %s\", args[0].Type())\n\t}\n}"
time=2025-09-18T09:43:11.525Z level=DEBUG source=/app/symgo/evaluator/resolver.go:54 msg="type resolution failed, returning placeholder" type=untyped_nil_expr error="type \"untyped_nil_expr\" cannot be resolved: no resolver available"
time=2025-09-18T09:43:11.525Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/minigo/evaluator/evaluator.go:48:2 source="\"len\""
time=2025-09-18T09:43:11.526Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:73:9 source="{\n\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\tif len(args) != 1 {\n\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t}\n\t\tswitch arg := args[0].(type) {\n\t\tcase *object.Array:\n\t\t\treturn &object.Integer{Value: int64(cap(arg.Elements))}\n\t\tcase *object.GoValue:\n\t\t\tval := arg.Value\n\t\t\tswitch val.Kind() {\n\t\t\tcase reflect.Array, reflect.Slice:\n\t\t\t\treturn &object.Integer{Value: int64(val.Cap())}\n\t\t\tdefault:\n\t\t\t\treturn ctx.NewError(pos, \"argument to `cap` not supported, got Go value of type %s\", val.Kind())\n\t\t\t}\n\t\tdefault:\n\t\t\treturn ctx.NewError(pos, \"argument to `cap` not supported, got %s\", args[0].Type())\n\t\t}\n\t},\n}"
time=2025-09-18T09:43:11.526Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.FuncLit pos=/app/minigo/evaluator/evaluator.go:74:7 source="func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\tif len(args) != 1 {\n\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t}\n\tswitch arg := args[0].(type) {\n\tcase *object.Array:\n\t\treturn &object.Integer{Value: int64(cap(arg.Elements))}\n\tcase *object.GoValue:\n\t\tval := arg.Value\n\t\tswitch val.Kind() {\n\t\tcase reflect.Array, reflect.Slice:\n\t\t\treturn &object.Integer{Value: int64(val.Cap())}\n\t\tdefault:\n\t\t\treturn ctx.NewError(pos, \"argument to `cap` not supported, got Go value of type %s\", val.Kind())\n\t\t}\n\tdefault:\n\t\treturn ctx.NewError(pos, \"argument to `cap` not supported, got %s\", args[0].Type())\n\t}\n}"
time=2025-09-18T09:43:11.526Z level=DEBUG source=/app/symgo/evaluator/resolver.go:54 msg="type resolution failed, returning placeholder" type=untyped_nil_expr error="type \"untyped_nil_expr\" cannot be resolved: no resolver available"
time=2025-09-18T09:43:11.526Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/minigo/evaluator/evaluator.go:73:2 source="\"cap\""
time=2025-09-18T09:43:11.526Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:94:10 source="{\n\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\tif len(args) != 2 {\n\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=2\", len(args))\n\t\t}\n\t\tdst, ok := args[0].(*object.Array)\n\t\tif !ok {\n\t\t\treturn ctx.NewError(pos, \"argument 1 to `copy` must be array, got %s\", args[0].Type())\n\t\t}\n\t\tsrc, ok := args[1].(*object.Array)\n\t\tif !ok {\n\t\t\treturn ctx.NewError(pos, \"argument 2 to `copy` must be array, got %s\", args[1].Type())\n\t\t}\n\n\t\tn := copy(dst.Elements, src.Elements)\n\t\treturn &object.Integer{Value: int64(n)}\n\t},\n}"
time=2025-09-18T09:43:11.526Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.FuncLit pos=/app/minigo/evaluator/evaluator.go:95:7 source="func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\tif len(args) != 2 {\n\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=2\", len(args))\n\t}\n\tdst, ok := args[0].(*object.Array)\n\tif !ok {\n\t\treturn ctx.NewError(pos, \"argument 1 to `copy` must be array, got %s\", args[0].Type())\n\t}\n\tsrc, ok := args[1].(*object.Array)\n\tif !ok {\n\t\treturn ctx.NewError(pos, \"argument 2 to `copy` must be array, got %s\", args[1].Type())\n\t}\n\n\tn := copy(dst.Elements, src.Elements)\n\treturn &object.Integer{Value: int64(n)}\n}"
time=2025-09-18T09:43:11.526Z level=DEBUG source=/app/symgo/evaluator/resolver.go:54 msg="type resolution failed, returning placeholder" type=untyped_nil_expr error="type \"untyped_nil_expr\" cannot be resolved: no resolver available"
time=2025-09-18T09:43:11.526Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/minigo/evaluator/evaluator.go:94:2 source="\"copy\""
time=2025-09-18T09:43:11.526Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:112:12 source="{\n\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\tif len(args) != 2 {\n\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=2\", len(args))\n\t\t}\n\t\tm, ok := args[0].(*object.Map)\n\t\tif !ok {\n\t\t\treturn ctx.NewError(pos, \"argument to `delete` must be a map, got %s\", args[0].Type())\n\t\t}\n\t\tkey, ok := args[1].(object.Hashable)\n\t\tif !ok {\n\t\t\treturn ctx.NewError(pos, \"unusable as map key: %s\", args[1].Type())\n\t\t}\n\t\tdelete(m.Pairs, key.HashKey())\n\t\treturn object.NIL\n\t},\n}"
time=2025-09-18T09:43:11.526Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.FuncLit pos=/app/minigo/evaluator/evaluator.go:113:7 source="func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\tif len(args) != 2 {\n\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=2\", len(args))\n\t}\n\tm, ok := args[0].(*object.Map)\n\tif !ok {\n\t\treturn ctx.NewError(pos, \"argument to `delete` must be a map, got %s\", args[0].Type())\n\t}\n\tkey, ok := args[1].(object.Hashable)\n\tif !ok {\n\t\treturn ctx.NewError(pos, \"unusable as map key: %s\", args[1].Type())\n\t}\n\tdelete(m.Pairs, key.HashKey())\n\treturn object.NIL\n}"
time=2025-09-18T09:43:11.526Z level=DEBUG source=/app/symgo/evaluator/resolver.go:54 msg="type resolution failed, returning placeholder" type=untyped_nil_expr error="type \"untyped_nil_expr\" cannot be resolved: no resolver available"
time=2025-09-18T09:43:11.526Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/minigo/evaluator/evaluator.go:112:2 source="\"delete\""
time=2025-09-18T09:43:11.527Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:129:10 source="{\n\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\tif len(args) == 0 {\n\t\t\treturn ctx.NewError(pos, \"missing argument to make\")\n\t\t}\n\n\t\tswitch typeArg := args[0].(type) {\n\t\tcase *object.MapType:\n\t\t\tif len(args) > 2 {\n\t\t\t\treturn ctx.NewError(pos, \"make(map) takes at most 1 size argument\")\n\t\t\t}\n\n\t\t\treturn &object.Map{Pairs: make(map[object.HashKey]object.MapPair)}\n\n\t\tcase *object.ArrayType:\n\t\t\tif len(args) < 2 || len(args) > 3 {\n\t\t\t\treturn ctx.NewError(pos, \"make([]T) requires len and optional cap arguments\")\n\t\t\t}\n\t\t\tlenArg, ok := args[1].(*object.Integer)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"argument 2 to `make` must be an integer, got %s\", args[1].Type())\n\t\t\t}\n\t\t\tlength := lenArg.Value\n\n\t\t\tvar capacity int64\n\t\t\tif len(args) == 3 {\n\t\t\t\tcapArg, ok := args[2].(*object.Integer)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn ctx.NewError(pos, \"argument 3 to `make` must be an integer, got %s\", args[2].Type())\n\t\t\t\t}\n\t\t\t\tcapacity = capArg.Value\n\t\t\t} else {\n\t\t\t\tcapacity = length\n\t\t\t}\n\n\t\t\tif length < 0 || capacity < 0 || length > capacity {\n\t\t\t\treturn ctx.NewError(pos, \"invalid arguments: len=%d, cap=%d\", length, capacity)\n\t\t\t}\n\n\t\t\telements := make([]object.Object, length, capacity)\n\t\t\tfor i := range elements {\n\t\t\t\telements[i] = object.NIL\n\t\t\t}\n\t\t\treturn &object.Array{Elements: elements}\n\t\tdefault:\n\t\t\treturn ctx.NewError(pos, \"argument 1 to `make` must be a slice or map type, got %s\", typeArg.Type())\n\t\t}\n\t},\n}"
time=2025-09-18T09:43:11.527Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.FuncLit pos=/app/minigo/evaluator/evaluator.go:130:7 source="func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\tif len(args) == 0 {\n\t\treturn ctx.NewError(pos, \"missing argument to make\")\n\t}\n\n\tswitch typeArg := args[0].(type) {\n\tcase *object.MapType:\n\t\tif len(args) > 2 {\n\t\t\treturn ctx.NewError(pos, \"make(map) takes at most 1 size argument\")\n\t\t}\n\n\t\treturn &object.Map{Pairs: make(map[object.HashKey]object.MapPair)}\n\n\tcase *object.ArrayType:\n\t\tif len(args) < 2 || len(args) > 3 {\n\t\t\treturn ctx.NewError(pos, \"make([]T) requires len and optional cap arguments\")\n\t\t}\n\t\tlenArg, ok := args[1].(*object.Integer)\n\t\tif !ok {\n\t\t\treturn ctx.NewError(pos, \"argument 2 to `make` must be an integer, got %s\", args[1].Type())\n\t\t}\n\t\tlength := lenArg.Value\n\n\t\tvar capacity int64\n\t\tif len(args) == 3 {\n\t\t\tcapArg, ok := args[2].(*object.Integer)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"argument 3 to `make` must be an integer, got %s\", args[2].Type())\n\t\t\t}\n\t\t\tcapacity = capArg.Value\n\t\t} else {\n\t\t\tcapacity = length\n\t\t}\n\n\t\tif length < 0 || capacity < 0 || length > capacity {\n\t\t\treturn ctx.NewError(pos, \"invalid arguments: len=%d, cap=%d\", length, capacity)\n\t\t}\n\n\t\telements := make([]object.Object, length, capacity)\n\t\tfor i := range elements {\n\t\t\telements[i] = object.NIL\n\t\t}\n\t\treturn &object.Array{Elements: elements}\n\tdefault:\n\t\treturn ctx.NewError(pos, \"argument 1 to `make` must be a slice or map type, got %s\", typeArg.Type())\n\t}\n}"
time=2025-09-18T09:43:11.527Z level=DEBUG source=/app/symgo/evaluator/resolver.go:54 msg="type resolution failed, returning placeholder" type=untyped_nil_expr error="type \"untyped_nil_expr\" cannot be resolved: no resolver available"
time=2025-09-18T09:43:11.527Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/minigo/evaluator/evaluator.go:129:2 source="\"make\""
time=2025-09-18T09:43:11.527Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:178:11 source="{\n\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\tif len(args) != 1 {\n\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t}\n\t\tswitch arg := args[0].(type) {\n\t\tcase *object.Map:\n\t\t\targ.Pairs = make(map[object.HashKey]object.MapPair)\n\t\t\treturn object.NIL\n\t\tcase *object.Array:\n\t\t\tfor i := range arg.Elements {\n\t\t\t\targ.Elements[i] = object.NIL\n\t\t\t}\n\t\t\treturn object.NIL\n\t\tdefault:\n\t\t\treturn ctx.NewError(pos, \"argument to `clear` must be map or slice, got %s\", arg.Type())\n\t\t}\n\t},\n}"
time=2025-09-18T09:43:11.527Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.FuncLit pos=/app/minigo/evaluator/evaluator.go:179:7 source="func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\tif len(args) != 1 {\n\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t}\n\tswitch arg := args[0].(type) {\n\tcase *object.Map:\n\t\targ.Pairs = make(map[object.HashKey]object.MapPair)\n\t\treturn object.NIL\n\tcase *object.Array:\n\t\tfor i := range arg.Elements {\n\t\t\targ.Elements[i] = object.NIL\n\t\t}\n\t\treturn object.NIL\n\tdefault:\n\t\treturn ctx.NewError(pos, \"argument to `clear` must be map or slice, got %s\", arg.Type())\n\t}\n}"
time=2025-09-18T09:43:11.527Z level=DEBUG source=/app/symgo/evaluator/resolver.go:54 msg="type resolution failed, returning placeholder" type=untyped_nil_expr error="type \"untyped_nil_expr\" cannot be resolved: no resolver available"
time=2025-09-18T09:43:11.527Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/minigo/evaluator/evaluator.go:178:2 source="\"clear\""
time=2025-09-18T09:43:11.527Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:197:13 source="{\n\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\tif len(args) != 2 {\n\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=2\", len(args))\n\t\t}\n\n\t\tgetNumberAsFloat := func(arg object.Object) (float64, bool) {\n\t\t\tswitch n := arg.(type) {\n\t\t\tcase *object.Integer:\n\t\t\t\treturn float64(n.Value), true\n\t\t\tcase *object.Float:\n\t\t\t\treturn n.Value, true\n\t\t\tdefault:\n\t\t\t\treturn 0, false\n\t\t\t}\n\t\t}\n\n\t\tr, ok := getNumberAsFloat(args[0])\n\t\tif !ok {\n\t\t\treturn ctx.NewError(pos, \"argument 1 to `complex` must be a number, got %s\", args[0].Type())\n\t\t}\n\t\ti, ok := getNumberAsFloat(args[1])\n\t\tif !ok {\n\t\t\treturn ctx.NewError(pos, \"argument 2 to `complex` must be a number, got %s\", args[1].Type())\n\t\t}\n\n\t\treturn &object.Complex{Real: r, Imag: i}\n\t},\n}"
time=2025-09-18T09:43:11.527Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.FuncLit pos=/app/minigo/evaluator/evaluator.go:198:7 source="func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\tif len(args) != 2 {\n\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=2\", len(args))\n\t}\n\n\tgetNumberAsFloat := func(arg object.Object) (float64, bool) {\n\t\tswitch n := arg.(type) {\n\t\tcase *object.Integer:\n\t\t\treturn float64(n.Value), true\n\t\tcase *object.Float:\n\t\t\treturn n.Value, true\n\t\tdefault:\n\t\t\treturn 0, false\n\t\t}\n\t}\n\n\tr, ok := getNumberAsFloat(args[0])\n\tif !ok {\n\t\treturn ctx.NewError(pos, \"argument 1 to `complex` must be a number, got %s\", args[0].Type())\n\t}\n\ti, ok := getNumberAsFloat(args[1])\n\tif !ok {\n\t\treturn ctx.NewError(pos, \"argument 2 to `complex` must be a number, got %s\", args[1].Type())\n\t}\n\n\treturn &object.Complex{Real: r, Imag: i}\n}"
time=2025-09-18T09:43:11.527Z level=DEBUG source=/app/symgo/evaluator/resolver.go:54 msg="type resolution failed, returning placeholder" type=untyped_nil_expr error="type \"untyped_nil_expr\" cannot be resolved: no resolver available"
time=2025-09-18T09:43:11.527Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/minigo/evaluator/evaluator.go:197:2 source="\"complex\""
time=2025-09-18T09:43:11.528Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:226:10 source="{\n\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\tif len(args) != 1 {\n\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t}\n\t\tc, ok := args[0].(*object.Complex)\n\t\tif !ok {\n\t\t\treturn ctx.NewError(pos, \"argument to `real` must be a complex number, got %s\", args[0].Type())\n\t\t}\n\t\treturn &object.Float{Value: c.Real}\n\t},\n}"
time=2025-09-18T09:43:11.528Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.FuncLit pos=/app/minigo/evaluator/evaluator.go:227:7 source="func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\tif len(args) != 1 {\n\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t}\n\tc, ok := args[0].(*object.Complex)\n\tif !ok {\n\t\treturn ctx.NewError(pos, \"argument to `real` must be a complex number, got %s\", args[0].Type())\n\t}\n\treturn &object.Float{Value: c.Real}\n}"
time=2025-09-18T09:43:11.528Z level=DEBUG source=/app/symgo/evaluator/resolver.go:54 msg="type resolution failed, returning placeholder" type=untyped_nil_expr error="type \"untyped_nil_expr\" cannot be resolved: no resolver available"
time=2025-09-18T09:43:11.528Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/minigo/evaluator/evaluator.go:226:2 source="\"real\""
time=2025-09-18T09:43:11.528Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:238:10 source="{\n\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\tif len(args) != 1 {\n\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t}\n\t\tc, ok := args[0].(*object.Complex)\n\t\tif !ok {\n\t\t\treturn ctx.NewError(pos, \"argument to `imag` must be a complex number, got %s\", args[0].Type())\n\t\t}\n\t\treturn &object.Float{Value: c.Imag}\n\t},\n}"
time=2025-09-18T09:43:11.528Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.FuncLit pos=/app/minigo/evaluator/evaluator.go:239:7 source="func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\tif len(args) != 1 {\n\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t}\n\tc, ok := args[0].(*object.Complex)\n\tif !ok {\n\t\treturn ctx.NewError(pos, \"argument to `imag` must be a complex number, got %s\", args[0].Type())\n\t}\n\treturn &object.Float{Value: c.Imag}\n}"
time=2025-09-18T09:43:11.528Z level=DEBUG source=/app/symgo/evaluator/resolver.go:54 msg="type resolution failed, returning placeholder" type=untyped_nil_expr error="type \"untyped_nil_expr\" cannot be resolved: no resolver available"
time=2025-09-18T09:43:11.528Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/minigo/evaluator/evaluator.go:238:2 source="\"imag\""
time=2025-09-18T09:43:11.528Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:250:12 source="{\n\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\tif len(args) < 2 {\n\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want at least 2\", len(args))\n\t\t}\n\n\t\tvar elements []object.Object\n\t\tif arr, ok := args[0].(*object.Array); ok {\n\t\t\telements = arr.Elements\n\t\t} else if args[0] == object.NIL || args[0].Type() == object.TYPED_NIL_OBJ {\n\t\t\telements = []object.Object{}\n\t\t} else {\n\t\t\treturn ctx.NewError(pos, \"argument to `append` must be array or nil, got %s\", args[0].Type())\n\t\t}\n\n\t\tnewElements := make([]object.Object, len(elements), len(elements)+len(args)-1)\n\t\tcopy(newElements, elements)\n\t\tnewElements = append(newElements, args[1:]...)\n\n\t\treturn &object.Array{Elements: newElements}\n\t},\n}"
time=2025-09-18T09:43:11.528Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.FuncLit pos=/app/minigo/evaluator/evaluator.go:251:7 source="func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\tif len(args) < 2 {\n\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want at least 2\", len(args))\n\t}\n\n\tvar elements []object.Object\n\tif arr, ok := args[0].(*object.Array); ok {\n\t\telements = arr.Elements\n\t} else if args[0] == object.NIL || args[0].Type() == object.TYPED_NIL_OBJ {\n\t\telements = []object.Object{}\n\t} else {\n\t\treturn ctx.NewError(pos, \"argument to `append` must be array or nil, got %s\", args[0].Type())\n\t}\n\n\tnewElements := make([]object.Object, len(elements), len(elements)+len(args)-1)\n\tcopy(newElements, elements)\n\tnewElements = append(newElements, args[1:]...)\n\n\treturn &object.Array{Elements: newElements}\n}"
time=2025-09-18T09:43:11.528Z level=DEBUG source=/app/symgo/evaluator/resolver.go:54 msg="type resolution failed, returning placeholder" type=untyped_nil_expr error="type \"untyped_nil_expr\" cannot be resolved: no resolver available"
time=2025-09-18T09:43:11.528Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/minigo/evaluator/evaluator.go:250:2 source="\"append\""
time=2025-09-18T09:43:11.528Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:272:9 source="{\n\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\tif len(args) == 0 {\n\t\t\treturn ctx.NewError(pos, \"max() requires at least one argument\")\n\t\t}\n\t\tmaxVal, ok := args[0].(*object.Integer)\n\t\tif !ok {\n\t\t\treturn ctx.NewError(pos, \"all arguments to max() must be integers\")\n\t\t}\n\t\tfor i := 1; i < len(args); i++ {\n\t\t\tval, ok := args[i].(*object.Integer)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"all arguments to max() must be integers\")\n\t\t\t}\n\t\t\tif val.Value > maxVal.Value {\n\t\t\t\tmaxVal = val\n\t\t\t}\n\t\t}\n\t\treturn maxVal\n\t},\n}"
time=2025-09-18T09:43:11.529Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.FuncLit pos=/app/minigo/evaluator/evaluator.go:273:7 source="func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\tif len(args) == 0 {\n\t\treturn ctx.NewError(pos, \"max() requires at least one argument\")\n\t}\n\tmaxVal, ok := args[0].(*object.Integer)\n\tif !ok {\n\t\treturn ctx.NewError(pos, \"all arguments to max() must be integers\")\n\t}\n\tfor i := 1; i < len(args); i++ {\n\t\tval, ok := args[i].(*object.Integer)\n\t\tif !ok {\n\t\t\treturn ctx.NewError(pos, \"all arguments to max() must be integers\")\n\t\t}\n\t\tif val.Value > maxVal.Value {\n\t\t\tmaxVal = val\n\t\t}\n\t}\n\treturn maxVal\n}"
time=2025-09-18T09:43:11.529Z level=DEBUG source=/app/symgo/evaluator/resolver.go:54 msg="type resolution failed, returning placeholder" type=untyped_nil_expr error="type \"untyped_nil_expr\" cannot be resolved: no resolver available"
time=2025-09-18T09:43:11.529Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/minigo/evaluator/evaluator.go:272:2 source="\"max\""
time=2025-09-18T09:43:11.529Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:293:9 source="{\n\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\tif len(args) == 0 {\n\t\t\treturn ctx.NewError(pos, \"min() requires at least one argument\")\n\t\t}\n\t\tminVal, ok := args[0].(*object.Integer)\n\t\tif !ok {\n\t\t\treturn ctx.NewError(pos, \"all arguments to min() must be integers\")\n\t\t}\n\t\tfor i := 1; i < len(args); i++ {\n\t\t\tval, ok := args[i].(*object.Integer)\n\t\t\tif !ok {\n\t\t\t\treturn ctx.NewError(pos, \"all arguments to min() must be integers\")\n\t\t\t}\n\t\t\tif val.Value < minVal.Value {\n\t\t\t\tminVal = val\n\t\t\t}\n\t\t}\n\t\treturn minVal\n\t},\n}"
time=2025-09-18T09:43:11.529Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.FuncLit pos=/app/minigo/evaluator/evaluator.go:294:7 source="func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\tif len(args) == 0 {\n\t\treturn ctx.NewError(pos, \"min() requires at least one argument\")\n\t}\n\tminVal, ok := args[0].(*object.Integer)\n\tif !ok {\n\t\treturn ctx.NewError(pos, \"all arguments to min() must be integers\")\n\t}\n\tfor i := 1; i < len(args); i++ {\n\t\tval, ok := args[i].(*object.Integer)\n\t\tif !ok {\n\t\t\treturn ctx.NewError(pos, \"all arguments to min() must be integers\")\n\t\t}\n\t\tif val.Value < minVal.Value {\n\t\t\tminVal = val\n\t\t}\n\t}\n\treturn minVal\n}"
time=2025-09-18T09:43:11.529Z level=DEBUG source=/app/symgo/evaluator/resolver.go:54 msg="type resolution failed, returning placeholder" type=untyped_nil_expr error="type \"untyped_nil_expr\" cannot be resolved: no resolver available"
time=2025-09-18T09:43:11.529Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/minigo/evaluator/evaluator.go:293:2 source="\"min\""
time=2025-09-18T09:43:11.529Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:314:9 source="{\n\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\tif len(args) != 1 {\n\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t}\n\n\t\tdef, ok := args[0].(*object.StructDefinition)\n\t\tif !ok {\n\t\t\treturn ctx.NewError(pos, \"argument to `new` must be a struct type, got %s\", args[0].Type())\n\t\t}\n\n\t\tinstance := &object.StructInstance{\n\t\t\tDef:\tdef,\n\t\t\tFields:\tmake(map[string]object.Object),\n\t\t}\n\t\tfor _, field := range def.Fields {\n\n\t\t\tinstance.Fields[field.Names[0].Name] = object.NIL\n\t\t}\n\n\t\tvar obj object.Object = instance\n\t\treturn &object.Pointer{Element: &obj}\n\t},\n}"
time=2025-09-18T09:43:11.529Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.FuncLit pos=/app/minigo/evaluator/evaluator.go:315:7 source="func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\tif len(args) != 1 {\n\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t}\n\n\tdef, ok := args[0].(*object.StructDefinition)\n\tif !ok {\n\t\treturn ctx.NewError(pos, \"argument to `new` must be a struct type, got %s\", args[0].Type())\n\t}\n\n\tinstance := &object.StructInstance{\n\t\tDef:\tdef,\n\t\tFields:\tmake(map[string]object.Object),\n\t}\n\tfor _, field := range def.Fields {\n\n\t\tinstance.Fields[field.Names[0].Name] = object.NIL\n\t}\n\n\tvar obj object.Object = instance\n\treturn &object.Pointer{Element: &obj}\n}"
time=2025-09-18T09:43:11.529Z level=DEBUG source=/app/symgo/evaluator/resolver.go:54 msg="type resolution failed, returning placeholder" type=untyped_nil_expr error="type \"untyped_nil_expr\" cannot be resolved: no resolver available"
time=2025-09-18T09:43:11.529Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/minigo/evaluator/evaluator.go:314:2 source="\"new\""
time=2025-09-18T09:43:11.529Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:343:11 source="{\n\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\tif len(args) != 1 {\n\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t}\n\t\treturn &object.Panic{Value: args[0]}\n\t},\n}"
time=2025-09-18T09:43:11.529Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.FuncLit pos=/app/minigo/evaluator/evaluator.go:344:7 source="func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\tif len(args) != 1 {\n\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t}\n\treturn &object.Panic{Value: args[0]}\n}"
time=2025-09-18T09:43:11.529Z level=DEBUG source=/app/symgo/evaluator/resolver.go:54 msg="type resolution failed, returning placeholder" type=untyped_nil_expr error="type \"untyped_nil_expr\" cannot be resolved: no resolver available"
time=2025-09-18T09:43:11.529Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/minigo/evaluator/evaluator.go:343:2 source="\"panic\""
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:351:13 source="{\n\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\tif len(args) != 0 {\n\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=0\", len(args))\n\t\t}\n\n\t\tif !ctx.IsExecutingDefer() {\n\t\t\treturn object.NIL\n\t\t}\n\t\tif p := ctx.GetPanic(); p != nil {\n\t\t\tctx.ClearPanic()\n\t\t\treturn p.Value\n\t\t}\n\t\treturn object.NIL\n\t},\n}"
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.FuncLit pos=/app/minigo/evaluator/evaluator.go:352:7 source="func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\tif len(args) != 0 {\n\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=0\", len(args))\n\t}\n\n\tif !ctx.IsExecutingDefer() {\n\t\treturn object.NIL\n\t}\n\tif p := ctx.GetPanic(); p != nil {\n\t\tctx.ClearPanic()\n\t\treturn p.Value\n\t}\n\treturn object.NIL\n}"
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/resolver.go:54 msg="type resolution failed, returning placeholder" type=untyped_nil_expr error="type \"untyped_nil_expr\" cannot be resolved: no resolver available"
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/minigo/evaluator/evaluator.go:351:2 source="\"recover\""
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:367:11 source="{\n\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\tif len(args) != 1 {\n\t\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t\t}\n\n\t\treturn ctx.NewError(pos, \"argument to `close` must be a channel, got %s\", args[0].Type())\n\t},\n}"
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.FuncLit pos=/app/minigo/evaluator/evaluator.go:368:7 source="func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\tif len(args) != 1 {\n\t\treturn ctx.NewError(pos, \"wrong number of arguments. got=%d, want=1\", len(args))\n\t}\n\n\treturn ctx.NewError(pos, \"argument to `close` must be a channel, got %s\", args[0].Type())\n}"
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/resolver.go:54 msg="type resolution failed, returning placeholder" type=untyped_nil_expr error="type \"untyped_nil_expr\" cannot be resolved: no resolver available"
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/minigo/evaluator/evaluator.go:367:2 source="\"close\""
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:376:11 source="{\n\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\tfor i, arg := range args {\n\t\t\tif i > 0 {\n\t\t\t\tfmt.Fprint(ctx.Stdout, \" \")\n\t\t\t}\n\t\t\tfmt.Fprint(ctx.Stdout, arg.Inspect())\n\t\t}\n\t\treturn object.NIL\n\t},\n}"
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.FuncLit pos=/app/minigo/evaluator/evaluator.go:377:7 source="func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\tfor i, arg := range args {\n\t\tif i > 0 {\n\t\t\tfmt.Fprint(ctx.Stdout, \" \")\n\t\t}\n\t\tfmt.Fprint(ctx.Stdout, arg.Inspect())\n\t}\n\treturn object.NIL\n}"
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/resolver.go:54 msg="type resolution failed, returning placeholder" type=untyped_nil_expr error="type \"untyped_nil_expr\" cannot be resolved: no resolver available"
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/minigo/evaluator/evaluator.go:376:2 source="\"print\""
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/minigo/evaluator/evaluator.go:387:13 source="{\n\tFn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\t\tfor i, arg := range args {\n\t\t\tif i > 0 {\n\t\t\t\tfmt.Fprint(ctx.Stdout, \" \")\n\t\t\t}\n\t\t\tfmt.Fprint(ctx.Stdout, arg.Inspect())\n\t\t}\n\t\tfmt.Fprintln(ctx.Stdout)\n\t\treturn object.NIL\n\t},\n}"
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.FuncLit pos=/app/minigo/evaluator/evaluator.go:388:7 source="func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {\n\tfor i, arg := range args {\n\t\tif i > 0 {\n\t\t\tfmt.Fprint(ctx.Stdout, \" \")\n\t\t}\n\t\tfmt.Fprint(ctx.Stdout, arg.Inspect())\n\t}\n\tfmt.Fprintln(ctx.Stdout)\n\treturn object.NIL\n}"
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/resolver.go:54 msg="type resolution failed, returning placeholder" type=untyped_nil_expr error="type \"untyped_nil_expr\" cannot be resolved: no resolver available"
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.BasicLit pos=/app/minigo/evaluator/evaluator.go:387:2 source="\"println\""
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.530Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.531Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.532Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/evaluator
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/evaluator scanned=true
time=2025-09-18T09:43:11.533Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/minigo/stdlib/crypto/md5
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/minigo/stdlib/crypto/md5/install.go:3:1 source="// Code generated by minigo-gen-bindings. DO NOT EDIT.\n\npackage md5\n\nimport (\n\t\"crypto/md5\"\n\n\t\"github.com/podhmo/go-scan/minigo\"\n)\n\n// Install binds all exported symbols from the \"crypto/md5\" package to the interpreter.\nfunc Install(interp *minigo.Interpreter) {\n\tinterp.Register(\"crypto/md5\", map[string]any{\n\t\t\"BlockSize\":\tmd5.BlockSize,\n\t\t\"New\":\t\tmd5.New,\n\t\t\"Size\":\t\tmd5.Size,\n\t\t\"Sum\":\t\tmd5.Sum,\n\t})\n}\n"
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/crypto/md5
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/minigo/stdlib/crypto/md5
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/minigo/stdlib/crypto/md5
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/minigo/stdlib/crypto/md5 types=0
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/crypto/md5 scanned=true
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/minigo/stdlib/crypto/md5
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/crypto/md5 scanned=true
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/crypto/md5
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/stdlib/crypto/md5 scanned=true
time=2025-09-18T09:43:11.533Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/crypto/md5 scanned=true
time=2025-09-18T09:43:11.533Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.534Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/examples/docgen/analyzer.go:1:1 source="package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"strings\"\n\n\tgoscan \"github.com/podhmo/go-scan\"\n\t\"github.com/podhmo/go-scan/examples/docgen/openapi\"\n\t\"github.com/podhmo/go-scan/examples/docgen/patterns\"\n\t\"github.com/podhmo/go-scan/symgo\"\n)\n\n// Analyzer analyzes Go code and generates an OpenAPI specification.\ntype Analyzer struct {\n\tScanner\t\t*goscan.Scanner\n\tinterpreter\t*symgo.Interpreter\n\tOpenAPI\t\t*openapi.OpenAPI\n\tlogger\t\t*slog.Logger\n\ttracer\t\tsymgo.Tracer\t// Optional tracer\n\toperationStack\t[]*openapi.Operation\n\tcustomPatterns\t[]patterns.Pattern\n}\n\n// Option is a functional option for configuring the Analyzer.\ntype Option func(*Analyzer)\n\n// WithTracer sets a tracer on the analyzer to instrument the symbolic execution.\nfunc WithTracer(tracer symgo.Tracer) Option {\n\treturn func(a *Analyzer) {\n\t\ta.tracer = tracer\n\t}\n}\n\n// NewAnalyzer creates a new Analyzer.\nfunc NewAnalyzer(s *goscan.Scanner, logger *slog.Logger, extraPkgs []string, options ...any) (*Analyzer, error) {\n\ta := &Analyzer{\n\t\tScanner:\ts,\n\t\tlogger:\t\tlogger,\n\t\tOpenAPI: &openapi.OpenAPI{\n\t\t\tOpenAPI:\t\"3.1.0\",\n\t\t\tInfo: openapi.Info{\n\t\t\t\tTitle:\t\t\"Sample API\",\n\t\t\t\tVersion:\t\"0.0.1\",\n\t\t\t},\n\t\t\tPaths:\tmake(map[string]*openapi.PathItem),\n\t\t\tComponents: &openapi.Components{\n\t\t\t\tSchemas: make(map[string]*openapi.Schema),\n\t\t\t},\n\t\t},\n\t}\n\n\t// Process options\n\tfor _, opt := range options {\n\t\tswitch v := opt.(type) {\n\t\tcase Option:\n\t\t\tv(a)\n\t\tcase patterns.Pattern:\n\t\t\ta.customPatterns = append(a.customPatterns, v)\n\t\tdefault:\n\t\t\t// For backward compatibility, assume it's a pattern.\n\t\t\tif p, ok := opt.(patterns.Pattern); ok {\n\t\t\t\ta.customPatterns = append(a.customPatterns, p)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Define the analysis scopes.\n\t// Primary scope includes the workspace modules and any extra packages specified via -include-pkg.\n\tprimaryScope := make([]string, 0, len(s.Modules())+len(extraPkgs))\n\tfor _, m := range s.Modules() {\n\t\t// Use a wildcard to include all sub-packages of the main modules.\n\t\tprimaryScope = append(primaryScope, m.Path+\"/...\")\n\t}\n\tprimaryScope = append(primaryScope, extraPkgs...)\n\n\t// Symbolic scope includes net/http, as we need its type definitions but not its function bodies.\n\tsymbolicScope := []string{\"net/http\"}\n\n\tinterpOpts := []symgo.Option{\n\t\tsymgo.WithLogger(logger),\n\t\tsymgo.WithPrimaryAnalysisScope(primaryScope...),\n\t\tsymgo.WithSymbolicDependencyScope(symbolicScope...),\n\t}\n\tif a.tracer != nil {\n\t\tinterpOpts = append(interpOpts, symgo.WithTracer(a.tracer))\n\t}\n\n\tinterp, err := symgo.NewInterpreter(s, interpOpts...)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create symgo interpreter: %w\", err)\n\t}\n\ta.interpreter = interp\n\n\t// Register intrinsics.\n\tinterp.RegisterIntrinsic(\"net/http.NewServeMux\", func(ctx context.Context, i *symgo.Interpreter, args []symgo.Object) symgo.Object {\n\t\treturn a.handleNewServeMux(ctx, i, args)\n\t})\n\tinterp.RegisterIntrinsic(\"net/http.HandleFunc\", func(ctx context.Context, i *symgo.Interpreter, args []symgo.Object) symgo.Object {\n\t\treturn a.analyzeTopLevelHandleFunc(ctx, i, args)\n\t})\n\tinterp.RegisterIntrinsic(\"(*net/http.ServeMux).HandleFunc\", func(ctx context.Context, i *symgo.Interpreter, args []symgo.Object) symgo.Object {\n\t\treturn a.analyzeHandleFunc(ctx, i, args)\n\t})\n\tinterp.RegisterIntrinsic(\"net/http.ListenAndServe\", func(ctx context.Context, i *symgo.Interpreter, args []symgo.Object) symgo.Object { return nil })\n\n\t// Intrinsics for handling http.Handler interface wrappers\n\tinterp.RegisterIntrinsic(\"net/http.HandlerFunc\", func(ctx context.Context, i *symgo.Interpreter, args []symgo.Object) symgo.Object {\n\t\treturn a.handleHandlerFunc(ctx, i, args)\n\t})\n\tinterp.RegisterIntrinsic(\"net/http.TimeoutHandler\", func(ctx context.Context, i *symgo.Interpreter, args []symgo.Object) symgo.Object {\n\t\treturn a.handleTimeoutHandler(ctx, i, args)\n\t})\n\tinterp.RegisterIntrinsic(\"(*net/http.ServeMux).Handle\", func(ctx context.Context, i *symgo.Interpreter, args []symgo.Object) symgo.Object {\n\t\treturn a.analyzeHandle(ctx, i, args)\n\t})\n\n\treturn a, nil\n}\n\nfunc (a *Analyzer) OperationStack() []*openapi.Operation {\n\treturn a.operationStack\n}\n\nfunc (a *Analyzer) GetOpenAPI() *openapi.OpenAPI {\n\treturn a.OpenAPI\n}\n\nfunc (a *Analyzer) handleNewServeMux(ctx context.Context, interp *symgo.Interpreter, args []symgo.Object) symgo.Object {\n\treturn patterns.NewSymbolicInstance(interp, \"net/http.ServeMux\")\n}\n\nfunc (a *Analyzer) analyzeTopLevelHandleFunc(ctx context.Context, interp *symgo.Interpreter, args []symgo.Object) symgo.Object {\n\t// Expects 2 args for http.HandleFunc: pattern, handler\n\tif len(args) != 2 {\n\t\treturn &symgo.Error{Message: fmt.Sprintf(\"http.HandleFunc expects 2 arguments, but got %d\", len(args))}\n\t}\n\t// Prepend a nil receiver to match the signature of the existing analyzeHandleFunc\n\tnewArgs := append([]symgo.Object{&symgo.Nil{}}, args...)\n\treturn a.analyzeHandleFunc(ctx, interp, newArgs)\n}\n\n// Analyze analyzes the package starting from a specific entrypoint function.\nfunc (a *Analyzer) Analyze(ctx context.Context, importPath string, entrypoint string) error {\n\tpkg, err := a.Scanner.ScanPackageByImport(ctx, importPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to load sample API package: %w\", err)\n\t}\n\n\t// Find the entrypoint function declaration in the scanned package.\n\tvar entrypointFunc *goscan.FunctionInfo\n\tfor _, f := range pkg.Functions {\n\t\tif f.Name == entrypoint {\n\t\t\tentrypointFunc = f\n\t\t\tbreak\n\t\t}\n\t}\n\tif entrypointFunc == nil || entrypointFunc.AstDecl.Body == nil {\n\t\treturn fmt.Errorf(\"entrypoint function %q not found or has no body\", entrypoint)\n\t}\n\n\t// Find the AST file that contains the entrypoint function.\n\tentrypointFile, ok := pkg.AstFiles[entrypointFunc.FilePath]\n\tif !ok {\n\t\treturn fmt.Errorf(\"could not find AST file %q for entrypoint\", entrypointFunc.FilePath)\n\t}\n\n\t// The core analysis is now driven by the symgo interpreter.\n\t// First, evaluate the entire file of the entrypoint. This will populate the\n\t// interpreter's environment with imports and top-level declarations.\n\tif _, err := a.interpreter.Eval(ctx, entrypointFile, pkg); err != nil {\n\t\t// This is the change: we now return the error instead of just printing it.\n\t\treturn fmt.Errorf(\"error during file-level symgo eval: %w\", err)\n\t}\n\n\t// Get the function object from the environment.\n\tentrypointObj, ok := a.interpreter.FindObjectInPackage(ctx, importPath, entrypoint)\n\tif !ok {\n\t\treturn fmt.Errorf(\"entrypoint function %q not found in interpreter environment\", entrypoint)\n\t}\n\tentrypointFn, ok := entrypointObj.(*symgo.Function)\n\tif !ok {\n\t\treturn fmt.Errorf(\"entrypoint %q is not a function\", entrypoint)\n\t}\n\n\t// Then, call the entrypoint function.\n\tif _, err := a.interpreter.Apply(ctx, entrypointFn, []symgo.Object{}, pkg); err != nil {\n\t\t// This is the change: we now return the error instead of just printing it.\n\t\treturn fmt.Errorf(\"error during entrypoint apply: %w\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (a *Analyzer) handleHandlerFunc(ctx context.Context, interp *symgo.Interpreter, args []symgo.Object) symgo.Object {\n\tif len(args) != 1 {\n\t\treturn &symgo.Error{Message: fmt.Sprintf(\"HandlerFunc expects 1 argument, but got %d\", len(args))}\n\t}\n\tfn, ok := args[0].(*symgo.Function)\n\tif !ok {\n\t\t// It might be an instance wrapping a function, let's try to unwrap it.\n\t\tunwrapped := a.unwrapHandler(ctx, args[0])\n\t\tif unwrapped == nil {\n\t\t\treturn &symgo.Error{Message: fmt.Sprintf(\"HandlerFunc expects a function, but got %T\", args[0])}\n\t\t}\n\t\tfn = unwrapped\n\t}\n\treturn &symgo.Instance{\n\t\tTypeName:\t\"net/http.Handler\",\n\t\tUnderlying:\tfn,\n\t\tBaseObject:\tsymgo.BaseObject{ResolvedTypeInfo: fn.TypeInfo()},\n\t}\n}\n\nfunc (a *Analyzer) handleTimeoutHandler(ctx context.Context, interp *symgo.Interpreter, args []symgo.Object) symgo.Object {\n\tif len(args) != 3 {\n\t\treturn &symgo.Error{Message: fmt.Sprintf(\"TimeoutHandler expects 3 arguments, but got %d\", len(args))}\n\t}\n\t// The first argument is the handler, which we care about.\n\t// The other two are timeout and message, which we can ignore for doc generation.\n\thandler, ok := args[0].(symgo.Object)\t// Should be an Instance, but we just pass it through\n\tif !ok {\n\t\treturn &symgo.Error{Message: fmt.Sprintf(\"TimeoutHandler expects a handler, but got %T\", args[0])}\n\t}\n\n\t// Wrap it in another instance to represent the handler returned by TimeoutHandler.\n\treturn &symgo.Instance{\n\t\tTypeName:\t\"net/http.Handler\",\n\t\tUnderlying:\thandler,\n\t\tBaseObject:\tsymgo.BaseObject{ResolvedTypeInfo: handler.TypeInfo()},\n\t}\n}\n\nfunc (a *Analyzer) analyzeHandle(ctx context.Context, interp *symgo.Interpreter, args []symgo.Object) symgo.Object {\n\tif len(args) != 3 {\n\t\treturn &symgo.Error{Message: fmt.Sprintf(\"Handle expects 3 arguments, but got %d\", len(args))}\n\t}\n\n\tpatternObj, ok := args[1].(*symgo.String)\n\tif !ok {\n\t\treturn &symgo.Error{Message: fmt.Sprintf(\"Handle pattern argument must be a string, but got %T\", args[1])}\n\t}\n\n\t// Unwrap the handler to find the root function.\n\thandlerFunc := a.unwrapHandler(ctx, args[2])\n\tif handlerFunc == nil {\n\t\t// Return nil instead of error, as some handlers might be intentionally opaque.\n\t\ta.logger.DebugContext(ctx, \"could not unwrap handler\", \"arg\", args[2].Inspect())\n\t\treturn nil\n\t}\n\n\t// Create a new argument slice for analyzeHandleFunc.\n\t// The first arg (receiver) and second (pattern) are the same.\n\t// The third is the unwrapped function.\n\tnewArgs := []symgo.Object{args[0], patternObj, handlerFunc}\n\n\treturn a.analyzeHandleFunc(ctx, interp, newArgs)\n}\n\n// unwrapHandler recursively unwraps http.Handler instances to find the underlying function.\nfunc (a *Analyzer) unwrapHandler(ctx context.Context, obj symgo.Object) *symgo.Function {\n\tswitch v := obj.(type) {\n\tcase *symgo.Function:\n\t\treturn v\n\tcase *symgo.Instance:\n\t\tif v.Underlying != nil {\n\t\t\treturn a.unwrapHandler(ctx, v.Underlying)\n\t\t}\n\t\treturn nil\n\tdefault:\n\t\treturn nil\n\t}\n}\n\n// analyzeHandleFunc is the intrinsic for (*http.ServeMux).HandleFunc.\nfunc (a *Analyzer) analyzeHandleFunc(ctx context.Context, interp *symgo.Interpreter, args []symgo.Object) symgo.Object {\n\t// Expects 3 args for HandleFunc: receiver, pattern, handler\n\tif len(args) != 3 {\n\t\treturn &symgo.Error{Message: fmt.Sprintf(\"HandleFunc expects 3 arguments, but got %d\", len(args))}\n\t}\n\n\t// Arg 0 is the receiver, which we can ignore.\n\t// Arg 1 is the pattern string.\n\tpatternObj, ok := args[1].(*symgo.String)\n\tif !ok {\n\t\treturn &symgo.Error{Message: fmt.Sprintf(\"HandleFunc pattern argument must be a string, but got %T\", args[1])}\n\t}\n\n\t// Arg 2 is the handler function.\n\thandlerObj, ok := args[2].(*symgo.Function)\n\tif !ok {\n\t\t// It's possible the handler is not yet resolved, this is a limitation for now.\n\t\treturn &symgo.Error{Message: fmt.Sprintf(\"HandleFunc handler argument must be a function, but got %T\", args[2])}\n\t}\n\n\tpattern := patternObj.Value\n\tmethod, path, _ := strings.Cut(pattern, \" \")\n\tif path == \"\" {\n\t\tpath = method\n\t\tmethod = \"GET\"\n\t}\n\tmethod = strings.ToUpper(method)\n\n\thandlerDecl := handlerObj.Decl\n\tif handlerDecl == nil {\n\t\treturn nil\n\t}\n\n\t// Generate a unique operation ID based on package and function name.\n\tpkgPath := handlerObj.Package.ImportPath\n\tpkgPathForID := strings.ReplaceAll(pkgPath, \"/\", \"_\")\n\tpkgPathForID = strings.ReplaceAll(pkgPathForID, \".\", \"_\")\n\tparts := strings.Split(pkgPathForID, \"_\")\n\tif len(parts) > 2 {\n\t\tpkgPathForID = strings.Join(parts[len(parts)-2:], \"_\")\n\t}\n\toperationID := fmt.Sprintf(\"%s_%s\", pkgPathForID, handlerDecl.Name.Name)\n\n\top := &openapi.Operation{\n\t\tOperationID: operationID,\n\t}\n\tif handlerDecl.Doc != nil {\n\t\top.Description = strings.TrimSpace(handlerDecl.Doc.Text())\n\t}\n\n\t// Analyze the handler body for request/response schemas\n\tif handlerDecl.Body != nil {\n\t\top = a.analyzeHandlerBody(ctx, handlerObj, op)\n\t}\n\n\tif a.OpenAPI.Paths[path] == nil {\n\t\ta.OpenAPI.Paths[path] = &openapi.PathItem{}\n\t}\n\tpathItem := a.OpenAPI.Paths[path]\n\n\tswitch method {\n\tcase \"GET\":\n\t\tpathItem.Get = op\n\tcase \"POST\":\n\t\tpathItem.Post = op\n\tcase \"PUT\":\n\t\tpathItem.Put = op\n\tcase \"DELETE\":\n\t\tpathItem.Delete = op\n\tcase \"PATCH\":\n\t\tpathItem.Patch = op\n\tcase \"HEAD\":\n\t\tpathItem.Head = op\n\tcase \"OPTIONS\":\n\t\tpathItem.Options = op\n\tcase \"TRACE\":\n\t\tpathItem.Trace = op\n\t}\n\n\treturn nil\n}\n\n// analyzeHandlerBody analyzes the body of an HTTP handler function to find\n// request and response schemas.\nfunc (a *Analyzer) analyzeHandlerBody(ctx context.Context, handler *symgo.Function, op *openapi.Operation) *openapi.Operation {\n\t// Capture stack size before we modify it.\n\toriginalStackSize := len(a.operationStack)\n\tdefer func() {\n\t\t// Always restore the stack to its original size.\n\t\ta.operationStack = a.operationStack[:originalStackSize]\n\t}()\n\n\t// Push the current operation onto the stack for the duration of this analysis.\n\ta.operationStack = append(a.operationStack, op)\n\n\tpkg, err := a.Scanner.ScanPackageByPos(ctx, handler.Decl.Pos())\n\tif err != nil {\n\t\tfmt.Printf(\"warn: failed to get package for handler %q: %v\\n\", handler.Name.Name, err)\n\t\treturn op\t// Return original op on error\n\t}\n\n\t// Create symbolic arguments for the handler function (w, r).\n\tvar handlerArgs []symgo.Object\n\tif handler.Decl.Type.Params != nil {\n\t\tfile := pkg.Fset.File(handler.Decl.Pos())\n\t\tif file == nil {\n\t\t\tfmt.Printf(\"warn: could not find file for handler %q\\n\", handler.Name.Name)\n\t\t\treturn op\t// Return original op on error\n\t\t}\n\t\tastFile, ok := pkg.AstFiles[file.Name()]\n\t\tif !ok {\n\t\t\tfmt.Printf(\"warn: could not find AST file for handler %q\\n\", handler.Name.Name)\n\t\t\treturn op\t// Return original op on error\n\t\t}\n\t\timportLookup := a.Scanner.BuildImportLookup(astFile)\n\n\t\tfor _, field := range handler.Decl.Type.Params.List {\n\t\t\tfieldType := a.Scanner.TypeInfoFromExpr(ctx, field.Type, nil, pkg, importLookup)\n\t\t\ttypeInfo, _ := fieldType.Resolve(ctx)\n\n\t\t\t// For each parameter name (can be multiple like w1, w2 http.ResponseWriter), create a variable.\n\t\t\tfor _, name := range field.Names {\n\t\t\t\targ := &symgo.Variable{\n\t\t\t\t\tName:\tname.Name,\n\t\t\t\t\tBaseObject: symgo.BaseObject{\n\t\t\t\t\t\tResolvedTypeInfo: typeInfo,\n\t\t\t\t\t},\n\t\t\t\t\tValue:\t&symgo.SymbolicPlaceholder{Reason: \"function parameter\"},\n\t\t\t\t}\n\t\t\t\thandlerArgs = append(handlerArgs, arg)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Bind the http.ResponseWriter interface to a concrete type for analysis.\n\t// This allows us to track calls to methods like WriteHeader and Write.\n\tif err := a.interpreter.BindInterface(ctx, \"net/http.ResponseWriter\", \"*net/http/httptest.ResponseRecorder\"); err != nil {\n\t\t// This binding is critical, so we log a warning if it fails.\n\t\ta.logger.Warn(\"failed to bind ResponseWriter interface, response analysis will be incomplete\", \"error\", err)\n\t}\n\n\t// Push a new scope for temporary intrinsics for this handler.\n\tintrinsics := a.buildHandlerIntrinsics(a)\n\ta.interpreter.PushIntrinsics(intrinsics)\n\tdefer a.interpreter.PopIntrinsics()\t// Ensure we clean up the scope.\n\n\t// Call the handler function with the created symbolic arguments.\n\ta.interpreter.Apply(ctx, handler, handlerArgs, pkg)\n\n\t// After Apply, the operation on the top of the stack is the one that has been modified.\n\t// We retrieve it before the defer pops it.\n\tfinalOp := a.operationStack[len(a.operationStack)-1]\n\n\treturn finalOp\n}\n\n// buildHandlerIntrinsics creates the map of intrinsic handlers for analyzing\n// a handler's body by using the extensible pattern registry.\nfunc (a *Analyzer) buildHandlerIntrinsics(analyzer *Analyzer) map[string]symgo.IntrinsicFunc {\n\tintrinsics := make(map[string]symgo.IntrinsicFunc)\n\n\tallPatterns := append(patterns.GetDefaultPatterns(), a.customPatterns...)\n\n\tfor _, p := range allPatterns {\n\t\t// Capture the pattern for the closure.\n\t\tpattern := p\n\t\tintrinsics[pattern.Key] = func(ctx context.Context, i *symgo.Interpreter, args []symgo.Object) symgo.Object {\n\t\t\t// The analyzer instance `a` is captured from the outer scope.\n\t\t\t// The pattern's Apply function will use it to get the current operation.\n\t\t\treturn pattern.Apply(ctx, i, analyzer, args)\n\t\t}\n\t}\n\n\treturn intrinsics\n}\n"
time=2025-09-18T09:43:11.535Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.535Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.535Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.535Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/examples/docgen types=3
time=2025-09-18T09:43:11.535Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.535Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.535Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/examples/docgen/loader.go:1:1 source="package main\n\nimport (\n\t\"fmt\"\n\t\"go/ast\"\n\t\"log/slog\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\tgoscan \"github.com/podhmo/go-scan\"\n\t\"github.com/podhmo/go-scan/examples/docgen/patterns\"\n\t\"github.com/podhmo/go-scan/minigo\"\n\t\"github.com/podhmo/go-scan/minigo/object\"\n)\n\n// LoadPatternsFromConfig loads custom analysis patterns from a Go configuration file.\n// It is a wrapper around LoadPatternsFromSource.\nfunc LoadPatternsFromConfig(filePath string, logger *slog.Logger, scanner *goscan.Scanner) ([]patterns.Pattern, error) {\n\tconfigSource, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not read patterns config file %q: %w\", filePath, err)\n\t}\n\treturn LoadPatternsFromSource(configSource, logger, scanner)\n}\n\n// LoadPatternsFromSource loads custom analysis patterns from a Go configuration source.\nfunc LoadPatternsFromSource(source []byte, logger *slog.Logger, scanner *goscan.Scanner) ([]patterns.Pattern, error) {\n\t// Step 1: Set up the minigo interpreter.\n\t// The fix in `go-scan`'s locator allows the interpreter to correctly\n\t// resolve imports via `replace` directives.\n\tinterp, err := minigo.NewInterpreter(scanner)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create minigo interpreter: %w\", err)\n\t}\n\n\t// Step 2: Evaluate the script.\n\tif _, err := interp.EvalString(string(source)); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to evaluate patterns config source: %w\", err)\n\t}\n\n\t// Step 3: Extract the 'Patterns' variable from the global environment.\n\tpatternsObj, ok := interp.GlobalEnvForTest().Get(\"Patterns\")\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"could not find 'Patterns' variable in config source\")\n\t}\n\n\t// Step 4: Unmarshal the minigo object directly into a slice of PatternConfig structs.\n\t// This is now possible because the script returns a typed slice instead of []map[string]any.\n\tvar configs []patterns.PatternConfig\n\tresult := minigo.Result{Value: patternsObj}\n\tif err := result.As(&configs); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal 'Patterns' variable into []patterns.PatternConfig: %w\", err)\n\t}\n\n\t// Step 5: Convert the data-only configs into executable patterns.\n\treturn convertConfigsToPatterns(configs, logger, scanner)\n}\n\n// convertConfigsToPatterns translates the user-defined pattern configurations\n// into the internal Pattern format with executable Apply functions.\nfunc convertConfigsToPatterns(configs []patterns.PatternConfig, logger *slog.Logger, scanner *goscan.Scanner) ([]patterns.Pattern, error) {\n\tresult := make([]patterns.Pattern, len(configs))\n\tfor i, config := range configs {\n\t\tc := config\t// capture loop variable\n\n\t\tvar key string\n\t\t// If Fn is provided, derive the key from the function object.\n\t\tif fn, ok := c.Fn.(*object.GoSourceFunction); ok && fn != nil {\n\t\t\tpkgPath := fn.PkgPath\n\t\t\t// The PkgPath from a GoSourceFunction evaluated by minigo tends to be\n\t\t\t// the absolute file path. We need to convert it to a Go import path\n\t\t\t// to match the keys generated by the symgo engine.\n\t\t\tif fn.ModuleDir != \"\" && fn.ModulePath != \"\" {\n\t\t\t\tif strings.HasPrefix(pkgPath, fn.ModuleDir) {\n\t\t\t\t\t// It's a path inside the current module, so construct the import path.\n\t\t\t\t\trelPath, err := filepath.Rel(fn.ModuleDir, pkgPath)\n\t\t\t\t\tif err == nil {\n\t\t\t\t\t\tpkgPath = path.Join(fn.ModulePath, relPath)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tkey = fmt.Sprintf(\"%s.%s\", pkgPath, fn.Fn.Name)\n\t\t} else if mv, ok := c.Fn.(*object.GoMethodValue); ok && mv != nil {\n\t\t\t// Handle method references like (*MyType)(nil).MyMethod\n\t\t\tkey = buildKeyForMethod(mv.Fn, mv.RecvDef)\n\t\t} else if bm, ok := c.Fn.(*object.BoundMethod); ok && bm != nil {\n\t\t\t// Handle method references on an instance, e.g., var v MyType; v.MyMethod\n\t\t\tvar def *object.StructDefinition\n\t\t\tswitch recv := bm.Receiver.(type) {\n\t\t\tcase *object.StructInstance:\n\t\t\t\tdef = recv.Def\n\t\t\tcase *object.Pointer:\n\t\t\t\tif inst, ok := (*recv.Element).(*object.StructInstance); ok {\n\t\t\t\t\tdef = inst.Def\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif def == nil {\n\t\t\t\treturn nil, fmt.Errorf(\"could not determine struct definition from bound method receiver: %T\", bm.Receiver)\n\t\t\t}\n\t\t\tkey = buildKeyForMethod(bm.Fn, def)\n\t\t} else {\n\t\t\tkey = c.Key\n\t\t}\n\n\t\tif key == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"pattern %q requires either a 'Key' string or a 'Fn' reference\", c.Name)\n\t\t}\n\n\t\t// Validate the pattern type string and required fields.\n\t\tswitch c.Type {\n\t\tcase patterns.RequestBody, patterns.ResponseBody, patterns.DefaultResponse:\n\t\t\t// valid\n\t\tcase patterns.CustomResponse:\n\t\t\tif c.StatusCode == \"\" {\n\t\t\t\treturn nil, fmt.Errorf(\"pattern %q: 'StatusCode' is required for type %q\", c.Name, c.Type)\n\t\t\t}\n\t\tcase patterns.PathParameter, patterns.QueryParameter, patterns.HeaderParameter:\n\t\t\t// We can't easily validate that NameArgIndex and ArgIndex are set\n\t\t\t// because 0 is a valid value. The runtime will handle incorrect indices.\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"pattern %q: unknown 'Type' value %q\", c.Name, c.Type)\n\t\t}\n\n\t\tresult[i].Key = key\n\n\t\tswitch c.Type {\n\t\tcase patterns.RequestBody:\n\t\t\tresult[i].Apply = patterns.HandleCustomRequestBody(c.ArgIndex)\n\t\tcase patterns.ResponseBody:\n\t\t\tresult[i].Apply = patterns.HandleCustomResponseBody(c.ArgIndex)\n\t\tcase patterns.CustomResponse:\n\t\t\tresult[i].Apply = patterns.HandleCustomResponse(c.StatusCode, c.ArgIndex)\n\t\tcase patterns.DefaultResponse:\n\t\t\tresult[i].Apply = patterns.HandleDefaultResponse(c.ArgIndex)\n\t\tcase patterns.PathParameter, patterns.QueryParameter, patterns.HeaderParameter:\n\t\t\tresult[i].Apply = patterns.HandleCustomParameter(string(c.Type), c.Description, c.NameArgIndex, c.ArgIndex)\n\t\tdefault:\n\t\t\t// This case should be unreachable due to the validation above\n\t\t\tlogger.Warn(\"unreachable: unknown pattern type\", \"type\", c.Type, \"key\", key)\n\t\t\treturn nil, fmt.Errorf(\"unknown pattern type %q for key %q\", c.Type, key)\n\t\t}\n\t\tlogger.Debug(\"loaded custom pattern\", \"key\", key, \"type\", c.Type, \"argIndex\", c.ArgIndex)\n\t}\n\treturn result, nil\n}\n\n// buildKeyForMethod constructs the fully qualified key for a method.\nfunc buildKeyForMethod(fn *object.Function, def *object.StructDefinition) string {\n\tpkgPath := def.PkgPath\n\tif def.ModuleDir != \"\" && def.ModulePath != \"\" {\n\t\tif strings.HasPrefix(pkgPath, def.ModuleDir) {\n\t\t\trelPath, err := filepath.Rel(def.ModuleDir, pkgPath)\n\t\t\tif err == nil {\n\t\t\t\tpkgPath = path.Join(def.ModulePath, relPath)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Determine if the receiver is a pointer or a value from the method's AST.\n\trecvString := getReceiverString(fn, def)\n\treturn fmt.Sprintf(\"%s.%s.%s\", pkgPath, recvString, fn.Name.Name)\n}\n\n// getReceiverString formats the receiver part of the key, e.g., \"(*MyType)\" or \"MyType\".\nfunc getReceiverString(fn *object.Function, def *object.StructDefinition) string {\n\tif fn.Recv != nil && len(fn.Recv.List) > 0 {\n\t\trecvField := fn.Recv.List[0]\n\t\tif _, isStar := recvField.Type.(*ast.StarExpr); isStar {\n\t\t\treturn fmt.Sprintf(\"(*%s)\", def.Name.Name)\n\t\t}\n\t\treturn def.Name.Name\n\t}\n\t// Fallback, should not happen for valid methods.\n\treturn def.Name.Name\n}\n"
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/examples/docgen/main.go:1:1 source="package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"os\"\n\n\tgoscan \"github.com/podhmo/go-scan\"\n\t\"github.com/podhmo/go-scan/examples/docgen/patterns\"\n\t\"gopkg.in/yaml.v3\"\n)\n\n// stringSlice is a custom type for handling repeatable string flags\ntype stringSlice []string\n\nfunc (s *stringSlice) String() string {\n\treturn fmt.Sprintf(\"%v\", *s)\n}\n\nfunc (s *stringSlice) Set(value string) error {\n\t*s = append(*s, value)\n\treturn nil\n}\n\nfunc main() {\n\tvar (\n\t\tdebug\t\tbool\n\t\tformat\t\tstring\n\t\tpatternsFile\tstring\n\t\tentrypoint\tstring\n\t\textraPkgs\tstringSlice\n\t)\n\tflag.BoolVar(&debug, \"debug\", false, \"Enable debug logging for the analysis\")\n\tflag.StringVar(&format, \"format\", \"json\", \"Output format (json or yaml)\")\n\tflag.StringVar(&patternsFile, \"patterns\", \"\", \"Path to a Go file with custom pattern configurations\")\n\tflag.StringVar(&entrypoint, \"entrypoint\", \"NewServeMux\", \"The entrypoint function name\")\n\tflag.Var(&extraPkgs, \"include-pkg\", \"Specify an external package to treat as internal (can be used multiple times)\")\n\tflag.Parse()\n\n\tlogLevel := slog.LevelInfo\n\tif debug {\n\t\tlogLevel = slog.LevelDebug\n\t}\n\tlogger := slog.New(slog.NewJSONHandler(os.Stderr, &slog.HandlerOptions{Level: logLevel}))\n\n\tif err := run(logger, format, patternsFile, entrypoint, extraPkgs); err != nil {\n\t\tlogger.Error(\"docgen failed\", \"error\", err)\n\t\tos.Exit(1)\n\t}\n}\n\nfunc run(logger *slog.Logger, format string, patternsFile string, entrypoint string, extraPkgs []string) error {\n\tif flag.NArg() == 0 {\n\t\treturn fmt.Errorf(\"required argument: <package-path>\")\n\t}\n\tctx := context.Background()\n\tsampleAPIPath, err := goscan.ResolvePath(ctx, flag.Arg(0))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to resolve package path: %w\", err)\n\t}\n\n\t// Let symgo's interpreter configuration handle which packages are declarations-only.\n\ts, err := goscan.New(\n\t\tgoscan.WithGoModuleResolver(),\n\t\tgoscan.WithLogger(logger),\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcustomPatterns, err := loadCustomPatterns(patternsFile, logger, s)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar opts []any\n\tfor _, p := range customPatterns {\n\t\topts = append(opts, p)\n\t}\n\n\tanalyzer, err := NewAnalyzer(s, logger, extraPkgs, opts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := analyzer.Analyze(ctx, sampleAPIPath, entrypoint); err != nil {\n\t\treturn err\n\t}\n\n\tswitch format {\n\tcase \"json\":\n\t\tenc := json.NewEncoder(os.Stdout)\n\t\tenc.SetIndent(\"\", \"  \")\n\t\treturn enc.Encode(analyzer.OpenAPI)\n\tcase \"yaml\":\n\t\tenc := yaml.NewEncoder(os.Stdout)\n\t\treturn enc.Encode(analyzer.OpenAPI)\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupported format: %q\", format)\n\t}\n}\n\nfunc loadCustomPatterns(filePath string, logger *slog.Logger, scanner *goscan.Scanner) ([]patterns.Pattern, error) {\n\tif filePath == \"\" {\n\t\treturn nil, nil\n\t}\n\tlogger.Info(\"loading custom patterns\", \"file\", filePath)\n\treturn LoadPatternsFromConfig(filePath, logger, scanner)\n}\n"
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.536Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/examples/docgen
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/examples/docgen scanned=true
time=2025-09-18T09:43:11.537Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/minigo/stdlib/math/rand
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/minigo/stdlib/math/rand/install.go:3:1 source="// Code generated by minigo-gen-bindings. DO NOT EDIT.\n\npackage rand\n\nimport (\n\t\"math/rand\"\n\t\"reflect\"\n\n\t\"github.com/podhmo/go-scan/minigo\"\n)\n\n// Install binds all exported symbols from the \"math/rand\" package to the interpreter.\nfunc Install(interp *minigo.Interpreter) {\n\tinterp.Register(\"math/rand\", map[string]any{\n\t\t\"ExpFloat64\":\trand.ExpFloat64,\n\t\t\"Float32\":\trand.Float32,\n\t\t\"Float64\":\trand.Float64,\n\t\t\"Int\":\t\trand.Int,\n\t\t\"Int31\":\trand.Int31,\n\t\t\"Int31n\":\trand.Int31n,\n\t\t\"Int63\":\trand.Int63,\n\t\t\"Int63n\":\trand.Int63n,\n\t\t\"Intn\":\t\trand.Intn,\n\t\t\"New\":\t\trand.New,\n\t\t\"NewSource\":\trand.NewSource,\n\t\t\"NewZipf\":\trand.NewZipf,\n\t\t\"NormFloat64\":\trand.NormFloat64,\n\t\t\"Perm\":\t\trand.Perm,\n\t\t\"Read\":\t\trand.Read,\n\t\t\"Seed\":\t\trand.Seed,\n\t\t\"Shuffle\":\trand.Shuffle,\n\t\t\"Uint32\":\trand.Uint32,\n\t\t\"Uint64\":\trand.Uint64,\n\t\t\"Rand\":\t\treflect.TypeOf((*rand.Rand)(nil)).Elem(),\n\t\t\"Source\":\treflect.TypeOf((*rand.Source)(nil)).Elem(),\n\t\t\"Source64\":\treflect.TypeOf((*rand.Source64)(nil)).Elem(),\n\t\t\"Zipf\":\t\treflect.TypeOf((*rand.Zipf)(nil)).Elem(),\n\t})\n}\n"
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/math/rand
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/minigo/stdlib/math/rand
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/minigo/stdlib/math/rand
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/minigo/stdlib/math/rand types=0
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/math/rand scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/minigo/stdlib/math/rand
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/math/rand scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/minigo/stdlib/math/rand
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: found in cache" exec_pos=/app/symgo/evaluator/evaluator.go:1215 path=github.com/podhmo/go-scan/minigo/stdlib/math/rand scanned=true
time=2025-09-18T09:43:11.537Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/minigo/stdlib/math/rand scanned=true
time=2025-09-18T09:43:11.537Z level=INFO source=/app/examples/find-orphans/main.go:553 msg="** scan package" package=github.com/podhmo/go-scan/scanner
time=2025-09-18T09:43:11.539Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/scanner/models.go:1:1 source="package scanner\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/constant\"\n\t\"go/token\"\n\t\"log/slog\"\n\t\"reflect\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// Context keys for passing information through the resolution process.\ntype (\n\tresolutionPathKey\tstruct{}\n\tloggerKey\t\tstruct{}\n\tinspectKey\t\tstruct{}\n)\n\n// Public context keys to be used by packages like goscan.\nvar (\n\tResolutionPathKey\t= resolutionPathKey{}\n\tLoggerKey\t\t= loggerKey{}\n\tInspectKey\t\t= inspectKey{}\n)\n\n// TypeParamInfo stores information about a single type parameter.\ntype TypeParamInfo struct {\n\tName\t\tstring\t\t`json:\"name\"`\n\tConstraint\t*FieldType\t`json:\"constraint,omitempty\"`\n}\n\n// Kind defines the category of a type definition.\ntype Kind int\n\nconst (\n\tStructKind\tKind\t= iota\n\tAliasKind\n\tFuncKind\n\tInterfaceKind\n\tUnknownKind\n)\n\n// PackageResolver is an interface that can resolve an import path to a package definition.\n// It is implemented by the top-level typescanner.Scanner to enable lazy, cached lookups.\ntype PackageResolver interface {\n\tScanPackageByImport(ctx context.Context, importPath string) (*PackageInfo, error)\n}\n\n// PackageInfo holds all the extracted information from a single package.\ntype PackageInfo struct {\n\tName\t\tstring\n\tPath\t\tstring\n\tImportPath\tstring\t// Added: Canonical import path of the package\n\tModulePath\tstring\t// The go module path this package belongs to.\n\tModuleDir\tstring\t// The absolute path to the module's root directory\n\tFiles\t\t[]string\n\tTypes\t\t[]*TypeInfo\n\tConstants\t[]*ConstantInfo\n\tVariables\t[]*VariableInfo\n\tFunctions\t[]*FunctionInfo\n\tFset\t\t*token.FileSet\t\t// Added: Fileset for position information\n\tAstFiles\tmap[string]*ast.File\t// Added: Parsed AST for each file\n\n\tlookupOnce\tsync.Once\n\tlookup\t\tmap[string]*TypeInfo\n}\n\n// Lookup finds a type by name in the package.\nfunc (p *PackageInfo) Lookup(name string) *TypeInfo {\n\tp.lookupOnce.Do(func() {\n\t\tp.lookup = make(map[string]*TypeInfo, len(p.Types))\n\t\tfor _, t := range p.Types {\n\t\t\tif t != nil {\n\t\t\t\tp.lookup[t.Name] = t\n\t\t\t}\n\t\t}\n\t})\n\treturn p.lookup[name]\n}\n\n// ExternalTypeOverride defines a mapping from a fully qualified type name\n// (e.g., \"time.Time\") to a pre-defined TypeInfo struct.\n// This allows users to provide a \"synthetic\" type definition for certain types,\n// bypassing the need for the scanner to parse them from source. This is particularly\n// useful for standard library types that can cause issues when scanned from\n// within a test binary, or for any type where manual definition is preferred.\n// The key is the fully qualified type name (ImportPath + \".\" + TypeName).\n// The value is a pointer to a scanner.TypeInfo struct that defines the type.\ntype ExternalTypeOverride map[string]*TypeInfo\n\n// Overlay provides a way to replace the contents of a file with alternative content.\n// The key is either a project-relative path (from the module root) or a\n// Go package path concatenated with a file name.\ntype Overlay map[string][]byte\n\n// TypeInfo represents a single type declaration (`type T ...`).\ntype TypeInfo struct {\n\tName\t\tstring\t\t\t`json:\"name\"`\n\tPkgPath\t\tstring\t\t\t`json:\"pkgPath\"`\n\tFilePath\tstring\t\t\t`json:\"filePath\"`\n\tDoc\t\tstring\t\t\t`json:\"doc,omitempty\"`\n\tKind\t\tKind\t\t\t`json:\"kind\"`\n\tTypeParams\t[]*TypeParamInfo\t`json:\"typeParams,omitempty\"`\t// For generic types\n\tNode\t\tast.Node\t\t`json:\"-\"`\t\t\t// Avoid cyclic JSON with Node itself.\n\tStruct\t\t*StructInfo\t\t`json:\"struct,omitempty\"`\n\tFunc\t\t*FunctionInfo\t\t`json:\"func,omitempty\"`\t// For type alias to func type\n\tInterface\t*InterfaceInfo\t\t`json:\"interface,omitempty\"`\n\tUnderlying\t*FieldType\t\t`json:\"underlying,omitempty\"`\t// For alias types\n\n\t// --- Fields for Enum-like patterns ---\n\tIsEnum\t\tbool\t\t`json:\"isEnum,omitempty\"`\t// True if this type is identified as an enum\n\tEnumMembers\t[]*ConstantInfo\t`json:\"enumMembers,omitempty\"`\t// List of constants belonging to this enum type\n\n\t// --- Fields for inspect mode ---\n\tInspect\t\t\tbool\t\t`json:\"-\"`\t\t\t// Flag to enable inspection logging\n\tLogger\t\t\t*slog.Logger\t`json:\"-\"`\t\t\t// Logger for inspection\n\tFset\t\t\t*token.FileSet\t`json:\"-\"`\t\t\t// Fileset for position information\n\tResolutionContext\tcontext.Context\t`json:\"-\"`\t\t\t// Context for resolving nested types\n\tUnresolved\t\tbool\t\t`json:\"unresolved,omitempty\"`\t// True if the type is from a package that was not scanned.\n}\n\n// NewUnresolvedTypeInfo creates a new TypeInfo placeholder for a type that is\n// intentionally not being scanned or resolved. This is used by higher-level\n// tools like symgo to represent types from packages outside a defined scan policy.\nfunc NewUnresolvedTypeInfo(pkgPath, name string) *TypeInfo {\n\treturn &TypeInfo{\n\t\tPkgPath:\tpkgPath,\n\t\tName:\t\tname,\n\t\tUnresolved:\ttrue,\n\t\tKind:\t\tUnknownKind,\n\t}\n}\n\n// Annotation extracts the value of a specific annotation from the TypeInfo's Doc string.\n// Annotations are expected to be in the format \"@<name>[:<value>]\" or \"@<name> <value>\".\n// If inspect mode is enabled, it logs the checking process.\nfunc (ti *TypeInfo) Annotation(ctx context.Context, name string) (value string, ok bool) {\n\t// The core annotation searching logic.\n\tsearchValue, found := ti.searchAnnotation(name)\n\n\t// If inspect mode is off, just return the result.\n\tif !ti.Inspect || ti.Logger == nil {\n\t\treturn searchValue, found\n\t}\n\n\t// Prepare structured logging fields.\n\tlogArgs := []any{\n\t\tslog.String(\"component\", \"go-scan\"),\n\t\tslog.String(\"type_name\", ti.Name),\n\t\tslog.String(\"type_pkg_path\", ti.PkgPath),\n\t\tslog.String(\"annotation_name\", \"@\"+name),\n\t}\n\tif ti.Node != nil && ti.Fset != nil {\n\t\tpos := ti.Fset.Position(ti.Node.Pos())\n\t\tlogArgs = append(logArgs, slog.String(\"type_file_path\", fmt.Sprintf(\"%s:%d:%d\", pos.Filename, pos.Line, pos.Column)))\n\t}\n\n\t// Log the result of the check.\n\tif found {\n\t\tlogArgs = append(logArgs, slog.String(\"annotation_value\", searchValue))\n\t\tti.Logger.InfoContext(ctx, \"found annotation\", logArgs...)\n\t} else {\n\t\tlogArgs = append(logArgs, slog.String(\"result\", \"miss\"))\n\t\tti.Logger.DebugContext(ctx, \"checking for annotation\", logArgs...)\n\t}\n\n\treturn searchValue, found\n}\n\n// searchAnnotation is the core logic for finding an annotation, separated to keep the main Annotation method clean.\nfunc (ti *TypeInfo) searchAnnotation(name string) (value string, ok bool) {\n\tif ti.Doc == \"\" {\n\t\treturn \"\", false\n\t}\n\tlines := strings.Split(ti.Doc, \"\\n\")\n\tprefix := \"@\" + name\n\tfor _, line := range lines {\n\t\ttrimmedLine := strings.TrimSpace(line)\n\t\ttrimmedLine = strings.TrimPrefix(trimmedLine, \"//\")\n\t\ttrimmedLine = strings.TrimPrefix(trimmedLine, \"/*\")\n\t\ttrimmedLine = strings.TrimSuffix(trimmedLine, \"*/\")\n\t\ttrimmedLine = strings.TrimSpace(trimmedLine)\n\n\t\tif !strings.HasPrefix(trimmedLine, prefix) {\n\t\t\tcontinue\n\t\t}\n\n\t\trest := trimmedLine[len(prefix):]\n\n\t\tif rest != \"\" {\n\t\t\tfirstChar := rest[0]\n\t\t\tif firstChar != ':' && firstChar != ' ' && firstChar != '\\t' {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tok = true\n\t\tvalue = strings.TrimSpace(rest)\n\t\tif len(value) > 0 && value[0] == ':' {\n\t\t\tvalue = strings.TrimSpace(value[1:])\n\t\t}\n\t\treturn value, ok\n\t}\n\treturn \"\", false\n}\n\n// InterfaceInfo represents an interface type.\ntype InterfaceInfo struct {\n\tMethods\t[]*MethodInfo\t`json:\"methods\"`\n\t// Embedded stores the field types for embedded interfaces.\n\t// The symgo evaluator is responsible for resolving these and collecting\n\t// their method sets. Resolution is currently supported for interfaces\n\t// within the same package.\n\tEmbedded\t[]*FieldType\t`json:\"embedded,omitempty\"`\n}\n\n// MethodInfo represents a single method in an interface.\ntype MethodInfo struct {\n\tName\t\tstring\n\tParameters\t[]*FieldInfo\n\tResults\t\t[]*FieldInfo\n\t// We might need position or AST node info later if generating code that needs to refer back to the source.\n}\n\n// StructInfo represents a struct type.\ntype StructInfo struct {\n\tFields []*FieldInfo\n}\n\n// FieldInfo represents a single field in a struct or a parameter/result in a function.\ntype FieldInfo struct {\n\tName\t\tstring\n\tDoc\t\tstring\n\tType\t\t*FieldType\n\tTag\t\tstring\n\tEmbedded\tbool\n\tIsExported\tbool\t// True if the field is exported (starts with an uppercase letter).\n}\n\n// TagValue extracts the value associated with the given tagName from the struct tag.\n// If the tag value contains a comma (e.g., \"name,omitempty\"), only the part before the comma is returned.\n// Returns an empty string if the tag is not present or malformed.\nfunc (fi *FieldInfo) TagValue(tagName string) string {\n\tif fi.Tag == \"\" {\n\t\treturn \"\"\n\t}\n\ttag := reflect.StructTag(fi.Tag)\n\ttagVal := tag.Get(tagName)\n\tif commaIdx := strings.Index(tagVal, \",\"); commaIdx != -1 {\n\t\treturn tagVal[:commaIdx]\n\t}\n\treturn tagVal\n}\n\n// FieldType represents the type of a field.\ntype FieldType struct {\n\tName\t\tstring\t\t`json:\"name\"`\n\tPkgName\t\tstring\t\t`json:\"pkgName,omitempty\"`\t// e.g., \"json\", \"models\"\n\tMapKey\t\t*FieldType\t`json:\"mapKey,omitempty\"`\t// For map types\n\tElem\t\t*FieldType\t`json:\"elem,omitempty\"`\t\t// For slice, map, pointer, array types\n\tIsPointer\tbool\t\t`json:\"isPointer,omitempty\"`\n\tIsSlice\t\tbool\t\t`json:\"isSlice,omitempty\"`\n\tIsMap\t\tbool\t\t`json:\"isMap,omitempty\"`\n\tIsChan\t\tbool\t\t`json:\"isChan,omitempty\"`\n\tIsTypeParam\tbool\t\t`json:\"isTypeParam,omitempty\"`\t// True if this FieldType refers to a type parameter\n\tIsConstraint\tbool\t\t`json:\"isConstraint,omitempty\"`\t// True if this FieldType represents a type constraint\n\tTypeArgs\t[]*FieldType\t`json:\"typeArgs,omitempty\"`\t// For instantiated generic types, e.g., T in List[T]\n\n\tDefinition\t\t*TypeInfo\t`json:\"-\"`\t// Caches the resolved type definition. Avoid cyclic JSON.\n\tIsResolvedByConfig\tbool\t\t`json:\"isResolvedByConfig,omitempty\"`\n\tIsBuiltin\t\tbool\t\t`json:\"isBuiltin,omitempty\"`\n\n\t// Resolver, FullImportPath, and TypeName are used for on-demand package scanning.\n\t// They are exported to allow consumers of the library to construct a resolvable\n\t// FieldType manually, for instance when parsing type information from an\n\t// annotation rather than from a Go AST node.\n\tResolver\tPackageResolver\t`json:\"-\"`\t// For lazy-loading the type definition.\n\tFullImportPath\tstring\t\t`json:\"-\"`\t// Full import path of the type, e.g., \"example.com/project/models\".\n\tTypeName\tstring\t\t`json:\"-\"`\t// The name of the type within its package, e.g., \"User\".\n\tCurrentPkg\t*PackageInfo\t`json:\"-\"`\t// Reference to the package where this type is used.\n}\n\n// Resolve finds and returns the full definition of the type.\n// It uses the PackageResolver to parse other packages on-demand.\n// The result is cached for subsequent calls.\n\n// String returns the Go string representation of the field type.\n// e.g., \"*pkgname.MyType\", \"[]string\", \"map[string]int\", \"MyType[string]\"\nfunc (ft *FieldType) String() string {\n\tif ft == nil {\n\t\treturn \"<nil_FieldType>\"\n\t}\n\tvar sb strings.Builder\n\n\tif ft.IsPointer {\n\t\tsb.WriteString(\"*\")\n\t\t// For pointers, the current parsing for StarExpr in parseTypeExpr does:\n\t\t//   underlyingType := s.parseTypeExpr(t.X, currentTypeParams)\n\t\t//   underlyingType.IsPointer = true\n\t\t//   return underlyingType\n\t\t// This means `underlyingType` (which is `ft` here) *is* the element type, but marked as a pointer.\n\t\t// So, we write \"*\" and then format `ft` as if it's not a pointer for the rest of its structure.\n\t\t// ft.Elem is primarily for slice/map element types.\n\t}\n\n\tif ft.IsSlice {\n\t\tsb.WriteString(\"[]\")\n\t\tif ft.Elem != nil {\n\t\t\tsb.WriteString(ft.Elem.String())\t// Recursive call for element type\n\t\t} else {\n\t\t\t// This case should ideally not happen for valid Go code.\n\t\t\tsb.WriteString(\"interface{}\")\t// Fallback\n\t\t}\n\t\treturn sb.String()\t// Slice representation is complete\n\t}\n\n\tif ft.IsMap {\n\t\tsb.WriteString(\"map[\")\n\t\tif ft.MapKey != nil {\n\t\t\tsb.WriteString(ft.MapKey.String())\n\t\t} else {\n\t\t\tsb.WriteString(\"interface{}\")\t// Fallback\n\t\t}\n\t\tsb.WriteString(\"]\")\n\t\tif ft.Elem != nil {\n\t\t\tsb.WriteString(ft.Elem.String())\n\t\t} else {\n\t\t\tsb.WriteString(\"interface{}\")\t// Fallback\n\t\t}\n\t\treturn sb.String()\t// Map representation is complete\n\t}\n\n\t// Named types, primitives, or type parameters\n\tname := ft.Name\n\tif ft.PkgName != \"\" && !ft.IsTypeParam {\t// Type parameters don't have package names like \"pkg.T\"\n\t\t// For qualified types like \"pkg.MyType\"\n\t\t// ft.Name might already be \"pkg.MyType\" if parsed from SelectorExpr.\n\t\t// Or ft.Name is \"MyType\" and ft.PkgName is \"pkg\".\n\t\t// Prefer ft.TypeName if available (set by SelectorExpr parsing for the base name).\n\t\tactualName := ft.Name\n\t\tif ft.TypeName != \"\" {\n\t\t\tactualName = ft.TypeName\n\t\t}\n\t\tname = fmt.Sprintf(\"%s.%s\", ft.PkgName, actualName)\n\t}\n\tsb.WriteString(name)\n\n\t// Append type arguments if any, e.g., MyType[T, U]\n\tif len(ft.TypeArgs) > 0 {\n\t\tsb.WriteString(\"[\")\n\t\tfor i, typeArg := range ft.TypeArgs {\n\t\t\tif i > 0 {\n\t\t\t\tsb.WriteString(\", \")\n\t\t\t}\n\t\t\tsb.WriteString(typeArg.String())\n\t\t}\n\t\tsb.WriteString(\"]\")\n\t}\n\n\treturn sb.String()\n}\n\nfunc (ft *FieldType) Resolve(ctx context.Context) (*TypeInfo, error) {\n\t// If the definition is already cached (e.g. from an override), return it.\n\tif ft.Definition != nil {\n\t\treturn ft.Definition, nil\n\t}\n\n\t// For pointer types, try to resolve the element first. If the element is\n\t// resolved (e.g., by an override), the pointer itself is considered resolved.\n\t// This prevents unnecessary package scanning for pointers to overridden types.\n\tif ft.IsPointer && ft.Elem != nil {\n\t\telemDef, err := ft.Elem.Resolve(ctx)\n\t\tif err != nil {\n\t\t\t// Return the error, but wrap it to provide context.\n\t\t\treturn nil, fmt.Errorf(\"could not resolve pointer element for %s: %w\", ft.String(), err)\n\t\t}\n\t\t// If the element's resolution returned a definition, the pointer is resolved.\n\t\t// A pointer's definition is its element's definition.\n\t\tif elemDef != nil {\n\t\t\tft.Definition = elemDef\t// Cache the result\n\t\t\treturn elemDef, nil\n\t\t}\n\t\t// If the element is a built-in type (like *string), it resolves to a nil TypeInfo.\n\t\t// In this case, the pointer is also considered resolved.\n\t\tif ft.Elem.IsBuiltin {\n\t\t\treturn nil, nil\n\t\t}\n\t}\n\n\tif ft.IsBuiltin {\n\t\t// Built-in types like 'string' do not have a full TypeInfo definition, so we return nil.\n\t\t// The caller can inspect ft.IsBuiltin if it needs to differentiate.\n\t\treturn nil, nil\n\t}\n\tif ft.Resolver == nil {\n\t\treturn nil, fmt.Errorf(\"type %q cannot be resolved: no resolver available\", ft.Name)\n\t}\n\t// Check for local types (they have no PkgName) before attempting cross-package resolution.\n\tif ft.PkgName == \"\" {\n\t\t// This is a type from the same package.\n\t\tif ft.CurrentPkg == nil {\n\t\t\t// This can happen if a FieldType is constructed manually without setting the package context.\n\t\t\treturn nil, fmt.Errorf(\"cannot resolve local type %q: current package context is missing\", ft.TypeName)\n\t\t}\n\t\t// Look up the type in the current package's type map.\n\t\ttypeInfo := ft.CurrentPkg.Lookup(ft.TypeName)\n\t\tif typeInfo == nil {\n\t\t\t// Built-in types (like 'string') and type parameters (like 'T' in generics)\n\t\t\t// are parsed as local types with no PkgName, but they don't have a TypeInfo definition.\n\t\t\t// They are not an error.\n\t\t\tif ft.IsBuiltin || ft.IsTypeParam {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\t// The type was not found in the current package. This is the error we want.\n\t\t\treturn nil, fmt.Errorf(\"could not resolve type %q in package %q\", ft.TypeName, ft.CurrentPkg.ImportPath)\n\t\t}\n\t\t// Type was found locally.\n\t\tft.Definition = typeInfo\n\t\treturn typeInfo, nil\n\t}\n\n\t// Extract logger, inspect flag, and current resolution path from context.\n\tlogger, _ := ctx.Value(LoggerKey).(*slog.Logger)\n\tinspect, _ := ctx.Value(InspectKey).(bool)\n\tpath, _ := ctx.Value(ResolutionPathKey).([]string)\n\tif path == nil {\n\t\tpath = []string{}\t// Should not happen if called via designated entry points.\n\t}\n\n\ttypeIdentifier := ft.FullImportPath + \".\" + ft.TypeName\n\n\t// --- Cycle Detection ---\n\tfor _, p := range path {\n\t\tif p == typeIdentifier {\n\t\t\treturn nil, nil\t// Cycle detected.\n\t\t}\n\t}\n\n\t// --- Logging (if inspect mode is on) ---\n\tif inspect && logger != nil {\n\t\tlogger.DebugContext(ctx, \"resolving type\",\n\t\t\t\"type\", typeIdentifier,\n\t\t\t\"resolution_path\", path,\n\t\t)\n\t}\n\n\t// --- Resolve the package ---\n\tpkgInfo, err := ft.Resolver.ScanPackageByImport(ctx, ft.FullImportPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to scan package %q for type %q: %w\", ft.FullImportPath, ft.TypeName, err)\n\t}\n\n\ttypeInfo := pkgInfo.Lookup(ft.TypeName)\n\tif typeInfo == nil {\n\t\treturn nil, fmt.Errorf(\"type %q not found in package %q\", ft.TypeName, ft.FullImportPath)\n\t}\n\n\t// --- Success ---\n\tif inspect && logger != nil {\n\t\tlogger.InfoContext(ctx, \"resolved type\",\n\t\t\t\"type\", typeIdentifier,\n\t\t\t\"resolution_path\", path,\n\t\t)\n\t}\n\n\t// --- Prepare context for child resolutions ---\n\tnewPath := append(path, typeIdentifier)\n\tchildCtx := context.WithValue(ctx, ResolutionPathKey, newPath)\n\t// Propagate other necessary values.\n\tif logger != nil {\n\t\tchildCtx = context.WithValue(childCtx, LoggerKey, logger)\n\t}\n\tchildCtx = context.WithValue(childCtx, InspectKey, inspect)\n\n\ttypeInfo.ResolutionContext = childCtx\n\ttypeInfo.Logger = logger\n\ttypeInfo.Inspect = inspect\n\n\tft.Definition = typeInfo\t// Cache the result.\n\treturn typeInfo, nil\n}\n\n// ConstantInfo represents a single top-level constant declaration.\ntype ConstantInfo struct {\n\tName\t\tstring\n\tFilePath\tstring\t// Added: Absolute path to the file where this const is defined\n\tDoc\t\tstring\n\tType\t\t*FieldType\t// Changed from string to *FieldType\n\tValue\t\tstring\n\tRawValue\tstring\t\t// The raw, unquoted string value, if the constant is a string.\n\tIsExported\tbool\t\t// Added to indicate if the constant is exported\n\tNode\t\tast.Node\t// Added: AST node for position, if needed, though FilePath is primary\n\tConstVal\tconstant.Value\n\tIotaValue\tint\t// The value of iota for the spec this constant was in.\n\tValExpr\t\tast.Expr\n}\n\n// VariableInfo represents a single top-level variable declaration.\ntype VariableInfo struct {\n\tName\t\tstring\n\tFilePath\tstring\n\tDoc\t\tstring\n\tType\t\t*FieldType\n\tIsExported\tbool\n\tNode\t\tast.Node\n\tGenDecl\t\t*ast.GenDecl\t// The *ast.GenDecl node for the var declaration\n}\n\n// FunctionInfo represents a single top-level function or method declaration.\ntype FunctionInfo struct {\n\tName\t\tstring\t\t\t`json:\"name\"`\n\tFilePath\tstring\t\t\t`json:\"filePath\"`\n\tDoc\t\tstring\t\t\t`json:\"doc,omitempty\"`\n\tReceiver\t*FieldInfo\t\t`json:\"receiver,omitempty\"`\n\tTypeParams\t[]*TypeParamInfo\t`json:\"typeParams,omitempty\"`\t// For generic functions\n\tParameters\t[]*FieldInfo\t\t`json:\"parameters,omitempty\"`\n\tResults\t\t[]*FieldInfo\t\t`json:\"results,omitempty\"`\n\tIsVariadic\tbool\t\t\t`json:\"isVariadic,omitempty\"`\n\tAstDecl\t\t*ast.FuncDecl\t\t`json:\"-\"`\t// Avoid cyclic JSON.\n}\n\n// SetResolver is a test helper to overwrite the internal resolver.\nfunc (ft *FieldType) SetResolver(r PackageResolver) {\n\tft.Resolver = r\n}\n\n// var _ = strings.Builder{} // This helper is no longer needed as \"strings\" is directly imported.\n\n// PackageImports holds the minimal information about a package's direct imports.\ntype PackageImports struct {\n\tName\t\tstring\n\tImportPath\tstring\n\tImports\t\t[]string\n\tFileImports\tmap[string][]string\t// file path -> import paths\n}\n\n// Visitor defines the interface for operations to be performed at each node\n// during a dependency graph walk.\ntype Visitor interface {\n\t// Visit is called for each package discovered during the walk.\n\t// It can inspect the package's imports and return the list of\n\t// imports that the walker should follow next. Returning an empty\n\t// slice stops the traversal from that node.\n\tVisit(pkg *PackageImports) (importsToFollow []string, err error)\n}\n\n// ModuleInfo holds information about a single Go module in a workspace.\ntype ModuleInfo struct {\n\tPath\tstring\t// The module path (e.g., \"github.com/podhmo/go-scan\").\n\tDir\tstring\t// The absolute path to the module's root directory.\n}\n"
time=2025-09-18T09:43:11.539Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="getOrLoadPackage: requesting package" exec_pos=/app/symgo/evaluator/evaluator.go:1213 path=github.com/podhmo/go-scan/scanner
time=2025-09-18T09:43:11.539Z level=DEBUG source=/app/symgo/evaluator/resolver.go:156 msg="ResolvePackage: checking policy" path=github.com/podhmo/go-scan/scanner
time=2025-09-18T09:43:11.539Z level=DEBUG source=/app/symgo/evaluator/resolver.go:161 msg="ResolvePackage: allowed by policy, scanning" path=github.com/podhmo/go-scan/scanner
time=2025-09-18T09:43:11.539Z level=DEBUG source=/app/goscan.go:974 msg="ScanPackageByImport CACHE HIT" importPath=github.com/podhmo/go-scan/scanner types=25
time=2025-09-18T09:43:11.539Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/scanner scanned=true
time=2025-09-18T09:43:11.539Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:1267 msg="populating package-level constants" package=github.com/podhmo/go-scan/scanner
time=2025-09-18T09:43:11.540Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:2906 msg="ensurePackageEnvPopulated: checking package" exec_pos=/app/symgo/evaluator/evaluator.go:1253 path=github.com/podhmo/go-scan/scanner scanned=true
time=2025-09-18T09:43:11.540Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/scanner/models.go:24:22 source=resolutionPathKey{}
time=2025-09-18T09:43:11.540Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/scanner/models.go:25:22 source=loggerKey{}
time=2025-09-18T09:43:11.540Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.CompositeLit pos=/app/scanner/models.go:26:22 source=inspectKey{}
time=2025-09-18T09:43:11.543Z level=DEBUG source=/app/symgo/evaluator/evaluator.go:251 msg="evaluating node" type=*ast.File pos=/app/scanner/scanner.go:1:1 source="package scanner\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/constant\"\n\t\"go/parser\"\n\t\"go/token\"\n\t\"log/slog\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"golang.org/x/sync/errgroup\"\n)\n\n// resolutionCacheKey is used to pass a map for tracking in-progress type resolutions.\ntype resolutionCacheKey struct{}\n\n// fileParseResult holds the result of parsing a single Go source file.\ntype fileParseResult struct {\n\tfilePath\tstring\n\tfileAst\t\t*ast.File\n\terr\t\terror\n}\n\n// Scanner parses Go source files within