# Troubleshooting `symgo` Infinite Symbolic Recursion Issue

This document details the investigation and analysis of an infinite recursion issue within the `symgo` symbolic execution engine, which occurred during the execution of the `find-orphans` tool.

## 1. Problem Overview

When running the `find-orphans` tool, it crashes while analyzing code with recursive data structures. A detailed analysis of the logs reveals an infinite symbolic recursion occurring when the `symgo` evaluator is asked to analyze the `scanner.FieldType.String()` method.

The core issue is a failure in `symgo`'s recursion detection mechanism when dealing with methods on cyclically defined data structures.

## 2. The Symbolic Call Stack

A critical piece of evidence is the log's call stack. **This is not a Go runtime stack trace; it is a symbolic call stack generated by the `symgo` evaluator's own logging.**

```
stack.5.func=String
stack.5.pos=$HOME/ghq/github.com/podhmo/go-scan/scanner/models.go:307:19
stack.6.func=String
stack.6.pos=$HOME/ghq/github.com/podhmo/go-scan/scanner/models.go:307:19
...
```

This trace indicates that `symgo`'s `applyFunction` is symbolically evaluating the `String` method. The evaluation of this method leads to another symbolic call to `String`, creating an infinite loop within the evaluator itself.

## 3. Detailed Cause Analysis

The infinite recursion is caused by the following chain of events:

### Step 1: `symgo` Creates a Cyclic `FieldType`

When `symgo` analyzes code with a recursive type definition (e.g., `type T []*T`), it generates `scanner.FieldType` objects to represent the types of intermediate values. To faithfully model the recursive nature of the type, this process creates a data structure in memory where a `FieldType`'s `Elem` field can point back to a `FieldType` that is structurally identical to itself, thus creating a cycle. This part of the behavior is correct.

### Step 2: A Symbolic Call to the `String()` Method

During its analysis, a tool like `find-orphans` may need the string representation of a type, triggering a symbolic evaluation of the `(*scanner.FieldType).String()` method on one of these cyclically defined `FieldType` objects.

### Step 3: Infinite Loop in the Symbolic Evaluator

1.  `symgo` begins evaluating `ft.String()`.
2.  Inside the body of the `String()` method, the evaluator encounters the expression `ft.Elem.String()`.
3.  To handle this, the evaluator must now start a *new* symbolic evaluation of the `String()` method, this time with `ft.Elem` as the receiver.
4.  Because `ft` is a cyclic structure, `ft.Elem` is effectively the same as `ft`. This leads the evaluator into a loop: `eval(ft.String())` -> `eval(ft.Elem.String())` -> `eval(ft.Elem.Elem.String())` and so on.

### Step 4: Failure of Recursion Bounding

The `symgo` evaluator has a "bounded recursion" mechanism in `applyFunction` designed to prevent such loops. It checks if the same function definition is being called on the same receiver object.

The failure occurs because while the function being called (`String`) is the same, the receiver object (`*scanner.FieldType`) for each step in the symbolic recursion might be a different Go object instance in memory, even if they are structurally identical. The check `frame.Fn.Receiver == f.Receiver` likely fails because it compares pointers, not the deep structure of the objects. As a result, the evaluator does not detect the recursion, and its internal symbolic call stack grows indefinitely, leading to a crash.

## 4. Conclusion

The root cause of the crash is a **failure in `symgo`'s symbolic recursion detection logic**. The engine does not correctly identify a recursive method evaluation when the receiver objects are different instances of a cyclically defined data structure. This allows the symbolic evaluation to loop infinitely, consuming resources until it fails.

The problem is not a Go runtime stack overflow within the `String()` method itself, but an infinite loop within the `symgo` evaluator that is trying to analyze that method.
