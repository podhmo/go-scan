// Code generated by go-scan for package converter. DO NOT EDIT.

package converter

import (
	"context"
	destination "example.com/convert/models/destination"
	source "example.com/convert/models/source"
)

// ConvertSrcUserToDstUser converts SrcUser to DstUser.
func ConvertSrcUserToDstUser(ctx context.Context, src source.SrcUser) (destination.DstUser, error) {
	dst := convertSrcUserToDstUser(ctx, src)
	return dst, nil
}

// convertSrcUserToDstUser is the internal conversion function.
func convertSrcUserToDstUser(ctx context.Context, src source.SrcUser) destination.DstUser {
	dst := destination.DstUser{}

	if src.Details != nil {
		newSlice := make([]DstInternalDetail, 0, len(src.Details))
		for _, elem := range src.Details {
			newSlice = append(newSlice, elem)
		}
		dst.Details = newSlice
	}
	dst.CreatedAt = src.CreatedAt
	if src.UpdatedAt != nil {
		dst.UpdatedAt = *src.UpdatedAt
	}
	return dst
}

// ConvertSrcOrderToDstOrder converts SrcOrder to DstOrder.
func ConvertSrcOrderToDstOrder(ctx context.Context, src source.SrcOrder) (destination.DstOrder, error) {
	dst := convertSrcOrderToDstOrder(ctx, src)
	return dst, nil
}

// convertSrcOrderToDstOrder is the internal conversion function.
func convertSrcOrderToDstOrder(ctx context.Context, src source.SrcOrder) destination.DstOrder {
	dst := destination.DstOrder{}
	return dst
}

// ConvertComplexSourceToComplexTarget converts ComplexSource to ComplexTarget.
func ConvertComplexSourceToComplexTarget(ctx context.Context, src source.ComplexSource) (destination.ComplexTarget, error) {
	dst := convertComplexSourceToComplexTarget(ctx, src)
	return dst, nil
}

// convertComplexSourceToComplexTarget is the internal conversion function.
func convertComplexSourceToComplexTarget(ctx context.Context, src source.ComplexSource) destination.ComplexTarget {
	dst := destination.ComplexTarget{}
	dst.Value = src.Value
	if src.Ptr != nil {
		tmp := *src.Ptr
		dst.Ptr = &tmp
	}

	if src.Slice != nil {
		newSlice := make([]SubTarget, 0, len(src.Slice))
		for _, elem := range src.Slice {
			newSlice = append(newSlice, elem)
		}
		dst.Slice = newSlice
	}

	if src.SliceOfPtrs != nil {
		newSlice := make([]*SubTarget, 0, len(src.SliceOfPtrs))
		for _, elem := range src.SliceOfPtrs {
			if elem != nil {
				tmp := *elem
				newSlice = append(newSlice, &tmp)
			}
		}
		dst.SliceOfPtrs = newSlice
	}
	return dst
}
