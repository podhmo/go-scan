// Code generated by convert. DO NOT EDIT.
package generated

import (
	"context"
	"errors"
	"fmt"

	convutil "github.com/podhmo/go-scan/examples/convert/convutil"
	"github.com/podhmo/go-scan/examples/convert/model"
	destination "github.com/podhmo/go-scan/examples/convert/sampledata/destination"
	source "github.com/podhmo/go-scan/examples/convert/sampledata/source"
)

func convertSrcUserToDstUser(ctx context.Context, ec *model.ErrorCollector, src *source.SrcUser) *destination.DstUser {
	if src == nil {
		return nil
	}
	dst := &destination.DstUser{}
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("Details")
	{
		convertedSlice := make([]destination.DstInternalDetail, len(src.Details))
		for i, item := range src.Details {
			ec.Enter(fmt.Sprintf("[%d]", i))
			convertedSlice[i] = *convertSrcInternalDetailToDstInternalDetail(ctx, ec, &item)
			ec.Leave()
		}
		dst.Details = convertedSlice
	}

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("CreatedAt")
	dst.CreatedAt = convutil.TimeToString(ctx, ec, src.CreatedAt)

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("UpdatedAt")
	dst.UpdatedAt = convutil.PtrTimeToString(ctx, ec, src.UpdatedAt)

	ec.Leave()
	return dst
}

// ConvertSrcUserToDstUser converts source.SrcUser to destination.DstUser.
//
// Fields that are not populated by this converter:
//   - Address
//   - Contact
//   - FullName
//   - UserID
func ConvertSrcUserToDstUser(ctx context.Context, src *source.SrcUser) (*destination.DstUser, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSrcUserToDstUser(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
func convertSrcOrderToDstOrder(ctx context.Context, ec *model.ErrorCollector, src *source.SrcOrder) *destination.DstOrder {
	if src == nil {
		return nil
	}
	dst := &destination.DstOrder{}
	return dst
}

// ConvertSrcOrderToDstOrder converts source.SrcOrder to destination.DstOrder.
//
// Fields that are not populated by this converter:
//   - ID
//   - LineItems
//   - TotalAmount
func ConvertSrcOrderToDstOrder(ctx context.Context, src *source.SrcOrder) (*destination.DstOrder, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSrcOrderToDstOrder(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
func convertComplexSourceToComplexTarget(ctx context.Context, ec *model.ErrorCollector, src *source.ComplexSource) *destination.ComplexTarget {
	if src == nil {
		return nil
	}
	dst := &destination.ComplexTarget{}
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("Value")
	dst.Value = src.Value

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("Ptr")
	if src.Ptr != nil {
		tmp := (*src.Ptr)
		dst.Ptr = &tmp
	} else {
		dst.Ptr = nil
	}

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("Slice")
	{
		convertedSlice := make([]destination.SubTarget, len(src.Slice))
		for i, item := range src.Slice {
			ec.Enter(fmt.Sprintf("[%d]", i))
			convertedSlice[i] = *convertSubSourceToSubTarget(ctx, ec, &item)
			ec.Leave()
		}
		dst.Slice = convertedSlice
	}

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("SliceOfPtrs")
	{
		convertedSlice := make([]*destination.SubTarget, len(src.SliceOfPtrs))
		for i, item := range src.SliceOfPtrs {
			ec.Enter(fmt.Sprintf("[%d]", i))
			convertedSlice[i] = convertSubSourceToSubTarget(ctx, ec, item)
			ec.Leave()
		}
		dst.SliceOfPtrs = convertedSlice
	}

	ec.Leave()
	return dst
}

// ConvertComplexSourceToComplexTarget converts source.ComplexSource to destination.ComplexTarget.
//
// Fields that are not populated by this converter:
func ConvertComplexSourceToComplexTarget(ctx context.Context, src *source.ComplexSource) (*destination.ComplexTarget, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertComplexSourceToComplexTarget(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
func convertSourceWithMapToTargetWithMap(ctx context.Context, ec *model.ErrorCollector, src *source.SourceWithMap) *destination.TargetWithMap {
	if src == nil {
		return nil
	}
	dst := &destination.TargetWithMap{}
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("ValueMap")
	{
		convertedMap := make(map[string]destination.SubTarget, len(src.ValueMap))
		for key, value := range src.ValueMap {
			ec.Enter(fmt.Sprintf("[%v]", key))
			convertedMap[key] = *convertSubSourceToSubTarget(ctx, ec, &value)
			ec.Leave()
		}
		dst.ValueMap = convertedMap
	}

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("PtrMap")
	{
		convertedMap := make(map[string]*destination.SubTarget, len(src.PtrMap))
		for key, value := range src.PtrMap {
			ec.Enter(fmt.Sprintf("[%v]", key))
			convertedMap[key] = convertSubSourceToSubTarget(ctx, ec, value)
			ec.Leave()
		}
		dst.PtrMap = convertedMap
	}

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("StringToStr")
	{
		convertedMap := make(map[string]string, len(src.StringToStr))
		for key, value := range src.StringToStr {
			ec.Enter(fmt.Sprintf("[%v]", key))
			convertedMap[key] = value
			ec.Leave()
		}
		dst.StringToStr = convertedMap
	}

	ec.Leave()
	return dst
}

// ConvertSourceWithMapToTargetWithMap converts source.SourceWithMap to destination.TargetWithMap.
//
// Fields that are not populated by this converter:
func ConvertSourceWithMapToTargetWithMap(ctx context.Context, src *source.SourceWithMap) (*destination.TargetWithMap, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSourceWithMapToTargetWithMap(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
func convertSrcInternalDetailToDstInternalDetail(ctx context.Context, ec *model.ErrorCollector, src *source.SrcInternalDetail) *destination.DstInternalDetail {
	if src == nil {
		return nil
	}
	dst := &destination.DstInternalDetail{}
	return dst
}

// ConvertSrcInternalDetailToDstInternalDetail converts source.SrcInternalDetail to destination.DstInternalDetail.
//
// Fields that are not populated by this converter:
//   - ItemCode
//   - LocalizedDesc
func ConvertSrcInternalDetailToDstInternalDetail(ctx context.Context, src *source.SrcInternalDetail) (*destination.DstInternalDetail, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSrcInternalDetailToDstInternalDetail(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
func convertSubSourceToSubTarget(ctx context.Context, ec *model.ErrorCollector, src *source.SubSource) *destination.SubTarget {
	if src == nil {
		return nil
	}
	dst := &destination.SubTarget{}
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("Value")
	dst.Value = src.Value

	ec.Leave()
	return dst
}

// ConvertSubSourceToSubTarget converts source.SubSource to destination.SubTarget.
//
// Fields that are not populated by this converter:
func ConvertSubSourceToSubTarget(ctx context.Context, src *source.SubSource) (*destination.SubTarget, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSubSourceToSubTarget(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
