package generator

import (
	"bytes"
	"context"
	"fmt"
	"go/format"
	"strings"
	"text/template"

	"example.com/convert/parser"
	"github.com/podhmo/go-scan"
	"github.com/podhmo/go-scan/scanner"
)

const codeTemplate = `
import (
	"context"
	{{- range $path, $alias := .Imports }}
	{{ $alias }} "{{ $path }}"
	{{- end }}
)

{{ range .Pairs }}
// {{ .ExportedFuncName }} converts {{ .SrcType.Name }} to {{ .DstType.Name }}.
func {{ .ExportedFuncName }}(ctx context.Context, src {{ .SrcType.Qualifier }}) ({{ .DstType.Qualifier }}, error) {
	dst := {{ .InternalFuncName }}(ctx, src)
	return dst, nil
}

// {{ .InternalFuncName }} is the internal conversion function.
func {{ .InternalFuncName }}(ctx context.Context, src {{ .SrcType.Qualifier }}) {{ .DstType.Qualifier }} {
	dst := {{ .DstType.Qualifier }}{}
	{{- range .Fields }}
	{{ getAssignment . "src" "dst" }}
	{{- end }}
	return dst
}
{{ end }}
`

type TemplateData struct {
	PackageName string
	Imports     map[string]string
	Pairs       []TemplatePair
}

type TemplatePair struct {
	ExportedFuncName string
	InternalFuncName string
	SrcType          QualifiedType
	DstType          QualifiedType
	Fields           []FieldMap
	im               *goscan.ImportManager
}

type FieldMap struct {
	SrcName     string
	DstName     string
	SrcField    *scanner.FieldInfo
	DstField    *scanner.FieldInfo
	IsSlice     bool
	NeedsHelper bool
	im          *goscan.ImportManager
}

type QualifiedType struct {
	Name      string
	Qualifier string
}

func Generate(packageName string, pairs []parser.ConversionPair, pkgInfo *scanner.PackageInfo) ([]byte, error) {
	im := goscan.NewImportManager(&scanner.PackageInfo{ImportPath: "example.com/convert/" + packageName})
	im.Add("context", "context")

	worklist := make(map[string]bool)
	allPairs := make([]parser.ConversionPair, len(pairs))
	copy(allPairs, pairs)

	for _, pair := range pairs {
		key := fmt.Sprintf("%s_to_%s", pair.SrcType.Name, pair.DstType.Name)
		worklist[key] = true
	}

	i := 0
	for i < len(allPairs) {
		pair := allPairs[i]
		i++
		if pair.SrcType.Struct == nil {
			continue
		}
		for _, field := range createFieldMaps(pair.SrcType.Struct, pair.DstType.Struct, im) {
			if field.NeedsHelper {
				srcElem := field.SrcField.Type.Elem
				if srcElem == nil {
					srcElem = field.SrcField.Type
				}
				dstElem := field.DstField.Type.Elem
				if dstElem == nil {
					dstElem = field.DstField.Type
				}

				helperKey := fmt.Sprintf("%s_to_%s", srcElem.Name, dstElem.Name)
				if !worklist[helperKey] {
					if srcElem.Definition != nil && dstElem.Definition != nil {
						allPairs = append(allPairs, parser.ConversionPair{
							SrcType:          srcElem.Definition,
							DstType:          dstElem.Definition,
							DstPkgImportPath: dstElem.FullImportPath(),
						})
						worklist[helperKey] = true
					}
				}
			}
		}
	}

	templatePairs := make([]TemplatePair, 0, len(allPairs))
	for _, pair := range allPairs {
		if pair.SrcType.Struct == nil || pair.DstType.Struct == nil {
			continue
		}
		srcQualifier := im.Qualify(pkgInfo.ImportPath, pair.SrcType.Name)
		dstQualifier := im.Qualify(pair.DstPkgImportPath, pair.DstType.Name)
		fieldMaps := createFieldMaps(pair.SrcType.Struct, pair.DstType.Struct, im)
		templatePairs = append(templatePairs, TemplatePair{
			ExportedFuncName: fmt.Sprintf("Convert%sTo%s", pair.SrcType.Name, pair.DstType.Name),
			InternalFuncName: fmt.Sprintf("convert%sTo%s", pair.SrcType.Name, pair.DstType.Name),
			SrcType:          QualifiedType{Name: pair.SrcType.Name, Qualifier: srcQualifier},
			DstType:          QualifiedType{Name: pair.DstType.Name, Qualifier: dstQualifier},
			Fields:           fieldMaps,
			im:               im,
		})
	}

	imports := im.Imports()
	delete(imports, "context")

	templateData := TemplateData{
		PackageName: packageName,
		Imports:     imports,
		Pairs:       templatePairs,
	}

	funcMap := template.FuncMap{
		"getAssignment": getAssignment,
	}

	tmpl, err := template.New("converter").Funcs(funcMap).Parse(strings.TrimSpace(codeTemplate))
	if err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	header := fmt.Sprintf("// Code generated by go-scan for package %s. DO NOT EDIT.\n\npackage %s\n\n", packageName, packageName)
	finalCode := append([]byte(header), buf.Bytes()...)

	formatted, err := format.Source(finalCode)
	if err != nil {
		return nil, fmt.Errorf("failed to format generated code: %w\n---\n%s\n---", err, string(finalCode))
	}

	return formatted, nil
}

func getAssignment(field FieldMap, srcVar, dstVar string) string {
	src := fmt.Sprintf("%s.%s", srcVar, field.SrcName)
	dst := fmt.Sprintf("%s.%s", dstVar, field.DstName)

	if field.IsSlice {
		return generateSliceConversion(src, dst, field.SrcField.Type, field.DstField.Type, field)
	}
	return generatePointerValueConversion(src, dst, field.SrcField.Type, field.DstField.Type, field)
}

func generateSliceConversion(src, dst string, srcType, dstType *scanner.FieldType, field FieldMap) string {
	srcElem := srcType.Elem
	dstElem := dstType.Elem
	if srcElem == nil || dstElem == nil {
		return fmt.Sprintf("// TODO: Cannot determine slice element types for %s", src)
	}

	helperFuncName := ""
	if field.NeedsHelper {
		srcBaseType := srcElem
		if srcElem.IsPointer {
			srcBaseType = srcElem.Elem
		}
		dstBaseType := dstElem
		if dstElem.IsPointer {
			dstBaseType = dstElem.Elem
		}
		if srcBaseType.Definition != nil && dstBaseType.Definition != nil {
			helperFuncName = fmt.Sprintf("convert%sTo%s", srcBaseType.Name, dstBaseType.Name)
		}
	}

	dstElemQualifier := field.im.Qualify(dstElem.FullImportPath(), dstElem.Name)
	dstSliceTypeQualifier := "[]" + dstElemQualifier


	var conversionLogic string
	if helperFuncName != "" {
		call := fmt.Sprintf("%s(ctx, elem)", helperFuncName)
		if srcElem.IsPointer {
			call = fmt.Sprintf("%s(ctx, *elem)", helperFuncName)
		}

		if dstElem.IsPointer {
			if srcElem.IsPointer {
				conversionLogic = fmt.Sprintf("if elem != nil {\n\t\t\ttmp := %s\n\t\t\tnewSlice = append(newSlice, &tmp)\n\t\t}", call)
			} else {
				conversionLogic = fmt.Sprintf("tmp := %s\n\t\tnewSlice = append(newSlice, &tmp)", call)
			}
		} else {
			if srcElem.IsPointer {
				conversionLogic = fmt.Sprintf("if elem != nil {\n\t\t\tnewSlice = append(newSlice, %s)\n\t\t}", call)
			} else {
				conversionLogic = fmt.Sprintf("newSlice = append(newSlice, %s)", call)
			}
		}
	} else {
		// No helper function, direct assignment with pointer handling.
		assign := "elem"
		if srcElem.IsPointer {
			assign = "*elem"
		}

		if dstElem.IsPointer {
			if srcElem.IsPointer {
				conversionLogic = fmt.Sprintf("if elem != nil { tmp := %s; newSlice = append(newSlice, &tmp) }", assign)
			} else {
				conversionLogic = fmt.Sprintf("tmp := %s\n\t\tnewSlice = append(newSlice, &tmp)", assign)
			}
		} else {
			if srcElem.IsPointer {
				conversionLogic = fmt.Sprintf("if elem != nil { newSlice = append(newSlice, %s) }", assign)
			} else {
				conversionLogic = fmt.Sprintf("newSlice = append(newSlice, %s)", assign)
			}
		}
	}

	return fmt.Sprintf(`
	if %s != nil {
		newSlice := make(%s, 0, len(%s))
		for _, elem := range %s {
			%s
		}
		%s = newSlice
	}`, src, dstSliceTypeQualifier, src, src, conversionLogic, dst)
}

func generatePointerValueConversion(src, dst string, srcType, dstType *scanner.FieldType, field FieldMap) string {
	srcIsPtr := srcType.IsPointer
	dstIsPtr := dstType.IsPointer

	srcBaseType := srcType
	if srcIsPtr {
		srcBaseType = srcType.Elem
	}
	dstBaseType := dstType
	if dstIsPtr {
		dstBaseType = dstType.Elem
	}

	helperFunc := ""
	if field.NeedsHelper {
		helperFunc = fmt.Sprintf("convert%sTo%s", srcBaseType.Name, dstBaseType.Name)
	}

	if !srcIsPtr && !dstIsPtr {
		if helperFunc != "" {
			return fmt.Sprintf("%s = %s(ctx, %s)", dst, helperFunc, src)
		}
		return fmt.Sprintf("%s = %s", dst, src)
	}
	if srcIsPtr && !dstIsPtr {
		if helperFunc != "" {
			return fmt.Sprintf("if %s != nil {\n\t\t%s = %s(ctx, *%s)\n\t}", src, dst, helperFunc, src)
		}
		return fmt.Sprintf("if %s != nil {\n\t\t%s = *%s\n\t}", src, dst, src)
	}
	if !srcIsPtr && dstIsPtr {
		if helperFunc != "" {
			return fmt.Sprintf("{\n\t\ttmp := %s(ctx, %s)\n\t\t%s = &tmp\n\t}", helperFunc, src, dst)
		}
		return fmt.Sprintf("{\n\t\ttmp := %s\n\t\t%s = &tmp\n\t}", src, dst)
	}
	if srcIsPtr && dstIsPtr {
		if helperFunc != "" {
			return fmt.Sprintf("if %s != nil {\n\t\ttmp := %s(ctx, *%s)\n\t\t%s = &tmp\n\t}", src, helperFunc, src, dst)
		}
		return fmt.Sprintf("if %s != nil {\n\t\ttmp := *%s\n\t\t%s = &tmp\n\t}", src, src, dst)
	}
	return fmt.Sprintf("// TODO: Conversion not implemented for %s -> %s", srcType.Name, dstType.Name)
}

func createFieldMaps(srcStruct, dstStruct *scanner.StructInfo, im *goscan.ImportManager) []FieldMap {
	var fieldMaps []FieldMap
	dstFields := make(map[string]*scanner.FieldInfo)
	for _, field := range dstStruct.Fields {
		dstFields[field.Name] = field
	}

	for _, srcField := range srcStruct.Fields {
		if dstField, ok := dstFields[srcField.Name]; ok {
			srcDef, _ := srcField.Type.Resolve(context.Background(), make(map[string]struct{}))
			dstDef, _ := dstField.Type.Resolve(context.Background(), make(map[string]struct{}))

			srcIsStruct := (srcDef != nil && srcDef.Struct != nil) || (srcField.Type.Elem != nil && srcField.Type.Elem.Definition != nil && srcField.Type.Elem.Definition.Struct != nil)
			dstIsStruct := (dstDef != nil && dstDef.Struct != nil) || (dstField.Type.Elem != nil && dstField.Type.Elem.Definition != nil && dstField.Type.Elem.Definition.Struct != nil)
			needsHelper := srcIsStruct && dstIsStruct

			fieldMaps = append(fieldMaps, FieldMap{
				SrcName:     srcField.Name,
				DstName:     srcField.Name,
				SrcField:    srcField,
				DstField:    dstField,
				IsSlice:     srcField.Type.IsSlice,
				NeedsHelper: needsHelper,
				im:          im,
			})
		}
	}

	return fieldMaps
}
