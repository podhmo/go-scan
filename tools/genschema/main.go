package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"reflect"
	"strconv"
	"strings"

	"github.com/iancoleman/orderedmap"
	"github.com/podhmo/flagstruct"
	goscan "github.com/podhmo/go-scan"
	"github.com/podhmo/go-scan/scanner"
)

type CLIOptions struct {
	Loose       bool     `flag:"loose" help:"if true, treating as additionalProperties:true" default:"true"`
	NameTags    []string `flag:"name-tag"`
	OverrideTag string   `flag:"override-tag"`
	RefRoot     string   `flag:"ref-root"`
	Indent      string   `flag:"indent"`

	Query       string `flag:"query" required:"true"`
	Title       string `flag:"schema-title" help:"title attribute of jsonschema"`
	Description string `flag:"schema-description" help:"description attribute of jsonschema"`
	SchemaSpec  string `flag:"schema-spec" help:"$schema attribute of jsonschema"`
}

type Config struct {
	*CLIOptions
}

func main() {
	options := &CLIOptions{
		NameTags:    []string{"json", "yaml", "toml"},
		OverrideTag: "jsonschema-override",
		RefRoot:     "$defs",
		SchemaSpec:  "http://json-schema.org/draft-07/schema#",
		Indent:      "\t",
		Description: fmt.Sprintf("Generated by `%s`", strings.Join(os.Args, " ")),
	}

	flagstruct.Parse(options, func(b *flagstruct.Builder) {
		b.Name = "genschema"
	})

	if err := run(&Config{CLIOptions: options}); err != nil {
		log.Fatalf("!! %+v", err)
	}
}

func run(config *Config) error {
	ctx := context.Background()
	s, err := goscan.New(goscan.WithGoModuleResolver())
	if err != nil {
		return fmt.Errorf("could not create scanner: %w", err)
	}

	// 1. parse query
	i := strings.LastIndex(config.Query, ".")
	if i < 0 {
		return fmt.Errorf("invalid query %q, expected <package>.<name>", config.Query)
	}
	pkgPath := config.Query[:i]
	typeName := config.Query[i+1:]

	// 2. scan package
	_, err = s.Scan(ctx, pkgPath)
	if err != nil {
		return fmt.Errorf("could not scan package %q: %w", pkgPath, err)
	}

	// 3. find type
	allPkgs := s.AllSeenPackages()
	pkgInfo, ok := allPkgs[pkgPath]
	if !ok {
		return fmt.Errorf("package %q not found after scan", pkgPath)
	}

	ob := pkgInfo.Lookup(typeName)
	if ob == nil {
		return fmt.Errorf("type %q not found in package %q", typeName, pkgPath)
	}

	// 4. generate schema
	g := &Generator{
		Config:    config,
		Scanner:   s,
		defs:      make(map[string]*orderedmap.OrderedMap),
		seen:      make(map[*scanner.TypeInfo]string),
		useCounts: make(map[string]int),
	}
	_, err = g.Generate(ctx, ob)
	if err != nil {
		return fmt.Errorf("generation failed: %w", err)
	}

	finalDoc := orderedmap.New()
	def, _ := g.defs[ob.Name]
	for _, k := range def.Keys() {
		v, _ := def.Get(k)
		finalDoc.Set(k, v)
	}
	delete(g.defs, ob.Name)

	// 5. assemble and print
	if len(g.defs) > 0 {
		finalDoc.Set(config.RefRoot, g.defs)
	}

	root := orderedmap.New()
	root.Set("$schema", config.SchemaSpec)
	if config.Title != "" {
		root.Set("title", config.Title)
	}
	if config.Description != "" {
		root.Set("description", config.Description)
	}
	for _, k := range finalDoc.Keys() {
		v, _ := finalDoc.Get(k)
		root.Set(k, v)
	}

	enc := json.NewEncoder(os.Stdout)
	enc.SetIndent("", config.Indent)
	if err := enc.Encode(root); err != nil {
		return fmt.Errorf("could not encode json: %w", err)
	}

	return nil
}

type Generator struct {
	Config    *Config
	Scanner   *goscan.Scanner
	defs      map[string]*orderedmap.OrderedMap
	seen      map[*scanner.TypeInfo]string
	useCounts map[string]int
}

// Generate handles the logic for named types, creating $ref schemas and populating the definitions map.
func (g *Generator) Generate(ctx context.Context, ob *scanner.TypeInfo) (*orderedmap.OrderedMap, error) {
	if refName, ok := g.seen[ob]; ok {
		g.useCounts[refName]++
		ref := orderedmap.New()
		ref.Set("$ref", fmt.Sprintf("#/%s/%s", g.Config.RefRoot, refName))
		return ref, nil
	}

	refName := ob.Name
	g.seen[ob] = refName
	g.useCounts[refName] = 1

	doc, err := g.generateSchemaForTypeInfo(ctx, ob)
	if err != nil {
		return nil, err
	}

	if ob.Doc != "" {
		doc.Set("description", ob.Doc)
	}

	g.defs[refName] = doc

	ref := orderedmap.New()
	ref.Set("$ref", fmt.Sprintf("#/%s/%s", g.Config.RefRoot, refName))
	return ref, nil
}

func (g *Generator) generateSchemaForTypeInfo(ctx context.Context, ob *scanner.TypeInfo) (*orderedmap.OrderedMap, error) {
	switch ob.Kind {
	case scanner.AliasKind:
		return g.generateSchemaForField(ctx, ob.Underlying)
	case scanner.StructKind:
		doc := orderedmap.New()
		doc.Set("type", "object")
		doc.Set("additionalProperties", g.Config.Loose)

		props := orderedmap.New()
		doc.Set("properties", props)
		var requiredList []string

		for _, field := range ob.Struct.Fields {
			if !field.IsExported {
				continue
			}
			tag := reflect.StructTag(field.Tag)
			name := field.Name
			required := !field.Type.IsPointer

			var jsonName string
			for _, nameTag := range g.Config.NameTags {
				if tagVal, ok := tag.Lookup(nameTag); ok {
					parts := strings.Split(tagVal, ",")
					jsonName = parts[0]
					if len(parts) > 1 && strings.TrimSpace(parts[1]) == "omitempty" {
						required = false
					}
					break
				}
			}
			if jsonName != "" {
				name = jsonName
			}

			if name == "-" {
				continue
			}

			fieldDef, err := g.generateSchemaForField(ctx, field.Type)
			if err != nil {
				return nil, fmt.Errorf("generating schema for field %q: %w", field.Name, err)
			}
			if field.Doc != "" {
				fieldDef.Set("description", field.Doc)
			}

			if v, ok := tag.Lookup("required"); ok {
				if b, err := strconv.ParseBool(v); err == nil {
					required = b
				}
			}

			if overrideTagVal, ok := tag.Lookup(g.Config.OverrideTag); ok {
				var overrides orderedmap.OrderedMap
				if err := json.Unmarshal([]byte(overrideTagVal), &overrides); err != nil {
					log.Printf("[WARN] could not unmarshal jsonschema-override tag for field %q: %v", field.Name, err)
				} else {
					for _, k := range overrides.Keys() {
						v, _ := overrides.Get(k)
						if k == "required" {
							if b, ok := v.(bool); ok {
								required = b
							}
							continue
						}
						fieldDef.Set(k, v)
					}
				}
			}

			props.Set(name, fieldDef)
			if required {
				requiredList = append(requiredList, name)
			}
		}

		if len(requiredList) > 0 {
			doc.Set("required", requiredList)
		}
		return doc, nil
	case scanner.InterfaceKind:
		if ob.Interface != nil && len(ob.Interface.Methods) == 0 && len(ob.Interface.Embedded) == 0 {
			doc := orderedmap.New()
			doc.Set("type", "object")
			doc.Set("additionalProperties", true)
			doc.Set("description", "any (interface{})")
			return doc, nil
		}
		return nil, fmt.Errorf("unsupported non-empty interface type: %s", ob.Name)
	default:
		return nil, fmt.Errorf("unsupported kind %v for type %s", ob.Kind, ob.Name)
	}
}

func (g *Generator) generateSchemaForField(ctx context.Context, ft *scanner.FieldType) (*orderedmap.OrderedMap, error) {
	if ft.IsPointer {
		return g.generateSchemaForField(ctx, ft.Elem)
	}
	if ft.IsSlice {
		doc := orderedmap.New()
		doc.Set("type", "array")
		items, err := g.generateSchemaForField(ctx, ft.Elem)
		if err != nil {
			return nil, fmt.Errorf("generating items for slice: %w", err)
		}
		doc.Set("items", items)
		return doc, nil
	}
	if ft.IsMap {
		doc := orderedmap.New()
		doc.Set("type", "object")
		props, err := g.generateSchemaForField(ctx, ft.Elem)
		if err != nil {
			return nil, fmt.Errorf("generating additionalProperties for map: %w", err)
		}
		doc.Set("additionalProperties", props)
		return doc, nil
	}

	if ft.IsBuiltin {
		doc := orderedmap.New()
		switch ft.Name {
		case "bool":
			doc.Set("type", "boolean")
		case "int", "int8", "int16", "int32", "int64",
			"uint", "uint8", "uint16", "uint32", "uint64", "uintptr", "rune", "byte":
			doc.Set("type", "integer")
			if strings.HasPrefix(ft.Name, "u") || ft.Name == "byte" || ft.Name == "rune" {
				doc.Set("minimum", 0)
			}
		case "float32", "float64", "complex64", "complex128":
			doc.Set("type", "number")
		case "string":
			doc.Set("type", "string")
		case "any":
			doc.Set("type", "object")
			doc.Set("additionalProperties", true)
			doc.Set("description", "any (interface{})")
		default:
			return nil, fmt.Errorf("unsupported basic type %q", ft.Name)
		}
		return doc, nil
	}

	def, err := ft.Resolve(ctx)
	if err != nil {
		return nil, fmt.Errorf("could not resolve type %q: %w", ft.Name, err)
	}
	if def == nil {
		return nil, fmt.Errorf("resolved type %q to a nil definition", ft.Name)
	}

	return g.Generate(ctx, def)
}
