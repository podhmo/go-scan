package generator

import (
	"context"
	"go/format"
	"path/filepath"
	"strings"
	"testing"

	"example.com/convert/parser"
	"github.com/google/go-cmp/cmp"
	"github.com/podhmo/go-scan"
	"github.com/podhmo/go-scan/scantest"
)

func TestGenerate_CrossPackage_WithSlices(t *testing.T) {
	files := map[string]string{
		"go.mod": `
module example.com/convert
go 1.24
replace github.com/podhmo/go-scan => ../../
`,
		"models/source/source.go": `
package source
import "time"

// @derivingconvert("example.com/convert/models/destination.DstUser")
type SrcUser struct {
	ID   int64
	Name string
}

// @derivingconvert("example.com/convert/models/destination.DstOrder")
type SrcOrder struct {
	OrderID string
	Items   []SrcItem
}

type SrcItem struct {
	SKU      string
	Quantity int
}
`,
		"models/destination/destination.go": `
package destination

type DstUser struct {
	ID   int64
	Name string
}

type DstOrder struct {
	OrderID string
	Items   []DstItem
}

type DstItem struct {
	SKU      string
	Quantity int
}
`,
	}

	tmpdir, cleanup := scantest.WriteFiles(t, files)
	defer cleanup()

	ctx := context.Background()
	s, err := goscan.New(goscan.WithWorkDir(tmpdir))
	if err != nil {
		t.Fatalf("goscan.New failed: %+v", err)
	}

	pkg, err := s.ScanPackage(ctx, filepath.Join(tmpdir, "models/source"))
	if err != nil {
		t.Fatalf("s.ScanPackage failed: %+v", err)
	}

	pairs, err := parser.Parse(ctx, pkg, s)
	if err != nil {
		t.Fatalf("parser.Parse failed: %+v", err)
	}

	got, err := Generate(s, "converter", pairs, pkg)
	if err != nil {
		t.Fatalf("Generate failed: %+v", err)
	}

	want := `// Code generated by go-scan for package converter. DO NOT EDIT.

package converter

import (
	"context"
	destination "example.com/convert/models/destination"
	source "example.com/convert/models/source"
)

// ConvertSrcUserToDstUser converts SrcUser to DstUser.
func ConvertSrcUserToDstUser(ctx context.Context, src source.SrcUser) (destination.DstUser, error) {
	dst := convertSrcUserToDstUser(ctx, src)
	return dst, nil
}

// convertSrcUserToDstUser is the internal conversion function.
func convertSrcUserToDstUser(ctx context.Context, src source.SrcUser) destination.DstUser {
	dst := destination.DstUser{}
	dst.ID = src.ID
	dst.Name = src.Name
	return dst
}

// ConvertSrcOrderToDstOrder converts SrcOrder to DstOrder.
func ConvertSrcOrderToDstOrder(ctx context.Context, src source.SrcOrder) (destination.DstOrder, error) {
	dst := convertSrcOrderToDstOrder(ctx, src)
	return dst, nil
}

// convertSrcOrderToDstOrder is the internal conversion function.
func convertSrcOrderToDstOrder(ctx context.Context, src source.SrcOrder) destination.DstOrder {
	dst := destination.DstOrder{}
	dst.OrderID = src.OrderID

	if src.Items != nil {
		newSlice := make([]destination.DstItem, 0, len(src.Items))
		for _, elem := range src.Items {
			newSlice = append(newSlice, convertSrcItemToDstItem(ctx, elem))
		}
		dst.Items = newSlice
	}
	return dst
}

// ConvertSrcItemToDstItem converts SrcItem to DstItem.
func ConvertSrcItemToDstItem(ctx context.Context, src source.SrcItem) (destination.DstItem, error) {
	dst := convertSrcItemToDstItem(ctx, src)
	return dst, nil
}

// convertSrcItemToDstItem is the internal conversion function.
func convertSrcItemToDstItem(ctx context.Context, src source.SrcItem) destination.DstItem {
	dst := destination.DstItem{}
	dst.SKU = src.SKU
	dst.Quantity = src.Quantity
	return dst
}
`

	formattedGot, err := format.Source(got)
	if err != nil {
		t.Logf("failed to format generated code: %+v\n--- raw output ---\n%s", err, string(got))
		formattedGot = got
	}

	formattedWant, err := format.Source([]byte(want))
	if err != nil {
		t.Fatalf("failed to format want code: %+v\n--- raw output ---\n%s", err, want)
	}

	if diff := cmp.Diff(strings.TrimSpace(string(formattedWant)), strings.TrimSpace(string(formattedGot))); diff != "" {
		t.Errorf("generated code mismatch (-want +got):\n%s", diff)
	}
}

func TestGenerate_WithMaps(t *testing.T) {
	files := map[string]string{
		"go.mod": `
module example.com/convert
go 1.24
replace github.com/podhmo/go-scan => ../../
`,
		"models/source/source.go": `
package source

// @derivingconvert("example.com/convert/models/destination.DstProfile")
type SrcProfile struct {
	Name       string
	Attributes map[string]string
	Tags       map[string]SrcTag
}

type SrcTag struct {
	Value string
}
`,
		"models/destination/destination.go": `
package destination

type DstProfile struct {
	Name       string
	Attributes map[string]string
	Tags       map[string]DstTag
}

type DstTag struct {
	Value string
}
`,
	}

	tmpdir, cleanup := scantest.WriteFiles(t, files)
	defer cleanup()

	ctx := context.Background()
	s, err := goscan.New(goscan.WithWorkDir(tmpdir))
	if err != nil {
		t.Fatalf("goscan.New failed: %+v", err)
	}

	pkg, err := s.ScanPackage(ctx, filepath.Join(tmpdir, "models/source"))
	if err != nil {
		t.Fatalf("s.ScanPackage failed: %+v", err)
	}

	pairs, err := parser.Parse(ctx, pkg, s)
	if err != nil {
		t.Fatalf("parser.Parse failed: %+v", err)
	}

	got, err := Generate(s, "converter", pairs, pkg)
	if err != nil {
		t.Fatalf("Generate failed: %+v", err)
	}

	want := `// Code generated by go-scan for package converter. DO NOT EDIT.

package converter

import (
	"context"
	destination "example.com/convert/models/destination"
	source "example.com/convert/models/source"
)

// ConvertSrcProfileToDstProfile converts SrcProfile to DstProfile.
func ConvertSrcProfileToDstProfile(ctx context.Context, src source.SrcProfile) (destination.DstProfile, error) {
	dst := convertSrcProfileToDstProfile(ctx, src)
	return dst, nil
}

// convertSrcProfileToDstProfile is the internal conversion function.
func convertSrcProfileToDstProfile(ctx context.Context, src source.SrcProfile) destination.DstProfile {
	dst := destination.DstProfile{}
	dst.Name = src.Name

	if src.Attributes != nil {
		newMap := make(map[string]string, len(src.Attributes))
		for key, value := range src.Attributes {
			newMap[key] = value
		}
		dst.Attributes = newMap
	}

	if src.Tags != nil {
		newMap := make(map[string]destination.DstTag, len(src.Tags))
		for key, value := range src.Tags {
			newMap[key] = convertSrcTagToDstTag(ctx, value)
		}
		dst.Tags = newMap
	}

	return dst
}

// ConvertSrcTagToDstTag converts SrcTag to DstTag.
func ConvertSrcTagToDstTag(ctx context.Context, src source.SrcTag) (destination.DstTag, error) {
	dst := convertSrcTagToDstTag(ctx, src)
	return dst, nil
}

// convertSrcTagToDstTag is the internal conversion function.
func convertSrcTagToDstTag(ctx context.Context, src source.SrcTag) destination.DstTag {
	dst := destination.DstTag{}
	dst.Value = src.Value
	return dst
}
`

	formattedGot, err := format.Source(got)
	if err != nil {
		t.Logf("failed to format generated code: %+v\n--- raw output ---\n%s", err, string(got))
		formattedGot = got
	}

	formattedWant, err := format.Source([]byte(want))
	if err != nil {
		t.Fatalf("failed to format want code: %+v\n--- raw output ---\n%s", err, want)
	}

	if diff := cmp.Diff(strings.TrimSpace(string(formattedWant)), strings.TrimSpace(string(formattedGot))); diff != "" {
		t.Errorf("generated code mismatch (-want +got):\n%s", diff)
	}
}
