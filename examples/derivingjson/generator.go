package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"reflect" // For parsing struct tags

	"github.com/podhmo/go-scan/goscan" // goscanパッケージをインポート
	// "github.com/podhmo/go-scan/scanner" // 必要に応じてscannerパッケージもインポートするかもしれない
)

const unmarshalAnnotation = "@deriving:unmarshall"

// TemplateData holds data for the UnmarshalJSON template
type TemplateData struct {
	PackageName              string
	StructName               string
	DiscriminatorFieldName     string
	DiscriminatorFieldType     string
	DiscriminatorFieldJSONTag  string
	OneOfFieldName           string
	OneOfFieldJSONTag        string
	OneOfFieldType           string // Interface type name for oneOf field
	OtherFields              []FieldInfo
	OneOfTypes               []OneOfTypeMapping
}

// FieldInfo holds information about a struct field
type FieldInfo struct {
	Name    string
	Type    string
	JSONTag string
}

// OneOfTypeMapping maps a JSON discriminator value to a Go type
type OneOfTypeMapping struct {
	JSONValue string
	GoType    string
}

const unmarshalJSONTemplate = `// Code generated by derivingjson. DO NOT EDIT.

package {{.PackageName}}

import (
	"encoding/json"
	"fmt"
)

func (s *{{.StructName}}) UnmarshalJSON(data []byte) error {
	var discriminatorDoc struct {
		Value {{.DiscriminatorFieldType}} ` + "`json:\"{{.DiscriminatorFieldJSONTag}}\"`" + `
	}
	if err := json.Unmarshal(data, &discriminatorDoc); err != nil {
		return fmt.Errorf("failed to unmarshal discriminator value for field '{{.DiscriminatorFieldJSONTag}}': %w", err)
	}

	s.{{.DiscriminatorFieldName}} = discriminatorDoc.Value

	var raw{{.OneOfFieldName}} json.RawMessage
	// Temporary structure to unmarshal known fields including the raw oneOf field.
	// Other fields are handled by unmarshalling the full map.
	var tempKnownFields struct {
		TargetContent *json.RawMessage ` + "`json:\"{{.OneOfFieldJSONTag}}\"`" + `
		// Discriminator is already handled.
		// Other fields will be extracted from fullMap.
	}

	// Unmarshal into a temporary map to safely access all fields, including "other" fields.
	var fullMap map[string]*json.RawMessage
	if err := json.Unmarshal(data, &fullMap); err != nil {
		return fmt.Errorf("failed to unmarshal full object: %w", err)
	}

	// Extract the raw oneOf field from the full map.
	if rawVal, ok := fullMap["{{.OneOfFieldJSONTag}}"]; ok && rawVal != nil {
		raw{{.OneOfFieldName}} = *rawVal
	}

	// Assign other fields from the full map.
	{{range .OtherFields}}
	if rawVal, ok := fullMap["{{.JSONTag}}"]; ok && rawVal != nil {
		var val {{.Type}}
		if err := json.Unmarshal(*rawVal, &val); err != nil {
			return fmt.Errorf("failed to unmarshal field '{{.JSONTag}}' into {{.Type}}: %w", err)
		}
		s.{{.Name}} = val
	}
	{{end}}

	switch discriminatorDoc.Value {
	{{range .OneOfTypes}}
	case "{{.JSONValue}}":
		var content {{.GoType}}
		if raw{{$.OneOfFieldName}} == nil {
			// Optional: Handle if oneOf field is not present.
			// Depending on requirements, this might be an error or allowed.
			// For now, if it's nil, content will be zero-value of {{.GoType}}.
		} else if err := json.Unmarshal(raw{{$.OneOfFieldName}}, &content); err != nil {
			return fmt.Errorf("failed to unmarshal {{$.OneOfFieldName}} as {{.GoType}} for discriminator '{{.JSONValue}}': %w", err)
		}
		s.{{$.OneOfFieldName}} = content
	{{end}}
	default:
		if raw{{.OneOfFieldName}} != nil && len(raw{{$.OneOfFieldName}}) > 0 && string(raw{{$.OneOfFieldName}}) != "null" {
			// Only error if there was content for the oneOf field but the type was unknown.
			return fmt.Errorf("unknown value for discriminator '{{.DiscriminatorFieldJSONTag}}': %s, cannot unmarshal '{{.OneOfFieldJSONTag}}'", discriminatorDoc.Value)
		}
	}
	return nil
}
`

// Generate function will be re-implemented using go-scan
func Generate(pkgPath string) error {
	// TODO: Re-implement using go-scan
	fmt.Printf("Attempting to generate for package path: %s using go-scan (not yet implemented)\n", pkgPath)

	// 1. Create a new scanner
	// Assuming pkgPath is a file system path. go-scan's New constructor needs a starting point
	// for finding go.mod (e.g., "." or the actual module root if known).
	// If pkgPath is an import path, we'd use ScanPackageByImport.
	// For now, let's assume pkgPath is a directory path relative to some module root.
	// The `main.go` passes a relative file path like `./testdata/simple`.
	// We need to determine the module root to initialize go-scan correctly,
	// or determine the import path of pkgPath.

	// Let's find the module root from the pkgPath.
	// This is a simplified approach; go-scan's New() does this internally starting from its arg.
	// We need to give `goscan.New()` a path from which it can find a `go.mod`.
	// If `pkgPath` is `./examples/derivingjson/testdata/simple`, and `go.mod` is at the repo root,
	// then `"."` (if running from repo root) or an absolute path to repo root would work for `goscan.New()`.

	// For `derivingjson` itself being a command within the module, using "." for `goscan.New`
	// when the CWD is `examples/derivingjson` might be problematic if `go.mod` is at `../../`.
	// Let's assume `main.go` is run from the module root for now, or `pkgPath` is adjusted.
	// Or, `goscan.New(pkgPath)` might work if `pkgPath` itself contains or is within a module.

	// The `main.go` calls `Generate(pkgPath)` where pkgPath is like "./testdata/simple".
	// `goscan.New()` needs a path from which it can find `go.mod`.
	// The `go-scan` library itself is in the root.
	// So, if `derivingjson` is run from `examples/derivingjson`, `goscan.New(".")` would look for
	// `examples/derivingjson/go.mod`.
	// We need `goscan.New("../..")` if CWD is `examples/derivingjson`.
	// Or, more robustly, find `go.mod` by walking up from `pkgPath`.

	// Let's assume the command is run from the module root for simplicity of this step.
	// And pkgPath is relative to module root e.g. "examples/derivingjson/testdata/simple"

	// Determine import path from file path. This is non-trivial.
	// For now, we'll assume pkgPath is a direct path to the package source files.
	// `ScanPackage(path string)` seems to take a file path.
	// `ScanPackageByImport(ipath string)` takes an import path.

	// The example in README uses `goscan.New(".")` then `scanner.ScanPackageByImport(pkgImportPath)`.
	// We need to convert `pkgPath` (e.g., "./testdata/simple") into an import path.
	// Or, if `goscan.Scanner.ScanPackage(pkgPath string)` can take a directory path directly.
	// Looking at `goscan.go`'s `ScanPackage` method, it seems to expect a directory path.

	scanner, err := goscan.New(".") // Assuming command run from module root.
	if err != nil {
		return fmt.Errorf("failed to create go-scan scanner: %w", err)
	}

	// We need the actual import path for the given pkgPath (e.g. examples/derivingjson/testdata/simple)
	// to correctly resolve types later if they refer to types by their full import paths.
	// `goscan.Package` has `ImportPath`. Let's see if `ScanPackage` populates it.
	// `pkgPath` is a file path.

	// Let's try ScanPackage with the direct file path.
	pkgInfo, err := scanner.ScanPackage(pkgPath)
	if err != nil {
		return fmt.Errorf("go-scan failed to scan package at %s: %w", pkgPath, err)
	}

	fmt.Printf("Scanned package: %s (ImportPath: %s, Files: %d)\n", pkgInfo.Name, pkgInfo.ImportPath, len(pkgInfo.Files))

	// --- DEBUG: Print all scanned types ---
	fmt.Println("DEBUG: All scanned types in the package:")
	for _, t := range pkgInfo.Types {
		fmt.Printf("  - Name: %s, Kind: %s, PkgName: %s, PkgImportPath: %s, DocComment: %q, TypeSpecDocComment: %q\n", t.Name, t.Kind, t.PkgName, t.PkgImportPath, t.DocComment, t.TypeSpecDocComment)
		if t.Kind == goscan.InterfaceKind && t.Interface != nil {
			fmt.Printf("    Interface Methods:\n")
			for _, m := range t.Interface.Methods {
				fmt.Printf("      - %s()\n", m.Name)
			}
		}
		if t.Kind == goscan.StructKind && t.Struct != nil {
			fmt.Printf("    Struct Methods:\n")
			for _, m := range t.Methods {
				fmt.Printf("      - %s() (Receiver: %s)\n", m.Name, m.Recv)
			}
		}
	}
	fmt.Println("--- END DEBUG ---")

	if pkgInfo.Name == "" {
	    // If pkgInfo.Name is empty, it might mean it's a directory with multiple packages,
	    // or it's not a valid Go package directory.
	    // For `testdata/simple`, pkgName should be `simple`.
	    // We might need to iterate `scanner.ScanPackage(pkgPath)` if it returns multiple packages,
	    // or ensure pkgPath points to a single package.
	    // `parser.ParseDir` returns a map, `go-scan` might do something similar or expect a more specific path.
	    // Based on `ScanPackage` in `goscan.go`, it seems it expects a path to a single package directory.
	    // And `pkgInfo.Name` would be the package name.
	    files, _ := os.ReadDir(pkgPath)
	    isSinglePackage := false
	    for _, f := range files {
	        if !f.IsDir() && strings.HasSuffix(f.Name(), ".go") {
	            isSinglePackage = true;
	            break
	        }
	    }
	    if !isSinglePackage {
	         return fmt.Errorf("path %s does not appear to be a single Go package directory", pkgPath)
	    }
	    // If ScanPackage returns empty PkgName, we might need to infer it or there's an issue.
	    // For now, assume ScanPackage populates PkgName correctly for a valid package dir.
	    // If pkgInfo.Name is still empty here, it's an issue.
	    // The current structure of `generator.go` expects to output one `_deriving.go` per package.
	}


	var generatedCodeForAllStructs bytes.Buffer
	needsImportEncodingJson := false
	needsImportFmt := false

	for _, typeInfo := range pkgInfo.Types {
		if typeInfo.Kind != goscan.StructKind {
			continue
		}
		if typeInfo.DocComment == "" || !strings.Contains(typeInfo.DocComment, unmarshalAnnotation) {
			// Check TypeSpecDocComment as well, as DocComment might be for the GenDecl.
			// go-scan's TypeInfo.DocComment should ideally capture the comment for the type spec.
			if typeInfo.TypeSpecDocComment == "" || !strings.Contains(typeInfo.TypeSpecDocComment, unmarshalAnnotation) {
				continue
			}
		}

		fmt.Printf("  Processing struct: %s for %s\n", typeInfo.Name, unmarshalAnnotation)

		data := TemplateData{
			PackageName: pkgInfo.Name, // Use scanned package name
			StructName:  typeInfo.Name,
		}

		oneOfInterfaceName := "" // To store the name of the interface type, e.g., "Shape"

		if typeInfo.Struct == nil { // Should not happen if Kind is StructKind
		    fmt.Printf("  Warning: Struct %s has nil StructInfo, skipping\n", typeInfo.Name)
		    continue
		}

		for _, field := range typeInfo.Struct.Fields {
			jsonTag := ""
			if field.Tag != "" {
				var structTag reflect.StructTag = reflect.StructTag(field.Tag)
				jsonTagVal := structTag.Get("json")
				if commaIdx := strings.Index(jsonTagVal, ","); commaIdx != -1 {
					jsonTag = jsonTagVal[:commaIdx]
				} else {
					jsonTag = jsonTagVal
				}
			}

			// Resolve field type to get its actual name (e.g. "string", "int", "Shape")
			// field.Type is a goscan.TypeRef
			resolvedFieldType, err := field.Type.Resolve() // This is key
			if err != nil {
				fmt.Printf("    Warning: Could not resolve type for field %s (%s): %v. Using raw name.\n", field.Name, field.Type.Name, err)
				// Fallback or skip? For now, use raw name if resolve fails.
				// This might happen for unimported packages if not handled by go-scan's setup.
			}

			fieldTypeName := field.Type.Name // Default to unresolved name
			if resolvedFieldType != nil {
			    fieldTypeName = resolvedFieldType.Name // Use resolved name if available
			    if resolvedFieldType.PkgName != "" && resolvedFieldType.PkgName != pkgInfo.Name { // if it's from a different package
			        // We need to ensure the type name includes the package selector if it's not a built-in or current package type
			        // However, for template generation, we typically need the selector for external package types.
			        // go-scan's TypeRef.String() or a helper might be needed.
			        // For now, let's assume types within the same package or builtins are most common for this generator.
			        // If `Shape` is in the same package, `fieldTypeName` would be `Shape`.
			        // If `Other` is in the same package, `fieldTypeName` would be `Other`.
			    }
			}


			// Heuristic for discriminator: string type with json tag "type"
			// goscan.TypeRef.Name for "string" should be "string". IsPrimitive should be true.
			isStringPrimitive := field.Type.IsPrimitive && field.Type.Name == "string"
			if resolvedFieldType != nil && resolvedFieldType.IsPrimitive && resolvedFieldType.Name == "string" {
				isStringPrimitive = true
			}

			if strings.ToLower(jsonTag) == "type" && isStringPrimitive {
				data.DiscriminatorFieldName = field.Name
				data.DiscriminatorFieldType = "string" // Known to be string
				data.DiscriminatorFieldJSONTag = jsonTag
				fmt.Printf("      Found Discriminator: %s (string) json:\"%s\"\n", field.Name, jsonTag)
			} else if resolvedFieldType != nil && resolvedFieldType.Kind == goscan.InterfaceKind {
				// This field is an interface type, potential oneOf target
				data.OneOfFieldName = field.Name
				data.OneOfFieldJSONTag = jsonTag
				data.OneOfFieldType = field.Type.Name // Use the unresolved name for the interface type itself, e.g. "Shape"
				oneOfInterfaceName = field.Type.Name
				fmt.Printf("      Found OneOf Field (potential): %s (%s) json:\"%s\"\n", field.Name, data.OneOfFieldType, jsonTag)
			} else {
				actualFieldTypeString := field.Type.String() // Get string representation, e.g., "*User", "[]string"
				// Ensure that the type string is suitable for use in generated Go code.
				// field.Type.String() should provide this.
				data.OtherFields = append(data.OtherFields, FieldInfo{
					Name:    field.Name,
					Type:    actualFieldTypeString,
					JSONTag: jsonTag,
				})
				fmt.Printf("      Found Other Field: %s (%s) json:\"%s\"\n", field.Name, actualFieldTypeString, jsonTag)
			}
		}

		if data.DiscriminatorFieldName == "" || data.OneOfFieldName == "" {
			fmt.Printf("  Skipping struct %s: missing discriminator or oneOf field\n", typeInfo.Name)
			continue
		}

		// Find implementations of the oneOfInterfaceName using go-scan's capabilities
		if oneOfInterfaceName != "" {
			for _, potentialImplTypeInfo := range pkgInfo.Types {
				if potentialImplTypeInfo.Kind != goscan.StructKind || potentialImplTypeInfo.Name == typeInfo.Name /* skip self */ {
					continue
				}
				// How to check if `potentialImplTypeInfo` implements `oneOfInterfaceName` using go-scan?
				// We need to check its methods against the interface's methods.
				// This requires resolving the interface definition and its methods,
				// and then checking methods of `potentialImplTypeInfo`.
				// This is complex. For now, let's use the testdata knowledge as a HACK.
				// HACK: Assume types "Circle" and "Rectangle" implement "Shape" if that's the interface.
				// Let's try to make this more robust.
				// 1. Resolve the interface type to get its definition.
				var oneOfInterfaceDef *goscan.TypeInfo
				for _, t := range pkgInfo.Types {
					if t.Name == oneOfInterfaceName && t.Kind == goscan.InterfaceKind {
						oneOfInterfaceDef = t
						break
					}
				}
				if oneOfInterfaceDef == nil || oneOfInterfaceDef.Interface == nil {
					fmt.Printf("    Warning: Could not find definition for interface %s in package %s. Skipping oneOf mapping.\n", oneOfInterfaceName, pkgInfo.Name)
				} else {
					// 2. Iterate through all types in the package.
					for _, structCandidate := range pkgInfo.Types {
						if structCandidate.Kind != goscan.StructKind || structCandidate.Name == typeInfo.Name {
							continue // Skip non-structs and the container struct itself
						}

						// 3. Check if structCandidate implements all methods of oneOfInterfaceDef
						if goscan.Implements(structCandidate, oneOfInterfaceDef) {
							jsonVal := strings.ToLower(structCandidate.Name)
							data.OneOfTypes = append(data.OneOfTypes, OneOfTypeMapping{
								JSONValue: jsonVal,
								GoType:    structCandidate.Name,
							})
							fmt.Printf("        Mapping: type \"%s\" -> %s (implements %s)\n", jsonVal, structCandidate.Name, oneOfInterfaceName)
						}
					}
				}
			}
		}


		if len(data.OneOfTypes) == 0 {
			// If the oneOf field is something like `interface{}`, this might be fine.
			// But for a specific interface, we expect implementations.
			// However, the interface itself might be a type parameter or from another package not easily scanned.
			// For now, if no types are mapped, we proceed, and the switch in the template will hit default.
			// This might be an error condition depending on requirements.
			fmt.Printf("  Warning: For struct %s, no types found implementing interface %s. Generated UnmarshalJSON might be incomplete.\n", typeInfo.Name, oneOfInterfaceName)
			continue
		}

		tmpl, err := template.New("unmarshal").Parse(unmarshalJSONTemplate)
		if err != nil {
			return fmt.Errorf("failed to parse template: %w", err)
		}

		var currentGeneratedCode bytes.Buffer
		if err := tmpl.Execute(&currentGeneratedCode, data); err != nil {
			return fmt.Errorf("failed to execute template for struct %s: %w", typeInfo.Name, err)
		}

		generatedCodeForAllStructs.Write(currentGeneratedCode.Bytes())
		generatedCodeForAllStructs.WriteString("\n\n")
		needsImportEncodingJson = true
		needsImportFmt = true
	}


	if generatedCodeForAllStructs.Len() == 0 {
		fmt.Println("No structs found requiring UnmarshalJSON generation.")
		return nil // Nothing to write
	}

	finalOutput := bytes.Buffer{}
	finalOutput.WriteString(fmt.Sprintf("// Code generated by derivingjson for package %s. DO NOT EDIT.\n\n", pkgInfo.Name))
	finalOutput.WriteString(fmt.Sprintf("package %s\n\n", pkgInfo.Name))

	if needsImportEncodingJson || needsImportFmt {
		finalOutput.WriteString("import (\n")
		if needsImportEncodingJson {
			finalOutput.WriteString("\t\"encoding/json\"\n")
		}
		if needsImportFmt {
			finalOutput.WriteString("\t\"fmt\"\n")
		}
		finalOutput.WriteString(")\n\n")
	}
	finalOutput.Write(generatedCodeForAllStructs.Bytes())

	formattedCode, err := format.Source(finalOutput.Bytes())
	if err != nil {
		fmt.Printf("Error formatting generated code for package %s: %v\nUnformatted code:\n%s\n", pkgInfo.Name, err, finalOutput.String())
		return fmt.Errorf("failed to format generated code for package %s: %w", pkgInfo.Name, err)
	}

	outputFileName := filepath.Join(pkgPath, fmt.Sprintf("%s_deriving.go", pkgInfo.Name))
	if _, err := os.Stat(outputFileName); err == nil {
		os.Remove(outputFileName)
	}

	err = os.WriteFile(outputFileName, formattedCode, 0644)
	if err != nil {
		return fmt.Errorf("failed to write generated code to %s: %w", outputFileName, err)
	}
	fmt.Printf("Generated code written to %s\n", outputFileName)

	return nil
}

// Old helper functions (getTypeName, getJSONTag, isInterfaceType, findImplementingTypes, etc.)
// would be removed or significantly refactored to use go-scan types.
// For now, they are effectively replaced by logic within Generate.
// The StructInfo type is also no longer needed in the same way.
// The ensureImports helper might still be useful or adapted.
// The template data structures (TemplateData, FieldInfo, OneOfTypeMapping) and the template itself remain.
