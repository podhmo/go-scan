// Code generated by convert2 tool. DO NOT EDIT.
package simple

import (
	"context"
	"errors"
	"fmt"
	"strings"
)

// errorCollector collects errors with path tracking.
type errorCollector struct {
	maxErrors int
	errors    []error
	pathStack []string
}

func newErrorCollector(maxErrors int) *errorCollector {
	return &errorCollector{
		maxErrors: maxErrors,
		errors:    make([]error, 0),
		pathStack: make([]string, 0),
	}
}
func (ec *errorCollector) Add(reason string) bool {
	if ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors {
		return true
	}
	fullPath := strings.Join(ec.pathStack, "")
	err := fmt.Errorf("%s: %s", fullPath, reason)
	ec.errors = append(ec.errors, err)
	return ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors
}
func (ec *errorCollector) Addf(format string, args ...interface{}) bool {
	if ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors {
		return true
	}
	return ec.Add(fmt.Sprintf(format, args...))
}
func (ec *errorCollector) Enter(segment string) {
	// separator variable was unused, logic is directly handled below.
	if strings.HasPrefix(segment, "[") && strings.HasSuffix(segment, "]") { // Array/slice index
		ec.pathStack = append(ec.pathStack, segment)
	} else { // Field name
		if len(ec.pathStack) == 0 {
			ec.pathStack = append(ec.pathStack, segment)
		} else {
			ec.pathStack = append(ec.pathStack, "."+segment)
		}
	}
}
func (ec *errorCollector) Leave() {
	if len(ec.pathStack) > 0 {
		ec.pathStack = ec.pathStack[:len(ec.pathStack)-1]
	}
}
func (ec *errorCollector) Errors() []error {
	return ec.errors
}
func (ec *errorCollector) HasErrors() bool {
	return len(ec.errors) > 0
}
func (ec *errorCollector) MaxErrorsReached() bool {
	return ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors
}

func srcSimpleToDstSimple(ec *errorCollector, src SrcSimple) DstSimple {
	dst := DstSimple{}
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field SrcSimple.ID (int) to DstSimple.ID (int)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("ID")
	dst.ID = src.ID
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field SrcSimple.Name (string) to DstSimple.Name (string)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("Name")
	dst.Name = src.Name
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Source field SrcSimple.Description is skipped due to tag '-'.
	// Mapping field SrcSimple.Value (float64) to DstSimple.Value (float64)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("Value")
	dst.Value = src.Value
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field SrcSimple.Timestamp (time.Time) to DstSimple.CreationTime (time.Time)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("CreationTime")
	dst.CreationTime = src.Timestamp
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field SrcSimple.PtrString (*string) to DstSimple.PtrString (*string)
	// Src: Ptr=true, ElemFull=string | Dst: Ptr=true, ElemFull=string
	ec.Enter("PtrString")
	dst.PtrString = src.PtrString
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field SrcSimple.StringPtr (string) to DstSimple.StringPtr (*string)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=true, ElemFull=string
	ec.Enter("StringPtr")
	{
		srcVal := src.StringPtr
		dst.StringPtr = &srcVal
	}
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field SrcSimple.PtrToValue (*float32) to DstSimple.PtrToValue (float32)
	// Src: Ptr=true, ElemFull=float32 | Dst: Ptr=false, ElemFull=nil
	ec.Enter("PtrToValue")
	if src.PtrToValue != nil {
		dst.PtrToValue = *src.PtrToValue
	}
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field SrcSimple.RequiredPtrToValue (*int) to DstSimple.RequiredPtrToValue (int)
	// Src: Ptr=true, ElemFull=int | Dst: Ptr=false, ElemFull=nil
	ec.Enter("RequiredPtrToValue")
	if src.RequiredPtrToValue == nil {
		ec.Addf("field 'RequiredPtrToValue' is required but source field RequiredPtrToValue is nil")
	} else {
		dst.RequiredPtrToValue = *src.RequiredPtrToValue
	}
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field SrcSimple.CustomIntToString (int) to DstSimple.CustomStr (string)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("CustomStr")
	// Applying field tag: using IntToStr
	dst.CustomStr = IntToStr(ec, src.CustomIntToString)
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

func srcWithAliasToDstWithAlias(ec *errorCollector, src SrcWithAlias) DstWithAlias {
	dst := DstWithAlias{}
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field SrcWithAlias.EventTime (example.com/convert2/testdata/simple.MyTime) to DstWithAlias.EventTimestamp (time.Time)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("EventTimestamp")
	// TODO: Implement conversion for EventTime (example.com/convert2/testdata/simple.MyTime) to EventTimestamp (time.Time).
	ec.Addf("type mismatch or complex conversion not yet implemented for field 'EventTimestamp' (example.com/convert2/testdata/simple.MyTime -> time.Time)")
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

func ConvertSrcSimple(ctx context.Context, src SrcSimple) (DstSimple, error) {
	ec := newErrorCollector(0)
	dst := srcSimpleToDstSimple(ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

func ConvertSrcWithAlias(ctx context.Context, src SrcWithAlias) (DstWithAlias, error) {
	ec := newErrorCollector(0)
	dst := srcWithAliasToDstWithAlias(ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
