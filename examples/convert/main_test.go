package main

import (
	"context"
	"go/format"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	goscan "github.com/podhmo/go-scan"
	"github.com/podhmo/go-scan/scanner"
	"github.com/podhmo/go-scan/scantest"
)

func TestGenerate(t *testing.T) {
	type want struct {
		Code string
	}
	cases := []struct {
		name  string
		files map[string]string
		want  want
	}{
		{
			name: "simple",
			files: map[string]string{
				"go.mod": `
module example.com/convert/testdata/simple
go 1.22.4
`,
				"models/models.go": `
package models

import "time"

// --- Source Structs ---

type SrcAddress struct {
	Street string
	City   string
}

type SrcContact struct {
	Email string
	Phone *string // Pointer to allow for nil
}

type SrcInternalDetail struct {
	Code        int
	Description string // This might need "translation"
}

type SrcUser struct {
	ID        int64
	FirstName string
	LastName  string
	SrcAddress
	ContactInfo SrcContact
	Details     []SrcInternalDetail
	CreatedAt   time.Time
	UpdatedAt   *time.Time
}

type SrcOrder struct {
	OrderID string
	Amount  float64
	Items   []SrcItem
}

type SrcItem struct {
	SKU      string
	Quantity int
}

// --- Destination Structs ---

type DstAddress struct {
	FullStreet string // Different name
	CityName   string // Different name
}

type DstContact struct {
	EmailAddress string // Different name
	PhoneNumber  string // Pointer to value
}

type DstInternalDetail struct {
	ItemCode      int    // Different name
	LocalizedDesc string // Different name, implies processing
}

type DstUser struct {
	UserID    string // Different type (int64 to string)
	FullName  string // Combination of FirstName and LastName
	Address   DstAddress
	Contact   DstContact
	Details   []DstInternalDetail
	CreatedAt string // Different type (time.Time to string)
	UpdatedAt string // Pointer to value, different type
}

type DstOrder struct {
	ID          string
	TotalAmount float64
	LineItems   []DstItem // Different name
}

type DstItem struct {
	ProductCode string // Different name
	Count       int    // Different name
}
`,
			},
			want: want{
				Code: `
// Code generated by go-scan for package converter. DO NOT EDIT.

package converter

import (
	context "context"
	fmt "fmt"
	time "time"
)

// ConvertUserToDstUser converts models.SrcUser to models.DstUser
func ConvertUserToDstUser(ctx context.Context, src models.SrcUser) models.DstUser {
	if ctx == nil {
		ctx = context.Background()
	}
	dst := models.DstUser{}
	dst.UserID = fmt.Sprintf("user-%d", src.ID)
	dst.FullName = src.FirstName + " " + src.LastName
	dst.Address = srcAddressToDstAddress(ctx, src.SrcAddress)
	dst.Contact = srcContactToDstContact(ctx, src.ContactInfo)
	if src.Details != nil {
		dst.Details = make([]models.DstInternalDetail, len(src.Details))
		for i, sElem := range src.Details {
			dst.Details[i] = srcInternalDetailToDstInternalDetail(ctx, sElem)
		}
	}
	dst.CreatedAt = src.CreatedAt.Format(time.RFC3339)
	if src.UpdatedAt != nil {
		dst.UpdatedAt = src.UpdatedAt.Format(time.RFC3339)
	} else {
		dst.UpdatedAt = ""
	}
	return dst
}

// ConvertOrderToDstOrder converts models.SrcOrder to models.DstOrder
func ConvertOrderToDstOrder(ctx context.Context, src models.SrcOrder) models.DstOrder {
	if ctx == nil {
		ctx = context.Background()
	}
	dst := models.DstOrder{}
	dst.ID = src.OrderID
	dst.TotalAmount = src.Amount
	if src.Items != nil {
		dst.LineItems = make([]models.DstItem, len(src.Items))
		for i, sElem := range src.Items {
			dst.LineItems[i] = srcItemToDstItem(ctx, sElem)
		}
	}
	return dst
}

// srcAddressToDstAddress converts models.SrcAddress to models.DstAddress
func srcAddressToDstAddress(ctx context.Context, src models.SrcAddress) models.DstAddress {
	if ctx == nil {
		ctx = context.Background()
	}
	dst := models.DstAddress{}
	dst.FullStreet = src.Street
	dst.CityName = src.City
	return dst
}

// srcContactToDstContact converts models.SrcContact to models.DstContact
func srcContactToDstContact(ctx context.Context, src models.SrcContact) models.DstContact {
	if ctx == nil {
		ctx = context.Background()
	}
	dst := models.DstContact{}
	dst.EmailAddress = src.Email
	if src.Phone != nil {
		dst.PhoneNumber = *src.Phone
	} else {
		dst.PhoneNumber = "N/A"
	}
	return dst
}

// srcInternalDetailToDstInternalDetail converts models.SrcInternalDetail to models.DstInternalDetail
func srcInternalDetailToDstInternalDetail(ctx context.Context, src models.SrcInternalDetail) models.DstInternalDetail {
	if ctx == nil {
		ctx = context.Background()
	}
	dst := models.DstInternalDetail{}
	dst.ItemCode = src.Code
	dst.LocalizedDesc = translateDescription(ctx, src.Description, "jp") // TODO: Make lang configurable
	return dst
}

// srcItemToDstItem converts models.SrcItem to models.DstItem
func srcItemToDstItem(ctx context.Context, src models.SrcItem) models.DstItem {
	if ctx == nil {
		ctx = context.Background()
	}
	dst := models.DstItem{}
	dst.ProductCode = src.SKU
	dst.Count = src.Quantity
	return dst
}

// translateDescription is a helper function simulating internal processing.
func translateDescription(ctx context.Context, text string, targetLang string) string {
	if targetLang == "jp" {
		return "翻訳済み (JP): " + text
	}
	return text
}
`,
			},
		},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			tmpdir, cleanup := scantest.WriteFiles(t, tc.files)
			defer cleanup()

			action := func(ctx context.Context, s *goscan.Scanner, pkgs []*scanner.PackageInfo) error {
				for _, pkg := range pkgs {
					if err := Generate(ctx, s, pkg); err != nil {
						return err
					}
				}
				return nil
			}

			result, err := scantest.Run(t, tmpdir, []string{"./models"}, action)
			if err != nil {
				t.Fatalf("scantest.Run failed: %+v", err)
			}

			if result == nil {
				t.Fatal("scantest.Run result is nil")
			}
			if len(result.Outputs) != 1 {
				t.Fatalf("unexpected number of outputs, got %d, want 1", len(result.Outputs))
			}

			var got string
			// The output file name is 'generated_converters.go'.
			filename := "generated_converters.go"
			gotBytes, ok := result.Outputs[filename]
			if !ok {
				// Collect available keys for a better error message
				availableKeys := make([]string, 0, len(result.Outputs))
				for k := range result.Outputs {
					availableKeys = append(availableKeys, k)
				}
				t.Fatalf("expected output file %q not found; available files: %v", filename, availableKeys)
			}
			got = string(gotBytes)

			// Format both got and want code for a consistent comparison
			formattedGot, err := format.Source([]byte(got))
			if err != nil {
				t.Fatalf("failed to format generated code: %+v\n--- raw output ---\n%s", err, got)
			}

			formattedWant, err := format.Source([]byte(tc.want.Code))
			if err != nil {
				t.Fatalf("failed to format want code: %+v", err)
			}

			if diff := cmp.Diff(strings.TrimSpace(string(formattedWant)), strings.TrimSpace(string(formattedGot))); diff != "" {
				t.Errorf("generated code mismatch (-want +got):\n%s", diff)
			}
		})
	}
}
