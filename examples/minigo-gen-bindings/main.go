package main

import (
	"context"
	"flag"
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	goscan "github.com/podhmo/go-scan"
)

var dependencies = map[string][]string{
	"text/template": {
		"bytes",
		"errors",
		"fmt",
		"io",
		"net/url",
		"os",
		"path/filepath",
		"strings",
	},
}

var tmpl = template.Must(template.New("install.go").Parse(`// Code generated by minigo-gen-bindings. DO NOT EDIT.

package {{ .PackageName }}

import (
	"{{ .PackagePath }}"
	"github.com/podhmo/go-scan/minigo"
	{{- range .Dependencies }}
	std{{ .PkgName }} "github.com/podhmo/go-scan/minigo/stdlib/{{ .Path }}"
	{{- end }}
)

// Install binds all exported symbols from the "{{ .PackagePath }}" package to the interpreter.
func Install(interp *minigo.Interpreter, installed map[string]bool) {
	if installed["{{ .PackagePath }}"] {
		return
	}
	installed["{{ .PackagePath }}"] = true

	{{- range .Dependencies }}
	std{{ .PkgName }}.Install(interp, installed)
	{{- end }}

	interp.Register("{{ .PackagePath }}", map[string]any{
		{{- range .Symbols }}
		"{{ . }}": {{ $.PackageName }}.{{ . }},
		{{- end }}
	})
}
`))

func main() {
	var (
		outputDir = flag.String("output", "", "output directory")
	)
	flag.Parse()

	if *outputDir == "" {
		slog.Error("-output flag is required")
		os.Exit(1)
	}

	pkgPaths := flag.Args()
	if len(pkgPaths) == 0 {
		slog.Error("at least one package path is required")
		os.Exit(1)
	}

	ctx := context.Background()
	logger := slog.Default()
	ctx = context.WithValue(ctx, "logger", logger)

	if err := run(ctx, *outputDir, pkgPaths); err != nil {
		slog.ErrorContext(ctx, "!!", slog.Any("error", err))
		os.Exit(1)
	}
}

func run(ctx context.Context, outputDir string, pkgPaths []string) error {
	s, err := goscan.New(goscan.WithGoModuleResolver())
	if err != nil {
		return fmt.Errorf("failed to create scanner: %w", err)
	}

	for _, pkgPath := range pkgPaths {
		slog.InfoContext(ctx, "processing package", slog.String("package", pkgPath))
		if err := generate(ctx, s, outputDir, pkgPath); err != nil {
			return fmt.Errorf("failed to generate for package %q: %w", pkgPath, err)
		}
	}
	return nil
}

type Dependency struct {
	PkgName string
	Path    string
}

func generate(ctx context.Context, s *goscan.Scanner, outputDir, pkgPath string) error {
	pkgInfo, err := s.ScanPackageByImport(ctx, pkgPath)
	if err != nil {
		return fmt.Errorf("failed to scan package %s: %w", pkgPath, err)
	}

	symbols := make(map[string]struct{})
	for _, f := range pkgInfo.Functions {
		if f.Receiver == nil && f.AstDecl != nil && f.AstDecl.Name != nil && f.AstDecl.Name.IsExported() {
			symbols[f.Name] = struct{}{}
		}
	}
	for _, c := range pkgInfo.Constants {
		if c.IsExported {
			symbols[c.Name] = struct{}{}
		}
	}

	symbolSlice := make([]string, 0, len(symbols))
	for s := range symbols {
		symbolSlice = append(symbolSlice, s)
	}

	pkgName := pkgInfo.Name
	deps := dependencies[pkgPath]
	depInfos := make([]Dependency, len(deps))
	for i, depPath := range deps {
		parts := strings.Split(depPath, "/")
		depInfos[i] = Dependency{
			PkgName: parts[len(parts)-1],
			Path:    depPath,
		}
	}

	params := struct {
		PackageName  string
		PackagePath  string
		Symbols      []string
		Dependencies []Dependency
	}{
		PackageName:  pkgName,
		PackagePath:  pkgPath,
		Symbols:      symbolSlice,
		Dependencies: depInfos,
	}

	pkgOutputDir := filepath.Join(outputDir, pkgPath)
	if err := os.MkdirAll(pkgOutputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory %q: %w", pkgOutputDir, err)
	}

	filePath := filepath.Join(pkgOutputDir, "install.go")
	f, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create output file %q: %w", filePath, err)
	}
	defer f.Close()

	if err := tmpl.Execute(f, params); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}
	slog.InfoContext(ctx, "generated", slog.String("path", filePath))
	return nil
}
