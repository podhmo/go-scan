// Code generated by convert2 tool. DO NOT EDIT.
package simple

import (
	"context"
	"errors"
	"fmt"
	"strings"
)

// errorCollector collects errors with path tracking.
type errorCollector struct {
	maxErrors int
	errors    []error
	pathStack []string
}

func newErrorCollector(maxErrors int) *errorCollector {
	return &errorCollector{
		maxErrors: maxErrors,
		errors:    make([]error, 0),
		pathStack: make([]string, 0),
	}
}
func (ec *errorCollector) Add(reason string) bool {
	if ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors {
		return true
	}
	fullPath := strings.Join(ec.pathStack, "")
	err := fmt.Errorf("%s: %s", fullPath, reason)
	ec.errors = append(ec.errors, err)
	return ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors
}
func (ec *errorCollector) Addf(format string, args ...interface{}) bool {
	if ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors {
		return true
	}
	return ec.Add(fmt.Sprintf(format, args...))
}
func (ec *errorCollector) Enter(segment string) {
	// separator variable was unused, logic is directly handled below.
	if strings.HasPrefix(segment, "[") && strings.HasSuffix(segment, "]") { // Array/slice index
		ec.pathStack = append(ec.pathStack, segment)
	} else { // Field name
		if len(ec.pathStack) == 0 {
			ec.pathStack = append(ec.pathStack, segment)
		} else {
			ec.pathStack = append(ec.pathStack, "."+segment)
		}
	}
}
func (ec *errorCollector) Leave() {
	if len(ec.pathStack) > 0 {
		ec.pathStack = ec.pathStack[:len(ec.pathStack)-1]
	}
}
func (ec *errorCollector) Errors() []error {
	return ec.errors
}
func (ec *errorCollector) HasErrors() bool {
	return len(ec.errors) > 0
}
func (ec *errorCollector) MaxErrorsReached() bool {
	return ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors
}

// srcSimpleToDstSimple converts SrcSimple to DstSimple.
// Fields in DstSimple not populated by this conversion:
// - NoMatchSrc
func srcSimpleToDstSimple(ec *errorCollector, src SrcSimple) DstSimple {
	dst := DstSimple{}
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field SrcSimple.ID (int) to DstSimple.ID (int)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("ID")
	dst.ID = src.ID
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field SrcSimple.Name (string) to DstSimple.Name (string)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("Name")
	dst.Name = src.Name
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Source field SrcSimple.Description is skipped due to tag '-'.
	// Mapping field SrcSimple.Value (float64) to DstSimple.Value (float64)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("Value")
	dst.Value = src.Value
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field SrcSimple.Timestamp (time.Time) to DstSimple.CreationTime (time.Time)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("CreationTime")
	dst.CreationTime = src.Timestamp
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field SrcSimple.PtrString (*string) to DstSimple.PtrString (*string)
	// Src: Ptr=true, ElemFull=string | Dst: Ptr=true, ElemFull=string
	ec.Enter("PtrString")
	dst.PtrString = src.PtrString
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field SrcSimple.StringPtr (string) to DstSimple.StringPtr (*string)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=true, ElemFull=string
	ec.Enter("StringPtr")
	{
		srcVal := src.StringPtr
		dst.StringPtr = &srcVal
	}
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field SrcSimple.PtrToValue (*float32) to DstSimple.PtrToValue (float32)
	// Src: Ptr=true, ElemFull=float32 | Dst: Ptr=false, ElemFull=nil
	ec.Enter("PtrToValue")
	if src.PtrToValue != nil {
		dst.PtrToValue = *src.PtrToValue
	}
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field SrcSimple.RequiredPtrToValue (*int) to DstSimple.RequiredPtrToValue (int)
	// Src: Ptr=true, ElemFull=int | Dst: Ptr=false, ElemFull=nil
	ec.Enter("RequiredPtrToValue")
	if src.RequiredPtrToValue == nil {
		ec.Addf("field 'RequiredPtrToValue' is required but source field RequiredPtrToValue is nil")
	} else {
		dst.RequiredPtrToValue = *src.RequiredPtrToValue
	}
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field SrcSimple.CustomIntToString (int) to DstSimple.CustomStr (string)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("CustomStr")
	// Applying field tag: using IntToStr
	dst.CustomStr = IntToStr(ec, src.CustomIntToString)
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

func srcWithAliasToDstWithAlias(ec *errorCollector, src SrcWithAlias) DstWithAlias {
	dst := DstWithAlias{}
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field SrcWithAlias.EventTime (example.com/convert2/testdata/simple.MyTime) to DstWithAlias.EventTimestamp (time.Time)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("EventTimestamp")
	// TODO: Implement conversion for EventTime (example.com/convert2/testdata/simple.MyTime) to EventTimestamp (time.Time).
	ec.Addf("type mismatch or complex conversion not yet implemented for field 'EventTimestamp' (example.com/convert2/testdata/simple.MyTime -> time.Time)")
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

func innerSrcToInnerDst(ec *errorCollector, src InnerSrc) InnerDst {
	dst := InnerDst{}
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field InnerSrc.InnerID (int) to InnerDst.InnerID (int)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("InnerID")
	dst.InnerID = src.InnerID
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field InnerSrc.InnerName (string) to InnerDst.InnerName (string)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("InnerName")
	dst.InnerName = src.InnerName
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

func outerSrcToOuterDst(ec *errorCollector, src OuterSrc) OuterDst {
	dst := OuterDst{}
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field OuterSrc.OuterID (int) to OuterDst.OuterID (int)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("OuterID")
	dst.OuterID = src.OuterID
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field OuterSrc.Nested (example.com/convert2/testdata/simple.InnerSrc) to OuterDst.Nested (example.com/convert2/testdata/simple.InnerDst)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("Nested")
	// Recursive call for nested struct InnerSrc -> InnerDst
	dst.Nested = innerSrcToInnerDst(ec, src.Nested)
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field OuterSrc.NestedPtr (*example.com/convert2/testdata/simple.InnerSrc) to OuterDst.NestedPtr (*example.com/convert2/testdata/simple.InnerDst)
	// Src: Ptr=true, ElemFull=example.com/convert2/testdata/simple.InnerSrc | Dst: Ptr=true, ElemFull=example.com/convert2/testdata/simple.InnerDst
	ec.Enter("NestedPtr")
	// Recursive call for nested struct InnerSrc -> InnerDst
	if src.NestedPtr != nil {
		nestedVal := innerSrcToInnerDst(ec, *src.NestedPtr)
		dst.NestedPtr = &nestedVal
	} else {
		dst.NestedPtr = nil // Source pointer is nil, so destination pointer is nil
	}
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field OuterSrc.Name (string) to OuterDst.OuterName (string)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("OuterName")
	dst.OuterName = src.Name
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

func innerSrcDiffToInnerDstDiff(ec *errorCollector, src InnerSrcDiff) InnerDstDiff {
	dst := InnerDstDiff{}
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field InnerSrcDiff.SrcInnerVal (int) to InnerDstDiff.DstInnerVal (int)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("DstInnerVal")
	dst.DstInnerVal = src.SrcInnerVal
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

func outerSrcDiffToOuterDstDiff(ec *errorCollector, src OuterSrcDiff) OuterDstDiff {
	dst := OuterDstDiff{}
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field OuterSrcDiff.ID (int) to OuterDstDiff.ID (int)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("ID")
	dst.ID = src.ID
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// Mapping field OuterSrcDiff.DiffNested (example.com/convert2/testdata/simple.InnerSrcDiff) to OuterDstDiff.DestNested (example.com/convert2/testdata/simple.InnerDstDiff)
	// Src: Ptr=false, ElemFull=nil | Dst: Ptr=false, ElemFull=nil
	ec.Enter("DestNested")
	// Recursive call for nested struct InnerSrcDiff -> InnerDstDiff
	dst.DestNested = innerSrcDiffToInnerDstDiff(ec, src.DiffNested)
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

func ConvertInnerSrcDiffToInnerDstDiff(ctx context.Context, src InnerSrcDiff) (InnerDstDiff, error) {
	ec := newErrorCollector(0)
	dst := innerSrcDiffToInnerDstDiff(ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

func ConvertOuterSrcDiffToOuterDstDiff(ctx context.Context, src OuterSrcDiff) (OuterDstDiff, error) {
	ec := newErrorCollector(0)
	dst := outerSrcDiffToOuterDstDiff(ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

func ConvertSrcSimpleToDstSimple(ctx context.Context, src SrcSimple) (DstSimple, error) {
	ec := newErrorCollector(0)
	dst := srcSimpleToDstSimple(ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

func ConvertSrcWithAliasToDstWithAlias(ctx context.Context, src SrcWithAlias) (DstWithAlias, error) {
	ec := newErrorCollector(0)
	dst := srcWithAliasToDstWithAlias(ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

func ConvertInnerSrcToInnerDst(ctx context.Context, src InnerSrc) (InnerDst, error) {
	ec := newErrorCollector(0)
	dst := innerSrcToInnerDst(ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

func ConvertOuterSrcToOuterDst(ctx context.Context, src OuterSrc) (OuterDst, error) {
	ec := newErrorCollector(0)
	dst := outerSrcToOuterDst(ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
