// Code generated by go-scan for package converter. DO NOT EDIT.

package converter

import (
	"context"
	destination "example.com/convert/models/destination"
	source "example.com/convert/models/source"
	"time"
)

// ConvertSrcUserToDstUser converts SrcUser to DstUser.
func ConvertSrcUserToDstUser(ctx context.Context, src source.SrcUser) (destination.DstUser, error) {
	dst := convertSrcUserToDstUser(ctx, src)
	return dst, nil
}

// convertSrcUserToDstUser is the internal conversion function.
func convertSrcUserToDstUser(ctx context.Context, src source.SrcUser) destination.DstUser {
	dst := destination.DstUser{}

	if src.Details != nil {
		newSlice := make([]destination.DstInternalDetail, 0, len(src.Details))
		for _, elem := range src.Details {
			newSlice = append(newSlice, convertSrcInternalDetailToDstInternalDetail(ctx, elem))
		}
		dst.Details = newSlice
	}
	dst.CreatedAt = src.CreatedAt
	if src.UpdatedAt != nil {
		dst.UpdatedAt = *src.UpdatedAt
	}
	return dst
}

// ConvertSrcOrderToDstOrder converts SrcOrder to DstOrder.
func ConvertSrcOrderToDstOrder(ctx context.Context, src source.SrcOrder) (destination.DstOrder, error) {
	dst := convertSrcOrderToDstOrder(ctx, src)
	return dst, nil
}

// convertSrcOrderToDstOrder is the internal conversion function.
func convertSrcOrderToDstOrder(ctx context.Context, src source.SrcOrder) destination.DstOrder {
	dst := destination.DstOrder{}
	dst.OrderID = src.OrderID
	if src.Items != nil {
		newSlice := make([]destination.DstItem, 0, len(src.Items))
		for _, elem := range src.Items {
			newSlice = append(newSlice, convertSrcItemToDstItem(ctx, elem))
		}
		dst.Items = newSlice
	}
	return dst
}

// ConvertComplexSourceToComplexTarget converts ComplexSource to ComplexTarget.
func ConvertComplexSourceToComplexTarget(ctx context.Context, src source.ComplexSource) (destination.ComplexTarget, error) {
	dst := convertComplexSourceToComplexTarget(ctx, src)
	return dst, nil
}

// convertComplexSourceToComplexTarget is the internal conversion function.
func convertComplexSourceToComplexTarget(ctx context.Context, src source.ComplexSource) destination.ComplexTarget {
	dst := destination.ComplexTarget{}
	dst.Value = src.Value
	if src.Ptr != nil {
		tmp := *src.Ptr
		dst.Ptr = &tmp
	}

	if src.Slice != nil {
		newSlice := make([]destination.SubTarget, 0, len(src.Slice))
		for _, elem := range src.Slice {
			newSlice = append(newSlice, convertSubSourceToSubTarget(ctx, elem))
		}
		dst.Slice = newSlice
	}

	if src.SliceOfPtrs != nil {
		newSlice := make([]*destination.SubTarget, 0, len(src.SliceOfPtrs))
		for _, elem := range src.SliceOfPtrs {
			if elem != nil {
				tmp := convertSubSourceToSubTarget(ctx, *elem)
				newSlice = append(newSlice, &tmp)
			}
		}
		dst.SliceOfPtrs = newSlice
	}
	return dst
}

// convertSrcInternalDetailToDstInternalDetail is the internal conversion function.
func convertSrcInternalDetailToDstInternalDetail(ctx context.Context, src source.SrcInternalDetail) destination.DstInternalDetail {
	dst := destination.DstInternalDetail{}
	dst.Code = src.Code
	dst.Description = src.Description
	return dst
}

// convertSrcItemToDstItem is the internal conversion function.
func convertSrcItemToDstItem(ctx context.Context, src source.SrcItem) destination.DstItem {
	dst := destination.DstItem{}
	dst.SKU = src.SKU
	dst.Quantity = src.Quantity
	return dst
}

// convertSubSourceToSubTarget is the internal conversion function.
func convertSubSourceToSubTarget(ctx context.Context, src source.SubSource) destination.SubTarget {
	dst := destination.SubTarget{}
	dst.Value = src.Value
	return dst
}
