
// Code generated by convert. DO NOT EDIT.
package generated

import (
	"context"
	"errors"
	"fmt"
	"time"
	"github.com/podhmo/go-scan/examples/convert/model"
	destination "github.com/podhmo/go-scan/examples/convert/sampledata/destination"
	time "time"
)

func convertSrcUserToDstUser(ctx context.Context, ec *model.ErrorCollector, src *SrcUser) *DstUser {
	if src == nil {
		return nil
	}
	dst := &DstUser{}
	if ec.MaxErrorsReached() { return dst }
	ec.Enter("Details")
	dst.Details = func() []destination.DstInternalDetail {
	convertedSlice := make([]destination.DstInternalDetail, len(src.Details))
	for i, item := range src.Details {
		ec.Enter(fmt.Sprintf("[%d]", i))
		convertedSlice[i] = *convertSrcInternalDetailToDstInternalDetail(ctx, ec, &item)
		ec.Leave()
	}
	return convertedSlice
}()
	ec.Leave()
	if ec.MaxErrorsReached() { return dst }
	ec.Enter("CreatedAt")
	dst.CreatedAt = src.CreatedAt
	ec.Leave()
	if ec.MaxErrorsReached() { return dst }
	ec.Enter("UpdatedAt")
	// Cannot convert pointer to value, element type is nil
	ec.Leave()
	return dst
}

// ConvertSrcUserToDstUser converts SrcUser to DstUser.
func ConvertSrcUserToDstUser(ctx context.Context, src *SrcUser) (*DstUser, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSrcUserToDstUser(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
func convertSrcInternalDetailToDstInternalDetail(ctx context.Context, ec *model.ErrorCollector, src *SrcInternalDetail) *DstInternalDetail {
	if src == nil {
		return nil
	}
	dst := &DstInternalDetail{}
	return dst
}

// ConvertSrcInternalDetailToDstInternalDetail converts SrcInternalDetail to DstInternalDetail.
func ConvertSrcInternalDetailToDstInternalDetail(ctx context.Context, src *SrcInternalDetail) (*DstInternalDetail, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSrcInternalDetailToDstInternalDetail(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
func convertSrcOrderToDstOrder(ctx context.Context, ec *model.ErrorCollector, src *SrcOrder) *DstOrder {
	if src == nil {
		return nil
	}
	dst := &DstOrder{}
	return dst
}

// ConvertSrcOrderToDstOrder converts SrcOrder to DstOrder.
func ConvertSrcOrderToDstOrder(ctx context.Context, src *SrcOrder) (*DstOrder, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSrcOrderToDstOrder(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
func convertComplexSourceToComplexTarget(ctx context.Context, ec *model.ErrorCollector, src *ComplexSource) *ComplexTarget {
	if src == nil {
		return nil
	}
	dst := &ComplexTarget{}
	if ec.MaxErrorsReached() { return dst }
	ec.Enter("Value")
	dst.Value = src.Value
	ec.Leave()
	if ec.MaxErrorsReached() { return dst }
	ec.Enter("Ptr")
	dst.Ptr = src.Ptr // Cannot convert pointer types, element type is nil
	ec.Leave()
	if ec.MaxErrorsReached() { return dst }
	ec.Enter("Slice")
	dst.Slice = func() []destination.SubTarget {
	convertedSlice := make([]destination.SubTarget, len(src.Slice))
	for i, item := range src.Slice {
		ec.Enter(fmt.Sprintf("[%d]", i))
		convertedSlice[i] = *convertSubSourceToSubTarget(ctx, ec, &item)
		ec.Leave()
	}
	return convertedSlice
}()
	ec.Leave()
	if ec.MaxErrorsReached() { return dst }
	ec.Enter("SliceOfPtrs")
	dst.SliceOfPtrs = func() []*interface{} {
	convertedSlice := make([]*interface{}, len(src.SliceOfPtrs))
	for i, item := range src.SliceOfPtrs {
		ec.Enter(fmt.Sprintf("[%d]", i))
		convertedSlice[i] = item
		ec.Leave()
	}
	return convertedSlice
}()
	ec.Leave()
	return dst
}

// ConvertComplexSourceToComplexTarget converts ComplexSource to ComplexTarget.
func ConvertComplexSourceToComplexTarget(ctx context.Context, src *ComplexSource) (*ComplexTarget, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertComplexSourceToComplexTarget(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
func convertSubSourceToSubTarget(ctx context.Context, ec *model.ErrorCollector, src *SubSource) *SubTarget {
	if src == nil {
		return nil
	}
	dst := &SubTarget{}
	if ec.MaxErrorsReached() { return dst }
	ec.Enter("Value")
	dst.Value = src.Value
	ec.Leave()
	return dst
}

// ConvertSubSourceToSubTarget converts SubSource to SubTarget.
func ConvertSubSourceToSubTarget(ctx context.Context, src *SubSource) (*SubTarget, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSubSourceToSubTarget(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
func convertSourceWithMapToTargetWithMap(ctx context.Context, ec *model.ErrorCollector, src *SourceWithMap) *TargetWithMap {
	if src == nil {
		return nil
	}
	dst := &TargetWithMap{}
	if ec.MaxErrorsReached() { return dst }
	ec.Enter("ValueMap")
	dst.ValueMap = func() map[string]destination.SubTarget {
	convertedMap := make(map[string]destination.SubTarget, len(src.ValueMap))
	for key, value := range src.ValueMap {
		ec.Enter(fmt.Sprintf("[%v]", key))
		convertedMap[key] = *convertSubSourceToSubTarget(ctx, ec, &value)
		ec.Leave()
	}
	return convertedMap
}()
	ec.Leave()
	if ec.MaxErrorsReached() { return dst }
	ec.Enter("PtrMap")
	dst.PtrMap = func() map[string]*interface{} {
	convertedMap := make(map[string]*interface{}, len(src.PtrMap))
	for key, value := range src.PtrMap {
		ec.Enter(fmt.Sprintf("[%v]", key))
		convertedMap[key] = value
		ec.Leave()
	}
	return convertedMap
}()
	ec.Leave()
	if ec.MaxErrorsReached() { return dst }
	ec.Enter("StringToStr")
	dst.StringToStr = func() map[string]string {
	convertedMap := make(map[string]string, len(src.StringToStr))
	for key, value := range src.StringToStr {
		ec.Enter(fmt.Sprintf("[%v]", key))
		convertedMap[key] =  = value
		ec.Leave()
	}
	return convertedMap
}()
	ec.Leave()
	return dst
}

// ConvertSourceWithMapToTargetWithMap converts SourceWithMap to TargetWithMap.
func ConvertSourceWithMapToTargetWithMap(ctx context.Context, src *SourceWithMap) (*TargetWithMap, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSourceWithMapToTargetWithMap(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
