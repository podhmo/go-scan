// Code generated by derivngbind for package simple. DO NOT EDIT.

package simple

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
)

func (s *ComprehensiveBind) Bind(req *http.Request, pathVar func(string) string) error {
	var err error
	_ = err // prevent unused var error if no error handling is needed below

	// Path parameter binding for field PathString (string) from "id"
	if pathValueStr := pathVar("id"); pathValueStr != "" {

		s.PathString = pathValueStr

	} else {

		// For non-pointer, non-required, missing path param means field remains zero-value.
	}

	// Query parameter binding for field QueryName (string) from "name"

	if req.URL.Query().Has("name") {
		val := req.URL.Query().Get("name")

		s.QueryName = val

	} else { // Key does not exist

		// For non-pointer, non-required, missing param means field remains zero-value.
	}

	// Query parameter binding for field QueryAge (int) from "age"

	if req.URL.Query().Has("age") {
		val := req.URL.Query().Get("age")

		v, err := strconv.Atoi(val)
		if err != nil {
			return fmt.Errorf("failed to convert query parameter \"age\" (value: %q) to int for field QueryAge: %w", val, err)
		}

		s.QueryAge = v

	} else { // Key does not exist

		// For non-pointer, non-required, missing param means field remains zero-value.
	}

	// Query parameter binding for field QueryActive (bool) from "active"

	if req.URL.Query().Has("active") {
		val := req.URL.Query().Get("active")

		v, err := strconv.ParseBool(val)
		if err != nil {
			return fmt.Errorf("failed to convert query parameter \"active\" (value: %q) to bool for field QueryActive: %w", val, err)
		}

		s.QueryActive = v

	} else { // Key does not exist

		// For non-pointer, non-required, missing param means field remains zero-value.
	}

	// Header binding for field HeaderToken (string) from "X-Auth-Token"
	if val := req.Header.Get("X-Auth-Token"); val != "" {

		s.HeaderToken = val

	} else {

	}

	// Cookie binding for field CookieSession (string) from "session_id"
	if cookie, cerr := req.Cookie("session_id"); cerr == nil && cookie.Value != "" {
		val := cookie.Value

		s.CookieSession = val

	} else { // Cookie not found or value is empty

		// If cerr is .ErrNoCookie and not required, it's fine. Field remains nil/zero.
		// If other cerr, it might be an issue even if not required, but current logic is to ignore.
	}

	if req.Body != nil && req.Body != http.NoBody {
		isSpecificFieldBodyTarget := false

		if isSpecificFieldBodyTarget {

		} else {
			// The struct ComprehensiveBind itself is the target for the request body
			if err := json.NewDecoder(req.Body).Decode(s); err != nil {
				if err != io.EOF { // EOF might be acceptable
					return fmt.Errorf("failed to decode request body into ComprehensiveBind: %w", err)
				}
			}
		}

	}

	return nil
}

func (s *SpecificBodyFieldBind) Bind(req *http.Request, pathVar func(string) string) error {
	var err error
	_ = err // prevent unused var error if no error handling is needed below

	// Header binding for field RequestID (string) from "X-Request-ID"
	if val := req.Header.Get("X-Request-ID"); val != "" {

		s.RequestID = val

	} else {

	}

	// Query parameter binding for field OtherQueryParam (string) from "other"

	if req.URL.Query().Has("other") {
		val := req.URL.Query().Get("other")

		s.OtherQueryParam = val

	} else { // Key does not exist

		// For non-pointer, non-required, missing param means field remains zero-value.
	}

	if req.Body != nil && req.Body != http.NoBody {
		isSpecificFieldBodyTarget := false

		isSpecificFieldBodyTarget = true

		if isSpecificFieldBodyTarget {

			// Field Payload is the target for the entire request body
			if err := json.NewDecoder(req.Body).Decode(&s.Payload); err != nil {
				if err != io.EOF { // EOF might be acceptable if body is optional
					return fmt.Errorf("failed to decode request body into field Payload: %w", err)
				}
			}
			goto afterBodyProcessing // Process only one 'in:"body"' field

		} else {
			// The struct SpecificBodyFieldBind itself is the target for the request body
			if err := json.NewDecoder(req.Body).Decode(s); err != nil {
				if err != io.EOF { // EOF might be acceptable
					return fmt.Errorf("failed to decode request body into SpecificBodyFieldBind: %w", err)
				}
			}
		}

	afterBodyProcessing: // Label for goto only if there was a specific body field target that could jump here

	}

	return nil
}

func (s *FullBodyBind) Bind(req *http.Request, pathVar func(string) string) error {
	var err error
	_ = err // prevent unused var error if no error handling is needed below

	// Header binding for field SourceHeader (string) from "X-Source"
	if val := req.Header.Get("X-Source"); val != "" {

		s.SourceHeader = val

	} else {

	}

	if req.Body != nil && req.Body != http.NoBody {
		isSpecificFieldBodyTarget := false

		if isSpecificFieldBodyTarget {

		} else {
			// The struct FullBodyBind itself is the target for the request body
			if err := json.NewDecoder(req.Body).Decode(s); err != nil {
				if err != io.EOF { // EOF might be acceptable
					return fmt.Errorf("failed to decode request body into FullBodyBind: %w", err)
				}
			}
		}

	}

	return nil
}

func (s *QueryAndPathOnlyBind) Bind(req *http.Request, pathVar func(string) string) error {
	var err error
	_ = err // prevent unused var error if no error handling is needed below

	// Path parameter binding for field UserID (string) from "userID"
	if pathValueStr := pathVar("userID"); pathValueStr != "" {

		s.UserID = pathValueStr

	} else {

		// For non-pointer, non-required, missing path param means field remains zero-value.
	}

	// Query parameter binding for field ItemCode (string) from "itemCode"

	if req.URL.Query().Has("itemCode") {
		val := req.URL.Query().Get("itemCode")

		s.ItemCode = val

	} else { // Key does not exist

		// For non-pointer, non-required, missing param means field remains zero-value.
	}

	// Query parameter binding for field Limit (int) from "limit"

	if req.URL.Query().Has("limit") {
		val := req.URL.Query().Get("limit")

		v, err := strconv.Atoi(val)
		if err != nil {
			return fmt.Errorf("failed to convert query parameter \"limit\" (value: %q) to int for field Limit: %w", val, err)
		}

		s.Limit = v

	} else { // Key does not exist

		// For non-pointer, non-required, missing param means field remains zero-value.
	}

	return nil
}

func (s *TestRequiredNonPointerFields) Bind(req *http.Request, pathVar func(string) string) error {
	var err error
	_ = err // prevent unused var error if no error handling is needed below

	// Query parameter binding for field QueryStrRequired (string) from "qStrReq"

	if req.URL.Query().Has("qStrReq") {
		val := req.URL.Query().Get("qStrReq")

		s.QueryStrRequired = val

	} else { // Key does not exist

		return fmt.Errorf("required query parameter \"qStrReq\" for field QueryStrRequired is missing")

		// For non-pointer, non-required, missing param means field remains zero-value.
	}

	// Query parameter binding for field QueryIntRequired (int) from "qIntReq"

	if req.URL.Query().Has("qIntReq") {
		val := req.URL.Query().Get("qIntReq")

		v, err := strconv.Atoi(val)
		if err != nil {
			return fmt.Errorf("failed to convert query parameter \"qIntReq\" (value: %q) to int for field QueryIntRequired: %w", val, err)
		}

		s.QueryIntRequired = v

	} else { // Key does not exist

		return fmt.Errorf("required query parameter \"qIntReq\" for field QueryIntRequired is missing")

		// For non-pointer, non-required, missing param means field remains zero-value.
	}

	// Header binding for field HeaderStrRequired (string) from "hStrReq"
	if val := req.Header.Get("hStrReq"); val != "" {

		s.HeaderStrRequired = val

	} else {

		return fmt.Errorf("required header \"hStrReq\" for field HeaderStrRequired is missing")

	}

	// Path parameter binding for field PathStrRequired (string) from "pStrReq"
	if pathValueStr := pathVar("pStrReq"); pathValueStr != "" {

		s.PathStrRequired = pathValueStr

	} else {

		return fmt.Errorf("required path parameter \"pStrReq\" for field PathStrRequired is missing")

		// For non-pointer, non-required, missing path param means field remains zero-value.
	}

	// Cookie binding for field CookieStrRequired (string) from "cStrReq"
	if cookie, cerr := req.Cookie("cStrReq"); cerr == nil && cookie.Value != "" {
		val := cookie.Value

		s.CookieStrRequired = val

	} else { // Cookie not found or value is empty

		return fmt.Errorf("required cookie \"cStrReq\" for field CookieStrRequired is missing, empty, or could not be retrieved")

		// If cerr is .ErrNoCookie and not required, it's fine. Field remains nil/zero.
		// If other cerr, it might be an issue even if not required, but current logic is to ignore.
	}

	return nil
}
