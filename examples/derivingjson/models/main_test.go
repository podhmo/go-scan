package models

import (
	"encoding/json"
	"fmt"
	"reflect"
	"testing"
)

// TestUnmarshalAPIResponse tests the custom UnmarshalJSON functionality
// for APIResponse, which should be generated by the derivingjson generator.
func TestUnmarshalAPIResponse(t *testing.T) {
	fmt.Println("--- Unmarshaling Demo ---")

	// NOTE: The JSON samples have been slightly modified from the initial user request.
	// The "type" field values ("userprofile", "productinfo") match what the current
	// generator.go is expected to produce as discriminator values (lowercase of type name).
	// The original samples used "user_profile" and "product_info".
	// To make the generator use the original values, its discriminator detection logic
	// would need to be enhanced (e.g., by reading a struct tag or calling a method).
	jsonSamples := map[string]struct {
		jsonString string
		wantErr    bool
		expectedStatus string
		expectedDataType reflect.Type
		// We can add more specific checks for Data content if needed
	}{
		"Case 1: UserProfile": {
			jsonString: `{"status":"ok","data":{"type":"userprofile","userId":"u-abc","userName":"Jiro"}}`,
			wantErr:    false,
			expectedStatus: "ok",
			expectedDataType: reflect.TypeOf(&UserProfile{}),
		},
		"Case 2: ProductInfo": {
			jsonString: `{"status":"ok","data":{"type":"productinfo","productId":"p-xyz","productName":"Mouse","price":5000}}`,
			wantErr:    false,
			expectedStatus: "ok",
			expectedDataType: reflect.TypeOf(&ProductInfo{}),
		},
		"Case 3: Unknown Type": {
			// This will cause an error because "billing_info" is not a known type discriminator.
			jsonString: `{"status":"error","data":{"type":"billing_info","invoiceId":"i-123"}}`,
			wantErr:    true,
		},
		"Case 4: Invalid JSON in Data (missing type)": {
			// This will cause an error because the "type" field is missing in the data object.
			jsonString: `{"status":"error","data":{"invoiceId":"i-123"}}`,
			wantErr:    true,
		},
		"Case 5: Null Data": {
			jsonString: `{"status":"ok","data":null}`,
			wantErr:    false,
			expectedStatus: "ok",
			expectedDataType: nil, // Expect Data to be nil
		},
		"Case 6: Empty Data Object": {
			// This should also result in an error because 'type' field is missing.
			// The generated code's behavior for `aux.Data == "{}"` might lead to discriminator detection error.
			jsonString: `{"status":"error","data":{}}`,
			wantErr:    true,
		},
		"Case 7: Data field completely missing": {
			// This is valid if Data is omitempty or not required.
			// The current APIResponse struct does not use omitempty for Data.
			// Standard unmarshaling would leave Data as nil.
			// Our custom unmarshaler should behave similarly if aux.Data is not found (though json.RawMessage would be nil).
			// The Alias part handles this; aux.Data would be nil.
			jsonString: `{"status":"ok_no_data"}`,
			wantErr:    false,
			expectedStatus: "ok_no_data",
			expectedDataType: nil,
		},
	}

	for name, tc := range jsonSamples {
		t.Run(name, func(t *testing.T) {
			fmt.Printf("\n[%s]\n", name)
			fmt.Printf("Input JSON: %s\n", tc.jsonString)

			var response APIResponse
			// The UnmarshalJSON method for APIResponse is expected to be generated
			// in a file like models_deriving.go by the generator.
			err := json.Unmarshal([]byte(tc.jsonString), &response)

			if (err != nil) != tc.wantErr {
				t.Errorf("json.Unmarshal() error = %v, wantErr %v", err, tc.wantErr)
				return
			}

			if err != nil {
				fmt.Printf("Result: Unmarshal failed as expected! Error: %v\n", err)
			} else {
				fmt.Printf("Result: Unmarshal successful.\n")
				fmt.Printf("  - Response.Status: %s\n", response.Status)
				if response.Data != nil {
					fmt.Printf("  - Type of Response.Data: %T\n", response.Data)
					fmt.Printf("  - Value of Response.Data: %+v\n", response.Data)
				} else {
					fmt.Printf("  - Response.Data is nil\n")
				}


				if response.Status != tc.expectedStatus {
					t.Errorf("Expected Status %s, got %s", tc.expectedStatus, response.Status)
				}

				var currentDataType reflect.Type
				if response.Data != nil {
					currentDataType = reflect.TypeOf(response.Data)
				}

				if currentDataType != tc.expectedDataType {
					t.Errorf("Expected Response.Data type %v, got %v", tc.expectedDataType, currentDataType)
				}

				// Specific checks for UserProfile data
				if tc.expectedDataType == reflect.TypeOf(&UserProfile{}) && response.Data != nil {
					userProfile, ok := response.Data.(*UserProfile)
					if !ok {
						t.Errorf("Expected response.Data to be *UserProfile, but it's not")
					} else {
						if userProfile.UserID == "" || userProfile.UserName == "" {
							t.Errorf("UserProfile fields are not correctly unmarshalled: %+v", userProfile)
						}
					}
				}
                // Specific checks for ProductInfo data
				if tc.expectedDataType == reflect.TypeOf(&ProductInfo{}) && response.Data != nil {
					productInfo, ok := response.Data.(*ProductInfo)
					if !ok {
						t.Errorf("Expected response.Data to be *ProductInfo, but it's not")
					} else {
						if productInfo.ProductID == "" || productInfo.ProductName == "" || productInfo.Price == 0 {
							t.Errorf("ProductInfo fields are not correctly unmarshalled: %+v", productInfo)
						}
					}
				}
			}
		})
	}
}
