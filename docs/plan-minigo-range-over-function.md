> [!NOTE]
> This feature has been implemented.

# Implementation Plan for Range Over Function in `minigo`

## 1. Introduction

This document outlines the implementation plan for adding support for the "range over function" feature, introduced in Go 1.22, to the `minigo` interpreter. This feature allows iterating over a sequence of values generated by a function, using the standard `for...range` loop syntax.

The goal is to implement this feature in a way that is idiomatic to `minigo`'s architecture, requires minimal changes to the existing parser and AST, and provides a robust and well-tested addition to the interpreter's capabilities.

## 2. Background: Go 1.22 Range Over Function

In Go 1.22, the `for...range` statement was extended to work with functions. A function suitable for ranging (an "iterator") must have one of the following signatures:

```go
func(yield func() bool)
func(yield func(V) bool)
func(yield func(K, V) bool)
```

The loop body is effectively transformed into the `yield` function. When `yield` is called, the loop body executes with the provided values bound to the loop variables. If `yield` returns `false`, the iteration stops.

A common pattern is to use a "generator" function that returns an iterator function. The `range` statement then consumes the iterator. `minigo` supports this pattern naturally due to its dynamic typing.

```go
// Generator function that returns an iterator
func rangeUpTo(n int) iter.Seq[int] { // iter.Seq[int] is an alias for func(yield func(int) bool)
    // The returned function is the iterator
    return func(yield func(int) bool) {
        for i := 0; i < n; i++ {
            if !yield(i) {
                return
            }
        }
    }
}

// The for...range statement operates on the iterator returned by rangeUpTo(5)
for num := range rangeUpTo(5) {
    fmt.Println(num)
}
```

## 3. `minigo`'s Current Architecture

The core of `minigo`'s execution logic is in `minigo/evaluator/evaluator.go`. The `Eval` function recursively walks the AST.

The relevant part for this feature is the `evalForRangeStmt` function within the `Evaluator`. Currently, it handles ranging over:
- `*object.Array`
- `*object.String`
- `*object.Map`
- `*object.GoValue` (for wrapped Go slices and maps)

The function checks the type of the ranged expression and dispatches to a type-specific helper function (e.g., `evalRangeArray`). We will add a new case for `*object.Function`.

## 4. Proposed Implementation

The implementation will be contained entirely within the evaluator, with no changes to the parser or AST, as we are reusing the existing `ast.RangeStmt`.

### 4.1. Step 1: Extend `evalForRangeStmt`

The `evalForRangeStmt` function will be modified to check if the expression being ranged over is an `*object.Function`.

```go
// in evalForRangeStmt
switch iterable := iterable.(type) {
case *object.Array:
    return e.evalRangeArray(rs, iterable, env, fscope)
// ... other cases
case *object.Function: // New case
    return e.evalRangeFunction(rs, iterable, env, fscope)
default:
    return e.newError(rs.X.Pos(), "range operator not supported for %s", iterable.Type())
}
```

### 4.2. Step 2: Implement `evalRangeFunction`

This new function, `evalRangeFunction`, will contain the core logic.

1.  **Create a `yield` Built-in:** A new `*object.Builtin` will be created dynamically to serve as the `yield` function. This is preferable to creating an `*object.Function` because its behavior is defined by Go code, not an AST.

2.  **Define the `yield` Function's Logic:** The `Fn` of the built-in will:
    a.  Accept 0, 1, or 2 arguments (`...object.Object`).
    b.  Create a new, enclosed environment for the loop body: `loopEnv := object.NewEnclosedEnvironment(env)`.
    c.  Bind the arguments to the loop variables (`rs.Key`, `rs.Value`) in `loopEnv`. It must handle cases where `Key` or `Value` are the blank identifier `_`.
    d.  Evaluate the loop body: `result := e.Eval(rs.Body, loopEnv, fscope)`.
    e.  **Handle Control Flow:** The `result` of the evaluation determines the return value of `yield`.
        - If `result` is `object.BREAK`, `yield` returns `object.FALSE` to stop the iteration.
        - If `result` is `object.CONTINUE`, `yield` returns `object.TRUE` to continue.
        - If `result` is `object.ERROR` or `object.RETURN_VALUE`, it must be propagated. The `yield` function will store this special result in a variable in the parent `evalRangeFunction`'s scope and return `object.FALSE` to stop the loop immediately.
        - Otherwise, `yield` returns `object.TRUE`.

3.  **Call the User's Function:** The `evalRangeFunction` will then call the user's function (`iterable`) using `e.applyFunction`, passing the newly created `yield` built-in as the sole argument.

4.  **Propagate Results:** After the user's function returns, `evalRangeFunction` will check if an error or return value was captured from the `yield` function and, if so, return it. Otherwise, it will return `object.NIL` to signify successful completion of the loop.

### 4.3. Code Sketch

```go
// in evaluator.go
func (e *Evaluator) evalRangeFunction(rs *ast.RangeStmt, fn *object.Function, env *object.Environment, fscope *object.FileScope) object.Object {
    var loopErr object.Object // To capture errors/returns from the yield function

    yield := &object.Builtin{
        Fn: func(ctx *object.BuiltinContext, pos token.Pos, args ...object.Object) object.Object {
            // 1. Create enclosed environment for loop body
            loopEnv := object.NewEnclosedEnvironment(env)

            // 2. Bind loop variables (key, value) from args
            // ... (handle rs.Key, rs.Value, and arg count mismatch)

            // 3. Evaluate the loop body
            result := e.Eval(rs.Body, loopEnv, fscope)

            // 4. Handle control flow
            switch result {
            case object.BREAK:
                return object.FALSE // Stop iteration
            case object.CONTINUE:
                return object.TRUE // Continue iteration
            }

            if result != nil && (result.Type() == object.ERROR_OBJ || result.Type() == object.RETURN_VALUE_OBJ) {
                loopErr = result // Capture error/return
                return object.FALSE // Stop iteration
            }

            return object.TRUE // Continue iteration
        },
    }

    // 5. Call the user's function with our yield implementation
    e.applyFunction(nil, fn, []object.Object{yield}, fscope)

    // 6. Return any captured error or return value
    if loopErr != nil {
        return loopErr
    }

    return object.NIL
}
```

## 5. Testing Strategy

A new test file, `minigo/minigo_range_func_test.go`, will be created to thoroughly test the feature.

1.  **Basic Iteration:** Test with functions that yield one and two values.
    ```minigo
    // one value
    func(yield) { for i := 0; i < 3; i++ { yield(i) } }
    // two values
    func(yield) { yield("a", 1); yield("b", 2) }
    ```
2.  **Control Flow:**
    - Test `break` inside the loop body. The loop should terminate early.
    - Test `continue` inside the loop body. The loop should skip to the next iteration correctly.
3.  **Early Exit:** Test the case where the `yield` function returns `false` inside the user's function, causing an early exit.
    ```minigo
    func(yield) {
        if !yield(1) { return }
        if !yield(2) { return } // This should not be executed
    }
    ```
4.  **Error Propagation:** Test that an error occurring inside the loop body is propagated correctly out of the `for...range` statement.
5.  **Return Propagation:** Test that a `return` statement inside the loop body correctly terminates the function and returns the value.
6.  **Argument Mismatch:** Test that providing a function with an incorrect signature (e.g., wrong number of arguments) to `range` results in a runtime error.
