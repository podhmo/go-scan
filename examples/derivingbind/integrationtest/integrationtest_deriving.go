// Code generated by derivingbind for package integrationtest. DO NOT EDIT.

package integrationtest

import (
	"errors"
	"fmt"
	"net/http"
	"strconv"
	"strings"
)

func (s *TestBindStringQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (string) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			s.Val = valStr // Empty value for string is itself

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || true {

			s.Val = valStr

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (string) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			// Required string can be empty unless specific validation says otherwise
			s.Val = valStr

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || true {

			s.Val = valStr

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (string) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		s.Val = valStr

	} else { // Header value is empty or header not found

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (string) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		s.Val = valStr

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (string) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		s.Val = valStr

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (string) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		s.Val = valStr

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (string) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		s.Val = pathValueStr

	} else { // Path value string is empty

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (string) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		s.Val = pathValueStr

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (int) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			// Empty value for non-pointer, non-string, non-required. Stays zero/default. Or error?
			// Let's be strict: if it's not string and empty, it's a conversion problem unless specifically allowed.
			// However, current logic for non-slice non-required non-pointer is to leave as zero value if key exists but val is empty and conv fails.
			// This behavior should be consistent. For now, if not string, treat empty as potential conversion error handled by strconv.

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseInt(valStr, 10, 0)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to int for field Val: %w", valStr, convErr))
			} else {
				s.Val = int(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (int) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to int"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseInt(valStr, 10, 0)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to int for field Val: %w", valStr, convErr))
			} else {
				s.Val = int(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (int) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseInt(valStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to int for field Val: %w", valStr, convErr))
		} else {
			s.Val = int(v)
		}

	} else { // Header value is empty or header not found

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (int) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseInt(valStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to int for field Val: %w", valStr, convErr))
		} else {
			s.Val = int(v)
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (int) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseInt(valStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to int for field Val: %w", valStr, convErr))
		} else {
			s.Val = int(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (int) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseInt(valStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to int for field Val: %w", valStr, convErr))
		} else {
			s.Val = int(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (int) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseInt(pathValueStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to int for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = int(v)
		}

	} else { // Path value string is empty

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (int) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseInt(pathValueStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to int for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = int(v)
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (bool) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			// Empty value for non-pointer, non-string, non-required. Stays zero/default. Or error?
			// Let's be strict: if it's not string and empty, it's a conversion problem unless specifically allowed.
			// However, current logic for non-slice non-required non-pointer is to leave as zero value if key exists but val is empty and conv fails.
			// This behavior should be consistent. For now, if not string, treat empty as potential conversion error handled by strconv.

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseBool(valStr)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to bool for field Val: %w", valStr, convErr))
			} else {
				s.Val = v
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (bool) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to bool"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseBool(valStr)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to bool for field Val: %w", valStr, convErr))
			} else {
				s.Val = v
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (bool) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseBool(valStr)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to bool for field Val: %w", valStr, convErr))
		} else {
			s.Val = v
		}

	} else { // Header value is empty or header not found

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (bool) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseBool(valStr)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to bool for field Val: %w", valStr, convErr))
		} else {
			s.Val = v
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (bool) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseBool(valStr)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to bool for field Val: %w", valStr, convErr))
		} else {
			s.Val = v
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (bool) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseBool(valStr)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to bool for field Val: %w", valStr, convErr))
		} else {
			s.Val = v
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (bool) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseBool(pathValueStr)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to bool for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = v
		}

	} else { // Path value string is empty

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (bool) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseBool(pathValueStr)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to bool for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = v
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPointerQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*string) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			s.Val = &valStr // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || true {

			s.Val = &valStr

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.Val = nil

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPointerQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*string) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			// Required string can be empty unless specific validation says otherwise
			s.Val = &valStr

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || true {

			s.Val = &valStr

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPointerHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*string) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		s.Val = &valStr

	} else { // Header value is empty or header not found

		s.Val = nil

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPointerHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*string) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		s.Val = &valStr

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPointerCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*string) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		s.Val = &valStr

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		s.Val = nil

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPointerCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*string) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		s.Val = &valStr

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPointerPath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*string) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		s.Val = &pathValueStr

	} else { // Path value string is empty

		s.Val = nil

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPointerPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*string) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		s.Val = &pathValueStr

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPointerQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*int) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			s.Val = nil // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseInt(valStr, 10, 0)
			if convErr != nil {
				s.Val = nil
			} else {
				convertedValue := int(v)
				s.Val = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.Val = nil

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPointerQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*int) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to int"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseInt(valStr, 10, 0)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to int for field Val: %w", valStr, convErr))
			} else {
				convertedValue := int(v)
				s.Val = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPointerHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*int) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseInt(valStr, 10, 0)
		if convErr != nil {
			s.Val = nil
		} else {
			convertedValue := int(v)
			s.Val = &convertedValue
		}

	} else { // Header value is empty or header not found

		s.Val = nil

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPointerHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*int) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseInt(valStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to int for field Val: %w", valStr, convErr))
		} else {
			convertedValue := int(v)
			s.Val = &convertedValue
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPointerCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*int) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseInt(valStr, 10, 0)
		if convErr != nil {
			s.Val = nil
		} else {
			convertedValue := int(v)
			s.Val = &convertedValue
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		s.Val = nil

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPointerCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*int) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseInt(valStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to int for field Val: %w", valStr, convErr))
		} else {
			convertedValue := int(v)
			s.Val = &convertedValue
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPointerPath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*int) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseInt(pathValueStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to int for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := int(v)
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		s.Val = nil

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPointerPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*int) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseInt(pathValueStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to int for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := int(v)
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPointerQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*bool) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			s.Val = nil // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseBool(valStr)
			if convErr != nil {
				s.Val = nil
			} else {
				s.Val = &v
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.Val = nil

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPointerQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*bool) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to bool"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseBool(valStr)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to bool for field Val: %w", valStr, convErr))
			} else {
				s.Val = &v
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPointerHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*bool) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseBool(valStr)
		if convErr != nil {
			s.Val = nil
		} else {
			s.Val = &v
		}

	} else { // Header value is empty or header not found

		s.Val = nil

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPointerHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*bool) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseBool(valStr)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to bool for field Val: %w", valStr, convErr))
		} else {
			s.Val = &v
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPointerCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*bool) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseBool(valStr)
		if convErr != nil {
			s.Val = nil
		} else {
			s.Val = &v
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		s.Val = nil

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPointerCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*bool) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseBool(valStr)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to bool for field Val: %w", valStr, convErr))
		} else {
			s.Val = &v
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPointerPath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*bool) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseBool(pathValueStr)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to bool for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = &v
		}

	} else { // Path value string is empty

		s.Val = nil

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPointerPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*bool) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseBool(pathValueStr)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to bool for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = &v
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32Query) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (float32) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			// Empty value for non-pointer, non-string, non-required. Stays zero/default. Or error?
			// Let's be strict: if it's not string and empty, it's a conversion problem unless specifically allowed.
			// However, current logic for non-slice non-required non-pointer is to leave as zero value if key exists but val is empty and conv fails.
			// This behavior should be consistent. For now, if not string, treat empty as potential conversion error handled by strconv.

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseFloat(valStr, 32)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to float32 for field Val: %w", valStr, convErr))
			} else {
				s.Val = float32(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32QueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (float32) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to float32"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseFloat(valStr, 32)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to float32 for field Val: %w", valStr, convErr))
			} else {
				s.Val = float32(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32Header) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (float32) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseFloat(valStr, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to float32 for field Val: %w", valStr, convErr))
		} else {
			s.Val = float32(v)
		}

	} else { // Header value is empty or header not found

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32HeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (float32) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseFloat(valStr, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to float32 for field Val: %w", valStr, convErr))
		} else {
			s.Val = float32(v)
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32Cookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (float32) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseFloat(valStr, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to float32 for field Val: %w", valStr, convErr))
		} else {
			s.Val = float32(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32CookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (float32) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseFloat(valStr, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to float32 for field Val: %w", valStr, convErr))
		} else {
			s.Val = float32(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32Path) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (float32) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseFloat(pathValueStr, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to float32 for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = float32(v) // This was already correct
		}

	} else { // Path value string is empty

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32PathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (float32) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseFloat(pathValueStr, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to float32 for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = float32(v) // This was already correct
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32PointerQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*float32) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			s.Val = nil // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseFloat(valStr, 32)
			if convErr != nil {
				s.Val = nil
			} else {
				convertedValue := float32(v)
				s.Val = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.Val = nil

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32PointerQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*float32) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to float32"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseFloat(valStr, 32)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to float32 for field Val: %w", valStr, convErr))
			} else {
				convertedValue := float32(v)
				s.Val = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32PointerHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*float32) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseFloat(valStr, 32)
		if convErr != nil {
			s.Val = nil
		} else {
			convertedValue := float32(v)
			s.Val = &convertedValue
		}

	} else { // Header value is empty or header not found

		s.Val = nil

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32PointerHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*float32) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseFloat(valStr, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to float32 for field Val: %w", valStr, convErr))
		} else {
			convertedValue := float32(v)
			s.Val = &convertedValue
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32PointerCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*float32) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseFloat(valStr, 32)
		if convErr != nil {
			s.Val = nil
		} else {
			convertedValue := float32(v)
			s.Val = &convertedValue
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		s.Val = nil

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32PointerCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*float32) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseFloat(valStr, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to float32 for field Val: %w", valStr, convErr))
		} else {
			convertedValue := float32(v)
			s.Val = &convertedValue
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32PointerPath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*float32) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseFloat(pathValueStr, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to float32 for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := float32(v)
			// Corrected: s.FieldName is already a pointer type if .IsPointer is true.
			// For complex types, direct assignment of convertedValue (which is complex64/128)
			// to s.FieldName (which is *complex64/*complex128) is wrong.
			// We need to assign the address of convertedValue.
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		s.Val = nil

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32PointerPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*float32) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseFloat(pathValueStr, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to float32 for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := float32(v)
			// Corrected: s.FieldName is already a pointer type if .IsPointer is true.
			// For complex types, direct assignment of convertedValue (which is complex64/128)
			// to s.FieldName (which is *complex64/*complex128) is wrong.
			// We need to assign the address of convertedValue.
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64Query) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (float64) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			// Empty value for non-pointer, non-string, non-required. Stays zero/default. Or error?
			// Let's be strict: if it's not string and empty, it's a conversion problem unless specifically allowed.
			// However, current logic for non-slice non-required non-pointer is to leave as zero value if key exists but val is empty and conv fails.
			// This behavior should be consistent. For now, if not string, treat empty as potential conversion error handled by strconv.

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseFloat(valStr, 64)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to float64 for field Val: %w", valStr, convErr))
			} else {
				s.Val = float64(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64QueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (float64) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to float64"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseFloat(valStr, 64)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to float64 for field Val: %w", valStr, convErr))
			} else {
				s.Val = float64(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64Header) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (float64) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseFloat(valStr, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to float64 for field Val: %w", valStr, convErr))
		} else {
			s.Val = float64(v)
		}

	} else { // Header value is empty or header not found

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64HeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (float64) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseFloat(valStr, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to float64 for field Val: %w", valStr, convErr))
		} else {
			s.Val = float64(v)
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64Cookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (float64) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseFloat(valStr, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to float64 for field Val: %w", valStr, convErr))
		} else {
			s.Val = float64(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64CookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (float64) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseFloat(valStr, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to float64 for field Val: %w", valStr, convErr))
		} else {
			s.Val = float64(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64Path) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (float64) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseFloat(pathValueStr, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to float64 for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = float64(v) // This was already correct
		}

	} else { // Path value string is empty

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64PathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (float64) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseFloat(pathValueStr, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to float64 for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = float64(v) // This was already correct
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64PointerQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*float64) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			s.Val = nil // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseFloat(valStr, 64)
			if convErr != nil {
				s.Val = nil
			} else {
				convertedValue := float64(v)
				s.Val = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.Val = nil

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64PointerQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*float64) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to float64"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseFloat(valStr, 64)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to float64 for field Val: %w", valStr, convErr))
			} else {
				convertedValue := float64(v)
				s.Val = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64PointerHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*float64) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseFloat(valStr, 64)
		if convErr != nil {
			s.Val = nil
		} else {
			convertedValue := float64(v)
			s.Val = &convertedValue
		}

	} else { // Header value is empty or header not found

		s.Val = nil

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64PointerHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*float64) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseFloat(valStr, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to float64 for field Val: %w", valStr, convErr))
		} else {
			convertedValue := float64(v)
			s.Val = &convertedValue
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64PointerCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*float64) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseFloat(valStr, 64)
		if convErr != nil {
			s.Val = nil
		} else {
			convertedValue := float64(v)
			s.Val = &convertedValue
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		s.Val = nil

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64PointerCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*float64) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseFloat(valStr, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to float64 for field Val: %w", valStr, convErr))
		} else {
			convertedValue := float64(v)
			s.Val = &convertedValue
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64PointerPath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*float64) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseFloat(pathValueStr, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to float64 for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := float64(v)
			// Corrected: s.FieldName is already a pointer type if .IsPointer is true.
			// For complex types, direct assignment of convertedValue (which is complex64/128)
			// to s.FieldName (which is *complex64/*complex128) is wrong.
			// We need to assign the address of convertedValue.
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		s.Val = nil

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64PointerPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*float64) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseFloat(pathValueStr, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to float64 for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := float64(v)
			// Corrected: s.FieldName is already a pointer type if .IsPointer is true.
			// For complex types, direct assignment of convertedValue (which is complex64/128)
			// to s.FieldName (which is *complex64/*complex128) is wrong.
			// We need to assign the address of convertedValue.
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (uint) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			// Empty value for non-pointer, non-string, non-required. Stays zero/default. Or error?
			// Let's be strict: if it's not string and empty, it's a conversion problem unless specifically allowed.
			// However, current logic for non-slice non-required non-pointer is to leave as zero value if key exists but val is empty and conv fails.
			// This behavior should be consistent. For now, if not string, treat empty as potential conversion error handled by strconv.

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 0)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to uint for field Val: %w", valStr, convErr))
			} else {
				s.Val = uint(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (uint) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to uint"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 0)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to uint for field Val: %w", valStr, convErr))
			} else {
				s.Val = uint(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (uint) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to uint for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint(v)
		}

	} else { // Header value is empty or header not found

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (uint) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to uint for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint(v)
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (uint) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to uint for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (uint) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to uint for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintPath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (uint) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = uint(v)
		}

	} else { // Path value string is empty

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (uint) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = uint(v)
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintPointerQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*uint) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			s.Val = nil // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 0)
			if convErr != nil {
				s.Val = nil
			} else {
				convertedValue := uint(v)
				s.Val = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.Val = nil

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintPointerQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*uint) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to uint"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 0)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to uint for field Val: %w", valStr, convErr))
			} else {
				convertedValue := uint(v)
				s.Val = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintPointerHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*uint) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 0)
		if convErr != nil {
			s.Val = nil
		} else {
			convertedValue := uint(v)
			s.Val = &convertedValue
		}

	} else { // Header value is empty or header not found

		s.Val = nil

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintPointerHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*uint) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to uint for field Val: %w", valStr, convErr))
		} else {
			convertedValue := uint(v)
			s.Val = &convertedValue
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintPointerCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*uint) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 0)
		if convErr != nil {
			s.Val = nil
		} else {
			convertedValue := uint(v)
			s.Val = &convertedValue
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		s.Val = nil

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintPointerCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*uint) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to uint for field Val: %w", valStr, convErr))
		} else {
			convertedValue := uint(v)
			s.Val = &convertedValue
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintPointerPath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*uint) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := uint(v)
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		s.Val = nil

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintPointerPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*uint) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := uint(v)
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8Query) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (uint8) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			// Empty value for non-pointer, non-string, non-required. Stays zero/default. Or error?
			// Let's be strict: if it's not string and empty, it's a conversion problem unless specifically allowed.
			// However, current logic for non-slice non-required non-pointer is to leave as zero value if key exists but val is empty and conv fails.
			// This behavior should be consistent. For now, if not string, treat empty as potential conversion error handled by strconv.

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 8)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to uint8 for field Val: %w", valStr, convErr))
			} else {
				s.Val = uint8(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8QueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (uint8) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to uint8"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 8)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to uint8 for field Val: %w", valStr, convErr))
			} else {
				s.Val = uint8(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8Header) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (uint8) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 8)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to uint8 for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint8(v)
		}

	} else { // Header value is empty or header not found

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8HeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (uint8) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 8)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to uint8 for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint8(v)
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8Cookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (uint8) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 8)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to uint8 for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint8(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8CookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (uint8) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 8)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to uint8 for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint8(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8Path) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (uint8) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 8)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint8 for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = uint8(v)
		}

	} else { // Path value string is empty

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8PathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (uint8) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 8)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint8 for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = uint8(v)
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8PointerQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*uint8) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			s.Val = nil // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 8)
			if convErr != nil {
				s.Val = nil
			} else {
				convertedValue := uint8(v)
				s.Val = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.Val = nil

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8PointerQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*uint8) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to uint8"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 8)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to uint8 for field Val: %w", valStr, convErr))
			} else {
				convertedValue := uint8(v)
				s.Val = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8PointerHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*uint8) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 8)
		if convErr != nil {
			s.Val = nil
		} else {
			convertedValue := uint8(v)
			s.Val = &convertedValue
		}

	} else { // Header value is empty or header not found

		s.Val = nil

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8PointerHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*uint8) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 8)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to uint8 for field Val: %w", valStr, convErr))
		} else {
			convertedValue := uint8(v)
			s.Val = &convertedValue
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8PointerCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*uint8) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 8)
		if convErr != nil {
			s.Val = nil
		} else {
			convertedValue := uint8(v)
			s.Val = &convertedValue
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		s.Val = nil

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8PointerCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*uint8) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 8)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to uint8 for field Val: %w", valStr, convErr))
		} else {
			convertedValue := uint8(v)
			s.Val = &convertedValue
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8PointerPath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*uint8) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 8)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint8 for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := uint8(v)
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		s.Val = nil

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8PointerPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*uint8) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 8)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint8 for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := uint8(v)
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16Query) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (uint16) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			// Empty value for non-pointer, non-string, non-required. Stays zero/default. Or error?
			// Let's be strict: if it's not string and empty, it's a conversion problem unless specifically allowed.
			// However, current logic for non-slice non-required non-pointer is to leave as zero value if key exists but val is empty and conv fails.
			// This behavior should be consistent. For now, if not string, treat empty as potential conversion error handled by strconv.

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 16)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to uint16 for field Val: %w", valStr, convErr))
			} else {
				s.Val = uint16(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16QueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (uint16) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to uint16"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 16)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to uint16 for field Val: %w", valStr, convErr))
			} else {
				s.Val = uint16(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16Header) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (uint16) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 16)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to uint16 for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint16(v)
		}

	} else { // Header value is empty or header not found

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16HeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (uint16) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 16)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to uint16 for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint16(v)
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16Cookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (uint16) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 16)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to uint16 for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint16(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16CookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (uint16) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 16)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to uint16 for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint16(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16Path) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (uint16) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 16)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint16 for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = uint16(v)
		}

	} else { // Path value string is empty

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16PathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (uint16) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 16)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint16 for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = uint16(v)
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16PointerQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*uint16) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			s.Val = nil // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 16)
			if convErr != nil {
				s.Val = nil
			} else {
				convertedValue := uint16(v)
				s.Val = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.Val = nil

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16PointerQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*uint16) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to uint16"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 16)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to uint16 for field Val: %w", valStr, convErr))
			} else {
				convertedValue := uint16(v)
				s.Val = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16PointerHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*uint16) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 16)
		if convErr != nil {
			s.Val = nil
		} else {
			convertedValue := uint16(v)
			s.Val = &convertedValue
		}

	} else { // Header value is empty or header not found

		s.Val = nil

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16PointerHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*uint16) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 16)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to uint16 for field Val: %w", valStr, convErr))
		} else {
			convertedValue := uint16(v)
			s.Val = &convertedValue
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16PointerCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*uint16) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 16)
		if convErr != nil {
			s.Val = nil
		} else {
			convertedValue := uint16(v)
			s.Val = &convertedValue
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		s.Val = nil

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16PointerCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*uint16) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 16)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to uint16 for field Val: %w", valStr, convErr))
		} else {
			convertedValue := uint16(v)
			s.Val = &convertedValue
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16PointerPath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*uint16) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 16)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint16 for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := uint16(v)
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		s.Val = nil

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16PointerPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*uint16) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 16)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint16 for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := uint16(v)
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32Query) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (uint32) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			// Empty value for non-pointer, non-string, non-required. Stays zero/default. Or error?
			// Let's be strict: if it's not string and empty, it's a conversion problem unless specifically allowed.
			// However, current logic for non-slice non-required non-pointer is to leave as zero value if key exists but val is empty and conv fails.
			// This behavior should be consistent. For now, if not string, treat empty as potential conversion error handled by strconv.

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 32)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to uint32 for field Val: %w", valStr, convErr))
			} else {
				s.Val = uint32(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32QueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (uint32) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to uint32"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 32)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to uint32 for field Val: %w", valStr, convErr))
			} else {
				s.Val = uint32(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32Header) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (uint32) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to uint32 for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint32(v)
		}

	} else { // Header value is empty or header not found

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32HeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (uint32) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to uint32 for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint32(v)
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32Cookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (uint32) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to uint32 for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint32(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32CookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (uint32) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to uint32 for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint32(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32Path) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (uint32) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint32 for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = uint32(v)
		}

	} else { // Path value string is empty

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32PathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (uint32) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint32 for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = uint32(v)
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32PointerQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*uint32) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			s.Val = nil // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 32)
			if convErr != nil {
				s.Val = nil
			} else {
				convertedValue := uint32(v)
				s.Val = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.Val = nil

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32PointerQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*uint32) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to uint32"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 32)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to uint32 for field Val: %w", valStr, convErr))
			} else {
				convertedValue := uint32(v)
				s.Val = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32PointerHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*uint32) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 32)
		if convErr != nil {
			s.Val = nil
		} else {
			convertedValue := uint32(v)
			s.Val = &convertedValue
		}

	} else { // Header value is empty or header not found

		s.Val = nil

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32PointerHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*uint32) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to uint32 for field Val: %w", valStr, convErr))
		} else {
			convertedValue := uint32(v)
			s.Val = &convertedValue
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32PointerCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*uint32) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 32)
		if convErr != nil {
			s.Val = nil
		} else {
			convertedValue := uint32(v)
			s.Val = &convertedValue
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		s.Val = nil

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32PointerCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*uint32) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to uint32 for field Val: %w", valStr, convErr))
		} else {
			convertedValue := uint32(v)
			s.Val = &convertedValue
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32PointerPath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*uint32) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint32 for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := uint32(v)
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		s.Val = nil

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32PointerPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*uint32) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint32 for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := uint32(v)
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64Query) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (uint64) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			// Empty value for non-pointer, non-string, non-required. Stays zero/default. Or error?
			// Let's be strict: if it's not string and empty, it's a conversion problem unless specifically allowed.
			// However, current logic for non-slice non-required non-pointer is to leave as zero value if key exists but val is empty and conv fails.
			// This behavior should be consistent. For now, if not string, treat empty as potential conversion error handled by strconv.

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 64)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to uint64 for field Val: %w", valStr, convErr))
			} else {
				s.Val = uint64(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64QueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (uint64) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to uint64"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 64)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to uint64 for field Val: %w", valStr, convErr))
			} else {
				s.Val = uint64(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64Header) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (uint64) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to uint64 for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint64(v)
		}

	} else { // Header value is empty or header not found

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64HeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (uint64) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to uint64 for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint64(v)
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64Cookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (uint64) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to uint64 for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint64(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64CookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (uint64) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to uint64 for field Val: %w", valStr, convErr))
		} else {
			s.Val = uint64(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64Path) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (uint64) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint64 for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = uint64(v)
		}

	} else { // Path value string is empty

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64PathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (uint64) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint64 for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = uint64(v)
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64PointerQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*uint64) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			s.Val = nil // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 64)
			if convErr != nil {
				s.Val = nil
			} else {
				convertedValue := uint64(v)
				s.Val = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.Val = nil

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64PointerQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*uint64) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to uint64"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 64)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to uint64 for field Val: %w", valStr, convErr))
			} else {
				convertedValue := uint64(v)
				s.Val = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64PointerHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*uint64) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 64)
		if convErr != nil {
			s.Val = nil
		} else {
			convertedValue := uint64(v)
			s.Val = &convertedValue
		}

	} else { // Header value is empty or header not found

		s.Val = nil

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64PointerHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*uint64) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to uint64 for field Val: %w", valStr, convErr))
		} else {
			convertedValue := uint64(v)
			s.Val = &convertedValue
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64PointerCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*uint64) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 64)
		if convErr != nil {
			s.Val = nil
		} else {
			convertedValue := uint64(v)
			s.Val = &convertedValue
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		s.Val = nil

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64PointerCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*uint64) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to uint64 for field Val: %w", valStr, convErr))
		} else {
			convertedValue := uint64(v)
			s.Val = &convertedValue
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64PointerPath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*uint64) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint64 for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := uint64(v)
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		s.Val = nil

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64PointerPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*uint64) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uint64 for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := uint64(v)
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (uintptr) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			// Empty value for non-pointer, non-string, non-required. Stays zero/default. Or error?
			// Let's be strict: if it's not string and empty, it's a conversion problem unless specifically allowed.
			// However, current logic for non-slice non-required non-pointer is to leave as zero value if key exists but val is empty and conv fails.
			// This behavior should be consistent. For now, if not string, treat empty as potential conversion error handled by strconv.

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 0)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to uintptr for field Val: %w", valStr, convErr))
			} else {
				s.Val = uintptr(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (uintptr) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to uintptr"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 0)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to uintptr for field Val: %w", valStr, convErr))
			} else {
				s.Val = uintptr(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (uintptr) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to uintptr for field Val: %w", valStr, convErr))
		} else {
			s.Val = uintptr(v)
		}

	} else { // Header value is empty or header not found

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (uintptr) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to uintptr for field Val: %w", valStr, convErr))
		} else {
			s.Val = uintptr(v)
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (uintptr) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to uintptr for field Val: %w", valStr, convErr))
		} else {
			s.Val = uintptr(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (uintptr) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to uintptr for field Val: %w", valStr, convErr))
		} else {
			s.Val = uintptr(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrPath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (uintptr) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uintptr for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = uintptr(v)
		}

	} else { // Path value string is empty

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (uintptr) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uintptr for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = uintptr(v)
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrPointerQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*uintptr) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			s.Val = nil // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 0)
			if convErr != nil {
				s.Val = nil
			} else {
				convertedValue := uintptr(v)
				s.Val = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.Val = nil

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrPointerQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*uintptr) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to uintptr"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 0)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to uintptr for field Val: %w", valStr, convErr))
			} else {
				convertedValue := uintptr(v)
				s.Val = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrPointerHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*uintptr) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 0)
		if convErr != nil {
			s.Val = nil
		} else {
			convertedValue := uintptr(v)
			s.Val = &convertedValue
		}

	} else { // Header value is empty or header not found

		s.Val = nil

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrPointerHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*uintptr) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to uintptr for field Val: %w", valStr, convErr))
		} else {
			convertedValue := uintptr(v)
			s.Val = &convertedValue
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrPointerCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*uintptr) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 0)
		if convErr != nil {
			s.Val = nil
		} else {
			convertedValue := uintptr(v)
			s.Val = &convertedValue
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		s.Val = nil

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrPointerCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*uintptr) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		// Unsigned
		v, convErr := strconv.ParseUint(valStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to uintptr for field Val: %w", valStr, convErr))
		} else {
			convertedValue := uintptr(v)
			s.Val = &convertedValue
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrPointerPath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*uintptr) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uintptr for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := uintptr(v)
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		s.Val = nil

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrPointerPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*uintptr) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		// Unsigned Integer
		v, convErr := strconv.ParseUint(pathValueStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to uintptr for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := uintptr(v)
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64Query) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (complex64) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			// Empty value for non-pointer, non-string, non-required. Stays zero/default. Or error?
			// Let's be strict: if it's not string and empty, it's a conversion problem unless specifically allowed.
			// However, current logic for non-slice non-required non-pointer is to leave as zero value if key exists but val is empty and conv fails.
			// This behavior should be consistent. For now, if not string, treat empty as potential conversion error handled by strconv.

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseComplex(valStr, 64)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to complex64 for field Val: %w", valStr, convErr))
			} else {
				s.Val = complex64(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64QueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (complex64) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to complex64"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseComplex(valStr, 64)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to complex64 for field Val: %w", valStr, convErr))
			} else {
				s.Val = complex64(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64Header) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (complex64) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseComplex(valStr, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to complex64 for field Val: %w", valStr, convErr))
		} else {
			s.Val = complex64(v)
		}

	} else { // Header value is empty or header not found

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64HeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (complex64) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseComplex(valStr, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to complex64 for field Val: %w", valStr, convErr))
		} else {
			s.Val = complex64(v)
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64Cookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (complex64) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseComplex(valStr, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to complex64 for field Val: %w", valStr, convErr))
		} else {
			s.Val = complex64(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64CookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (complex64) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseComplex(valStr, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to complex64 for field Val: %w", valStr, convErr))
		} else {
			s.Val = complex64(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64Path) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (complex64) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseComplex(pathValueStr, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to complex64 for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = complex64(v)
		}

	} else { // Path value string is empty

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64PathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (complex64) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseComplex(pathValueStr, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to complex64 for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = complex64(v)
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64PointerQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*complex64) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			s.Val = nil // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseComplex(valStr, 64)
			if convErr != nil {

				s.Val = nil

			} else {
				convertedValue := complex64(v)

				s.Val = &convertedValue

			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.Val = nil

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64PointerQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*complex64) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to complex64"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseComplex(valStr, 64)
			if convErr != nil {

				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to complex64 for field Val: %w", valStr, convErr))

			} else {
				convertedValue := complex64(v)

				s.Val = &convertedValue

			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64PointerHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*complex64) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseComplex(valStr, 64)
		if convErr != nil {

			s.Val = nil

		} else {
			convertedValue := complex64(v)

			s.Val = &convertedValue

		}

	} else { // Header value is empty or header not found

		s.Val = nil

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64PointerHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*complex64) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseComplex(valStr, 64)
		if convErr != nil {

			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to complex64 for field Val: %w", valStr, convErr))

		} else {
			convertedValue := complex64(v)

			s.Val = &convertedValue

		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64PointerCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*complex64) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseComplex(valStr, 64)
		if convErr != nil {

			s.Val = nil

		} else {
			convertedValue := complex64(v)

			s.Val = &convertedValue

		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		s.Val = nil

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64PointerCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*complex64) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseComplex(valStr, 64)
		if convErr != nil {

			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to complex64 for field Val: %w", valStr, convErr))

		} else {
			convertedValue := complex64(v)

			s.Val = &convertedValue

		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64PointerPath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*complex64) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseComplex(pathValueStr, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to complex64 for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := complex64(v)
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		s.Val = nil

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64PointerPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*complex64) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseComplex(pathValueStr, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to complex64 for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := complex64(v)
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128Query) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (complex128) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			// Empty value for non-pointer, non-string, non-required. Stays zero/default. Or error?
			// Let's be strict: if it's not string and empty, it's a conversion problem unless specifically allowed.
			// However, current logic for non-slice non-required non-pointer is to leave as zero value if key exists but val is empty and conv fails.
			// This behavior should be consistent. For now, if not string, treat empty as potential conversion error handled by strconv.

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseComplex(valStr, 128)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to complex128 for field Val: %w", valStr, convErr))
			} else {
				s.Val = complex128(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128QueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (complex128) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to complex128"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseComplex(valStr, 128)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to complex128 for field Val: %w", valStr, convErr))
			} else {
				s.Val = complex128(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128Header) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (complex128) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseComplex(valStr, 128)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to complex128 for field Val: %w", valStr, convErr))
		} else {
			s.Val = complex128(v)
		}

	} else { // Header value is empty or header not found

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128HeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (complex128) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseComplex(valStr, 128)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to complex128 for field Val: %w", valStr, convErr))
		} else {
			s.Val = complex128(v)
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128Cookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (complex128) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseComplex(valStr, 128)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to complex128 for field Val: %w", valStr, convErr))
		} else {
			s.Val = complex128(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128CookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (complex128) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseComplex(valStr, 128)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to complex128 for field Val: %w", valStr, convErr))
		} else {
			s.Val = complex128(v)
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128Path) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (complex128) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseComplex(pathValueStr, 128)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to complex128 for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = complex128(v)
		}

	} else { // Path value string is empty

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128PathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (complex128) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseComplex(pathValueStr, 128)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to complex128 for field Val: %w", pathValueStr, convErr))
		} else {
			s.Val = complex128(v)
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128PointerQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*complex128) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			s.Val = nil // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseComplex(valStr, 128)
			if convErr != nil {

				s.Val = nil

			} else {
				convertedValue := complex128(v)

				s.Val = &convertedValue

			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.Val = nil

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128PointerQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val (*complex128) from "val"
	// Not a slice for Query
	if req.URL.Query().Has("val") {
		valStr := req.URL.Query().Get("val")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val received an empty value which cannot be converted to complex128"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseComplex(valStr, 128)
			if convErr != nil {

				errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" (value: %q) to complex128 for field Val: %w", valStr, convErr))

			} else {
				convertedValue := complex128(v)

				s.Val = &convertedValue

			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128PointerHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*complex128) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseComplex(valStr, 128)
		if convErr != nil {

			s.Val = nil

		} else {
			convertedValue := complex128(v)

			s.Val = &convertedValue

		}

	} else { // Header value is empty or header not found

		s.Val = nil

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128PointerHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val (*complex128) from "X-Val"
	// Not a slice for Header
	if valStr := req.Header.Get("X-Val"); valStr != "" {

		v, convErr := strconv.ParseComplex(valStr, 128)
		if convErr != nil {

			errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" (value: %q) to complex128 for field Val: %w", valStr, convErr))

		} else {
			convertedValue := complex128(v)

			s.Val = &convertedValue

		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128PointerCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*complex128) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseComplex(valStr, 128)
		if convErr != nil {

			s.Val = nil

		} else {
			convertedValue := complex128(v)

			s.Val = &convertedValue

		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		s.Val = nil

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128PointerCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val (*complex128) from "val"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseComplex(valStr, 128)
		if convErr != nil {

			errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" (value: %q) to complex128 for field Val: %w", valStr, convErr))

		} else {
			convertedValue := complex128(v)

			s.Val = &convertedValue

		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie \"val\" for field Val is missing, empty, or could not be retrieved (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128PointerPath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*complex128) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseComplex(pathValueStr, 128)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to complex128 for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := complex128(v)
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		s.Val = nil

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128PointerPathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val (*complex128) from "val"

	if pathValueStr := pathVar("val"); pathValueStr != "" {

		v, convErr := strconv.ParseComplex(pathValueStr, 128)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"val\" (value: %q) to complex128 for field Val: %w", pathValueStr, convErr))
		} else {
			convertedValue := complex128(v)
			s.Val = &convertedValue
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringSliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]string) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]string, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {  // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// ElemType is string
				slice = append(slice, valStrLoop)

			} else { // Value is not empty, proceed with conversion

				slice = append(slice, valStrLoop)

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]string, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringSliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]string) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]string, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {  // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// ElemType is string
				slice = append(slice, valStrLoop)

			} else { // Value is not empty, proceed with conversion

				slice = append(slice, valStrLoop)

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringSliceHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val ([]string) from "X-Val"

	headerValStr := req.Header.Get("X-Val")
	if headerValStr != "" {
		valuesStr := strings.Split(headerValStr, ",") // Assuming comma-separated for simple style
		slice := make([]string, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// ElemType is string
				slice = append(slice, trimmedValStrLoop)

			} else {

				slice = append(slice, trimmedValStrLoop)

			}
		}
		s.Val = slice
	} else { // Header not found

		s.Val = nil // Or empty slice

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringSliceHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val ([]string) from "X-Val"

	headerValStr := req.Header.Get("X-Val")
	if headerValStr != "" {
		valuesStr := strings.Split(headerValStr, ",") // Assuming comma-separated for simple style
		slice := make([]string, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// ElemType is string
				slice = append(slice, trimmedValStrLoop)

			} else {

				slice = append(slice, trimmedValStrLoop)

			}
		}
		s.Val = slice
	} else { // Header not found

		errs = append(errs, fmt.Errorf("required header slice \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringSliceCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val ([]string) from "val"

	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valuesStr := strings.Split(cookie.Value, ",") // Assuming comma-separated for form style
		slice := make([]string, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// ElemType is string
				slice = append(slice, trimmedValStrLoop)

			} else {

				slice = append(slice, trimmedValStrLoop)

			}
		}
		s.Val = slice
	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil { // Report actual errors other than not found
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		s.Val = nil // Or empty slice

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringSliceCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val ([]string) from "val"

	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valuesStr := strings.Split(cookie.Value, ",") // Assuming comma-separated for form style
		slice := make([]string, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// ElemType is string
				slice = append(slice, trimmedValStrLoop)

			} else {

				slice = append(slice, trimmedValStrLoop)

			}
		}
		s.Val = slice
	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil { // Report actual errors other than not found
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie slice \"val\" for field Val is missing or empty (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringSlicePath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val ([]string) from "val"

	// TODO: Path parameter slice binding is not typically supported directly.
	// Consider if this is a valid use case or should be an error/skipped.
	// For now, skipping slice binding from path.
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringSlicePathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val ([]string) from "val"

	// TODO: Path parameter slice binding is not typically supported directly.
	// Consider if this is a valid use case or should be an error/skipped.
	// For now, skipping slice binding from path.
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntSliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]int) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]int, 0, sliceCap)   // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values { // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to int from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				v, convErr := strconv.Atoi(valStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to int for field Val: %w", valStrLoop, convErr))
				} else {
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]int, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntSliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]int) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]int, 0, sliceCap)   // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values { // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to int from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				v, convErr := strconv.Atoi(valStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to int for field Val: %w", valStrLoop, convErr))
				} else {
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntSliceHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val ([]int) from "X-Val"

	headerValStr := req.Header.Get("X-Val")
	if headerValStr != "" {
		valuesStr := strings.Split(headerValStr, ",") // Assuming comma-separated for simple style
		slice := make([]int, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for trimmed slice element of Val (header \"X-Val\") cannot be converted to int from %q", trimmedValStrLoop))

			} else {

				var v int
				var convErr error
				v, convErr = strconv.Atoi(trimmedValStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" element (value: %q) to int for field Val: %w", trimmedValStrLoop, convErr))
				} else {
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Header not found

		s.Val = nil // Or empty slice

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntSliceHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val ([]int) from "X-Val"

	headerValStr := req.Header.Get("X-Val")
	if headerValStr != "" {
		valuesStr := strings.Split(headerValStr, ",") // Assuming comma-separated for simple style
		slice := make([]int, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for trimmed slice element of Val (header \"X-Val\") cannot be converted to int from %q", trimmedValStrLoop))

			} else {

				var v int
				var convErr error
				v, convErr = strconv.Atoi(trimmedValStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" element (value: %q) to int for field Val: %w", trimmedValStrLoop, convErr))
				} else {
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Header not found

		errs = append(errs, fmt.Errorf("required header slice \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntSliceCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val ([]int) from "val"

	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valuesStr := strings.Split(cookie.Value, ",") // Assuming comma-separated for form style
		slice := make([]int, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for trimmed slice element of Val (cookie \"val\") cannot be converted to int from %q", trimmedValStrLoop))

			} else {

				v, convErr := strconv.Atoi(trimmedValStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" element (value: %q) to int for field Val: %w", trimmedValStrLoop, convErr))
				} else {
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil { // Report actual errors other than not found
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		s.Val = nil // Or empty slice

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntSliceCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val ([]int) from "val"

	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valuesStr := strings.Split(cookie.Value, ",") // Assuming comma-separated for form style
		slice := make([]int, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for trimmed slice element of Val (cookie \"val\") cannot be converted to int from %q", trimmedValStrLoop))

			} else {

				v, convErr := strconv.Atoi(trimmedValStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" element (value: %q) to int for field Val: %w", trimmedValStrLoop, convErr))
				} else {
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil { // Report actual errors other than not found
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie slice \"val\" for field Val is missing or empty (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntSlicePath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val ([]int) from "val"

	// TODO: Path parameter slice binding is not typically supported directly.
	// Consider if this is a valid use case or should be an error/skipped.
	// For now, skipping slice binding from path.
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntSlicePathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val ([]int) from "val"

	// TODO: Path parameter slice binding is not typically supported directly.
	// Consider if this is a valid use case or should be an error/skipped.
	// For now, skipping slice binding from path.
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolSliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]bool) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]bool, 0, sliceCap)  // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values { // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to bool from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var v bool
				var convErr error
				v, convErr = strconv.ParseBool(valStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to bool for field Val: %w", valStrLoop, convErr))
				} else {
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]bool, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolSliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]bool) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]bool, 0, sliceCap)  // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values { // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to bool from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var v bool
				var convErr error
				v, convErr = strconv.ParseBool(valStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to bool for field Val: %w", valStrLoop, convErr))
				} else {
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolSliceHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val ([]bool) from "X-Val"

	headerValStr := req.Header.Get("X-Val")
	if headerValStr != "" {
		valuesStr := strings.Split(headerValStr, ",") // Assuming comma-separated for simple style
		slice := make([]bool, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for trimmed slice element of Val (header \"X-Val\") cannot be converted to bool from %q", trimmedValStrLoop))

			} else {

				var v bool
				var convErr error
				v, convErr = strconv.ParseBool(trimmedValStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" element (value: %q) to bool for field Val: %w", trimmedValStrLoop, convErr))
				} else {
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Header not found

		s.Val = nil // Or empty slice

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolSliceHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val ([]bool) from "X-Val"

	headerValStr := req.Header.Get("X-Val")
	if headerValStr != "" {
		valuesStr := strings.Split(headerValStr, ",") // Assuming comma-separated for simple style
		slice := make([]bool, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for trimmed slice element of Val (header \"X-Val\") cannot be converted to bool from %q", trimmedValStrLoop))

			} else {

				var v bool
				var convErr error
				v, convErr = strconv.ParseBool(trimmedValStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" element (value: %q) to bool for field Val: %w", trimmedValStrLoop, convErr))
				} else {
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Header not found

		errs = append(errs, fmt.Errorf("required header slice \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolSliceCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val ([]bool) from "val"

	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valuesStr := strings.Split(cookie.Value, ",") // Assuming comma-separated for form style
		slice := make([]bool, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for trimmed slice element of Val (cookie \"val\") cannot be converted to bool from %q", trimmedValStrLoop))

			} else {

				var v bool
				var convErr error
				v, convErr = strconv.ParseBool(trimmedValStrLoop)

			}
		}
		s.Val = slice
	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil { // Report actual errors other than not found
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		s.Val = nil // Or empty slice

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolSliceCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val ([]bool) from "val"

	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valuesStr := strings.Split(cookie.Value, ",") // Assuming comma-separated for form style
		slice := make([]bool, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for trimmed slice element of Val (cookie \"val\") cannot be converted to bool from %q", trimmedValStrLoop))

			} else {

				var v bool
				var convErr error
				v, convErr = strconv.ParseBool(trimmedValStrLoop)

			}
		}
		s.Val = slice
	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil { // Report actual errors other than not found
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie slice \"val\" for field Val is missing or empty (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolSlicePath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val ([]bool) from "val"

	// TODO: Path parameter slice binding is not typically supported directly.
	// Consider if this is a valid use case or should be an error/skipped.
	// For now, skipping slice binding from path.
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolSlicePathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val ([]bool) from "val"

	// TODO: Path parameter slice binding is not typically supported directly.
	// Consider if this is a valid use case or should be an error/skipped.
	// For now, skipping slice binding from path.
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPointerSliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*string) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*string, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {   // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// ElemType is string
				emptyStr := ""
				slice = append(slice, &emptyStr)

			} else { // Value is not empty, proceed with conversion

				sPtr := valStrLoop
				slice = append(slice, &sPtr)

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]*string, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPointerSliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*string) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*string, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {   // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// ElemType is string
				emptyStr := ""
				slice = append(slice, &emptyStr)

			} else { // Value is not empty, proceed with conversion

				sPtr := valStrLoop
				slice = append(slice, &sPtr)

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPointerSliceHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val ([]*string) from "X-Val"

	headerValStr := req.Header.Get("X-Val")
	if headerValStr != "" {
		valuesStr := strings.Split(headerValStr, ",") // Assuming comma-separated for simple style
		slice := make([]*string, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// IsElemPointer
				// ElemType is string
				emptyStr := ""
				slice = append(slice, &emptyStr)

			} else {

				sPtr := trimmedValStrLoop
				slice = append(slice, &sPtr)

			}
		}
		s.Val = slice
	} else { // Header not found

		s.Val = nil // Or empty slice

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPointerSliceHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val ([]*string) from "X-Val"

	headerValStr := req.Header.Get("X-Val")
	if headerValStr != "" {
		valuesStr := strings.Split(headerValStr, ",") // Assuming comma-separated for simple style
		slice := make([]*string, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// IsElemPointer
				// ElemType is string
				emptyStr := ""
				slice = append(slice, &emptyStr)

			} else {

				sPtr := trimmedValStrLoop
				slice = append(slice, &sPtr)

			}
		}
		s.Val = slice
	} else { // Header not found

		errs = append(errs, fmt.Errorf("required header slice \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPointerSliceCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val ([]*string) from "val"

	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valuesStr := strings.Split(cookie.Value, ",") // Assuming comma-separated for form style
		slice := make([]*string, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// IsElemPointer
				// ElemType is string
				emptyStr := ""
				slice = append(slice, &emptyStr)

			} else {

				sPtr := trimmedValStrLoop
				slice = append(slice, &sPtr)

			}
		}
		s.Val = slice
	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil { // Report actual errors other than not found
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		s.Val = nil // Or empty slice

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPointerSliceCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val ([]*string) from "val"

	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valuesStr := strings.Split(cookie.Value, ",") // Assuming comma-separated for form style
		slice := make([]*string, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// IsElemPointer
				// ElemType is string
				emptyStr := ""
				slice = append(slice, &emptyStr)

			} else {

				sPtr := trimmedValStrLoop
				slice = append(slice, &sPtr)

			}
		}
		s.Val = slice
	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil { // Report actual errors other than not found
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie slice \"val\" for field Val is missing or empty (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPointerSlicePath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val ([]*string) from "val"

	// TODO: Path parameter slice binding is not typically supported directly.
	// Consider if this is a valid use case or should be an error/skipped.
	// For now, skipping slice binding from path.
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindStringPointerSlicePathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val ([]*string) from "val"

	// TODO: Path parameter slice binding is not typically supported directly.
	// Consider if this is a valid use case or should be an error/skipped.
	// For now, skipping slice binding from path.
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPointerSliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*int) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*int, 0, sliceCap)  // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values { // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *int
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				v, convErr := strconv.Atoi(valStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to int for field Val: %w", valStrLoop, convErr))
				} else {
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]*int, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPointerSliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*int) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*int, 0, sliceCap)  // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values { // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *int
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				v, convErr := strconv.Atoi(valStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to int for field Val: %w", valStrLoop, convErr))
				} else {
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPointerSliceHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val ([]*int) from "X-Val"

	headerValStr := req.Header.Get("X-Val")
	if headerValStr != "" {
		valuesStr := strings.Split(headerValStr, ",") // Assuming comma-separated for simple style
		slice := make([]*int, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *int
				slice = append(slice, typedNil)

			} else {

				var v int
				var convErr error
				v, convErr = strconv.Atoi(trimmedValStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" element (value: %q) to int for field Val: %w", trimmedValStrLoop, convErr))
				} else {
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Header not found

		s.Val = nil // Or empty slice

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPointerSliceHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val ([]*int) from "X-Val"

	headerValStr := req.Header.Get("X-Val")
	if headerValStr != "" {
		valuesStr := strings.Split(headerValStr, ",") // Assuming comma-separated for simple style
		slice := make([]*int, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *int
				slice = append(slice, typedNil)

			} else {

				var v int
				var convErr error
				v, convErr = strconv.Atoi(trimmedValStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" element (value: %q) to int for field Val: %w", trimmedValStrLoop, convErr))
				} else {
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Header not found

		errs = append(errs, fmt.Errorf("required header slice \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPointerSliceCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val ([]*int) from "val"

	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valuesStr := strings.Split(cookie.Value, ",") // Assuming comma-separated for form style
		slice := make([]*int, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *int
				slice = append(slice, typedNil)

			} else {

				v, convErr := strconv.Atoi(trimmedValStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" element (value: %q) to int for field Val: %w", trimmedValStrLoop, convErr))
				} else {
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil { // Report actual errors other than not found
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		s.Val = nil // Or empty slice

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPointerSliceCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val ([]*int) from "val"

	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valuesStr := strings.Split(cookie.Value, ",") // Assuming comma-separated for form style
		slice := make([]*int, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *int
				slice = append(slice, typedNil)

			} else {

				v, convErr := strconv.Atoi(trimmedValStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert cookie \"val\" element (value: %q) to int for field Val: %w", trimmedValStrLoop, convErr))
				} else {
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil { // Report actual errors other than not found
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie slice \"val\" for field Val is missing or empty (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPointerSlicePath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val ([]*int) from "val"

	// TODO: Path parameter slice binding is not typically supported directly.
	// Consider if this is a valid use case or should be an error/skipped.
	// For now, skipping slice binding from path.
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindIntPointerSlicePathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val ([]*int) from "val"

	// TODO: Path parameter slice binding is not typically supported directly.
	// Consider if this is a valid use case or should be an error/skipped.
	// For now, skipping slice binding from path.
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPointerSliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*bool) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*bool, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values { // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *bool
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var v bool
				var convErr error
				v, convErr = strconv.ParseBool(valStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to bool for field Val: %w", valStrLoop, convErr))
				} else {
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]*bool, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPointerSliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*bool) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*bool, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values { // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *bool
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var v bool
				var convErr error
				v, convErr = strconv.ParseBool(valStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to bool for field Val: %w", valStrLoop, convErr))
				} else {
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPointerSliceHeader) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val ([]*bool) from "X-Val"

	headerValStr := req.Header.Get("X-Val")
	if headerValStr != "" {
		valuesStr := strings.Split(headerValStr, ",") // Assuming comma-separated for simple style
		slice := make([]*bool, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *bool
				slice = append(slice, typedNil)

			} else {

				var v bool
				var convErr error
				v, convErr = strconv.ParseBool(trimmedValStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" element (value: %q) to bool for field Val: %w", trimmedValStrLoop, convErr))
				} else {
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Header not found

		s.Val = nil // Or empty slice

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPointerSliceHeaderRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Header binding for field Val ([]*bool) from "X-Val"

	headerValStr := req.Header.Get("X-Val")
	if headerValStr != "" {
		valuesStr := strings.Split(headerValStr, ",") // Assuming comma-separated for simple style
		slice := make([]*bool, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *bool
				slice = append(slice, typedNil)

			} else {

				var v bool
				var convErr error
				v, convErr = strconv.ParseBool(trimmedValStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert header \"X-Val\" element (value: %q) to bool for field Val: %w", trimmedValStrLoop, convErr))
				} else {
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Header not found

		errs = append(errs, fmt.Errorf("required header slice \"X-Val\" for field Val is missing"))

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPointerSliceCookie) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val ([]*bool) from "val"

	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valuesStr := strings.Split(cookie.Value, ",") // Assuming comma-separated for form style
		slice := make([]*bool, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *bool
				slice = append(slice, typedNil)

			} else {

				var v bool
				var convErr error
				v, convErr = strconv.ParseBool(trimmedValStrLoop)

			}
		}
		s.Val = slice
	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil { // Report actual errors other than not found
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		s.Val = nil // Or empty slice

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPointerSliceCookieRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Cookie binding for field Val ([]*bool) from "val"

	if cookie, cerr := req.Cookie("val"); cerr == nil && cookie.Value != "" {
		valuesStr := strings.Split(cookie.Value, ",") // Assuming comma-separated for form style
		slice := make([]*bool, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *bool
				slice = append(slice, typedNil)

			} else {

				var v bool
				var convErr error
				v, convErr = strconv.ParseBool(trimmedValStrLoop)

			}
		}
		s.Val = slice
	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil { // Report actual errors other than not found
			errs = append(errs, fmt.Errorf("error retrieving cookie \"val\" for field Val: %w", cerr))
		}

		errs = append(errs, fmt.Errorf("required cookie slice \"val\" for field Val is missing or empty (underlying error: %v)", cerr))

	}
	// End of not .IsSlice for Cookie

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPointerSlicePath) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val ([]*bool) from "val"

	// TODO: Path parameter slice binding is not typically supported directly.
	// Consider if this is a valid use case or should be an error/skipped.
	// For now, skipping slice binding from path.
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindBoolPointerSlicePathRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Path parameter binding for field Val ([]*bool) from "val"

	// TODO: Path parameter slice binding is not typically supported directly.
	// Consider if this is a valid use case or should be an error/skipped.
	// For now, skipping slice binding from path.
	// End of not .IsSlice for Path

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32SliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]float32) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]float32, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {   // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to float32 from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var v64 float64
				var convErr error
				v64, convErr = strconv.ParseFloat(valStrLoop, 32)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to float32 for field Val: %w", valStrLoop, convErr))
				} else {
					v := float32(v64)
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]float32, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32SliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]float32) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]float32, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {   // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to float32 from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var v64 float64
				var convErr error
				v64, convErr = strconv.ParseFloat(valStrLoop, 32)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to float32 for field Val: %w", valStrLoop, convErr))
				} else {
					v := float32(v64)
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64SliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]float64) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]float64, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {   // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to float64 from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var v float64
				var convErr error
				v, convErr = strconv.ParseFloat(valStrLoop, 64)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to float64 for field Val: %w", valStrLoop, convErr))
				} else {
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]float64, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64SliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]float64) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]float64, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {   // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to float64 from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var v float64
				var convErr error
				v, convErr = strconv.ParseFloat(valStrLoop, 64)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to float64 for field Val: %w", valStrLoop, convErr))
				} else {
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32PointerSliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*float32) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*float32, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {    // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *float32
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var v64 float64
				var convErr error
				v64, convErr = strconv.ParseFloat(valStrLoop, 32)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to float32 for field Val: %w", valStrLoop, convErr))
				} else {
					v := float32(v64)
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]*float32, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat32PointerSliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*float32) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*float32, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {    // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *float32
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var v64 float64
				var convErr error
				v64, convErr = strconv.ParseFloat(valStrLoop, 32)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to float32 for field Val: %w", valStrLoop, convErr))
				} else {
					v := float32(v64)
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64PointerSliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*float64) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*float64, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {    // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *float64
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var v float64
				var convErr error
				v, convErr = strconv.ParseFloat(valStrLoop, 64)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to float64 for field Val: %w", valStrLoop, convErr))
				} else {
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]*float64, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindFloat64PointerSliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*float64) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*float64, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {    // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *float64
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var v float64
				var convErr error
				v, convErr = strconv.ParseFloat(valStrLoop, 64)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to float64 for field Val: %w", valStrLoop, convErr))
				} else {
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintSliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]uint) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]uint, 0, sliceCap)  // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values { // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to uint from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var v64 uint64
				var convErr error
				v64, convErr = strconv.ParseUint(valStrLoop, 10, 0)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint for field Val: %w", valStrLoop, convErr))
				} else {
					v := uint(v64)
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]uint, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintSliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]uint) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]uint, 0, sliceCap)  // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values { // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to uint from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var v64 uint64
				var convErr error
				v64, convErr = strconv.ParseUint(valStrLoop, 10, 0)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint for field Val: %w", valStrLoop, convErr))
				} else {
					v := uint(v64)
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8SliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]uint8) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]uint8, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values { // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to uint8 from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var v64 uint64
				var convErr error
				v64, convErr = strconv.ParseUint(valStrLoop, 10, 8)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint8 for field Val: %w", valStrLoop, convErr))
				} else {
					v := uint8(v64)
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]uint8, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8SliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]uint8) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]uint8, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values { // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to uint8 from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var v64 uint64
				var convErr error
				v64, convErr = strconv.ParseUint(valStrLoop, 10, 8)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint8 for field Val: %w", valStrLoop, convErr))
				} else {
					v := uint8(v64)
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16SliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]uint16) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]uint16, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {  // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to uint16 from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var v64 uint64
				var convErr error
				v64, convErr = strconv.ParseUint(valStrLoop, 10, 16)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint16 for field Val: %w", valStrLoop, convErr))
				} else {
					v := uint16(v64)
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]uint16, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16SliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]uint16) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]uint16, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {  // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to uint16 from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var v64 uint64
				var convErr error
				v64, convErr = strconv.ParseUint(valStrLoop, 10, 16)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint16 for field Val: %w", valStrLoop, convErr))
				} else {
					v := uint16(v64)
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32SliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]uint32) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]uint32, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {  // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to uint32 from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var v64 uint64
				var convErr error
				v64, convErr = strconv.ParseUint(valStrLoop, 10, 32)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint32 for field Val: %w", valStrLoop, convErr))
				} else {
					v := uint32(v64)
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]uint32, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32SliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]uint32) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]uint32, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {  // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to uint32 from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var v64 uint64
				var convErr error
				v64, convErr = strconv.ParseUint(valStrLoop, 10, 32)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint32 for field Val: %w", valStrLoop, convErr))
				} else {
					v := uint32(v64)
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64SliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]uint64) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]uint64, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {  // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to uint64 from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var v uint64
				var convErr error
				v, convErr = strconv.ParseUint(valStrLoop, 10, 64)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint64 for field Val: %w", valStrLoop, convErr))
				} else {
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]uint64, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64SliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]uint64) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]uint64, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {  // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to uint64 from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var v uint64
				var convErr error
				v, convErr = strconv.ParseUint(valStrLoop, 10, 64)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint64 for field Val: %w", valStrLoop, convErr))
				} else {
					slice = append(slice, v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrSliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]uintptr) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]uintptr, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {   // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to uintptr from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				errs = append(errs, fmt.Errorf("unsupported slice element type %q for field Val (param \"val\")", "uintptr"))

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]uintptr, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrSliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]uintptr) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]uintptr, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {   // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to uintptr from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				errs = append(errs, fmt.Errorf("unsupported slice element type %q for field Val (param \"val\")", "uintptr"))

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintPointerSliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*uint) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*uint, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values { // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *uint
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var v64 uint64
				var convErr error
				v64, convErr = strconv.ParseUint(valStrLoop, 10, 0)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint for field Val: %w", valStrLoop, convErr))
				} else {
					v := uint(v64)
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]*uint, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintPointerSliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*uint) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*uint, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values { // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *uint
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var v64 uint64
				var convErr error
				v64, convErr = strconv.ParseUint(valStrLoop, 10, 0)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint for field Val: %w", valStrLoop, convErr))
				} else {
					v := uint(v64)
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8PointerSliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*uint8) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*uint8, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {  // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *uint8
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var v64 uint64
				var convErr error
				v64, convErr = strconv.ParseUint(valStrLoop, 10, 8)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint8 for field Val: %w", valStrLoop, convErr))
				} else {
					v := uint8(v64)
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]*uint8, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint8PointerSliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*uint8) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*uint8, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {  // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *uint8
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var v64 uint64
				var convErr error
				v64, convErr = strconv.ParseUint(valStrLoop, 10, 8)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint8 for field Val: %w", valStrLoop, convErr))
				} else {
					v := uint8(v64)
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16PointerSliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*uint16) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*uint16, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {   // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *uint16
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var v64 uint64
				var convErr error
				v64, convErr = strconv.ParseUint(valStrLoop, 10, 16)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint16 for field Val: %w", valStrLoop, convErr))
				} else {
					v := uint16(v64)
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]*uint16, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint16PointerSliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*uint16) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*uint16, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {   // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *uint16
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var v64 uint64
				var convErr error
				v64, convErr = strconv.ParseUint(valStrLoop, 10, 16)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint16 for field Val: %w", valStrLoop, convErr))
				} else {
					v := uint16(v64)
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32PointerSliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*uint32) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*uint32, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {   // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *uint32
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var v64 uint64
				var convErr error
				v64, convErr = strconv.ParseUint(valStrLoop, 10, 32)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint32 for field Val: %w", valStrLoop, convErr))
				} else {
					v := uint32(v64)
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]*uint32, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint32PointerSliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*uint32) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*uint32, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {   // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *uint32
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var v64 uint64
				var convErr error
				v64, convErr = strconv.ParseUint(valStrLoop, 10, 32)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint32 for field Val: %w", valStrLoop, convErr))
				} else {
					v := uint32(v64)
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64PointerSliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*uint64) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*uint64, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {   // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *uint64
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var v uint64
				var convErr error
				v, convErr = strconv.ParseUint(valStrLoop, 10, 64)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint64 for field Val: %w", valStrLoop, convErr))
				} else {
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]*uint64, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUint64PointerSliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*uint64) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*uint64, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {   // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *uint64
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var v uint64
				var convErr error
				v, convErr = strconv.ParseUint(valStrLoop, 10, 64)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to uint64 for field Val: %w", valStrLoop, convErr))
				} else {
					slice = append(slice, &v)
				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrPointerSliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*uintptr) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*uintptr, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {    // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *uintptr
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				errs = append(errs, fmt.Errorf("unsupported slice element type %q for field Val (param \"val\")", "uintptr"))

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]*uintptr, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindUintptrPointerSliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*uintptr) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*uintptr, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {    // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *uintptr
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				errs = append(errs, fmt.Errorf("unsupported slice element type %q for field Val (param \"val\")", "uintptr"))

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64SliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]complex64) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]complex64, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {     // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to complex64 from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var vComplex complex128
				var convErr error
				vComplex, convErr = strconv.ParseComplex(valStrLoop, 64)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to complex64 for field Val: %w", valStrLoop, convErr))
				} else {
					c := complex64(vComplex)

					slice = append(slice, c)

				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]complex64, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64SliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]complex64) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]complex64, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {     // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to complex64 from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var vComplex complex128
				var convErr error
				vComplex, convErr = strconv.ParseComplex(valStrLoop, 64)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to complex64 for field Val: %w", valStrLoop, convErr))
				} else {
					c := complex64(vComplex)

					slice = append(slice, c)

				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128SliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]complex128) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]complex128, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {      // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to complex128 from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var vComplex complex128
				var convErr error
				vComplex, convErr = strconv.ParseComplex(valStrLoop, 128)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to complex128 for field Val: %w", valStrLoop, convErr))
				} else {

					slice = append(slice, vComplex)

				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]complex128, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128SliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]complex128) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]complex128, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {      // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for slice element of Val (param \"val\") cannot be converted to complex128 from %q", valStrLoop))

			} else { // Value is not empty, proceed with conversion

				var vComplex complex128
				var convErr error
				vComplex, convErr = strconv.ParseComplex(valStrLoop, 128)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to complex128 for field Val: %w", valStrLoop, convErr))
				} else {

					slice = append(slice, vComplex)

				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64PointerSliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*complex64) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*complex64, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {      // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *complex64
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var vComplex complex128
				var convErr error
				vComplex, convErr = strconv.ParseComplex(valStrLoop, 64)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to complex64 for field Val: %w", valStrLoop, convErr))
				} else {
					c := complex64(vComplex)

					slice = append(slice, &c)

				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]*complex64, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex64PointerSliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*complex64) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*complex64, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {      // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *complex64
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var vComplex complex128
				var convErr error
				vComplex, convErr = strconv.ParseComplex(valStrLoop, 64)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to complex64 for field Val: %w", valStrLoop, convErr))
				} else {
					c := complex64(vComplex)

					slice = append(slice, &c)

				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128PointerSliceQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*complex128) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*complex128, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {       // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *complex128
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var vComplex complex128
				var convErr error
				vComplex, convErr = strconv.ParseComplex(valStrLoop, 128)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to complex128 for field Val: %w", valStrLoop, convErr))
				} else {

					slice = append(slice, &vComplex)

				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.Val = nil // Or empty slice: make([]*complex128, 0)

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindComplex128PointerSliceQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field Val ([]*complex128) from "val"

	if values, ok := req.URL.Query()["val"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*complex128, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {       // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *complex128
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var vComplex complex128
				var convErr error
				vComplex, convErr = strconv.ParseComplex(valStrLoop, 128)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"val\" element (value: %q) to complex128 for field Val: %w", valStrLoop, convErr))
				} else {

					slice = append(slice, &vComplex)

				}

			}
		}
		s.Val = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		errs = append(errs, fmt.Errorf("required query parameter slice \"val\" for field Val is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindMultipleQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field StringVal (string) from "sval"
	// Not a slice for Query
	if req.URL.Query().Has("sval") {
		valStr := req.URL.Query().Get("sval")
		if valStr == "" {

			s.StringVal = valStr // Empty value for string is itself

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || true {

			s.StringVal = valStr

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field IntVal (int) from "ival"
	// Not a slice for Query
	if req.URL.Query().Has("ival") {
		valStr := req.URL.Query().Get("ival")
		if valStr == "" {

			// Empty value for non-pointer, non-string, non-required. Stays zero/default. Or error?
			// Let's be strict: if it's not string and empty, it's a conversion problem unless specifically allowed.
			// However, current logic for non-slice non-required non-pointer is to leave as zero value if key exists but val is empty and conv fails.
			// This behavior should be consistent. For now, if not string, treat empty as potential conversion error handled by strconv.

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseInt(valStr, 10, 0)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"ival\" (value: %q) to int for field IntVal: %w", valStr, convErr))
			} else {
				s.IntVal = int(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field BoolVal (bool) from "bval"
	// Not a slice for Query
	if req.URL.Query().Has("bval") {
		valStr := req.URL.Query().Get("bval")
		if valStr == "" {

			// Empty value for non-pointer, non-string, non-required. Stays zero/default. Or error?
			// Let's be strict: if it's not string and empty, it's a conversion problem unless specifically allowed.
			// However, current logic for non-slice non-required non-pointer is to leave as zero value if key exists but val is empty and conv fails.
			// This behavior should be consistent. For now, if not string, treat empty as potential conversion error handled by strconv.

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseBool(valStr)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"bval\" (value: %q) to bool for field BoolVal: %w", valStr, convErr))
			} else {
				s.BoolVal = v
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field FloatVal (float64) from "fval"
	// Not a slice for Query
	if req.URL.Query().Has("fval") {
		valStr := req.URL.Query().Get("fval")
		if valStr == "" {

			// Empty value for non-pointer, non-string, non-required. Stays zero/default. Or error?
			// Let's be strict: if it's not string and empty, it's a conversion problem unless specifically allowed.
			// However, current logic for non-slice non-required non-pointer is to leave as zero value if key exists but val is empty and conv fails.
			// This behavior should be consistent. For now, if not string, treat empty as potential conversion error handled by strconv.

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseFloat(valStr, 64)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"fval\" (value: %q) to float64 for field FloatVal: %w", valStr, convErr))
			} else {
				s.FloatVal = float64(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field UintVal (uint) from "uval"
	// Not a slice for Query
	if req.URL.Query().Has("uval") {
		valStr := req.URL.Query().Get("uval")
		if valStr == "" {

			// Empty value for non-pointer, non-string, non-required. Stays zero/default. Or error?
			// Let's be strict: if it's not string and empty, it's a conversion problem unless specifically allowed.
			// However, current logic for non-slice non-required non-pointer is to leave as zero value if key exists but val is empty and conv fails.
			// This behavior should be consistent. For now, if not string, treat empty as potential conversion error handled by strconv.

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 0)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"uval\" (value: %q) to uint for field UintVal: %w", valStr, convErr))
			} else {
				s.UintVal = uint(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field ComplexVal (complex128) from "cval"
	// Not a slice for Query
	if req.URL.Query().Has("cval") {
		valStr := req.URL.Query().Get("cval")
		if valStr == "" {

			// Empty value for non-pointer, non-string, non-required. Stays zero/default. Or error?
			// Let's be strict: if it's not string and empty, it's a conversion problem unless specifically allowed.
			// However, current logic for non-slice non-required non-pointer is to leave as zero value if key exists but val is empty and conv fails.
			// This behavior should be consistent. For now, if not string, treat empty as potential conversion error handled by strconv.

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseComplex(valStr, 128)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"cval\" (value: %q) to complex128 for field ComplexVal: %w", valStr, convErr))
			} else {
				s.ComplexVal = complex128(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindMultipleQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field StringVal (string) from "sval"
	// Not a slice for Query
	if req.URL.Query().Has("sval") {
		valStr := req.URL.Query().Get("sval")
		if valStr == "" {

			// Required string can be empty unless specific validation says otherwise
			s.StringVal = valStr

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || true {

			s.StringVal = valStr

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"sval\" for field StringVal is missing"))

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field IntVal (int) from "ival"
	// Not a slice for Query
	if req.URL.Query().Has("ival") {
		valStr := req.URL.Query().Get("ival")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"ival\" for field IntVal received an empty value which cannot be converted to int"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseInt(valStr, 10, 0)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"ival\" (value: %q) to int for field IntVal: %w", valStr, convErr))
			} else {
				s.IntVal = int(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"ival\" for field IntVal is missing"))

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field BoolVal (bool) from "bval"
	// Not a slice for Query
	if req.URL.Query().Has("bval") {
		valStr := req.URL.Query().Get("bval")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"bval\" for field BoolVal received an empty value which cannot be converted to bool"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseBool(valStr)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"bval\" (value: %q) to bool for field BoolVal: %w", valStr, convErr))
			} else {
				s.BoolVal = v
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"bval\" for field BoolVal is missing"))

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field FloatVal (float64) from "fval"
	// Not a slice for Query
	if req.URL.Query().Has("fval") {
		valStr := req.URL.Query().Get("fval")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"fval\" for field FloatVal received an empty value which cannot be converted to float64"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseFloat(valStr, 64)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"fval\" (value: %q) to float64 for field FloatVal: %w", valStr, convErr))
			} else {
				s.FloatVal = float64(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"fval\" for field FloatVal is missing"))

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field UintVal (uint) from "uval"
	// Not a slice for Query
	if req.URL.Query().Has("uval") {
		valStr := req.URL.Query().Get("uval")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"uval\" for field UintVal received an empty value which cannot be converted to uint"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 0)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"uval\" (value: %q) to uint for field UintVal: %w", valStr, convErr))
			} else {
				s.UintVal = uint(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"uval\" for field UintVal is missing"))

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field ComplexVal (complex128) from "cval"
	// Not a slice for Query
	if req.URL.Query().Has("cval") {
		valStr := req.URL.Query().Get("cval")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"cval\" for field ComplexVal received an empty value which cannot be converted to complex128"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseComplex(valStr, 128)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"cval\" (value: %q) to complex128 for field ComplexVal: %w", valStr, convErr))
			} else {
				s.ComplexVal = complex128(v)
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"cval\" for field ComplexVal is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindMultiplePointerQuery) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field StringVal (*string) from "sval"
	// Not a slice for Query
	if req.URL.Query().Has("sval") {
		valStr := req.URL.Query().Get("sval")
		if valStr == "" {

			s.StringVal = &valStr // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || true {

			s.StringVal = &valStr

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.StringVal = nil

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field IntVal (*int) from "ival"
	// Not a slice for Query
	if req.URL.Query().Has("ival") {
		valStr := req.URL.Query().Get("ival")
		if valStr == "" {

			s.IntVal = nil // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseInt(valStr, 10, 0)
			if convErr != nil {
				s.IntVal = nil
			} else {
				convertedValue := int(v)
				s.IntVal = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.IntVal = nil

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field BoolVal (*bool) from "bval"
	// Not a slice for Query
	if req.URL.Query().Has("bval") {
		valStr := req.URL.Query().Get("bval")
		if valStr == "" {

			s.BoolVal = nil // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseBool(valStr)
			if convErr != nil {
				s.BoolVal = nil
			} else {
				s.BoolVal = &v
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.BoolVal = nil

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field FloatVal (*float64) from "fval"
	// Not a slice for Query
	if req.URL.Query().Has("fval") {
		valStr := req.URL.Query().Get("fval")
		if valStr == "" {

			s.FloatVal = nil // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseFloat(valStr, 64)
			if convErr != nil {
				s.FloatVal = nil
			} else {
				convertedValue := float64(v)
				s.FloatVal = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.FloatVal = nil

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field UintVal (*uint) from "uval"
	// Not a slice for Query
	if req.URL.Query().Has("uval") {
		valStr := req.URL.Query().Get("uval")
		if valStr == "" {

			s.UintVal = nil // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 0)
			if convErr != nil {
				s.UintVal = nil
			} else {
				convertedValue := uint(v)
				s.UintVal = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.UintVal = nil

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field ComplexVal (*complex128) from "cval"
	// Not a slice for Query
	if req.URL.Query().Has("cval") {
		valStr := req.URL.Query().Get("cval")
		if valStr == "" {

			s.ComplexVal = nil // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseComplex(valStr, 128)
			if convErr != nil {

				s.ComplexVal = nil

			} else {
				convertedValue := complex128(v)

				s.ComplexVal = &convertedValue

			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.ComplexVal = nil

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindMultiplePointerQueryRequired) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field StringVal (*string) from "sval"
	// Not a slice for Query
	if req.URL.Query().Has("sval") {
		valStr := req.URL.Query().Get("sval")
		if valStr == "" {

			// Required string can be empty unless specific validation says otherwise
			s.StringVal = &valStr

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || true {

			s.StringVal = &valStr

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"sval\" for field StringVal is missing"))

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field IntVal (*int) from "ival"
	// Not a slice for Query
	if req.URL.Query().Has("ival") {
		valStr := req.URL.Query().Get("ival")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"ival\" for field IntVal received an empty value which cannot be converted to int"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseInt(valStr, 10, 0)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"ival\" (value: %q) to int for field IntVal: %w", valStr, convErr))
			} else {
				convertedValue := int(v)
				s.IntVal = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"ival\" for field IntVal is missing"))

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field BoolVal (*bool) from "bval"
	// Not a slice for Query
	if req.URL.Query().Has("bval") {
		valStr := req.URL.Query().Get("bval")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"bval\" for field BoolVal received an empty value which cannot be converted to bool"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseBool(valStr)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"bval\" (value: %q) to bool for field BoolVal: %w", valStr, convErr))
			} else {
				s.BoolVal = &v
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"bval\" for field BoolVal is missing"))

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field FloatVal (*float64) from "fval"
	// Not a slice for Query
	if req.URL.Query().Has("fval") {
		valStr := req.URL.Query().Get("fval")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"fval\" for field FloatVal received an empty value which cannot be converted to float64"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseFloat(valStr, 64)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"fval\" (value: %q) to float64 for field FloatVal: %w", valStr, convErr))
			} else {
				convertedValue := float64(v)
				s.FloatVal = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"fval\" for field FloatVal is missing"))

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field UintVal (*uint) from "uval"
	// Not a slice for Query
	if req.URL.Query().Has("uval") {
		valStr := req.URL.Query().Get("uval")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"uval\" for field UintVal received an empty value which cannot be converted to uint"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 0)
			if convErr != nil {
				errs = append(errs, fmt.Errorf("failed to convert query parameter \"uval\" (value: %q) to uint for field UintVal: %w", valStr, convErr))
			} else {
				convertedValue := uint(v)
				s.UintVal = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"uval\" for field UintVal is missing"))

	}
	// End of not .IsSlice for Query

	// Query parameter binding for field ComplexVal (*complex128) from "cval"
	// Not a slice for Query
	if req.URL.Query().Has("cval") {
		valStr := req.URL.Query().Get("cval")
		if valStr == "" {

			errs = append(errs, fmt.Errorf("required query parameter \"cval\" for field ComplexVal received an empty value which cannot be converted to complex128"))

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			v, convErr := strconv.ParseComplex(valStr, 128)
			if convErr != nil {

				errs = append(errs, fmt.Errorf("failed to convert query parameter \"cval\" (value: %q) to complex128 for field ComplexVal: %w", valStr, convErr))

			} else {
				convertedValue := complex128(v)

				s.ComplexVal = &convertedValue

			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		errs = append(errs, fmt.Errorf("required query parameter \"cval\" for field ComplexVal is missing"))

	}
	// End of not .IsSlice for Query

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindMultipleMixed) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field QueryStr (string) from "qStr"
	// Not a slice for Query
	if req.URL.Query().Has("qStr") {
		valStr := req.URL.Query().Get("qStr")
		if valStr == "" {

			s.QueryStr = valStr // Empty value for string is itself

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || true {

			s.QueryStr = valStr

		} // End valStr not empty or is string
	} else { // Key does not exist for query

	}
	// End of not .IsSlice for Query

	// Header binding for field HeaderInt (int) from "X-HInt"
	// Not a slice for Header
	if valStr := req.Header.Get("X-HInt"); valStr != "" {

		v, convErr := strconv.ParseInt(valStr, 10, 0)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-HInt\" (value: %q) to int for field HeaderInt: %w", valStr, convErr))
		} else {
			s.HeaderInt = int(v)
		}

	} else { // Header value is empty or header not found

		errs = append(errs, fmt.Errorf("required header \"X-HInt\" for field HeaderInt is missing"))

	}
	// End of not .IsSlice for Header

	// Cookie binding for field CookieBool (*bool) from "cBool"
	// Not a slice for Cookie
	if cookie, cerr := req.Cookie("cBool"); cerr == nil && cookie.Value != "" {
		valStr := cookie.Value

		v, convErr := strconv.ParseBool(valStr)
		if convErr != nil {
			s.CookieBool = nil
		} else {
			s.CookieBool = &v
		}

	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil {
			errs = append(errs, fmt.Errorf("error retrieving cookie \"cBool\" for field CookieBool: %w", cerr))
		}

		s.CookieBool = nil

	}
	// End of not .IsSlice for Cookie

	// Path parameter binding for field PathFloat (float32) from "pFloat"

	if pathValueStr := pathVar("pFloat"); pathValueStr != "" {

		v, convErr := strconv.ParseFloat(pathValueStr, 32)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert path parameter \"pFloat\" (value: %q) to float32 for field PathFloat: %w", pathValueStr, convErr))
		} else {
			s.PathFloat = float32(v) // This was already correct
		}

	} else { // Path value string is empty

		errs = append(errs, fmt.Errorf("required path parameter \"pFloat\" for field PathFloat is missing"))

	}
	// End of not .IsSlice for Path

	// Query parameter binding for field QueryUintP (*uint) from "qUintP"
	// Not a slice for Query
	if req.URL.Query().Has("qUintP") {
		valStr := req.URL.Query().Get("qUintP")
		if valStr == "" {

			s.QueryUintP = nil // Empty value for non-string pointer is nil

		}
		// If valStr is not empty, or if it's an empty string for a string type, proceed with conversion
		if valStr != "" || false {

			// Unsigned
			v, convErr := strconv.ParseUint(valStr, 10, 0)
			if convErr != nil {
				s.QueryUintP = nil
			} else {
				convertedValue := uint(v)
				s.QueryUintP = &convertedValue
			}

		} // End valStr not empty or is string
	} else { // Key does not exist for query

		s.QueryUintP = nil

	}
	// End of not .IsSlice for Query

	// Header binding for field HeaderCmplx (complex64) from "X-HCmplx"
	// Not a slice for Header
	if valStr := req.Header.Get("X-HCmplx"); valStr != "" {

		v, convErr := strconv.ParseComplex(valStr, 64)
		if convErr != nil {
			errs = append(errs, fmt.Errorf("failed to convert header \"X-HCmplx\" (value: %q) to complex64 for field HeaderCmplx: %w", valStr, convErr))
		} else {
			s.HeaderCmplx = complex64(v)
		}

	} else { // Header value is empty or header not found

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (s *TestBindMultipleSlicesMixed) Bind(req *http.Request, pathVar func(string) string) error {
	var errs []error

	// Query parameter binding for field QueryStrSlice ([]string) from "qStrSlice"

	if values, ok := req.URL.Query()["qStrSlice"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]string, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values {  // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// ElemType is string
				slice = append(slice, valStrLoop)

			} else { // Value is not empty, proceed with conversion

				slice = append(slice, valStrLoop)

			}
		}
		s.QueryStrSlice = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.QueryStrSlice = nil // Or empty slice: make([]string, 0)

	}
	// End of not .IsSlice for Query

	// Header binding for field HeaderIntSlice ([]int) from "X-HIntSlice"

	headerValStr := req.Header.Get("X-HIntSlice")
	if headerValStr != "" {
		valuesStr := strings.Split(headerValStr, ",") // Assuming comma-separated for simple style
		slice := make([]int, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for trimmed slice element of HeaderIntSlice (header \"X-HIntSlice\") cannot be converted to int from %q", trimmedValStrLoop))

			} else {

				var v int
				var convErr error
				v, convErr = strconv.Atoi(trimmedValStrLoop)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert header \"X-HIntSlice\" element (value: %q) to int for field HeaderIntSlice: %w", trimmedValStrLoop, convErr))
				} else {
					slice = append(slice, v)
				}

			}
		}
		s.HeaderIntSlice = slice
	} else { // Header not found

		errs = append(errs, fmt.Errorf("required header slice \"X-HIntSlice\" for field HeaderIntSlice is missing"))

	}
	// End of not .IsSlice for Header

	// Cookie binding for field CookieBoolSlice ([]*bool) from "cBoolSlice"

	if cookie, cerr := req.Cookie("cBoolSlice"); cerr == nil && cookie.Value != "" {
		valuesStr := strings.Split(cookie.Value, ",") // Assuming comma-separated for form style
		slice := make([]*bool, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *bool
				slice = append(slice, typedNil)

			} else {

				var v bool
				var convErr error
				v, convErr = strconv.ParseBool(trimmedValStrLoop)

			}
		}
		s.CookieBoolSlice = slice
	} else { // Cookie not found or value is empty
		if cerr != http.ErrNoCookie && cerr != nil { // Report actual errors other than not found
			errs = append(errs, fmt.Errorf("error retrieving cookie \"cBoolSlice\" for field CookieBoolSlice: %w", cerr))
		}

		s.CookieBoolSlice = nil // Or empty slice

	}
	// End of not .IsSlice for Cookie

	// Path parameter binding for field PathFloatSlice ([]float32) from "pFloatSlice"

	// TODO: Path parameter slice binding is not typically supported directly.
	// Consider if this is a valid use case or should be an error/skipped.
	// For now, skipping slice binding from path.
	// End of not .IsSlice for Path

	// Query parameter binding for field QueryUintPSlice ([]*uint) from "qUintPSlice"

	if values, ok := req.URL.Query()["qUintPSlice"]; ok && len(values) > 0 {
		sliceCap := len(values)
		slice := make([]*uint, 0, sliceCap) // Use SliceElementType, e.g., "int", "*string"
		for _, valStrLoop := range values { // Renamed valStr to valStrLoop to avoid conflict if defined outside
			// Directly use valStrLoop and field properties like .SliceElementType, .BindName, .FieldName
			//  // This logic will be inlined or handled by nested if
			//  // This logic will be inlined

			if valStrLoop == "" { // Handle empty string in multi-value query param
				// IsElemPointer
				// *int, *bool etc.
				var typedNil *uint
				slice = append(slice, typedNil)

			} else { // Value is not empty, proceed with conversion

				var v64 uint64
				var convErr error
				v64, convErr = strconv.ParseUint(valStrLoop, 10, 0)
				if convErr != nil {
					errs = append(errs, fmt.Errorf("failed to convert query parameter \"qUintPSlice\" element (value: %q) to uint for field QueryUintPSlice: %w", valStrLoop, convErr))
				} else {
					v := uint(v64)
					slice = append(slice, &v)
				}

			}
		}
		s.QueryUintPSlice = slice
	} else { // Parameter not found or no values
		// This entire block (previously lines 255-307) was problematic as valStr is not defined here.
		// The logic for when a slice parameter is missing or empty is handled below.

		s.QueryUintPSlice = nil // Or empty slice: make([]*uint, 0)

	}
	// End of not .IsSlice for Query

	// Header binding for field HeaderCmplxSlice ([]complex64) from "X-HCmplxSlice"

	headerValStr := req.Header.Get("X-HCmplxSlice")
	if headerValStr != "" {
		valuesStr := strings.Split(headerValStr, ",") // Assuming comma-separated for simple style
		slice := make([]complex64, 0, len(valuesStr))
		for _, valStrLoop := range valuesStr {
			trimmedValStrLoop := strings.TrimSpace(valStrLoop)
			// Directly use trimmedValStrLoop and field properties
			if trimmedValStrLoop == "" {
				// int, bool etc. (non-pointer, non-string)
				errs = append(errs, fmt.Errorf("empty value for trimmed slice element of HeaderCmplxSlice (header \"X-HCmplxSlice\") cannot be converted to complex64 from %q", trimmedValStrLoop))

			} else {

				errs = append(errs, fmt.Errorf("unsupported slice element type %q for field HeaderCmplxSlice (param \"X-HCmplxSlice\")", "complex64"))

			}
		}
		s.HeaderCmplxSlice = slice
	} else { // Header not found

		s.HeaderCmplxSlice = nil // Or empty slice

	}
	// End of not .IsSlice for Header

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}
