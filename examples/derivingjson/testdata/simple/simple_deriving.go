// Code generated by derivingjson for package simple. DO NOT EDIT.

package simple

import (
	"encoding/json"
	"fmt"
)

func (s *Container) UnmarshalJSON(data []byte) error {
	var discriminatorDoc struct {
		Value string `json:"type"`
	}
	if err := json.Unmarshal(data, &discriminatorDoc); err != nil {
		return fmt.Errorf("failed to unmarshal discriminator value for field 'type': %w", err)
	}

	s.Type = discriminatorDoc.Value

	var rawContent json.RawMessage
	var tempKnownFields struct {
		TargetContent *json.RawMessage `json:"content"`
	}

	var fullMap map[string]*json.RawMessage
	if err := json.Unmarshal(data, &fullMap); err != nil {
		return fmt.Errorf("failed to unmarshal full object: %w", err)
	}

	if rawVal, ok := fullMap["content"]; ok && rawVal != nil {
		rawContent = *rawVal
	}

	if rawVal, ok := fullMap["other_content"]; ok && rawVal != nil {
		var val Other
		if err := json.Unmarshal(*rawVal, &val); err != nil {
			return fmt.Errorf("failed to unmarshal field 'other_content' into Other: %w", err)
		}
		s.OtherContent = val
	}

	switch discriminatorDoc.Value {

	case "circle":
		var content Circle
		if rawContent != nil {
			if err := json.Unmarshal(rawContent, &content); err != nil {
				return fmt.Errorf("failed to unmarshal Content as Circle for discriminator 'circle': %w", err)
			}
		}
		s.Content = content

	case "rectangle":
		var content Rectangle
		if rawContent != nil {
			if err := json.Unmarshal(rawContent, &content); err != nil {
				return fmt.Errorf("failed to unmarshal Content as Rectangle for discriminator 'rectangle': %w", err)
			}
		}
		s.Content = content

	default:
		if rawContent != nil && len(rawContent) > 0 && string(rawContent) != "null" {
			return fmt.Errorf("unknown value for discriminator 'type': %s, cannot unmarshal 'content'", discriminatorDoc.Value)
		}
	}
	return nil
}
