# Trouble Report: Implementing On-Demand, Multi-Package Scanning

This document details the unexpected issues encountered while implementing "Part 2: Library Consumer Updates" of the "On-Demand, Multi-Package AST Scanning" feature, as outlined in `docs/plan-multi-package-handling.md`.

## Summary of Work Done

My goal was to refactor `examples/convert` to use the new `FieldType.Resolve()` mechanism for cross-package type resolution. The process involved the following steps:

1.  **Initial Parser Refactoring:** I modified `examples/convert/parser/parser.go` to accept a `*goscan.Scanner` instance. My initial goal was to create `scanner.FieldType` instances manually from type names found in annotations (e.g., `@derivingconvert("destination.Dst")`) and then call a resolution method on them.

2.  **Discovery of Library API Limitation:** I discovered that it was not possible to create a "resolvable" `scanner.FieldType` from outside the `scanner` package. The necessary fields (`resolver`, `fullImportPath`, `typeName`) were unexported. The plan assumed that refactoring the consumer (`examples/convert`) would be sufficient, but a modification of the core library (`go-scan`) was required to proceed. This was an **unexpected event**, as the original plan did not account for modifying the library's public (or unexported) API.

3.  **Core Library Modification:** To overcome this, I decided to export the necessary fields on `scanner.FieldType` in `scanner/models.go` (`resolver` -> `Resolver`, etc.). This, in turn, required updating all internal usages of these fields across `scanner/scanner.go`, `type_relation.go`, and `examples/convert/generator/generator.go`. This led to a cascade of compilation errors that I had to fix iteratively.

4.  **Parser Logic Enhancement:** I enhanced `parser.go` to not only resolve the top-level conversion pair but to also recursively process newly discovered structs. When `destination.Dst` was resolved, the parser would then inspect `Dst` for further `@derivingconvert` annotations, ensuring that nested dependencies (like `external.ExternalInfo` -> `external.DstInfo`) were also added to the list of conversion pairs.

5.  **Integration Test:** I added a new test, `TestIntegration_WithMultiPackage`, to `examples/convert/main_test.go`. This test specifically creates a multi-package environment (`source`, `destination`, `external`) to validate the new on-demand resolution logic.

## Summary of Problems Encountered

The implementation process was plagued by a persistent cycle of test failures.

1.  **Initial `struct not found` Error:** After the initial refactoring, the new integration test failed with the error `destination struct "Dst" not found`. This was because my parser was correctly resolving the `TypeInfo` for `destination.Dst` but was not processing it and adding the corresponding `StructInfo` to the `ParsedInfo` object that the generator uses. I fixed this by adding the `processNewlyResolvedStruct` function to recursively handle newly discovered structs.

2.  **`generated code mismatch` Error:** After fixing the "struct not found" issue, the test began failing with a `generated code mismatch` error. The generated code for the multi-package test was syntactically incorrect. Specifically, the function call for the nested conversion was malformed:
    ```go
    // Incorrect generated call
    dst.Info = *convertexternal.external.ExternalInfoToexternal.external.ExternalInfo(ctx, ec, &src.Info)
    ```
    This clearly showed that the package alias (`external`) was being duplicated.

3.  **Debugging Cycle:** My attempts to fix this invalid function name generation led to a frustrating debugging cycle.
    *   I incorrectly identified the cause as a bug in `scanner/scanner.go`'s `parseTypeExpr`, where `FieldType.Name` was being set to a qualified name (`pkg.Type`) instead of just the type name. I "fixed" this.
    *   This fix was a red herring. The root cause was an inconsistency between how the generator created function *definitions* versus how it created function *calls* for nested types.
    *   The function **definition** was created by a template using the unqualified type name (e.g., `convertExternalInfoToDstInfo`).
    *   The function **call** was being generated by `generateConversion`, which was attempting to use a qualified type name, leading to the malformed call.

## Problem Analysis: Library vs. Consumer

The problems stemmed from both the `go-scan` library and the `examples/convert` consumer.

*   **go-scan (Library Issue):**
    *   **Primary Issue:** The library lacked a clear, public API to say, "Here is a type name as a string; please give me a resolvable `FieldType` for it." This forced me to export internal fields, which is not an ideal API design and created downstream work.
    *   **Secondary Issue (Self-Inflicted):** During my attempts to fix the generator, I introduced a bug into `scanner/scanner.go`'s `parseTypeExpr` by incorrectly changing how `FieldType.Name` was constructed. I have since identified and corrected this error.

*   **examples/convert (Consumer Issue):**
    *   **Parser Bug:** The parser initially did not process structs that were discovered on-demand. This was a bug in my implementation of the refactoring.
    *   **Generator Bug:** The generator's logic for creating function names was inconsistent. The template for top-level functions used unqualified names, while the logic for generating calls to nested conversion functions was attempting (and failing) to use qualified names. This is the root cause of the current `generated code mismatch` error.

In summary, while the plan in `docs/plan-multi-package-handling.md` was sound in its high-level strategy, it did not anticipate the API limitations of the core library. Overcoming this limitation by modifying the library's internals, while necessary, introduced complexity that cascaded into the consumer's implementation, leading to the persistent generator bug. The immediate next step must be to fix the inconsistency in the generator's function name construction.
