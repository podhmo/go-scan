// Code generated by convert. DO NOT EDIT.
package generated

import (
	"context"
	"errors"
	"fmt"

	convutil "github.com/podhmo/go-scan/examples/convert/convutil"
	"github.com/podhmo/go-scan/examples/convert/model"
	destination "github.com/podhmo/go-scan/examples/convert/sampledata/destination"
	source "github.com/podhmo/go-scan/examples/convert/sampledata/source"
)

func convertSrcUserToDstUser(ctx context.Context, ec *model.ErrorCollector, src *source.SrcUser) *destination.DstUser {
	if src == nil {
		return nil
	}
	dst := &destination.DstUser{}
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("Details")
	dst.Details = func() []destination.DstInternalDetail {
		convertedSlice := make([]destination.DstInternalDetail, len(src.Details))
		for i, item := range src.Details {
			ec.Enter(fmt.Sprintf("[%d]", i))
			convertedSlice[i] = *convertSrcInternalDetailToDstInternalDetail(ctx, ec, &item)
			ec.Leave()
		}
		return convertedSlice
	}()

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("CreatedAt")
	dst.CreatedAt = convutil.TimeToString(ctx, ec, src.CreatedAt)

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("UpdatedAt")
	dst.UpdatedAt = convutil.PtrTimeToString(ctx, ec, src.UpdatedAt)

	ec.Leave()
	return dst
}

// ConvertSrcUserToDstUser converts source.SrcUser to destination.DstUser.
func ConvertSrcUserToDstUser(ctx context.Context, src *source.SrcUser) (*destination.DstUser, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSrcUserToDstUser(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
func convertSrcOrderToDstOrder(ctx context.Context, ec *model.ErrorCollector, src *source.SrcOrder) *destination.DstOrder {
	if src == nil {
		return nil
	}
	dst := &destination.DstOrder{}
	return dst
}

// ConvertSrcOrderToDstOrder converts source.SrcOrder to destination.DstOrder.
func ConvertSrcOrderToDstOrder(ctx context.Context, src *source.SrcOrder) (*destination.DstOrder, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSrcOrderToDstOrder(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
func convertComplexSourceToComplexTarget(ctx context.Context, ec *model.ErrorCollector, src *source.ComplexSource) *destination.ComplexTarget {
	if src == nil {
		return nil
	}
	dst := &destination.ComplexTarget{}
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("Value")
	dst.Value = src.Value

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("Ptr")
	if src.Ptr != nil {
		tmp := (*src.Ptr)
		dst.Ptr = &tmp
	} else {
		dst.Ptr = nil
	}

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("Slice")
	dst.Slice = func() []destination.SubTarget {
		convertedSlice := make([]destination.SubTarget, len(src.Slice))
		for i, item := range src.Slice {
			ec.Enter(fmt.Sprintf("[%d]", i))
			convertedSlice[i] = *convertSubSourceToSubTarget(ctx, ec, &item)
			ec.Leave()
		}
		return convertedSlice
	}()

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("SliceOfPtrs")
	dst.SliceOfPtrs = func() []*destination.SubTarget {
		convertedSlice := make([]*destination.SubTarget, len(src.SliceOfPtrs))
		for i, item := range src.SliceOfPtrs {
			ec.Enter(fmt.Sprintf("[%d]", i))
			convertedSlice[i] = convertSubSourceToSubTarget(ctx, ec, item)
			ec.Leave()
		}
		return convertedSlice
	}()

	ec.Leave()
	return dst
}

// ConvertComplexSourceToComplexTarget converts source.ComplexSource to destination.ComplexTarget.
func ConvertComplexSourceToComplexTarget(ctx context.Context, src *source.ComplexSource) (*destination.ComplexTarget, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertComplexSourceToComplexTarget(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
func convertSourceWithMapToTargetWithMap(ctx context.Context, ec *model.ErrorCollector, src *source.SourceWithMap) *destination.TargetWithMap {
	if src == nil {
		return nil
	}
	dst := &destination.TargetWithMap{}
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("ValueMap")
	dst.ValueMap = func() map[string]destination.SubTarget {
		convertedMap := make(map[string]destination.SubTarget, len(src.ValueMap))
		for key, value := range src.ValueMap {
			ec.Enter(fmt.Sprintf("[%v]", key))
			convertedMap[key] = *convertSubSourceToSubTarget(ctx, ec, &value)
			ec.Leave()
		}
		return convertedMap
	}()

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("PtrMap")
	dst.PtrMap = func() map[string]*destination.SubTarget {
		convertedMap := make(map[string]*destination.SubTarget, len(src.PtrMap))
		for key, value := range src.PtrMap {
			ec.Enter(fmt.Sprintf("[%v]", key))
			convertedMap[key] = convertSubSourceToSubTarget(ctx, ec, value)
			ec.Leave()
		}
		return convertedMap
	}()

	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("StringToStr")
	dst.StringToStr = func() map[string]string {
		convertedMap := make(map[string]string, len(src.StringToStr))
		for key, value := range src.StringToStr {
			ec.Enter(fmt.Sprintf("[%v]", key))
			convertedMap[key] = value
			ec.Leave()
		}
		return convertedMap
	}()

	ec.Leave()
	return dst
}

// ConvertSourceWithMapToTargetWithMap converts source.SourceWithMap to destination.TargetWithMap.
func ConvertSourceWithMapToTargetWithMap(ctx context.Context, src *source.SourceWithMap) (*destination.TargetWithMap, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSourceWithMapToTargetWithMap(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
func convertSrcInternalDetailToDstInternalDetail(ctx context.Context, ec *model.ErrorCollector, src *source.SrcInternalDetail) *destination.DstInternalDetail {
	if src == nil {
		return nil
	}
	dst := &destination.DstInternalDetail{}
	return dst
}

// ConvertSrcInternalDetailToDstInternalDetail converts source.SrcInternalDetail to destination.DstInternalDetail.
func ConvertSrcInternalDetailToDstInternalDetail(ctx context.Context, src *source.SrcInternalDetail) (*destination.DstInternalDetail, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSrcInternalDetailToDstInternalDetail(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
func convertSubSourceToSubTarget(ctx context.Context, ec *model.ErrorCollector, src *source.SubSource) *destination.SubTarget {
	if src == nil {
		return nil
	}
	dst := &destination.SubTarget{}
	if ec.MaxErrorsReached() {
		return dst
	}
	ec.Enter("Value")
	dst.Value = src.Value

	ec.Leave()
	return dst
}

// ConvertSubSourceToSubTarget converts source.SubSource to destination.SubTarget.
func ConvertSubSourceToSubTarget(ctx context.Context, src *source.SubSource) (*destination.SubTarget, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector(0)
	dst := convertSubSourceToSubTarget(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
