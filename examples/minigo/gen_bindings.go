package main

import (
	"context"
	"flag"
	"fmt"
	"go/ast"
	"log/slog"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	goscan "github.com/podhmo/go-scan"
)

var tmplGenBindings = template.Must(template.New("install.go").Parse(`// Code generated by minigo gen-bindings. DO NOT EDIT.

package {{ .PackageName }}

import (
	{{- if .TypeSymbols }}
	"reflect"
	{{- end }}
	"{{ .PackagePath }}"
	"github.com/podhmo/go-scan/minigo"
)

// Install binds all exported symbols from the "{{ .PackagePath }}" package to the interpreter.
func Install(interp *minigo.Interpreter) {
	interp.Register("{{ .PackagePath }}", map[string]any{
		{{- range .ValueSymbols }}
		"{{ . }}": {{ $.PackageName }}.{{ . }},
		{{- end }}
		{{- range .TypeSymbols }}
		"{{ . }}": reflect.TypeOf((*{{ $.PackageName }}.{{ . }})(nil)).Elem(),
		{{- end }}
	})
}
`))

func runGenBindings(args []string) {
	fs := flag.NewFlagSet("gen-bindings", flag.ExitOnError)
	var (
		outputDir = fs.String("output", "", "output directory")
	)
	fs.Parse(args)

	if *outputDir == "" {
		slog.Error("-output flag is required")
		os.Exit(1)
	}

	pkgPaths := fs.Args()
	if len(pkgPaths) == 0 {
		slog.Error("at least one package path is required")
		os.Exit(1)
	}

	ctx := context.Background()
	logger := slog.Default()
	ctx = context.WithValue(ctx, "logger", logger)

	if err := runGenBindingsInternal(ctx, *outputDir, pkgPaths); err != nil {
		slog.ErrorContext(ctx, "!!", slog.Any("error", err))
		os.Exit(1)
	}
}

func runGenBindingsInternal(ctx context.Context, outputDir string, pkgPaths []string) error {
	s, err := goscan.New(goscan.WithGoModuleResolver())
	if err != nil {
		return fmt.Errorf("failed to create scanner: %w", err)
	}

	for _, pkgPath := range pkgPaths {
		slog.InfoContext(ctx, "processing package", slog.String("package", pkgPath))
		if err := generate(ctx, s, outputDir, pkgPath); err != nil {
			return fmt.Errorf("failed to generate for package %q: %w", pkgPath, err)
		}
	}
	return nil
}

func generate(ctx context.Context, s *goscan.Scanner, outputDir, pkgPath string) error {
	var pkgInfo *goscan.Package
	var err error
	if strings.HasPrefix(pkgPath, "./") || strings.HasPrefix(pkgPath, "/") {
		pkgInfo, err = s.ScanPackage(ctx, pkgPath)
	} else {
		pkgInfo, err = s.ScanPackageByImport(ctx, pkgPath)
	}
	if err != nil {
		return fmt.Errorf("failed to scan package %s: %w", pkgPath, err)
	}

	valueSymbols := make(map[string]struct{})
	typeSymbols := make(map[string]struct{})

	for _, f := range pkgInfo.Functions {
		if len(f.TypeParams) > 0 {
			continue
		}
		if f.Receiver == nil && f.AstDecl != nil && f.AstDecl.Name != nil && f.AstDecl.Name.IsExported() {
			valueSymbols[f.Name] = struct{}{}
		}
	}
	for _, c := range pkgInfo.Constants {
		if c.IsExported {
			valueSymbols[c.Name] = struct{}{}
		}
	}
	for _, v := range pkgInfo.Variables {
		if v.IsExported {
			valueSymbols[v.Name] = struct{}{}
		}
	}
	for _, t := range pkgInfo.Types {
		if t.Name != "" && ast.IsExported(t.Name) {
			typeSymbols[t.Name] = struct{}{}
		}
	}

	valueSymbolSlice := make([]string, 0, len(valueSymbols))
	for s := range valueSymbols {
		valueSymbolSlice = append(valueSymbolSlice, s)
	}
	sort.Strings(valueSymbolSlice)

	typeSymbolSlice := make([]string, 0, len(typeSymbols))
	for s := range typeSymbols {
		typeSymbolSlice = append(typeSymbolSlice, s)
	}
	sort.Strings(typeSymbolSlice)

	pkgName := pkgInfo.Name

	params := struct {
		PackageName  string
		PackagePath  string
		ValueSymbols []string
		TypeSymbols  []string
	}{
		PackageName:  pkgName,
		PackagePath:  pkgInfo.ImportPath,
		ValueSymbols: valueSymbolSlice,
		TypeSymbols:  typeSymbolSlice,
	}

	pkgOutputDir := filepath.Join(outputDir, pkgPath)
	if err := os.MkdirAll(pkgOutputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory %q: %w", pkgOutputDir, err)
	}

	filePath := filepath.Join(pkgOutputDir, "install.go")
	f, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create output file %q: %w", filePath, err)
	}
	defer f.Close()

	if err := tmplGenBindings.Execute(f, params); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}
	slog.InfoContext(ctx, "generated", slog.String("path", filePath))
	return nil
}
