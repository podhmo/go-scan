package scantest

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"

	scan "github.com/podhmo/go-scan"
)

func TestWriteFiles(t *testing.T) {
	files := map[string]string{
		"go.mod": "module example.com/me",
		"main.go": `package main`,
	}

	dir, cleanup := WriteFiles(t, files)
	defer cleanup()

	for name, content := range files {
		path := filepath.Join(dir, name)
		data, err := os.ReadFile(path)
		if err != nil {
			t.Errorf("ReadFile(%q): %v", path, err)
			continue
		}
		if string(data) != content {
			t.Errorf("expected content of %q is %q, but got %q", name, content, string(data))
		}
	}
}

func TestRun_PureCheck(t *testing.T) {
	dir, cleanup := WriteFiles(t, map[string]string{
		"go.mod": "module example.com/me",
		"person.go": `package main; type Person struct { Name string }`,
	})
	defer cleanup()

	action := func(ctx context.Context, s *scan.Scanner, pkgs []*scan.Package) error {
		if len(pkgs) == 0 {
			return fmt.Errorf("no packages found")
		}
		if pkgs[0].Name != "main" {
			return fmt.Errorf("package name is not main, got %s", pkgs[0].Name)
		}
		personType := pkgs[0].Lookup("Person")
		if personType == nil {
			return fmt.Errorf("type Person not found")
		}
		return nil
	}

	result, err := Run(t, dir, []string{"."}, action)
	if err != nil {
		t.Fatal(err)
	}
	if result != nil {
		t.Errorf("expected a nil result for a pure check, but got %+v", result)
	}
}

func TestRun_GenerateFile(t *testing.T) {
	dir, cleanup := WriteFiles(t, map[string]string{
		"go.mod":  "module example.com/me",
		"main.go": "package main",
	})
	defer cleanup()

	generateAction := func(ctx context.Context, s *scan.Scanner, pkgs []*scan.Package) error {
		// This uses the context-aware scan.WriteFile via SaveGoFile
		pd := scan.NewPackageDirectory(dir, "main")
		gf := scan.GoFile{
			CodeSet: "// Code generated by test",
		}
		return pd.SaveGoFile(ctx, gf, "main_gen.go")
	}

	result, err := Run(t, dir, []string{"."}, generateAction)
	if err != nil {
		t.Fatal(err)
	}

	if result == nil {
		t.Fatal("expected a non-nil result for a file generation action")
	}
	if len(result.Outputs) != 1 {
		t.Fatalf("expected 1 generated file, but got %d", len(result.Outputs))
	}

	content, ok := result.Outputs["main_gen.go"]
	if !ok {
		t.Fatal("expected file 'main_gen.go' was not in the result")
	}
	if !strings.Contains(string(content), "Code generated by test") {
		t.Errorf("generated file content is not what was expected")
	}
}
