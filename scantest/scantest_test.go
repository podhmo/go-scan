package scantest

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	scan "github.com/podhmo/go-scan"
)

func TestWriteFiles(t *testing.T) {
	files := map[string]string{
		"go.mod":  "module example.com/me",
		"main.go": `package main`,
	}

	dir, cleanup := WriteFiles(t, files)
	defer cleanup()

	for name, content := range files {
		path := filepath.Join(dir, name)
		data, err := os.ReadFile(path)
		if err != nil {
			t.Errorf("ReadFile(%q): %v", path, err)
			continue
		}
		if string(data) != content {
			t.Errorf("expected content of %q is %q, but got %q", name, content, string(data))
		}
	}
}

func TestRun_PureCheck(t *testing.T) {
	dir, cleanup := WriteFiles(t, map[string]string{
		"go.mod":    "module example.com/me",
		"person.go": `package main; type Person struct { Name string }`,
	})
	defer cleanup()

	action := func(ctx context.Context, s *scan.Scanner, pkgs []*scan.Package) error {
		if len(pkgs) == 0 {
			return fmt.Errorf("no packages found")
		}
		if pkgs[0].Name != "main" {
			return fmt.Errorf("package name is not main, got %s", pkgs[0].Name)
		}
		personType := pkgs[0].Lookup("Person")
		if personType == nil {
			return fmt.Errorf("type Person not found")
		}
		return nil
	}

	result, err := Run(t, nil, dir, []string{"."}, action, WithModuleRoot(dir))
	if err != nil {
		t.Fatal(err)
	}
	if result != nil {
		t.Errorf("expected a nil result for a pure check, but got %+v", result)
	}
}

func TestRun_GenerateFile(t *testing.T) {
	dir, cleanup := WriteFiles(t, map[string]string{
		"go.mod":  "module example.com/me",
		"main.go": "package main",
	})
	defer cleanup()

	generateAction := func(ctx context.Context, s *scan.Scanner, pkgs []*scan.Package) error {
		// This uses the context-aware scan.WriteFile via SaveGoFile
		pd := scan.NewPackageDirectory(dir, "main")
		gf := scan.GoFile{
			CodeSet: "// Code generated by test",
		}
		return pd.SaveGoFile(ctx, gf, "main_gen.go")
	}

	result, err := Run(t, nil, dir, []string{"."}, generateAction, WithModuleRoot(dir))
	if err != nil {
		t.Fatal(err)
	}

	if result == nil {
		t.Fatal("expected a non-nil result for a file generation action")
	}
	if len(result.Outputs) != 1 {
		t.Fatalf("expected 1 generated file, but got %d", len(result.Outputs))
	}

	content, ok := result.Outputs["main_gen.go"]
	if !ok {
		t.Fatal("expected file 'main_gen.go' was not in the result")
	}
	if !strings.Contains(string(content), "Code generated by test") {
		t.Errorf("generated file content is not what was expected")
	}
}

func TestRun_ModifyFile(t *testing.T) {
	dir, cleanup := WriteFiles(t, map[string]string{
		"go.mod":  "module example.com/me",
		"main.go": "package main\n\nfunc main() {}",
	})
	defer cleanup()

	originalContent := "package main\n\nfunc main() {}"
	modifiedContent := "package main\n\nfunc main() {}\n// modified"

	modifyAction := func(ctx context.Context, s *scan.Scanner, pkgs []*scan.Package) error {
		mainGoPath := filepath.Join(dir, "main.go")

		// Simulate modifying a file in-place, like `go fmt` would.
		// We use os.WriteFile directly to ensure the test doesn't rely on the
		// context-based writer for modification detection.
		err := os.WriteFile(mainGoPath, []byte(modifiedContent), 0644)
		if err != nil {
			return fmt.Errorf("failed to write modified file: %w", err)
		}
		return nil
	}

	result, err := Run(t, nil, dir, []string{"."}, modifyAction, WithModuleRoot(dir))
	if err != nil {
		t.Fatal(err)
	}

	if result == nil {
		t.Fatal("expected a non-nil result for a file modification action")
	}
	if len(result.Outputs) != 0 {
		t.Errorf("expected 0 generated files, but got %d", len(result.Outputs))
	}
	if len(result.Modified) != 1 {
		t.Fatalf("expected 1 modified file, but got %d", len(result.Modified))
	}

	content, ok := result.Modified["main.go"]
	if !ok {
		t.Fatal("expected file 'main.go' was not in the modified result")
	}
	if string(content) != modifiedContent {
		t.Errorf("modified file content mismatch:\ngot:  %q\nwant: %q", string(content), modifiedContent)
	}
	if bytes.Equal(content, []byte(originalContent)) {
		t.Error("modified content is the same as the original content")
	}
}

func TestRun_WithImportPathPattern(t *testing.T) {
	dir, cleanup := WriteFiles(t, map[string]string{
		"go.mod": "module example.com/me\n",
		"main.go": `
package main
import "example.com/me/foo"
func main() { foo.Do() }
`,
		"foo/foo.go": "package foo; func Do() {}",
	})
	defer cleanup()

	var pkgsFound []*scan.Package

	action := func(ctx context.Context, s *scan.Scanner, pkgs []*scan.Package) error {
		pkgsFound = pkgs
		return nil
	}

	// This is the key part of the test. We are passing an import path pattern,
	// not a file system pattern like ".". The scantest.Run function needs to
	// be able to resolve this.
	_, err := Run(t, nil, dir, []string{"example.com/me/..."}, action, WithModuleRoot(dir))
	if err != nil {
		t.Fatalf("scantest.Run() failed: %v", err)
	}

	if len(pkgsFound) != 2 {
		t.Fatalf("expected to find 2 packages, but got %d", len(pkgsFound))
	}

	// Add assertions to check if the correct packages were found.
	// This requires importing "github.com/google/go-cmp/cmp" and "sort"
	gotPaths := make([]string, len(pkgsFound))
	for i, p := range pkgsFound {
		gotPaths[i] = p.ImportPath
	}
	sort.Strings(gotPaths)

	wantPaths := []string{"example.com/me", "example.com/me/foo"}
	if diff := cmp.Diff(wantPaths, gotPaths); diff != "" {
		t.Errorf("found packages mismatch (-want +got):\n%s", diff)
	}
}

func TestRun_WithSpecificDirectoryPattern(t *testing.T) {
	dir, cleanup := WriteFiles(t, map[string]string{
		"go.mod":     "module example.com/me\n",
		"main.go":    `package main`,
		"pkg/a/a.go": `package a`,
		"pkg/b/b.go": `package b`,
	})
	defer cleanup()

	var pkgsFound []*scan.Package
	action := func(ctx context.Context, s *scan.Scanner, pkgs []*scan.Package) error {
		pkgsFound = pkgs
		return nil
	}

	_, err := Run(t, nil, dir, []string{"./pkg/a"}, action, WithModuleRoot(dir))
	if err != nil {
		t.Fatalf("scantest.Run() failed: %v", err)
	}

	if len(pkgsFound) != 1 {
		t.Fatalf("expected to find 1 package, but got %d", len(pkgsFound))
	}

	gotPath := pkgsFound[0].ImportPath
	wantPath := "example.com/me/pkg/a"
	if gotPath != wantPath {
		t.Errorf("found package mismatch: want %q, got %q", wantPath, gotPath)
	}
}

func TestRun_ResolvesRelativePathToImportPath(t *testing.T) {
	// This test confirms that scantest.Run can take a relative file path,
	// resolve it to a full Go import path, and scan the correct package.
	// This is the core functionality requested in the TODO.md item.
	dir, cleanup := WriteFiles(t, map[string]string{
		"go.mod": "module example.com/project",
		"api/api.go": `package api
type Request struct {}
`,
		"main.go": `package main`,
	})
	defer cleanup()

	var foundPkg *scan.Package
	action := func(ctx context.Context, s *scan.Scanner, pkgs []*scan.Package) error {
		if len(pkgs) != 1 {
			return fmt.Errorf("expected 1 package, got %d", len(pkgs))
		}
		foundPkg = pkgs[0]
		return nil
	}

	// Use a relative path to a specific package directory.
	_, err := Run(t, nil, dir, []string{"./api"}, action)
	if err != nil {
		t.Fatalf("scantest.Run() with relative path failed: %v", err)
	}

	if foundPkg == nil {
		t.Fatal("action was not run or did not find a package")
	}

	// The key assertion: the relative path "./api" should be resolved
	// to the full import path "example.com/project/api".
	wantImportPath := "example.com/project/api"
	if foundPkg.ImportPath != wantImportPath {
		t.Errorf("expected import path %q, but got %q", wantImportPath, foundPkg.ImportPath)
	}

	// Also check that the correct type was scanned.
	if typ := foundPkg.Lookup("Request"); typ == nil {
		t.Error("did not find 'Request' type in scanned package")
	}
}

func TestRun_WithReplaceDirective(t *testing.T) {
	// Create a temporary directory structure that requires a `replace` directive.
	// root/
	//   - go.mod (module example.com/me)
	//   - project/
	//     - go.mod (module example.com/project, replace example.com/lib => ../lib)
	//     - main.go (imports example.com/lib)
	//   - lib/
	//     - go.mod (module example.com/lib)
	//     - lib.go (defines type Thing)

	tmpDir := t.TempDir()

	// Create lib module
	libDir := filepath.Join(tmpDir, "lib")
	if err := os.Mkdir(libDir, 0755); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(filepath.Join(libDir, "go.mod"), []byte("module example.com/lib"), 0644); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(filepath.Join(libDir, "lib.go"), []byte("package lib; type Thing struct { Name string }"), 0644); err != nil {
		t.Fatal(err)
	}

	// Create project module
	projectDir := filepath.Join(tmpDir, "project")
	if err := os.Mkdir(projectDir, 0755); err != nil {
		t.Fatal(err)
	}
	projectGoMod := `
module example.com/project
go 1.18
replace example.com/lib => ../lib
`
	if err := os.WriteFile(filepath.Join(projectDir, "go.mod"), []byte(projectGoMod), 0644); err != nil {
		t.Fatal(err)
	}
	projectMainGo := `
package main
import "example.com/lib"
type Model struct {
    Thing lib.Thing
}
`
	if err := os.WriteFile(filepath.Join(projectDir, "main.go"), []byte(projectMainGo), 0644); err != nil {
		t.Fatal(err)
	}

	// Action to verify that the type from the replaced module is resolved
	action := func(ctx context.Context, s *scan.Scanner, pkgs []*scan.Package) error {
		if len(pkgs) == 0 {
			return fmt.Errorf("no packages found")
		}
		pkg := pkgs[0]
		modelType := pkg.Lookup("Model")
		if modelType == nil {
			return fmt.Errorf("type Model not found")
		}
		if modelType.Struct == nil || len(modelType.Struct.Fields) == 0 {
			return fmt.Errorf("Model struct is empty")
		}
		thingField := modelType.Struct.Fields[0]
		if thingField.Type.Name != "Thing" {
			return fmt.Errorf("expected field type name to be 'Thing', got %q", thingField.Type.Name)
		}
		if thingField.Type.PkgName != "lib" {
			return fmt.Errorf("expected field type package name to be 'lib', got %q", thingField.Type.PkgName)
		}

		// Try to resolve the field type
		resolvedType, err := s.ResolveType(ctx, thingField.Type)
		if err != nil {
			return fmt.Errorf("failed to resolve lib.Thing: %w", err)
		}
		if resolvedType == nil {
			return fmt.Errorf("resolved lib.Thing is nil")
		}
		if resolvedType.Name != "Thing" {
			return fmt.Errorf("expected resolved type name to be 'Thing', got %q", resolvedType.Name)
		}
		if resolvedType.PkgPath != "example.com/lib" {
			return fmt.Errorf("expected resolved type package path to be 'example.com/lib', got %q", resolvedType.PkgPath)
		}
		return nil
	}

	// Run the test on the project directory
	_, err := Run(t, nil, projectDir, []string{"."}, action)
	if err != nil {
		t.Fatalf("Run failed: %v", err)
	}
}

func TestToImportPath(t *testing.T) {
	// Setup a test directory structure in a temporary directory
	dir, cleanup := WriteFiles(t, map[string]string{
		"go.mod":     "module example.com/project",
		"api/api.go": "package api",
	})
	defer cleanup()

	// Change the current working directory to the temp dir for the test
	// to ensure that relative paths are resolved correctly.
	originalWD, err := os.Getwd()
	if err != nil {
		t.Fatalf("could not get current working directory: %v", err)
	}
	if err := os.Chdir(dir); err != nil {
		t.Fatalf("could not change directory to %s: %v", dir, err)
	}
	defer os.Chdir(originalWD)

	testCases := []struct {
		name     string
		path     string
		expected string
	}{
		{
			name:     "relative dir",
			path:     "./api",
			expected: "example.com/project/api",
		},
		{
			name:     "relative file",
			path:     "./api/api.go",
			expected: "example.com/project/api",
		},
		{
			name:     "root dir",
			path:     ".",
			expected: "example.com/project",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got, err := ToImportPath(tc.path)
			if err != nil {
				t.Fatalf("ToImportPath(%q) failed: %v", tc.path, err)
			}
			if got != tc.expected {
				t.Errorf("expected import path %q, but got %q", tc.expected, got)
			}
		})
	}
}
