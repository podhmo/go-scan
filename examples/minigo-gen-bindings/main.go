package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"text/template"

	goscan "github.com/podhmo/go-scan"
)

var tmpl = template.Must(template.New("install.go").Parse(`// Code generated by minigo-gen-bindings. DO NOT EDIT.

package {{ .PackageName }}

import (
	"{{ .PackagePath }}"
	"github.com/podhmo/go-scan/minigo"
)

// Install binds all exported symbols from the "{{ .PackagePath }}" package to the interpreter.
func Install(interp *minigo.Interpreter) {
	interp.Register("{{ .PackagePath }}", map[string]any{
		{{- range .Symbols }}
		"{{ . }}": {{ $.PackageName }}.{{ . }},
		{{- end }}
	})
}
`))

func main() {
	var (
		outputDir = flag.String("output", "", "output directory")
	)
	flag.Parse()

	if *outputDir == "" {
		log.Fatal("-output flag is required")
	}

	pkgPaths := flag.Args()
	if len(pkgPaths) == 0 {
		log.Fatal("at least one package path is required")
	}

	if err := run(context.Background(), *outputDir, pkgPaths); err != nil {
		log.Fatalf("!! %+v", err)
	}
}

func run(ctx context.Context, outputDir string, pkgPaths []string) error {
	s, err := goscan.New(goscan.WithGoModuleResolver())
	if err != nil {
		return fmt.Errorf("failed to create scanner: %w", err)
	}

	for _, pkgPath := range pkgPaths {
		log.Printf("processing package %q", pkgPath)
		if err := generate(ctx, s, outputDir, pkgPath); err != nil {
			return fmt.Errorf("failed to generate for package %q: %w", pkgPath, err)
		}
	}
	return nil
}

func generate(ctx context.Context, s *goscan.Scanner, outputDir, pkgPath string) error {
	pkgInfo, err := s.ScanPackageByImport(ctx, pkgPath)
	if err != nil {
		return fmt.Errorf("failed to scan package %s: %w", pkgPath, err)
	}

	var symbols []string
	for _, f := range pkgInfo.Functions {
		if f.Receiver == nil && f.AstDecl != nil && f.AstDecl.Name != nil && f.AstDecl.Name.IsExported() {
			symbols = append(symbols, f.Name)
		}
	}
	for _, c := range pkgInfo.Constants {
		if c.IsExported {
			symbols = append(symbols, c.Name)
		}
	}

	pkgName := pkgInfo.Name

	params := struct {
		PackageName string
		PackagePath string
		Symbols     []string
	}{
		PackageName: pkgName,
		PackagePath: pkgPath,
		Symbols:     symbols,
	}

	pkgOutputDir := filepath.Join(outputDir, pkgName)
	if err := os.MkdirAll(pkgOutputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory %q: %w", pkgOutputDir, err)
	}

	filePath := filepath.Join(pkgOutputDir, "install.go")
	f, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create output file %q: %w", filePath, err)
	}
	defer f.Close()

	if err := tmpl.Execute(f, params); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}
	log.Printf("generated %s", filePath)
	return nil
}
