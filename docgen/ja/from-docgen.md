# docgenとsymgoの現状分析と将来の展望

このドキュメントは、`go-scan`リポジトリの`symgo`エンジンと、それを利用する`docgen`ツールの現状を分析し、発見された課題と将来必要とされる機能についてまとめたものです。

分析は`docs/plan-symbolic-execution-like.md`で概説されている設計思想と、現在の`symgo`および`examples/docgen`の実装を比較することによって行われました。

## 1. 設計計画と実装の現状

まず、設計ドキュメントに記載されたマイルストーンと、現在の実装状況を比較します。

| 機能フェーズ | 計画内容 | 実装状況 |
| :--- | :--- | :--- |
| **フェーズ1: 基礎エンジン** | `symgo`のコア（Evaluator, Scope, Object）とintrinsicの仕組み | ✅ **実装済み** |
| **フェーズ2: 基本的なルート抽出** | `docgen`の骨格、`http.HandleFunc`からパスとメソッドを抽出 | ✅ **実装済み** |
| **フェーズ3: 詳細なハンドラ分析** | `json.Decode`/`Encode`等のパターンを分析し、リクエスト/レスポンスの型を特定 | 🟡 **部分的に実装済み** |
| **フェーズ4: 応用的な機能強化**| ヘルパー関数の追跡、`fmt.Sprintf`等のサポート | 🟡 **部分的に実装済み** |
| **フェーズ5: OpenAPI生成** | 収集した情報からOpenAPIドキュメントを生成 | ✅ **実装済み** |

全体として、`symgo`は設計思想のコア部分を実装しており、`docgen`はそれを利用して基本的なOpenAPI仕様を生成できる段階にあります。

しかし、「部分的実装」とした項目には、実用性を高める上で重要なギャップが残されています。

## 2. 発見されたギャップと不足機能

詳細な分析を通じて、以下の課題が明らかになりました。

### 2.1. 未実装および不完全な機能

計画にありながら実装されていない、あるいは実装が不完全な機能です。

*   **`fmt.Sprintf`の未サポート**:
    設計書では文字列結合の重要なパターンとして挙げられていましたが、`symgo`のintrinsicとして実装されていません。これにより、パスやレスポンスの一部が動的に生成される一般的なケースに対応できません。
*   **不完全な制御フロー分析**:
    - `if`文の評価において`else`ブロックが無視されます。これにより、エラーケースなど`else`側で定義されたレスポンスのパターンが検出されません。
    - `for`文の評価はループボディを1回実行するのみで、実質的にループ内のパターンを1度だけスキャンするだけに留まっています。

### 2.2. デバッグの難しさ（実行の不透明性）

ユーザーから指摘があった通り、現在の`symgo`および`docgen`は「なぜその結果になったのか」を追跡することが非常に困難です。

*   **限定的な実行トレース**:
    `symgo`の内部には関数呼び出しを追跡する`callStack`ログが存在しますが、これは`symgo`開発者向けのものであり、`docgen`の利用者が簡単に使えるものではありません。また、追跡できるのは関数呼び出しのみで、変数への代入や条件分岐の評価といった詳細なステップは追跡できません。
*   **エラーメッセージの位置情報欠如**:
    「識別子 `x` が見つかりません」といったエラーが発生しても、ソースコードのどのファイル・どの行でその問題が発生したのかが示されません。これにより、問題の特定と修正が著しく困難になっています。

### 2.3. モジュール境界の判定ロジック

計画書では「モジュール内（Intra-Module）」と「モジュール外（Extra-Module）」の関数呼び出しを区別する戦略が明確に示されています。この判定は`symgo`の挙動の根幹をなすため、その詳細を解説します。

*   **判定の仕組み**:
    1.  **`go-scan`によるパッケージ情報の取得**: `symgo`は、解析対象のコードの`go.mod`を`go-scan`を通じて読み込み、メインモジュールのパス（例: `github.com/podhmo/go-scan`）を把握しています。
    2.  **セレクタ式 (`pkg.Func`) の評価**: `symgo`の評価器が`pkg.Func`のような式を評価する際、まず`pkg`がどのインポートパスに対応するかを解決します。
    3.  **モジュールパスの比較**: 解決されたインポートパス（例: `net/http`や`github.com/another/library`）と、メインモジュールのパスを比較します。
        -   インポートパスがメインモジュールのパスを前方一致で含んでいれば、**モジュール内 (Intra-Module)** の呼び出しと判断されます。
        -   そうでなければ、**モジュール外 (Extra-Module)** の呼び出しと判断されます。標準ライブラリ（`net/http`など）もモジュール外として扱われます。
*   **挙動の違い**:
    - **モジュール内**: 評価器は関数の実体（AST）を再帰的に評価し、処理を深く追跡します。
    - **モジュール外**: 評価器はその関数を「中身が不明なブラックボックス」として扱い、intrinsic（事前登録されたカスタムハンドラ）がなければ、`SymbolicPlaceholder`という特殊なオブジェクトを返却して評価を打ち切ります。
*   **現状の評価**:
    このロジックは計画に沿って実装されており、`symgo`が無限に外部ライブラリのコードを追いかけるのを防ぐ重要な役割を果たしています。しかし、その判定は`go-scan`が提供するパッケージ情報に完全に依存しており、`evalSelectorExpr`関数内のロジックは非常に複雑です。この複雑さが、将来のメンテナンスにおいて課題となる可能性があります。

### 2.4. docgenの使いにくさと拡張性の低さ

`docgen`は強力なツールですが、特定のコーディングスタイルに強く依存しており、カスタマイズが困難です。

*   **ハードコードされた分析パターン**:
    リクエスト/レスポンスの型を特定するための分析パターン（例: `json.NewDecoder(...).Decode(...)`）は、`examples/docgen/patterns/` 以下にGoのコードとしてハードコードされています。ユーザーが独自のヘルパー関数（例: `myapp.DecodeJSON(r, &req)`）を使っている場合、分析は何も検知できずに静かに失敗します。
*   **高い拡張コスト**:
    新しい分析パターンを追加するには、`symgo`の`Object`モデルを理解した上で、`docgen`のGoコードを直接修正・再コンパイルする必要があります。これは、ツールを利用したいだけのユーザーにとっては非常に高いハードルです。

## 3. 提案：今後必要とされる機能

上記の課題を解決し、`symgo`と`docgen`をより実用的なツールにするために、以下の機能追加を提案します。

### 3.1. 抜本的なデバッグ機能の強化

*   **構造化された実行ログ (Structured Execution Log)**:
    `symgo`の評価器（Evaluator）が、その実行ステップを単なるログではなく、構造化されたデータとして生成・返却する機能を設けます。
    - **ログの内容**: `[ファイル名:行:列] ASTノードの種類 -> 評価結果オブジェクト` のような形式で、すべての評価ステップを記録します。
    - **活用方法**: `docgen`に`--debug-analysis <関数名>`のようなデバッグフラグを追加し、この構造化ログを出力させることで、ユーザーは「なぜこの型が選ばれたのか」「なぜこの処理が無視されたのか」を正確に追跡できるようになります。
*   **エラー報告の改善**:
    すべてのエラーオブジェクトに、エラー発生箇所のコード位置情報（`token.Pos`）を保持させ、最終的にユーザーに提示されるエラーメッセージにファイル名・行・列を含めるようにします。

### 3.2. ユーザーによる拡張性の確保

*   **minigoスクリプトによる外部パターン設定**:
    `docgen`が分析に用いるカスタムパターンを、Goコードではなく外部の`minigo`スクリプト（例: `docgen-patterns.minigo`）から読み込めるようにします。

    ```minigo
    # docgen-patterns.minigo
    # docgenが解析に使うカスタム関数パターンのリストを返す
    [
        {
            "key": "github.com/my-org/my-app/utils.DecodeJSON", // 追跡したい関数のフルパス
            "type": "requestBody",                             // パターンの種類
            "argIndex": 1                                      // 解析対象の引数インデックス
        },
        {
            "key": "github.com/my-org/my-app/utils.RenderJSON",
            "type": "responseBody",
            "argIndex": 2
        }
    ]
    ```
    **実装の精緻化**:
    `minigo`の実装 (`minigo/minigo.go`) には、スクリプトの実行結果をGoの構造体に直接マッピングする強力な機能 (`Result.As()`) が存在します。`docgen`はこれを利用して、以下のように設定を読み込みます。

    1.  `docgen`は `minigo.NewInterpreter()` で `minigo` の実行エンジンを初期化します。
    2.  `os.ReadFile()` で `docgen-patterns.minigo` の内容を読み込みます。
    3.  `interpreter.EvalString()` でスクリプトを実行し、返り値の `object.Object` を `minigo.Result` でラップします。
    4.  `result.As(&patterns)` を呼び出すことで、スクリプトが返した配列とマップの構造を、Goの `[]Pattern` のようなスライスに直接変換します。

    このアプローチにより、`docgen`はGoのコードを再コンパイルすることなく、ユーザーが定義したカスタムルールを動的に読み込んで分析ロジックを拡張できます。

### 3.3. `symgo`エンジンの機能補完

*   **不足しているintrinsicの実装**:
    `fmt.Sprintf`のような、一般的に使われる標準ライブラリ関数をintrinsicとして追加し、より多くのコードパターンに対応できるようにします。
*   **制御フロー分析の強化**:
    `if`文の`else`ブロックを評価するよう修正し、分析のカバレッジを向上させます。

これらの機能が実装されることで、`symgo`はより堅牢なシンボリック実行エンジンとなり、`docgen`は多様な実プロジェクトで活用できる、デバッグしやすく拡張性の高いドキュメント生成ツールへと進化することができるでしょう。

## 4. 提案機能の実装タスクリスト

提案した機能を実装するための、具体的なタスクリストを以下に示します。上から順に実装していくことで、段階的に`symgo`と`docgen`を改善していくことができます。

### ステップ1: エラー報告とエンジンの安定化
1.  **`object.Error`の拡張**: `symgo/object/object.go`の`Error`構造体に、エラー発生箇所の位置情報（`token.Pos`）を保持するフィールドを追加します。
2.  **エラーメッセージの改善**: `symgo/symgo.go`の`Interpreter`が`object.Error`をGoの`error`に変換する際に、`token.Pos`からファイル名・行・列の情報を付与して、より詳細なエラーメッセージを生成するように修正します。
3.  **`fmt.Sprintf`のintrinsic実装**: `symgo`に`fmt.Sprintf`の基本的な挙動を模倣するintrinsicを追加し、動的な文字列生成に対応します。
4.  **`if-else`のサポート**: `symgo/evaluator/evaluator.go`の`evalIfStmt`を修正し、`else`ブロックも評価対象に含めるようにします。

### ステップ2: デバッグ機能の導入
5.  **構造化ロガーの実装**: `symgo`の`Evaluator`に、評価ステップを記録する構造化ロガーを導入します。このロガーはON/OFF可能で、実行されたASTノードと位置情報、評価結果を記録します。
6.  **`docgen`へのデバッグフラグ追加**: `examples/docgen/main.go`に`--debug-analysis <関数名>`のようなコマンドラインフラグを追加します。このフラグが指定された場合、`symgo`の構造化ロガーを有効化し、結果を標準出力に書き出すようにします。

### ステップ3: ユーザーによる拡張性の確保
7.  **`minigo`によるパターンローダー実装**: `examples/docgen/`に、`.minigo`ファイルを読み込み、パターンのリスト（例: `[]map[string]any`）を解析するローダーを実装します。これは`minigo`の`EvalString`と`Result.As`を利用して実現します。
8.  **`Analyzer`とパターンローダーの統合**: `docgen`の`Analyzer`が、起動時に指定された`.minigo`設定ファイルを読み込み、その内容を`intrinsics`として動的に登録できるように修正します。
