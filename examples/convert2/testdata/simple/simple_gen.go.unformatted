// Code generated by convert2 tool. DO NOT EDIT.
package simple

import (
	"errors"
	"strings"
	"time"
	"context"
	"fmt"
)


// errorCollector collects errors with path tracking.
type errorCollector struct {
	maxErrors int
	errors    []error
	pathStack []string
}
func newErrorCollector(maxErrors int) *errorCollector {
	return &errorCollector{
		maxErrors: maxErrors,
		errors:    make([]error, 0),
		pathStack: make([]string, 0),
	}
}
func (ec *errorCollector) Add(reason string) bool {
	if ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors {
		return true
	}
	fullPath := strings.Join(ec.pathStack, "")
	err := fmt.Errorf("%s: %s", fullPath, reason)
	ec.errors = append(ec.errors, err)
	return ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors
}
func (ec *errorCollector) Addf(format string, args ...interface{}) bool {
	if ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors {
		return true
	}
	return ec.Add(fmt.Sprintf(format, args...))
}
func (ec *errorCollector) Enter(segment string) {
	separator := "."
	if len(ec.pathStack) == 0 {
		separator = ""
	} else {
		// Check if previous segment is an indexer, if so, no dot.
		// This logic needs to be robust: A.B[0].C
		// Current pathStack is like ["A", ".B", "[0]"]
		// If adding "C", it should be ".C".
		// If pathStack is empty, or ends with non-alphanumeric (like "[0]"), no leading dot for next field.
		// This is simpler: always dot for fields unless it's the first element.
		// Indices are handled by not having a dot.
	}
	if strings.HasPrefix(segment, "[") && strings.HasSuffix(segment, "]") { // Array/slice index
		ec.pathStack = append(ec.pathStack, segment)
	} else { // Field name
		if len(ec.pathStack) == 0 {
			ec.pathStack = append(ec.pathStack, segment)
		} else {
			ec.pathStack = append(ec.pathStack, "."+segment)
		}
	}
}
func (ec *errorCollector) Leave() {
	if len(ec.pathStack) > 0 {
		ec.pathStack = ec.pathStack[:len(ec.pathStack)-1]
	}
}
func (ec *errorCollector) Errors() []error {
	return ec.errors
}
func (ec *errorCollector) HasErrors() bool {
	return len(ec.errors) > 0
}
func (ec *errorCollector) MaxErrorsReached() bool {
	return ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors
}


func srcSimpleToDstSimple(ec *errorCollector, src SrcSimple) DstSimple {
	dst := DstSimple{}
	if ec.MaxErrorsReached() { return dst }

	// Mapping field SrcSimple.ID to DstSimple.ID
	ec.Enter("ID")
	// Mapping field SrcSimple.Name to DstSimple.Name
	ec.Enter("Name")
	// Source field SrcSimple.Description is skipped due to tag '-'.
	// Mapping field SrcSimple.Value to DstSimple.Value
	ec.Enter("Value")
	// Mapping field SrcSimple.Timestamp to DstSimple.CreationTime
	ec.Enter("CreationTime")
	// Mapping field SrcSimple.PtrString to DstSimple.PtrString
	ec.Enter("PtrString")
	// Mapping field SrcSimple.StringPtr to DstSimple.StringPtr
	ec.Enter("StringPtr")
	// Mapping field SrcSimple.PtrToValue to DstSimple.PtrToValue
	ec.Enter("PtrToValue")
	// Mapping field SrcSimple.RequiredPtrToValue to DstSimple.RequiredPtrToValue
	ec.Enter("RequiredPtrToValue")
	// Mapping field SrcSimple.CustomIntToString to DstSimple.CustomStr
	ec.Enter("CustomStr")
func srcWithAliasToDstWithAlias(ec *errorCollector, src SrcWithAlias) DstWithAlias {
	dst := DstWithAlias{}
	if ec.MaxErrorsReached() { return dst }

	// Mapping field SrcWithAlias.EventTime to DstWithAlias.EventTimestamp
	ec.Enter("EventTimestamp")
func ConvertSrcSimple(ctx context.Context, src SrcSimple) (DstSimple, error) {
	ec := newErrorCollector(0)
	dst := srcSimpleToDstSimple(ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

func ConvertSrcWithAlias(ctx context.Context, src SrcWithAlias) (DstWithAlias, error) {
	ec := newErrorCollector(0)
	dst := srcWithAliasToDstWithAlias(ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
