# Plan for scantest library

## 1. Overview

The `scantest` library will provide utilities for testing `go-scan` analyzers. It will be inspired by the `golang.org/x/tools/go/analysis/analysistest` package, but with a simplified feature set as requested.

The core idea is to provide helpers to run `go-scan` on a test codebase, which can be located in a `testdata` directory or created in a temporary directory.

## 2. Core API

The `scantest` library provides helpers to test tasks that use `go-scan`, such as static checks or code generation.

```go
package scantest

import (
	"testing"
	"github.com/podhmo/go-scan"
)

// ActionFunc is a function that performs a check or an action (e.g., code generation)
// based on the results of a go-scan. It should return an error to fail the test.
type ActionFunc func(s *goscan.Scanner, pkgs []*goscan.Package) error

// Run sets up a test environment, runs go-scan, and executes a user-provided action.
// t is the testing object.
// dir is the root directory for the scanner (where go.mod is).
// patterns are the import path patterns to scan.
// action is the function to execute after scanning.
// It returns an error if the scan or the action fails.
func Run(t *testing.T, dir string, patterns []string, action ActionFunc) error

// WriteFiles creates a temporary directory and populates it with the given files.
// It returns the path to the temporary directory and a cleanup function.
func WriteFiles(t *testing.T, files map[string]string) (string, func())
```

## 3. `Run` Function

The `Run` function orchestrates the testing of a `go-scan` based task. Its responsibilities are to:

1.  **Setup**: Initialize a `goscan.Scanner` for the given `dir`.
2.  **Scan**: Scan all packages that match the provided `patterns`.
3.  **Execute Action**: Invoke the user-provided `action` function with the scanner instance and the list of scanned packages. The action function contains the core test logic (e.g., checking for specific type properties or generating code).
4.  **Propagate Errors**: Return any error that occurs during scanning or is returned by the `action` function.

The verification of any side effects (like generated files) is the responsibility of the test author, not the `Run` function. This keeps the helper focused and flexible.

## 4. `WriteFiles` Function

The `WriteFiles` function is a helper for creating self-contained test cases. It will:

*   Create a new temporary directory using `t.TempDir()`.
*   Create a `src` subdirectory to mimic a GOPATH structure.
*   Write the files specified in the `files` map to the `src` directory.
*   Return the path to the `src` directory and a no-op cleanup function (as `t.TempDir` handles cleanup).

This allows test authors to easily create isolated test environments without needing a `testdata` directory.

## 5. Example Usage

### Example 1: Pure Check (No Side Effects)

This example shows how to use `scantest` to verify properties of scanned types without creating any files.

```go
package main_test

import (
	"fmt"
	"testing"

	"github.com/podhmo/go-scan"
	"github.com/podhmo/go-scan/scantest"
)

func TestStructFields(t *testing.T) {
	dir, cleanup := scantest.WriteFiles(t, map[string]string{
		"go.mod": "module example.com/me",
		"person.go": `
package main
type Person struct {
	Name string
	Age  int
}`,
	})
	defer cleanup()

	action := func(s *goscan.Scanner, pkgs []*goscan.Package) error {
		if len(pkgs) != 1 {
			return fmt.Errorf("expected 1 package, got %d", len(pkgs))
		}
		personType := pkgs[0].Lookup.Type("Person")
		if personType == nil {
			return fmt.Errorf("type Person not found")
		}
		if len(personType.Struct.Fields) != 2 {
			return fmt.Errorf("expected Person to have 2 fields, but got %d", len(personType.Struct.Fields))
		}
		return nil
	}

	if err := scantest.Run(t, dir, []string{"example.com/me"}, action); err != nil {
		t.Fatal(err)
	}
}
```

### Example 2: Code Generation (With Side Effects)

This example demonstrates testing a code generation task. The `action` function creates a new file, and the test code verifies its content afterward.

```go
package main_test

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/podhmo/go-scan"
	"github.com/podhmo/go-scan/scantest"
)

func generateFileAction(s *goscan.Scanner, pkgs []*goscan.Package) error {
	// In a real scenario, you would generate code based on the scanned packages.
	// Here, we just write a static file for simplicity.
	content := []byte("package main\n\n// Code generated by test\n")
	outputPath := filepath.Join(s.RootDir, "main_gen.go")
	return os.WriteFile(outputPath, content, 0644)
}

func TestGenerateCode(t *testing.T) {
	dir, cleanup := scantest.WriteFiles(t, map[string]string{
		"go.mod":  "module example.com/me",
		"main.go": "package main",
	})
	defer cleanup()

	// Run the action which generates a file.
	if err := scantest.Run(t, dir, []string{"example.com/me"}, generateFileAction); err != nil {
		t.Fatal(err)
	}

	// Verify the side effect (the generated file).
	generatedPath := filepath.Join(dir, "main_gen.go")
	content, err := os.ReadFile(generatedPath)
	if err != nil {
		t.Fatalf("failed to read generated file: %v", err)
	}

	if !strings.Contains(string(content), "Code generated by test") {
		t.Errorf("generated file content is not what was expected")
	}
}
```
