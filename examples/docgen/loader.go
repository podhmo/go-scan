package main

import (
	"fmt"
	"go/ast"
	"log/slog"
	"os"
	"path"
	"path/filepath"
	"strings"

	goscan "github.com/podhmo/go-scan"
	"github.com/podhmo/go-scan/examples/docgen/patterns"
	"github.com/podhmo/go-scan/minigo"
	"github.com/podhmo/go-scan/minigo/object"
)

// LoadPatternsFromConfig loads custom analysis patterns from a Go configuration file.
// It is a wrapper around LoadPatternsFromSource.
func LoadPatternsFromConfig(filePath string, logger *slog.Logger, scanner *goscan.Scanner) ([]patterns.Pattern, error) {
	configSource, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("could not read patterns config file %q: %w", filePath, err)
	}
	return LoadPatternsFromSource(configSource, logger, scanner)
}

// LoadPatternsFromSource loads custom analysis patterns from a Go configuration source.
func LoadPatternsFromSource(source []byte, logger *slog.Logger, scanner *goscan.Scanner) ([]patterns.Pattern, error) {
	// Step 1: Set up the minigo interpreter.
	// The fix in `go-scan`'s locator allows the interpreter to correctly
	// resolve imports via `replace` directives.
	interp, err := minigo.NewInterpreter(scanner)
	if err != nil {
		return nil, fmt.Errorf("failed to create minigo interpreter: %w", err)
	}

	// Step 2: Evaluate the script.
	if _, err := interp.EvalString(string(source)); err != nil {
		return nil, fmt.Errorf("failed to evaluate patterns config source: %w", err)
	}

	// Step 3: Extract the 'Patterns' variable from the global environment.
	patternsObj, ok := interp.GlobalEnvForTest().Get("Patterns")
	if !ok {
		return nil, fmt.Errorf("could not find 'Patterns' variable in config source")
	}

	// Step 4: Unmarshal the minigo object directly into a slice of PatternConfig structs.
	// This is now possible because the script returns a typed slice instead of []map[string]any.
	var configs []patterns.PatternConfig
	result := minigo.Result{Value: patternsObj}
	if err := result.As(&configs); err != nil {
		return nil, fmt.Errorf("failed to unmarshal 'Patterns' variable into []patterns.PatternConfig: %w", err)
	}

	// Step 5: Convert the data-only configs into executable patterns.
	return convertConfigsToPatterns(configs, logger, scanner)
}

// convertConfigsToPatterns translates the user-defined pattern configurations
// into the internal Pattern format with executable Apply functions.
func convertConfigsToPatterns(configs []patterns.PatternConfig, logger *slog.Logger, scanner *goscan.Scanner) ([]patterns.Pattern, error) {
	result := make([]patterns.Pattern, len(configs))
	for i, config := range configs {
		c := config // capture loop variable

		var key string
		// If Fn is provided, derive the key from the function object.
		if fn, ok := c.Fn.(*object.GoSourceFunction); ok && fn != nil {
			pkgPath := fn.PkgPath
			// The PkgPath from a GoSourceFunction evaluated by minigo tends to be
			// the absolute file path. We need to convert it to a Go import path
			// to match the keys generated by the symgo engine.
			if fn.ModuleDir != "" && fn.ModulePath != "" {
				if strings.HasPrefix(pkgPath, fn.ModuleDir) {
					// It's a path inside the current module, so construct the import path.
					relPath, err := filepath.Rel(fn.ModuleDir, pkgPath)
					if err == nil {
						pkgPath = path.Join(fn.ModulePath, relPath)
					}
				}
			}
			key = fmt.Sprintf("%s.%s", pkgPath, fn.Fn.Name)
		} else if mv, ok := c.Fn.(*object.GoMethodValue); ok && mv != nil {
			// Handle method references like (*MyType)(nil).MyMethod
			key = buildKeyForMethod(mv.Fn, mv.RecvDef)
		} else if bm, ok := c.Fn.(*object.BoundMethod); ok && bm != nil {
			// Handle method references on an instance, e.g., var v MyType; v.MyMethod
			var def *object.StructDefinition
			switch recv := bm.Receiver.(type) {
			case *object.StructInstance:
				def = recv.Def
			case *object.Pointer:
				if inst, ok := (*recv.Element).(*object.StructInstance); ok {
					def = inst.Def
				}
			}

			if def == nil {
				return nil, fmt.Errorf("could not determine struct definition from bound method receiver: %T", bm.Receiver)
			}
			key = buildKeyForMethod(bm.Fn, def)
		} else {
			key = c.Key
		}

		if key == "" {
			return nil, fmt.Errorf("pattern %q requires either a 'Key' string or a 'Fn' reference", c.Name)
		}

		// Validate the pattern type string and required fields.
		switch c.Type {
		case patterns.RequestBody, patterns.ResponseBody, patterns.DefaultResponse:
			// valid
		case patterns.CustomResponse:
			if c.StatusCode == "" {
				return nil, fmt.Errorf("pattern %q: 'StatusCode' is required for type %q", c.Name, c.Type)
			}
		case patterns.PathParameter, patterns.QueryParameter, patterns.HeaderParameter:
			// We can't easily validate that NameArgIndex and ArgIndex are set
			// because 0 is a valid value. The runtime will handle incorrect indices.
		default:
			return nil, fmt.Errorf("pattern %q: unknown 'Type' value %q", c.Name, c.Type)
		}

		result[i].Key = key

		switch c.Type {
		case patterns.RequestBody:
			result[i].Apply = patterns.HandleCustomRequestBody(c.ArgIndex)
		case patterns.ResponseBody:
			result[i].Apply = patterns.HandleCustomResponseBody(c.ArgIndex)
		case patterns.CustomResponse:
			result[i].Apply = patterns.HandleCustomResponse(c.StatusCode, c.ArgIndex)
		case patterns.DefaultResponse:
			result[i].Apply = patterns.HandleDefaultResponse(c.ArgIndex)
		case patterns.PathParameter, patterns.QueryParameter, patterns.HeaderParameter:
			result[i].Apply = patterns.HandleCustomParameter(string(c.Type), c.Description, c.NameArgIndex, c.ArgIndex)
		default:
			// This case should be unreachable due to the validation above
			logger.Warn("unreachable: unknown pattern type", "type", c.Type, "key", key)
			return nil, fmt.Errorf("unknown pattern type %q for key %q", c.Type, key)
		}
		logger.Debug("loaded custom pattern", "key", key, "type", c.Type, "argIndex", c.ArgIndex)
	}
	return result, nil
}

// buildKeyForMethod constructs the fully qualified key for a method.
func buildKeyForMethod(fn *object.Function, def *object.StructDefinition) string {
	pkgPath := def.PkgPath
	if def.ModuleDir != "" && def.ModulePath != "" {
		if strings.HasPrefix(pkgPath, def.ModuleDir) {
			relPath, err := filepath.Rel(def.ModuleDir, pkgPath)
			if err == nil {
				pkgPath = path.Join(def.ModulePath, relPath)
			}
		}
	}

	// Determine if the receiver is a pointer or a value from the method's AST.
	recvString := getReceiverString(fn, def)
	return fmt.Sprintf("%s.%s.%s", pkgPath, recvString, fn.Name.Name)
}

// getReceiverString formats the receiver part of the key, e.g., "(*MyType)" or "MyType".
func getReceiverString(fn *object.Function, def *object.StructDefinition) string {
	if fn.Recv != nil && len(fn.Recv.List) > 0 {
		recvField := fn.Recv.List[0]
		if _, isStar := recvField.Type.(*ast.StarExpr); isStar {
			return fmt.Sprintf("(*%s)", def.Name.Name)
		}
		return def.Name.Name
	}
	// Fallback, should not happen for valid methods.
	return def.Name.Name
}
