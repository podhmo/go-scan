package main

import (
	"context"
	"go/format"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	goscan "github.com/podhmo/go-scan"
	"github.com/podhmo/go-scan/scanner"
	"github.com/podhmo/go-scan/scantest"
)

func TestGenerate(t *testing.T) {
	type want struct {
		Code string
	}
	cases := []struct {
		name  string
		files map[string]string
		want  want
	}{
		{
			name: "simple",
			files: map[string]string{
				"go.mod": `
module example.com/convert
go 1.22.4
`,
				"models/source/source.go": `
package source
import "time"
// @derivingconvert("example.com/convert/models/destination.DstUser")
type SrcUser struct { ID int64; FirstName string; LastName string; SrcAddress; ContactInfo SrcContact; Details []SrcInternalDetail; CreatedAt time.Time; UpdatedAt *time.Time }
type SrcAddress struct { Street string; City string }
type SrcContact struct { Email string; Phone *string }
type SrcInternalDetail struct { Code int; Description string }
// @derivingconvert("example.com/convert/models/destination.DstOrder")
type SrcOrder struct { OrderID string; Amount float64; Items []SrcItem }
type SrcItem struct { SKU string; Quantity int }
`,
				"models/destination/destination.go": `
package destination
type DstUser struct { UserID string; FullName string; Address DstAddress; Contact DstContact; Details []DstInternalDetail; CreatedAt string; UpdatedAt string }
type DstAddress struct { FullStreet string; CityName string }
type DstContact struct { EmailAddress string; PhoneNumber string }
type DstInternalDetail struct { ItemCode int; LocalizedDesc string }
type DstOrder struct { ID string; TotalAmount float64; LineItems []DstItem }
type DstItem struct { ProductCode string; Count int }
`,
			},
			want: want{
				Code: `// Code generated by go-scan for package converter. DO NOT EDIT.

package converter

import (
	"context"
	destination "example.com/convert/models/destination"
	source "example.com/convert/models/source"
)

// ConvertSrcUserToDstUser converts SrcUser to DstUser.
func ConvertSrcUserToDstUser(ctx context.Context, src source.SrcUser) (destination.DstUser, error) {
	// In the future, this will use an error collector.
	// For now, we just call the internal function.
	dst := convertSrcUserToDstUser(ctx, src)
	return dst, nil
}

// convertSrcUserToDstUser is the internal conversion function.
func convertSrcUserToDstUser(ctx context.Context, src source.SrcUser) destination.DstUser {
	dst := destination.DstUser{}
	// Field mapping is not implemented in this version.
	return dst
}

// ConvertSrcOrderToDstOrder converts SrcOrder to DstOrder.
func ConvertSrcOrderToDstOrder(ctx context.Context, src source.SrcOrder) (destination.DstOrder, error) {
	// In the future, this will use an error collector.
	// For now, we just call the internal function.
	dst := convertSrcOrderToDstOrder(ctx, src)
	return dst, nil
}

// convertSrcOrderToDstOrder is the internal conversion function.
func convertSrcOrderToDstOrder(ctx context.Context, src source.SrcOrder) destination.DstOrder {
	dst := destination.DstOrder{}
	// Field mapping is not implemented in this version.
	return dst
}
`,
			},
		},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			tmpdir, cleanup := scantest.WriteFiles(t, tc.files)
			defer cleanup()

			action := func(ctx context.Context, s *goscan.Scanner, pkgs []*scanner.PackageInfo) error {
				for _, pkg := range pkgs {
					if err := Generate(ctx, s, pkg); err != nil {
						return err
					}
				}
				return nil
			}

			result, err := scantest.Run(t, tmpdir, []string{"./models/source"}, action)
			if err != nil {
				t.Fatalf("scantest.Run failed: %+v", err)
			}

			if result == nil {
				t.Fatal("scantest.Run result is nil")
			}
			if len(result.Outputs) != 1 {
				t.Fatalf("unexpected number of outputs, got %d, want 1", len(result.Outputs))
			}

			var got string
			filename := "generated_converters.go"
			gotBytes, ok := result.Outputs[filename]
			if !ok {
				availableKeys := make([]string, 0, len(result.Outputs))
				for k := range result.Outputs {
					availableKeys = append(availableKeys, k)
				}
				t.Fatalf("expected output file %q not found; available files: %v", filename, availableKeys)
			}
			got = string(gotBytes)

			// Format both got and want code for a consistent comparison
			formattedGot, err := format.Source([]byte(got))
			if err != nil {
				t.Logf("failed to format generated code: %+v\n--- raw output ---\n%s", err, got)
				formattedGot = []byte(got)
			}

			formattedWant, err := format.Source([]byte(tc.want.Code))
			if err != nil {
				t.Fatalf("failed to format want code: %+v\n--- raw output ---\n%s", err, tc.want.Code)
			}

			if diff := cmp.Diff(strings.TrimSpace(string(formattedWant)), strings.TrimSpace(string(formattedGot))); diff != "" {
				t.Errorf("generated code mismatch (-want +got):\n%s", diff)
			}
		})
	}
}
