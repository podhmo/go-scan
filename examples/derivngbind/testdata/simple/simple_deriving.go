// Code generated by derivngbind for package simple. DO NOT EDIT.

package simple

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
)

func (s *ComprehensiveBind) Bind(req *http.Request, pathVar func(string) string) error {
	var err error
	_ = err // prevent unused var error if no error handling is needed below

	// Path parameter binding using the provided pathVar function
	if pathValueStr := pathVar("id"); pathValueStr != "" {

		s.PathString = pathValueStr

	} else {
		// Handle missing path parameter "id" if necessary (e.g. return error or set default)
		// For now, if it's empty, we do nothing, field remains zero-value.
	}

	if val := req.URL.Query().Get("name"); val != "" {

		s.QueryName = val

	}

	if val := req.URL.Query().Get("age"); val != "" {

		s.QueryAge, err = strconv.Atoi(val)
		if err != nil {
			return fmt.Errorf("failed to bind query parameter \"age\" to field QueryAge: %w", err)
		}

	}

	if val := req.URL.Query().Get("active"); val != "" {

		s.QueryActive, err = strconv.ParseBool(val)
		if err != nil {
			return fmt.Errorf("failed to bind query parameter \"active\" to field QueryActive: %w", err)
		}

	}

	if val := req.Header.Get("X-Auth-Token"); val != "" {

		s.HeaderToken = val

	}

	if cookie, cerr := req.Cookie("session_id"); cerr == nil && cookie.Value != "" {

		s.CookieSession = cookie.Value

	}

	if req.Body != nil && req.Body != http.NoBody {
		isSpecificFieldBodyTarget := false

		if isSpecificFieldBodyTarget {

		} else {
			// The struct ComprehensiveBind itself is the target for the request body
			if err := json.NewDecoder(req.Body).Decode(s); err != nil {
				if err != io.EOF { // EOF might be acceptable
					return fmt.Errorf("failed to decode request body into ComprehensiveBind: %w", err)
				}
			}
		}

	}

	return nil
}

func (s *SpecificBodyFieldBind) Bind(req *http.Request, pathVar func(string) string) error {
	var err error
	_ = err // prevent unused var error if no error handling is needed below

	if val := req.Header.Get("X-Request-ID"); val != "" {

		s.RequestID = val

	}

	if val := req.URL.Query().Get("other"); val != "" {

		s.OtherQueryParam = val

	}

	if req.Body != nil && req.Body != http.NoBody {
		isSpecificFieldBodyTarget := false

		isSpecificFieldBodyTarget = true

		if isSpecificFieldBodyTarget {

			// Field Payload is the target for the entire request body
			if err := json.NewDecoder(req.Body).Decode(&s.Payload); err != nil {
				if err != io.EOF { // EOF might be acceptable if body is optional
					return fmt.Errorf("failed to decode request body into field Payload: %w", err)
				}
			}
			goto afterBodyProcessing // Process only one 'in:"body"' field

		} else {
			// The struct SpecificBodyFieldBind itself is the target for the request body
			if err := json.NewDecoder(req.Body).Decode(s); err != nil {
				if err != io.EOF { // EOF might be acceptable
					return fmt.Errorf("failed to decode request body into SpecificBodyFieldBind: %w", err)
				}
			}
		}

	afterBodyProcessing: // Label for goto only if there was a specific body field target that could jump here

	}

	return nil
}

func (s *FullBodyBind) Bind(req *http.Request, pathVar func(string) string) error {
	var err error
	_ = err // prevent unused var error if no error handling is needed below

	if val := req.Header.Get("X-Source"); val != "" {

		s.SourceHeader = val

	}

	if req.Body != nil && req.Body != http.NoBody {
		isSpecificFieldBodyTarget := false

		if isSpecificFieldBodyTarget {

		} else {
			// The struct FullBodyBind itself is the target for the request body
			if err := json.NewDecoder(req.Body).Decode(s); err != nil {
				if err != io.EOF { // EOF might be acceptable
					return fmt.Errorf("failed to decode request body into FullBodyBind: %w", err)
				}
			}
		}

	}

	return nil
}

func (s *QueryAndPathOnlyBind) Bind(req *http.Request, pathVar func(string) string) error {
	var err error
	_ = err // prevent unused var error if no error handling is needed below

	// Path parameter binding using the provided pathVar function
	if pathValueStr := pathVar("userID"); pathValueStr != "" {

		s.UserID = pathValueStr

	} else {
		// Handle missing path parameter "userID" if necessary (e.g. return error or set default)
		// For now, if it's empty, we do nothing, field remains zero-value.
	}

	if val := req.URL.Query().Get("itemCode"); val != "" {

		s.ItemCode = val

	}

	if val := req.URL.Query().Get("limit"); val != "" {

		s.Limit, err = strconv.Atoi(val)
		if err != nil {
			return fmt.Errorf("failed to bind query parameter \"limit\" to field Limit: %w", err)
		}

	}

	return nil
}
