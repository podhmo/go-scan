package main

import (
	"context"
	"go/format"
	"log/slog"
	"os"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	goscan "github.com/podhmo/go-scan"
	"github.com/podhmo/go-scan/scanner"
	"github.com/podhmo/go-scan/scantest"
)

func TestGenerate(t *testing.T) {
	logLevel := new(slog.LevelVar)
	logLevel.Set(slog.LevelDebug)
	opts := slog.HandlerOptions{Level: logLevel}
	handler := slog.NewTextHandler(os.Stderr, &opts)
	slog.SetDefault(slog.New(handler))

	type want struct {
		Code string
	}
	cases := []struct {
		name  string
		files map[string]string
		want  want
	}{
		{
			name: "simple",
			files: map[string]string{
				"go.mod": `
module github.com/podhmo/go-scan/examples/derivingjson/testdata/simple
go 1.22.4
`,
				"models.go": `
package models

// @deriving:unmarshal
type Event struct {
	ID string
	// this is oneof
	Data EventData ` + "`json:\"data\"`" + `
}

type EventData interface {
	EventData()
}

type UserCreated struct {
	UserID   string
	Username string
}

func (e *UserCreated) EventData() {}

type MessagePosted struct {
	UserID  string
	Message string
}

func (e *MessagePosted) EventData() {}
`,
			},
			want: want{
				Code: `// Code generated by go-scan for package models. DO NOT EDIT.

package models

import (
	json "encoding/json"
	fmt "fmt"
)

func (s *Event) UnmarshalJSON(data []byte) error {
	// Define an alias type to prevent infinite recursion with UnmarshalJSON.
	type Alias Event
	aux := &struct {
		Data json.RawMessage ` + "`json:\"data\"`" + `

		// All other fields will be handled by the standard unmarshaler via the Alias.
		*Alias
	}{
		Alias: (*Alias)(s),
	}

	if err := json.Unmarshal(data, &aux); err != nil {
		return fmt.Errorf("failed to unmarshal into aux struct for Event: %w", err)
	}

	// Process Data
	if aux.Data != nil && string(aux.Data) != "null" {
		var discriminatorDoc struct {
			Type string ` + "`json:\"type\"`" + ` // Discriminator field
		}
		if err := json.Unmarshal(aux.Data, &discriminatorDoc); err != nil {
			return fmt.Errorf("could not detect type from field 'data' (content: %s): %w", string(aux.Data), err)
		}

		switch discriminatorDoc.Type {

		case "usercreated":
			var content *UserCreated
			if err := json.Unmarshal(aux.Data, &content); err != nil {
				return fmt.Errorf("failed to unmarshal 'data' as *UserCreated for type 'usercreated' (content: %s): %w", string(aux.Data), err)
			}
			s.Data = content

		case "messageposted":
			var content *MessagePosted
			if err := json.Unmarshal(aux.Data, &content); err != nil {
				return fmt.Errorf("failed to unmarshal 'data' as *MessagePosted for type 'messageposted' (content: %s): %w", string(aux.Data), err)
			}
			s.Data = content

		default:
			if discriminatorDoc.Type == "" {
				return fmt.Errorf("discriminator field 'type' missing or empty in 'data' (content: %s)", string(aux.Data))
			}
			return fmt.Errorf("unknown data type '%s' for field 'data' (content: %s)", discriminatorDoc.Type, string(aux.Data))
		}
	} else {
		s.Data = nil // Explicitly set to nil if null or empty
	}

	return nil
}
`,
			},
		},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			tmpdir, cleanup := scantest.WriteFiles(t, tc.files)
			defer cleanup()

			action := func(ctx context.Context, s *goscan.Scanner, pkgs []*scanner.PackageInfo) error {
				for _, pkg := range pkgs {
					if err := Generate(ctx, s, pkg); err != nil {
						return err
					}
				}
				return nil
			}

			result, err := scantest.Run(t, tmpdir, []string{"."}, action)
			if err != nil {
				t.Fatalf("scantest.Run failed: %+v", err)
			}

			if result == nil {
				t.Fatal("scantest.Run result is nil")
			}
			if len(result.Outputs) != 1 {
				t.Fatalf("unexpected number of outputs, got %d, want 1", len(result.Outputs))
			}

			var got string
			for _, b := range result.Outputs {
				got = string(b)
				break
			}
			formatted, err := format.Source([]byte(got))
			if err != nil {
				t.Fatalf("failed to format generated code: %+v\n-- original --\n%s", err, got)
			}
			if diff := cmp.Diff(strings.TrimSpace(tc.want.Code), strings.TrimSpace(string(formatted))); diff != "" {
				t.Errorf("generated code mismatch (-want +got):\n%s", diff)
			}
		})
	}
}
