// Code generated by convert2 tool. DO NOT EDIT.
package simple

import (
	"context"
	"errors"
	"fmt"
	"strings"
)

// errorCollector collects errors with path tracking.
type errorCollector struct {
	maxErrors int
	errors    []error
	pathStack []string
}

func newErrorCollector(maxErrors int) *errorCollector {
	return &errorCollector{
		maxErrors: maxErrors,
		errors:    make([]error, 0),
		pathStack: make([]string, 0),
	}
}
func (ec *errorCollector) Add(reason string) bool {
	if ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors {
		return true
	}
	fullPath := strings.Join(ec.pathStack, "")
	err := fmt.Errorf("%s: %s", fullPath, reason)
	ec.errors = append(ec.errors, err)
	return ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors
}
func (ec *errorCollector) Addf(format string, args ...interface{}) bool {
	if ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors {
		return true
	}
	return ec.Add(fmt.Sprintf(format, args...))
}
func (ec *errorCollector) Enter(segment string) {
	// separator variable was unused, logic is directly handled below.
	if strings.HasPrefix(segment, "[") && strings.HasSuffix(segment, "]") { // Array/slice index
		ec.pathStack = append(ec.pathStack, segment)
	} else { // Field name
		if len(ec.pathStack) == 0 {
			ec.pathStack = append(ec.pathStack, segment)
		} else {
			ec.pathStack = append(ec.pathStack, "."+segment)
		}
	}
}
func (ec *errorCollector) Leave() {
	if len(ec.pathStack) > 0 {
		ec.pathStack = ec.pathStack[:len(ec.pathStack)-1]
	}
}
func (ec *errorCollector) Errors() []error {
	return ec.errors
}
func (ec *errorCollector) HasErrors() bool {
	return len(ec.errors) > 0
}
func (ec *errorCollector) MaxErrorsReached() bool {
	return ec.maxErrors > 0 && len(ec.errors) >= ec.maxErrors
}

func srcWithAliasToDstWithAlias(ec *errorCollector, src SrcWithAlias) DstWithAlias {
	dst := DstWithAlias{}
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Number of source fields: 1 for struct SrcWithAlias
	// DEBUG: Processing source field: EventTime
	// DEBUG: dstFieldName = EventTimestamp, dstField is nil = false
	// Mapping field SrcWithAlias.EventTime (example.com/convert2/testdata/simple.MyTime) to DstWithAlias.EventTimestamp (time.Time)
	// Src: Ptr=false, ElemFull=example.com/convert2/testdata/simple.MyTime | Dst: Ptr=false, ElemFull=time.Time
	ec.Enter("EventTimestamp")
	// DEBUG_SRC_FIELD: Name=MyTime, FullName=example.com/convert2/testdata/simple.MyTime, IsBasic=false, Kind=2
	// DEBUG_DST_FIELD: Name=Time, FullName=time.Time, IsBasic=false, Kind=2
	// DEBUG_SRC_ACTUAL_UNDERLYING: Name=MyTime, FullName=example.com/convert2/testdata/simple.MyTime, IsBasic=false, Kind=2
	// DEBUG_DST_ACTUAL_UNDERLYING: Name=Time, FullName=time.Time, IsBasic=false, Kind=2
	// DEBUG_BEFORE_underlyingTypesMatch_check: srcUnderlying is nil = false, dstUnderlying is nil = false
	// DEBUG_COND_PreCheck: srcUnderlying.IsBasic=false, dstUnderlying.IsBasic=false, srcUnderlying.Name=MyTime, dstUnderlying.Name=Time, srcUnderlying.FullName=example.com/convert2/testdata/simple.MyTime, dstUnderlying.FullName=time.Time
	// DEBUG_MATCH_COND: No match for underlying types.
	// DEBUG_FINAL_underlyingTypesMatch: false
	// TODO: Implement conversion for EventTime (example.com/convert2/testdata/simple.MyTime) to EventTimestamp (time.Time).
	ec.Addf("type mismatch or complex conversion not yet implemented for field 'EventTimestamp' (example.com/convert2/testdata/simple.MyTime -> time.Time)")
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

func innerSrcToInnerDst(ec *errorCollector, src InnerSrc) InnerDst {
	dst := InnerDst{}
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Number of source fields: 2 for struct InnerSrc
	// DEBUG: Processing source field: InnerID
	// DEBUG: dstFieldName = InnerID, dstField is nil = false
	// Mapping field InnerSrc.InnerID (int) to InnerDst.InnerID (int)
	// Src: Ptr=false, ElemFull=int | Dst: Ptr=false, ElemFull=int
	ec.Enter("InnerID")
	dst.InnerID = src.InnerID
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Processing source field: InnerName
	// DEBUG: dstFieldName = InnerName, dstField is nil = false
	// Mapping field InnerSrc.InnerName (string) to InnerDst.InnerName (string)
	// Src: Ptr=false, ElemFull=string | Dst: Ptr=false, ElemFull=string
	ec.Enter("InnerName")
	dst.InnerName = src.InnerName
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

func outerSrcToOuterDst(ec *errorCollector, src OuterSrc) OuterDst {
	dst := OuterDst{}
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Number of source fields: 4 for struct OuterSrc
	// DEBUG: Processing source field: OuterID
	// DEBUG: dstFieldName = OuterID, dstField is nil = false
	// Mapping field OuterSrc.OuterID (int) to OuterDst.OuterID (int)
	// Src: Ptr=false, ElemFull=int | Dst: Ptr=false, ElemFull=int
	ec.Enter("OuterID")
	dst.OuterID = src.OuterID
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Processing source field: Nested
	// DEBUG: dstFieldName = Nested, dstField is nil = false
	// Mapping field OuterSrc.Nested (example.com/convert2/testdata/simple.InnerSrc) to OuterDst.Nested (example.com/convert2/testdata/simple.InnerDst)
	// Src: Ptr=false, ElemFull=example.com/convert2/testdata/simple.InnerSrc | Dst: Ptr=false, ElemFull=example.com/convert2/testdata/simple.InnerDst
	ec.Enter("Nested")
	// Recursive call for nested struct InnerSrc -> InnerDst
	dst.Nested = innerSrcToInnerDst(ec, src.Nested)
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Processing source field: NestedPtr
	// DEBUG: dstFieldName = NestedPtr, dstField is nil = false
	// Mapping field OuterSrc.NestedPtr (*example.com/convert2/testdata/simple.InnerSrc) to OuterDst.NestedPtr (*example.com/convert2/testdata/simple.InnerDst)
	// Src: Ptr=true, ElemFull=example.com/convert2/testdata/simple.InnerSrc | Dst: Ptr=true, ElemFull=example.com/convert2/testdata/simple.InnerDst
	ec.Enter("NestedPtr")
	// Recursive call for nested struct InnerSrc -> InnerDst
	if src.NestedPtr != nil {
		nestedVal := innerSrcToInnerDst(ec, *src.NestedPtr)
		dst.NestedPtr = &nestedVal
	} else {
		dst.NestedPtr = nil // Source pointer is nil, so destination pointer is nil
	}
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Processing source field: Name
	// DEBUG: dstFieldName = OuterName, dstField is nil = false
	// Mapping field OuterSrc.Name (string) to OuterDst.OuterName (string)
	// Src: Ptr=false, ElemFull=string | Dst: Ptr=false, ElemFull=string
	ec.Enter("OuterName")
	dst.OuterName = src.Name
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

func innerSrcDiffToInnerDstDiff(ec *errorCollector, src InnerSrcDiff) InnerDstDiff {
	dst := InnerDstDiff{}
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Number of source fields: 1 for struct InnerSrcDiff
	// DEBUG: Processing source field: SrcInnerVal
	// DEBUG: dstFieldName = DstInnerVal, dstField is nil = false
	// Mapping field InnerSrcDiff.SrcInnerVal (int) to InnerDstDiff.DstInnerVal (int)
	// Src: Ptr=false, ElemFull=int | Dst: Ptr=false, ElemFull=int
	ec.Enter("DstInnerVal")
	dst.DstInnerVal = src.SrcInnerVal
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

func outerSrcDiffToOuterDstDiff(ec *errorCollector, src OuterSrcDiff) OuterDstDiff {
	dst := OuterDstDiff{}
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Number of source fields: 2 for struct OuterSrcDiff
	// DEBUG: Processing source field: ID
	// DEBUG: dstFieldName = ID, dstField is nil = false
	// Mapping field OuterSrcDiff.ID (int) to OuterDstDiff.ID (int)
	// Src: Ptr=false, ElemFull=int | Dst: Ptr=false, ElemFull=int
	ec.Enter("ID")
	dst.ID = src.ID
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Processing source field: DiffNested
	// DEBUG: dstFieldName = DestNested, dstField is nil = false
	// Mapping field OuterSrcDiff.DiffNested (example.com/convert2/testdata/simple.InnerSrcDiff) to OuterDstDiff.DestNested (example.com/convert2/testdata/simple.InnerDstDiff)
	// Src: Ptr=false, ElemFull=example.com/convert2/testdata/simple.InnerSrcDiff | Dst: Ptr=false, ElemFull=example.com/convert2/testdata/simple.InnerDstDiff
	ec.Enter("DestNested")
	// Recursive call for nested struct InnerSrcDiff -> InnerDstDiff
	dst.DestNested = innerSrcDiffToInnerDstDiff(ec, src.DiffNested)
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

// srcUnderlyingToDstUnderlying converts SrcUnderlying to DstUnderlying.
// Fields in DstUnderlying not populated by this conversion:
// - YourAge
// - YourName
func srcUnderlyingToDstUnderlying(ec *errorCollector, src SrcUnderlying) DstUnderlying {
	dst := DstUnderlying{}
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Number of source fields: 4 for struct SrcUnderlying
	// DEBUG: Processing source field: ID
	// DEBUG: dstFieldName = ID, dstField is nil = false
	// Mapping field SrcUnderlying.ID (int) to DstUnderlying.ID (int)
	// Src: Ptr=false, ElemFull=int | Dst: Ptr=false, ElemFull=int
	ec.Enter("ID")
	dst.ID = src.ID
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Processing source field: MyAge
	// DEBUG: dstFieldName = MyAge, dstField is nil = true
	// Info: No destination field named 'MyAge' found in 'DstUnderlying' to match source field SrcUnderlying.MyAge. Field skipped.
	// DEBUG: Processing source field: MyName
	// DEBUG: dstFieldName = MyName, dstField is nil = true
	// Info: No destination field named 'MyName' found in 'DstUnderlying' to match source field SrcUnderlying.MyName. Field skipped.
	// DEBUG: Processing source field: MaybeValue
	// DEBUG: dstFieldName = MaybeValue, dstField is nil = false
	// Mapping field SrcUnderlying.MaybeValue (example.com/convert2/testdata/simple.MyFloatPtr) to DstUnderlying.MaybeValue (*float64)
	// Src: Ptr=false, ElemFull=example.com/convert2/testdata/simple.MyFloatPtr | Dst: Ptr=true, ElemFull=float64
	ec.Enter("MaybeValue")
	// DEBUG_SRC_FIELD: Name=MyFloatPtr, FullName=example.com/convert2/testdata/simple.MyFloatPtr, IsBasic=false, Kind=2
	// DEBUG_DST_FIELD: Name=float64, FullName=*float64, IsBasic=true, Kind=3
	// DEBUG_SRC_ACTUAL_UNDERLYING: Name=MyFloatPtr, FullName=example.com/convert2/testdata/simple.MyFloatPtr, IsBasic=false, Kind=2
	// DEBUG_DST_ACTUAL_UNDERLYING: Name=float64, FullName=float64, IsBasic=true, Kind=1
	// DEBUG_BEFORE_underlyingTypesMatch_check: srcUnderlying is nil = false, dstUnderlying is nil = false
	// DEBUG_COND_PreCheck: srcUnderlying.IsBasic=false, dstUnderlying.IsBasic=true, srcUnderlying.Name=MyFloatPtr, dstUnderlying.Name=float64, srcUnderlying.FullName=example.com/convert2/testdata/simple.MyFloatPtr, dstUnderlying.FullName=float64
	// DEBUG_MATCH_COND: No match for underlying types.
	// DEBUG_FINAL_underlyingTypesMatch: false
	// TODO: Implement conversion for MaybeValue (example.com/convert2/testdata/simple.MyFloatPtr) to MaybeValue (*float64).
	ec.Addf("type mismatch or complex conversion not yet implemented for field 'MaybeValue' (example.com/convert2/testdata/simple.MyFloatPtr -> *float64)")
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

// srcSimpleToDstSimple converts SrcSimple to DstSimple.
// Fields in DstSimple not populated by this conversion:
// - NoMatchSrc
func srcSimpleToDstSimple(ec *errorCollector, src SrcSimple) DstSimple {
	dst := DstSimple{}
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Number of source fields: 11 for struct SrcSimple
	// DEBUG: Processing source field: ID
	// DEBUG: dstFieldName = ID, dstField is nil = false
	// Mapping field SrcSimple.ID (int) to DstSimple.ID (int)
	// Src: Ptr=false, ElemFull=int | Dst: Ptr=false, ElemFull=int
	ec.Enter("ID")
	dst.ID = src.ID
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Processing source field: Name
	// DEBUG: dstFieldName = Name, dstField is nil = false
	// Mapping field SrcSimple.Name (string) to DstSimple.Name (string)
	// Src: Ptr=false, ElemFull=string | Dst: Ptr=false, ElemFull=string
	ec.Enter("Name")
	dst.Name = src.Name
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Processing source field: Description
	// Source field SrcSimple.Description is skipped due to tag '-'.
	// DEBUG: Processing source field: Value
	// DEBUG: dstFieldName = Value, dstField is nil = false
	// Mapping field SrcSimple.Value (float64) to DstSimple.Value (float64)
	// Src: Ptr=false, ElemFull=float64 | Dst: Ptr=false, ElemFull=float64
	ec.Enter("Value")
	dst.Value = src.Value
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Processing source field: Timestamp
	// DEBUG: dstFieldName = CreationTime, dstField is nil = false
	// Mapping field SrcSimple.Timestamp (time.Time) to DstSimple.CreationTime (time.Time)
	// Src: Ptr=false, ElemFull=time.Time | Dst: Ptr=false, ElemFull=time.Time
	ec.Enter("CreationTime")
	dst.CreationTime = src.Timestamp
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Processing source field: NoMatchDst
	// DEBUG: dstFieldName = NoMatchDst, dstField is nil = true
	// Info: No destination field named 'NoMatchDst' found in 'DstSimple' to match source field SrcSimple.NoMatchDst. Field skipped.
	// DEBUG: Processing source field: PtrString
	// DEBUG: dstFieldName = PtrString, dstField is nil = false
	// Mapping field SrcSimple.PtrString (*string) to DstSimple.PtrString (*string)
	// Src: Ptr=true, ElemFull=string | Dst: Ptr=true, ElemFull=string
	ec.Enter("PtrString")
	dst.PtrString = src.PtrString
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Processing source field: StringPtr
	// DEBUG: dstFieldName = StringPtr, dstField is nil = false
	// Mapping field SrcSimple.StringPtr (string) to DstSimple.StringPtr (*string)
	// Src: Ptr=false, ElemFull=string | Dst: Ptr=true, ElemFull=string
	ec.Enter("StringPtr")
	{
		srcVal := src.StringPtr
		dst.StringPtr = &srcVal
	}
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Processing source field: PtrToValue
	// DEBUG: dstFieldName = PtrToValue, dstField is nil = false
	// Mapping field SrcSimple.PtrToValue (*float32) to DstSimple.PtrToValue (float32)
	// Src: Ptr=true, ElemFull=float32 | Dst: Ptr=false, ElemFull=float32
	ec.Enter("PtrToValue")
	if src.PtrToValue != nil {
		dst.PtrToValue = *src.PtrToValue
	}
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Processing source field: RequiredPtrToValue
	// DEBUG: dstFieldName = RequiredPtrToValue, dstField is nil = false
	// Mapping field SrcSimple.RequiredPtrToValue (*int) to DstSimple.RequiredPtrToValue (int)
	// Src: Ptr=true, ElemFull=int | Dst: Ptr=false, ElemFull=int
	ec.Enter("RequiredPtrToValue")
	if src.RequiredPtrToValue == nil {
		ec.Addf("field 'RequiredPtrToValue' is required but source field RequiredPtrToValue is nil")
	} else {
		dst.RequiredPtrToValue = *src.RequiredPtrToValue
	}
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	// DEBUG: Processing source field: CustomIntToString
	// DEBUG: dstFieldName = CustomStr, dstField is nil = false
	// Mapping field SrcSimple.CustomIntToString (int) to DstSimple.CustomStr (string)
	// Src: Ptr=false, ElemFull=int | Dst: Ptr=false, ElemFull=string
	ec.Enter("CustomStr")
	// Applying field tag: using IntToStr
	dst.CustomStr = IntToStr(ec, src.CustomIntToString)
	ec.Leave()
	if ec.MaxErrorsReached() {
		return dst
	}

	return dst
}

func ConvertSrcSimpleToDstSimple(ctx context.Context, src SrcSimple) (DstSimple, error) {
	ec := newErrorCollector(0)
	dst := srcSimpleToDstSimple(ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

func ConvertSrcWithAliasToDstWithAlias(ctx context.Context, src SrcWithAlias) (DstWithAlias, error) {
	ec := newErrorCollector(0)
	dst := srcWithAliasToDstWithAlias(ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

func ConvertInnerSrcToInnerDst(ctx context.Context, src InnerSrc) (InnerDst, error) {
	ec := newErrorCollector(0)
	dst := innerSrcToInnerDst(ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

func ConvertOuterSrcToOuterDst(ctx context.Context, src OuterSrc) (OuterDst, error) {
	ec := newErrorCollector(0)
	dst := outerSrcToOuterDst(ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

func ConvertInnerSrcDiffToInnerDstDiff(ctx context.Context, src InnerSrcDiff) (InnerDstDiff, error) {
	ec := newErrorCollector(0)
	dst := innerSrcDiffToInnerDstDiff(ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

func ConvertOuterSrcDiffToOuterDstDiff(ctx context.Context, src OuterSrcDiff) (OuterDstDiff, error) {
	ec := newErrorCollector(0)
	dst := outerSrcDiffToOuterDstDiff(ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}

func ConvertSrcUnderlyingToDstUnderlying(ctx context.Context, src SrcUnderlying) (DstUnderlying, error) {
	ec := newErrorCollector(0)
	dst := srcUnderlyingToDstUnderlying(ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
