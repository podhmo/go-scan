# `derivngbind` の実装から学ぶ `go-scan` の活用と改善点

`examples/derivngbind` は、`go-scan` を利用して、HTTPリクエストの様々な要素（パスパラメータ、クエリパラメータ、ヘッダー、クッキー、リクエストボディ(JSON)）からGoの構造体のフィールドに値をバインドする `Bind(req *http.Request) error` メソッドを自動生成するツールです。

このツールの実装は、`go-scan` がコードジェネレータ開発、特にHTTPリクエスト処理に関連する定型コードの自動生成において、どのように役立つかを示す良い例となります。同時に、`derivingjson` の経験も踏まえつつ、`go-scan` がさらに進化するためのポイントも見えてきます。

## `derivngbind` における `go-scan` の活用ポイント

1.  **アノテーションによる対象構造体の特定**:
    *   `derivngbind` は、構造体のDocコメントに含まれる `@derivng:binding` というアノテーションを検知することで、`Bind` メソッドを生成すべき対象の構造体を特定します。これは `go-scan` の `TypeInfo.Doc` を調べることで実現されます。

2.  **フィールドタグ (`in струк`) の解析**:
    *   各フィールドに付与された `in` タグ（例: `in:"query:user_id"`, `in:"header:X-API-Key"`, `in:"body"`）を解析し、どのリクエスト要素から、どの名前で値を取得し、どのフィールドにバインドするかを決定します。`go-scan` の `FieldInfo.Tag` を `reflect.StructTag` を使ってパースすることで情報を抽出しています。

3.  **フィールドの型情報の取得**:
    *   `FieldInfo.Type.Name` （例: `string`, `int`, `bool`）や、ポインタ型の場合は `FieldInfo.Type.IsPointer` フラグと `FieldInfo.Type.Name`（要素型名）を利用して、取得した値を適切な型に変換するコード（例: `strconv.Atoi`, `strconv.ParseBool`）や、ポインタの生成・`nil` 設定を行うコードを生成します。

4.  **`required` タグのハンドリング**:
    *   フィールドタグ `required:"true"` を `FieldInfo.Tag` から `reflect.StructTag` を使って解析し、このタグが付与されたフィールドがリクエストに存在しない場合（または必須フィールドに対して空の値が提供され、型変換に失敗する場合など）にエラーを返すロジックを生成します。

5.  **インポート管理**:
    *   生成コードが必要とするパッケージ（`net/http`, `strconv`, `fmt`, `encoding/json`, `io` など）を、処理中に検出し、最終的な出力ファイルに `import` 文を生成します。

## `derivngbind` の開発経験から `derivingjson` の学びを再確認・強調

`derivngbind` の実装は、`derivingjson` ([`docs/ja/from-derivngjson.md`](from-derivngjson.md) 参照) で得られた `go-scan` への改善提案の多くが、ここでも同様に有効であることを示しています。特に以下の点は、`derivngbind` のようなツールにとっても非常に有益です。

*   **アノテーション/コメントベースの型フィルタリング (提案1)**:
    `@derivng:binding` を持つ構造体を `go-scan` レベルでフィルタリングできれば、ジェネレータ側のコードはよりシンプルになります。

*   **フィールドタグの高度な解析とクエリ (提案2)**:
    `in:"query:user_id"` のようなタグから `"query"` (種別) と `"user_id"` (名前) を簡単に抽出できるAPI (`FieldInfo.TagValue("in", "key")` や `FieldInfo.TagSubValue("in")`) があれば、タグ解析ロジックが大幅に簡略化されます。現状は `strings.SplitN` などで自前処理しています。
    構造体Docコメントの `in:"body"` のようなアノテーションも同様に、タグ解析の仕組みでサポートされると便利です。

*   **型名の正規化/変換支援 (提案4)**:
    今回は直接的なニーズは少なかったものの、例えばOpenAPIスキーマ名との連携などを考えると、Goのフィールド名を `camelCase` や `snake_case` のパラメータ名に変換するユーティリティは役立ちます。

*   **フィールド型解決の強化と詳細情報 (提案5)**:
    *   **型が属するパッケージの完全なインポートパスの直接取得**: `derivngbind` では主に基本型を扱いましたが、リクエストボディの型が外部パッケージで定義されている場合などに、この機能は不可欠です。
    *   **ポインタ型、スライス、マップ等の複合型の判別と要素型へのアクセス**: プリミティブ型のポインタ (`*string`, `*int`, `*bool`) については、`go-scan` が提供する `FieldInfo.Type.IsPointer` フラグと `FieldInfo.Type.Name`（要素型名を返す）を利用することで、基本的なバインディング対応（値の設定や`nil`代入）が実装されました。これにより、以前は `FieldInfo.Type.Elem` が `nil` となり解析が困難だった問題が解決されました。より複雑なネストしたポインタや、`Elem` を再帰的に辿る必要があるケースなど、さらなるサポートの強化は依然として有益です。将来的には `[]string` のようなスライス型をサポートする際にも、これらの型情報への容易なアクセスが期待されます。
    *   `FieldType.String()` や `QualifiedName()`: 型名を正確にコード生成に反映させるために重要です。

*   **生成コードのインポート管理の支援 (提案6)**:
    `derivngbind` でも必要なインポートを手動で管理しています。`go-scan` が使用された型に基づいて必要なインポートセットを提供してくれれば、ジェネレータの負担は大きく減ります。

## `derivngbind` 特有の課題と `go-scan` への期待

`derivngbind` はHTTPリクエストを扱うため、特有の課題も存在します。

1.  **Path パラメータの扱い**:
    *   Path パラメータの抽出は、使用するルーティングライブラリ（例: `chi`, `gorilla/mux`, `gin`）に依存します。ジェネレータが特定のライブラリに強く結合するのを避けるには工夫が必要です。
    *   **`go-scan` への期待**: 直接的な解決策を `go-scan` に求めるのは難しいかもしれませんが、例えば「特定のインターフェースを実装した型をコンテキストから取得するコード片」のような、より高度なコードスニペット生成の支援や、ASTノードレベルでの操作を容易にするユーティリティがあれば、ジェネレータ側でアダプタコードを生成する際の助けになるかもしれません。
    *   現在の `derivngbind` では、`Bind` メソッドが `pathVar func(string) string` という関数を受け取ることで、特定のルーティングライブラリへの依存を排しつつ Path パラメータの取得に対応しています。この `pathVar` 関数経由で取得された値は、他のリクエストソース（Query, Headerなど）と同様に、`string`, `int`, `bool` 及びそれらのポインタ型へのバインディング、そして `required` タグの評価が行われます。

2.  **リクエストボディの多様な扱い**:
    *   リクエストボディ全体を構造体にマッピングする場合 (`@derivng:binding in:"body"` のように構造体自体に指定) と、構造体の一フィールドにリクエストボディをマッピングする場合 (`Payload MyStruct \`in:"body"\``) があります。
    *   **`go-scan` への期待**: 構造体レベルのアノテーション（Docコメント内）とフィールドレベルのタグの情報を統合的に扱いやすくするAPIがあると良いでしょう。例えば、`TypeInfo` が自身のDocコメントから解析されたアノテーション情報（`TagValue("in")`のような形で）を保持し、フィールド処理時にそれを参照できると、ジェネレータはよりスマートな判断ができます。

## `derivingjson` と `derivngbind` の比較から見るツールの価値

*   **`derivingjson`**: JSONのシリアライズ/デシリアライズ、特に `oneOf` のようなポリモーフィックな型構造の扱いに特化しています。データ構造の内部的な整合性や変換ロジックの自動生成が主眼です。
*   **`derivngbind`**: HTTPリクエストという外部入力からデータ構造へのマッピングに特化しています。バリデーションや型変換、多様な入力ソース（Path, Query, Header, Cookie, Body）の取り扱いが焦点です。

どちらのツールも、手作業で行うと冗長で間違いやすい定型コードの生成を自動化し、開発者がより本質的なビジネスロジックに集中できるようにするという共通の価値を提供します。

`go-scan` は、これらのような多様なコード生成タスクの「型情報の静的解析」という共通基盤を提供することで、それぞれのジェネレータが自身のドメイン特有のロジック構築に注力できるように支援します。今回 `derivngbind` を実装してみて、`go-scan` が提供する型情報がなければ、これらのタグベースのコード生成は遥かに困難であったことを改めて実感しました。

`go-scan` が本稿や `from-derivngjson.md` で提案されたような改善を取り入れていくことで、Goにおけるコード生成文化がさらに発展するための強力な基盤となることを期待します。
