// Code generated by go-scan for package converter. DO NOT EDIT.

package converter

import (
	"context"
	destination "example.com/convert/sampledata/destination"
	source "example.com/convert/sampledata/source"
)

// ConvertSrcUserToDstUser converts SrcUser to DstUser.
func ConvertSrcUserToDstUser(ctx context.Context, src source.SrcUser) (destination.DstUser, error) {
	dst := convertSrcUserToDstUser(ctx, src)
	return dst, nil
}

// convertSrcUserToDstUser is the internal conversion function.
func convertSrcUserToDstUser(ctx context.Context, src source.SrcUser) destination.DstUser {
	dst := destination.DstUser{}
	if src.Details != nil {
		newSlice := make([]destination.DstInternalDetail, 0, len(src.Details))
		for _, elem := range src.Details {
			newSlice = append(newSlice, convertSrcInternalDetailToDstInternalDetail(ctx, elem))
		}
		dst.Details = newSlice
	}
	dst.CreatedAt = src.CreatedAt
	if src.UpdatedAt != nil {
		dst.UpdatedAt = *src.UpdatedAt
	}
	return dst
}

// ConvertSrcOrderToDstOrder converts SrcOrder to DstOrder.
func ConvertSrcOrderToDstOrder(ctx context.Context, src source.SrcOrder) (destination.DstOrder, error) {
	dst := convertSrcOrderToDstOrder(ctx, src)
	return dst, nil
}

// convertSrcOrderToDstOrder is the internal conversion function.
func convertSrcOrderToDstOrder(ctx context.Context, src source.SrcOrder) destination.DstOrder {
	dst := destination.DstOrder{}
	return dst
}

// ConvertComplexSourceToComplexTarget converts ComplexSource to ComplexTarget.
func ConvertComplexSourceToComplexTarget(ctx context.Context, src source.ComplexSource) (destination.ComplexTarget, error) {
	dst := convertComplexSourceToComplexTarget(ctx, src)
	return dst, nil
}

// convertComplexSourceToComplexTarget is the internal conversion function.
func convertComplexSourceToComplexTarget(ctx context.Context, src source.ComplexSource) destination.ComplexTarget {
	dst := destination.ComplexTarget{}
	dst.Value = src.Value
	if src.Ptr != nil {
		tmp := *src.Ptr
		dst.Ptr = &tmp
	}
	if src.Slice != nil {
		newSlice := make([]destination.SubTarget, 0, len(src.Slice))
		for _, elem := range src.Slice {
			newSlice = append(newSlice, convertSubSourceToSubTarget(ctx, elem))
		}
		dst.Slice = newSlice
	}
	if src.SliceOfPtrs != nil {
		newSlice := make([]*destination.SubTarget, 0, len(src.SliceOfPtrs))
		for _, elem := range src.SliceOfPtrs {
			if elem != nil {
				tmp := convertSubSourceToSubTarget(ctx, *elem)
				newSlice = append(newSlice, &tmp)
			}
		}
		dst.SliceOfPtrs = newSlice
	}
	return dst
}

// ConvertSourceWithMapToTargetWithMap converts SourceWithMap to TargetWithMap.
func ConvertSourceWithMapToTargetWithMap(ctx context.Context, src source.SourceWithMap) (destination.TargetWithMap, error) {
	dst := convertSourceWithMapToTargetWithMap(ctx, src)
	return dst, nil
}

// convertSourceWithMapToTargetWithMap is the internal conversion function.
func convertSourceWithMapToTargetWithMap(ctx context.Context, src source.SourceWithMap) destination.TargetWithMap {
	dst := destination.TargetWithMap{}
	if src.ValueMap != nil {
		newMap := make(map[string]destination.SubTarget, len(src.ValueMap))
		for key, value := range src.ValueMap {
			newMap[key] = convertSubSourceToSubTarget(ctx, value)
		}
		dst.ValueMap = newMap
	}
	if src.PtrMap != nil {
		newMap := make(map[string]*destination.SubTarget, len(src.PtrMap))
		for key, value := range src.PtrMap {
			if value != nil {
				tmp := convertSubSourceToSubTarget(ctx, *value)
				newMap[key] = &tmp
			}
		}
		dst.PtrMap = newMap
	}
	if src.StringToStr != nil {
		newMap := make(map[string]string, len(src.StringToStr))
		for key, value := range src.StringToStr {
			newMap[key] = value
		}
		dst.StringToStr = newMap
	}
	return dst
}
