package generator

import (
	"bytes"
	"context"
	"fmt"
	"log"
	"strings"
	"text/template"

	goscan "github.com/podhmo/go-scan"
	"github.com/podhmo/go-scan/examples/convert/model"
	"github.com/podhmo/go-scan/scanner"
)

const codeTemplate = `
// Code generated by convert. DO NOT EDIT.
package {{ .PackageName }}

import (
	"context"
	"errors"
	"fmt"
	"github.com/podhmo/go-scan/examples/convert/model"
	{{- range $path, $alias := .Imports }}
	{{ $alias }} "{{ $path }}"
	{{- end }}
)

{{ range .Pairs -}}
func convert{{ .SrcType.Name }}To{{ .DstType.Name }}(ctx context.Context, ec *model.ErrorCollector, src *{{ getQualifiedTypeName $.Im .SrcType }}) *{{ getQualifiedTypeName $.Im .DstType }} {
	if src == nil {
		return nil
	}
	{{ range .Pair.Variables -}}
	var {{ .Name }} {{ .Type }}
	{{ end -}}
	dst := &{{ getQualifiedTypeName $.Im .DstType }}{}
	{{ range .Fields -}}
	if ec.MaxErrorsReached() { return dst }
	ec.Enter("{{ .DstName }}")
	{{ getAssignment $.Im $.Info . "src" "dst" "ec" "ctx" -}}
	{{- getValidator $.Im $.Info . "dst" "ec" "ctx" }}
	ec.Leave()
	{{ end -}}
	return dst
}

// Convert{{ .SrcType.Name }}To{{ .DstType.Name }} converts {{ getQualifiedTypeName $.Im .SrcType }} to {{ getQualifiedTypeName $.Im .DstType }}.
func Convert{{ .SrcType.Name }}To{{ .DstType.Name }}(ctx context.Context, src *{{ getQualifiedTypeName $.Im .SrcType }}) (*{{ getQualifiedTypeName $.Im .DstType }}, error) {
	if src == nil {
		return nil, nil
	}
	ec := model.NewErrorCollector({{ .Pair.MaxErrors }})
	dst := convert{{ .SrcType.Name }}To{{ .DstType.Name }}(ctx, ec, src)
	if ec.HasErrors() {
		return dst, errors.Join(ec.Errors()...)
	}
	return dst, nil
}
{{ end }}
`

type TemplateData struct {
	PackageName string
	Imports     map[string]string
	Pairs       []TemplatePair
	Im          *goscan.ImportManager
	Info        *model.ParsedInfo
}

type TemplatePair struct {
	SrcType *model.StructInfo
	DstType *model.StructInfo
	Fields  []FieldMap
	Pair    model.ConversionPair
}

type FieldMap struct {
	SrcName   string
	DstName   string
	Tag       model.ConvertTag
	SrcFieldT *scanner.FieldType
	DstFieldT *scanner.FieldType
}

func Generate(s *goscan.Scanner, info *model.ParsedInfo) ([]byte, error) {
	im := goscan.NewImportManager(&scanner.PackageInfo{ImportPath: info.PackagePath, Name: info.PackageName})
	ctx := context.Background()

	// Pre-register all necessary imports
	for alias, path := range info.Imports {
		im.Add(path, alias)
	}

	worklist := make([]model.ConversionPair, 0, len(info.ConversionPairs))
	processed := make(map[string]bool)
	allPairs := make([]TemplatePair, 0, len(info.ConversionPairs))

	// Initial population from explicit @derivingconvert annotations
	for _, pair := range info.ConversionPairs {
		key := fmt.Sprintf("%s.%s -> %s.%s", pair.SrcTypeInfo.PkgPath, pair.SrcTypeName, pair.DstTypeInfo.PkgPath, pair.DstTypeName)
		if !processed[key] {
			worklist = append(worklist, pair)
			processed[key] = true
		}
	}

	for i := 0; i < len(worklist); i++ {
		pair := worklist[i]

		srcStruct, ok := info.Structs[pair.SrcTypeName]
		if !ok {
			// This can happen if a struct is referenced but not defined in the scanned packages.
			log.Printf("Warning: source struct %q for conversion not found in parsed info, skipping.", pair.SrcTypeName)
			continue
		}
		dstStruct, ok := info.Structs[pair.DstTypeName]
		if !ok {
			log.Printf("Warning: destination struct %q for conversion not found in parsed info, skipping.", pair.DstTypeName)
			continue
		}

		// Register imports for the current pair's types
		for _, field := range srcStruct.Fields {
			registerImports(im, field.FieldType)
		}
		for _, field := range dstStruct.Fields {
			registerImports(im, field.FieldType)
		}

		fieldMaps, err := createFieldMaps(ctx, s, srcStruct, dstStruct)
		if err != nil {
			return nil, fmt.Errorf("creating field maps for %s -> %s: %w", srcStruct.Name, dstStruct.Name, err)
		}

		// Discover new pairs from fields
		for _, fm := range fieldMaps {
			if isStruct(fm.SrcFieldT) && isStruct(fm.DstFieldT) {
				srcFieldType := getUnderlyingStructType(fm.SrcFieldT)
				dstFieldType := getUnderlyingStructType(fm.DstFieldT)

				if srcFieldType.Definition == nil || dstFieldType.Definition == nil {
					log.Printf("Warning: could not resolve definition for field conversion %s -> %s", srcFieldType.Name, dstFieldType.Name)
					continue
				}

				key := fmt.Sprintf("%s.%s -> %s.%s", srcFieldType.Definition.PkgPath, srcFieldType.Name, dstFieldType.Definition.PkgPath, dstFieldType.Name)
				if !processed[key] {
					log.Printf("Discovered required conversion: %s", key)
					newPair := model.ConversionPair{
						SrcTypeName: srcFieldType.Name,
						DstTypeName: dstFieldType.Name,
						SrcTypeInfo: srcFieldType.Definition,
						DstTypeInfo: dstFieldType.Definition,
					}
					worklist = append(worklist, newPair)
					processed[key] = true
				}
			}
		}

		allPairs = append(allPairs, TemplatePair{
			SrcType: srcStruct,
			DstType: dstStruct,
			Fields:  fieldMaps,
			Pair:    pair,
		})
	}

	for _, rule := range info.GlobalRules {
		if rule.SrcTypeInfo != nil {
			im.Qualify(rule.SrcTypeInfo.PkgPath, rule.SrcTypeInfo.Name)
		}
		if rule.DstTypeInfo != nil {
			im.Qualify(rule.DstTypeInfo.PkgPath, rule.DstTypeInfo.Name)
		}
	}

	templateData := TemplateData{
		PackageName: info.PackageName,
		Imports:     im.Imports(),
		Pairs:       allPairs,
		Im:          im,
		Info:        info,
	}

	funcMap := template.FuncMap{
		"getAssignment": func(im *goscan.ImportManager, info *model.ParsedInfo, field FieldMap, srcVar, dstVar, ecVar, ctxVar string) string {
			return getAssignment(im, info, field, srcVar, dstVar, ecVar, ctxVar)
		},
		"getMapKeyAssignment": func(im *goscan.ImportManager, info *model.ParsedInfo, srcVar, dstVar string, srcT, dstT *scanner.FieldType, ecVar, ctxVar string) string {
			return getMapKeyAssignment(im, info, srcVar, dstVar, srcT, dstT, ecVar, ctxVar)
		},
		"getValidator": func(im *goscan.ImportManager, info *model.ParsedInfo, field FieldMap, dstVar, ecVar, ctxVar string) string {
			return getValidator(im, info, field, dstVar, ecVar, ctxVar)
		},
		"getQualifiedTypeName": func(im *goscan.ImportManager, structInfo *model.StructInfo) string {
			if structInfo == nil || structInfo.Type == nil {
				return "invalid"
			}
			// When generating code for a specific package, types within that package don't need qualification.
			if structInfo.Type.PkgPath == info.PackagePath {
				return structInfo.Name
			}
			return im.Qualify(structInfo.Type.PkgPath, structInfo.Name)
		},
	}

	tmpl, err := template.New("converter").Funcs(funcMap).Parse(codeTemplate)
	if err != nil {
		return nil, fmt.Errorf("parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		return nil, fmt.Errorf("executing template: %w", err)
	}
	return buf.Bytes(), nil
}

func createFieldMaps(ctx context.Context, s *goscan.Scanner, src, dst *model.StructInfo) ([]FieldMap, error) {
	var maps []FieldMap
	dstFieldsByName := make(map[string]model.FieldInfo)
	dstFieldsByNormalizedJSONTag := make(map[string]model.FieldInfo)
	dstFieldsByNormalizedName := make(map[string]model.FieldInfo)

	log.Printf("Destination struct: %s", dst.Name)
	for _, f := range dst.Fields {
		dstFieldsByName[f.Name] = f
		if f.JSONTag != "" && f.JSONTag != "-" {
			normalized := normalizeFieldName(f.JSONTag)
			dstFieldsByNormalizedJSONTag[normalized] = f
			log.Printf("  dst field %s, json: %s, normalized json: %s", f.Name, f.JSONTag, normalized)
		}
		normalized := normalizeFieldName(f.Name)
		dstFieldsByNormalizedName[normalized] = f
		log.Printf("  dst field %s, normalized name: %s", f.Name, normalized)
	}

	log.Printf("Source struct: %s", src.Name)
	for _, srcField := range src.Fields {
		_ = resolveFieldType(ctx, srcField.FieldType)
		if srcField.Tag.DstFieldName == "-" {
			log.Printf("  src field %s: skipped by `convert:\"-\"`", srcField.Name)
			continue
		}

		var dstField model.FieldInfo
		var ok bool
		var reason string

		// Priority 1: `convert` tag
		if srcField.Tag.DstFieldName != "" {
			dstField, ok = dstFieldsByName[srcField.Tag.DstFieldName]
			reason = fmt.Sprintf("`convert` tag (%s)", srcField.Tag.DstFieldName)
		}

		// Priority 2: Normalized `json` tag
		if !ok && srcField.JSONTag != "" && srcField.JSONTag != "-" {
			normalizedJSONTag := normalizeFieldName(srcField.JSONTag)
			dstField, ok = dstFieldsByNormalizedJSONTag[normalizedJSONTag]
			reason = fmt.Sprintf("normalized `json` tag (%s -> %s)", srcField.JSONTag, normalizedJSONTag)
		}

		// Priority 3: Normalized field name
		if !ok {
			normalizedSrcName := normalizeFieldName(srcField.Name)
			dstField, ok = dstFieldsByNormalizedName[normalizedSrcName]
			reason = fmt.Sprintf("normalized name (%s -> %s)", srcField.Name, normalizedSrcName)
		}

		if !ok {
			log.Printf("  src field %s: no match found", srcField.Name)
			continue
		}

		log.Printf("  src field %s -> dst field %s (matched by %s)", srcField.Name, dstField.Name, reason)
		_ = resolveFieldType(ctx, dstField.FieldType)
		maps = append(maps, FieldMap{
			SrcName:   srcField.Name,
			DstName:   dstField.Name,
			Tag:       srcField.Tag,
			SrcFieldT: srcField.FieldType,
			DstFieldT: dstField.FieldType,
		})
	}
	return maps, nil
}

func normalizeFieldName(name string) string {
	return strings.ToLower(strings.ReplaceAll(name, "_", ""))
}

func resolveFieldType(ctx context.Context, ft *scanner.FieldType) error {
	if ft == nil {
		return nil
	}
	if _, err := ft.Resolve(ctx, make(map[string]struct{})); err != nil {
		return err
	}
	if ft.Elem != nil {
		if err := resolveFieldType(ctx, ft.Elem); err != nil {
			return fmt.Errorf("resolving element type: %w", err)
		}
	}
	if ft.MapKey != nil {
		if err := resolveFieldType(ctx, ft.MapKey); err != nil {
			return fmt.Errorf("resolving map key type: %w", err)
		}
	}
	return nil
}

// -----------------------------------------------------------------------------
// Validator Logic
// -----------------------------------------------------------------------------

func getValidator(im *goscan.ImportManager, info *model.ParsedInfo, field FieldMap, dstVar, ecVar, ctxVar string) string {
	dstFieldT := field.DstFieldT
	dstFieldTypeName := getFullTypeNameFromFieldType(dstFieldT)
	dst := fmt.Sprintf("%s.%s", dstVar, field.DstName)

	for _, rule := range info.GlobalRules {
		if rule.ValidatorFunc == "" {
			continue
		}

		ruleDstName := getFullTypeNameFromTypeInfo(rule.DstTypeInfo)
		if ruleDstName == dstFieldTypeName {
			funcName := qualifyFunc(im, info, rule.ValidatorFunc)
			return fmt.Sprintf("%s(%s, %s)", funcName, ecVar, dst)
		}
	}
	return ""
}

func qualifyFunc(im *goscan.ImportManager, info *model.ParsedInfo, funcName string) string {
	parts := strings.Split(funcName, ".")
	if len(parts) != 2 {
		return funcName // Not a qualified function name, assume it's in the current package
	}
	alias, name := parts[0], parts[1]
	path, ok := info.Imports[alias]
	if !ok {
		// If the alias is not in our explicit import list, it might be a standard import
		// from the file itself. The import manager might know about it.
		// However, the current import manager API doesn't provide a direct way to get a path from an alias.
		// We'll assume for now that any qualified function must be from an explicit `// convert:import`.
		log.Printf("Warning: could not find import path for alias %q in function %q", alias, funcName)
		return funcName // Return as is, might fail compilation but gives a hint.
	}
	// Use the import manager to get the final, possibly-aliased name for the package
	return im.Qualify(path, name)
}

func registerImports(im *goscan.ImportManager, t *scanner.FieldType) {
	if t == nil {
		return
	}
	im.Qualify(t.FullImportPath, t.Name)
	if t.Elem != nil {
		registerImports(im, t.Elem)
	}
	if t.MapKey != nil {
		registerImports(im, t.MapKey)
	}
	for _, arg := range t.TypeArgs {
		registerImports(im, arg)
	}
}

// -----------------------------------------------------------------------------
// Assignment Logic
// -----------------------------------------------------------------------------

func getMapKeyAssignment(im *goscan.ImportManager, info *model.ParsedInfo, srcVar, dstVar string, srcT, dstT *scanner.FieldType, ecVar, ctxVar string) string {
	// Global conversion rule
	srcFieldTypeName := getFullTypeNameFromTypeInfo(srcT.Definition)
	dstFieldTypeName := getFullTypeNameFromTypeInfo(dstT.Definition)

	for _, rule := range info.GlobalRules {
		ruleSrcName := getFullTypeNameFromTypeInfo(rule.SrcTypeInfo)
		ruleDstName := getFullTypeNameFromTypeInfo(rule.DstTypeInfo)

		if ruleSrcName == srcFieldTypeName && ruleDstName == dstFieldTypeName {
			funcName := qualifyFunc(im, info, rule.UsingFunc)
			if dstVar != "" {
				return fmt.Sprintf("%s = %s(%s, %s, %s)", dstVar, funcName, ctxVar, ecVar, srcVar)
			}
			return fmt.Sprintf("%s(%s, %s, %s)", funcName, ctxVar, ecVar, srcVar)
		}
	}
	return generateConversion(im, info, srcVar, dstVar, srcT, dstT, 0, ecVar, ctxVar)
}

func getAssignment(im *goscan.ImportManager, info *model.ParsedInfo, field FieldMap, srcVar, dstVar, ecVar, ctxVar string) string {
	src := fmt.Sprintf("%s.%s", srcVar, field.SrcName)
	dst := fmt.Sprintf("%s.%s", dstVar, field.DstName)

	// Priority 1: Field-level using tag
	if field.Tag.UsingFunc != "" {
		funcName := qualifyFunc(im, info, field.Tag.UsingFunc)
		return fmt.Sprintf("%s = %s(%s, %s, %s)", dst, funcName, ctxVar, ecVar, src)
	}

	// Priority 2: Global conversion rule
	srcFieldTypeName := getFullTypeNameFromTypeInfo(field.SrcFieldT.Definition)
	dstFieldTypeName := getFullTypeNameFromTypeInfo(field.DstFieldT.Definition)

	for _, rule := range info.GlobalRules {
		ruleSrcName := getFullTypeNameFromTypeInfo(rule.SrcTypeInfo)
		ruleDstName := getFullTypeNameFromTypeInfo(rule.DstTypeInfo)

		if ruleSrcName == srcFieldTypeName && ruleDstName == dstFieldTypeName {
			funcName := qualifyFunc(im, info, rule.UsingFunc)
			return fmt.Sprintf("%s = %s(%s, %s, %s)", dst, funcName, ctxVar, ecVar, src)
		}
	}

	if field.Tag.Required && field.SrcFieldT.IsPointer {
		return fmt.Sprintf("if %s == nil {\n\t%s.Add(fmt.Errorf(\"%s is required\"))\n} else {\n\t%s\n}", src, ecVar, field.SrcName, generateConversion(im, info, src, dst, field.SrcFieldT, field.DstFieldT, 0, ecVar, ctxVar))
	}

	// Priority 3: Default conversion logic
	return generateConversion(im, info, src, dst, field.SrcFieldT, field.DstFieldT, 0, ecVar, ctxVar)
}

func generateConversion(im *goscan.ImportManager, info *model.ParsedInfo, src, dst string, srcT, dstT *scanner.FieldType, depth int, ecVar, ctxVar string) string {
	// Global conversion rule
	srcFieldTypeName := getFullTypeNameFromTypeInfo(srcT.Definition)
	dstFieldTypeName := getFullTypeNameFromTypeInfo(dstT.Definition)

	log.Printf("generateConversion: src=%q, dst=%q", srcFieldTypeName, dstFieldTypeName)
	for _, rule := range info.GlobalRules {
		ruleSrcName := getFullTypeNameFromTypeInfo(rule.SrcTypeInfo)
		ruleDstName := getFullTypeNameFromTypeInfo(rule.DstTypeInfo)
		log.Printf("  checking rule: src=%q, dst=%q", ruleSrcName, ruleDstName)
		if ruleSrcName == srcFieldTypeName && ruleDstName == dstFieldTypeName {
			log.Printf("  rule matched!")
			if dst != "" {
				return fmt.Sprintf("%s = %s(%s, %s)", dst, rule.UsingFunc, ctxVar, src)
			}
			return fmt.Sprintf("%s(%s, %s)", rule.UsingFunc, ctxVar, src)
		}
	}

	if srcT == nil || dstT == nil {
		return fmt.Sprintf("// srcT or dstT is nil for %s -> %s", src, dst)
	}

	// Pointer to Pointer
	if srcT.IsPointer && dstT.IsPointer {
		if srcT.Elem == nil || dstT.Elem == nil {
			// This is the path taken when the scanner fails to populate Elem for a pointer.
			// We can work around this by checking if the type name corresponds to a known struct.
			if _, ok := info.Structs[srcT.Name]; ok {
				// It's a known struct, so we can generate the recursive conversion call.
				// The helper function `convert<SrcName>To<DstName>` handles the nil check.
				return fmt.Sprintf("convert%sTo%s(%s, %s, %s)", srcT.Name, dstT.Name, ctxVar, ecVar, src)
			}

			// Not a known struct, so fallback to simple assignment.
			if dst != "" {
				return fmt.Sprintf("%s = %s", dst, src)
			}
			return src
		}

		// This is the original logic for when Elem is correctly populated.
		var b strings.Builder
		b.WriteString(fmt.Sprintf("if %s != nil {\n", src))
		b.WriteString(fmt.Sprintf("\ttmp := %s\n", generateConversion(im, info, "(*"+src+")", "", srcT.Elem, dstT.Elem, depth+1, ecVar, ctxVar)))
		if dst != "" {
			b.WriteString(fmt.Sprintf("\t%s = &tmp\n", dst))
		} else {
			b.WriteString(fmt.Sprintf("\treturn &tmp\n"))
		}
		b.WriteString("} else {\n")
		if dst != "" {
			b.WriteString(fmt.Sprintf("\t%s = nil\n", dst))
		} else {
			b.WriteString(fmt.Sprintf("\treturn nil\n"))
		}
		b.WriteString("}")
		return b.String()
	}
	// Pointer to Value
	if srcT.IsPointer && !dstT.IsPointer {
		if srcT.Elem == nil {
			return fmt.Sprintf("// Cannot convert pointer to value, element type is nil")
		}
		return fmt.Sprintf("if %s != nil {\n\t%s\n}", src, generateConversion(im, info, "(*"+src+")", dst, srcT.Elem, dstT, depth+1, ecVar, ctxVar))
	}
	// Value to Pointer
	if !srcT.IsPointer && dstT.IsPointer {
		if dstT.Elem == nil {
			return fmt.Sprintf("// Cannot convert value to pointer, element type is nil")
		}
		var b strings.Builder
		b.WriteString("{\n")
		b.WriteString(fmt.Sprintf("\ttmp := %s\n", generateConversion(im, info, src, "", srcT, dstT.Elem, depth+1, ecVar, ctxVar)))
		if dst != "" {
			b.WriteString(fmt.Sprintf("\t%s = &tmp\n", dst))
		} else {
			b.WriteString(fmt.Sprintf("\treturn &tmp\n"))
		}
		b.WriteString("}")
		return b.String()
	}

	// Slices
	if srcT.IsSlice && dstT.IsSlice {
		sliceConversion := generateSliceConversion(im, info, src, "", srcT, dstT, depth, ecVar, ctxVar)
		if dst != "" {
			return fmt.Sprintf("%s = %s", dst, sliceConversion)
		}
		return sliceConversion
	}

	// Maps
	if srcT.IsMap && dstT.IsMap {
		mapConversion := generateMapConversion(im, info, src, "", srcT, dstT, depth, ecVar, ctxVar)
		if dst != "" {
			return fmt.Sprintf("%s = %s", dst, mapConversion)
		}
		return mapConversion
	}

	// Structs
	if isStruct(srcT) && isStruct(dstT) && srcT.Name != "" && dstT.Name != "" {
		// This should be a pointer type, but we handle both cases.
		srcPtr := src
		if !srcT.IsPointer {
			srcPtr = "&" + src
		}
		conversion := fmt.Sprintf("*convert%sTo%s(%s, %s, %s)", srcT.Name, dstT.Name, ctxVar, ecVar, srcPtr)
		if dst != "" {
			return fmt.Sprintf("%s = %s", dst, conversion)
		}
		return conversion
	}

	// Basic assignment
	if dst != "" {
		return fmt.Sprintf("%s = %s", dst, src)
	}
	return src
}

func generateSliceConversion(im *goscan.ImportManager, info *model.ParsedInfo, src, dst string, srcT, dstT *scanner.FieldType, depth int, ecVar, ctxVar string) string {
	if srcT.Elem == nil || dstT.Elem == nil {
		return ""
	}

	var b strings.Builder
	b.WriteString(fmt.Sprintf("func() []%s {\n", getTypeName(im, dstT.Elem)))
	b.WriteString(fmt.Sprintf("\tconvertedSlice := make([]%s, len(%s))\n", getTypeName(im, dstT.Elem), src))
	b.WriteString(fmt.Sprintf("\tfor i, item := range %s {\n", src))
	b.WriteString("\t\t" + ecVar + ".Enter(fmt.Sprintf(\"[%d]\", i))\n")
	b.WriteString(fmt.Sprintf("\t\tconvertedSlice[i] = %s\n", generateConversion(im, info, "item", "", srcT.Elem, dstT.Elem, depth+2, ecVar, ctxVar)))
	b.WriteString("\t\t" + ecVar + ".Leave()\n")
	b.WriteString(fmt.Sprintf("\t}\n"))
	b.WriteString(fmt.Sprintf("\treturn convertedSlice\n"))
	b.WriteString(fmt.Sprintf("}()"))
	return b.String()
}

func generateMapConversion(im *goscan.ImportManager, info *model.ParsedInfo, src, dst string, srcT, dstT *scanner.FieldType, depth int, ecVar, ctxVar string) string {
	if srcT.MapKey == nil || srcT.Elem == nil || dstT.MapKey == nil || dstT.Elem == nil {
		return ""
	}

	var b strings.Builder
	b.WriteString(fmt.Sprintf("func() map[%s]%s {\n", getTypeName(im, dstT.MapKey), getTypeName(im, dstT.Elem)))
	b.WriteString(fmt.Sprintf("\tconvertedMap := make(map[%s]%s, len(%s))\n", getTypeName(im, dstT.MapKey), getTypeName(im, dstT.Elem), src))
	b.WriteString(fmt.Sprintf("\tfor key, value := range %s {\n", src))

	b.WriteString("\t\t" + ecVar + ".Enter(fmt.Sprintf(\"[%v]\", key))\n")
	keyExpr := "key"
	if getFullTypeNameFromTypeInfo(srcT.MapKey.Definition) != getFullTypeNameFromTypeInfo(dstT.MapKey.Definition) {
		keyExpr = getMapKeyAssignment(im, info, "key", "", srcT.MapKey, dstT.MapKey, ecVar, ctxVar)
	}
	b.WriteString(fmt.Sprintf("\t\tconvertedMap[%s] = %s\n",
		keyExpr,
		generateConversion(im, info, "value", "", srcT.Elem, dstT.Elem, depth+2, ecVar, ctxVar)))
	b.WriteString("\t\t" + ecVar + ".Leave()\n")
	b.WriteString(fmt.Sprintf("\t}\n"))
	b.WriteString(fmt.Sprintf("\treturn convertedMap\n"))
	b.WriteString(fmt.Sprintf("}()"))
	return b.String()
}

func getTypeName(im *goscan.ImportManager, t *scanner.FieldType) string {
	if t == nil {
		return "interface{}" // Should not happen in valid code
	}

	var sb strings.Builder

	if t.IsPointer {
		sb.WriteString("*")
		// The scanner might fail to populate Elem for a pointer type.
		// In that case, the type name is on the pointer FieldType itself.
		// If Elem is populated, recurse. Otherwise, use the current type's name.
		if t.Elem != nil {
			sb.WriteString(getTypeName(im, t.Elem))
		} else {
			// This is the fallback for when Elem is nil. The type name is on the pointer itself.
			// We just need to qualify it. This assumes no further nesting like *[]T.
			// A more robust scanner would populate Elem correctly.
			sb.WriteString(im.Qualify(t.FullImportPath, t.Name))
		}
		return sb.String()
	}

	if t.IsSlice {
		sb.WriteString("[]")
		sb.WriteString(getTypeName(im, t.Elem)) // Recurse, will be caught by t == nil if Elem is nil
		return sb.String()
	}

	if t.IsMap {
		keyType := getTypeName(im, t.MapKey)
		valType := getTypeName(im, t.Elem)
		return fmt.Sprintf("map[%s]%s", keyType, valType)
	}

	// Base case: a named type
	return im.Qualify(t.FullImportPath, t.Name)
}

func isStruct(t *scanner.FieldType) bool {
	if t == nil {
		return false
	}
	if t.IsPointer {
		if t.Elem == nil {
			return false
		}
		return isStruct(t.Elem)
	}
	// A struct that needs a recursive conversion is one defined in the scanned code,
	// not one provided by an override.
	return t.Definition != nil && t.Definition.Kind == scanner.StructKind && !t.IsResolvedByConfig
}

func getUnderlyingStructType(t *scanner.FieldType) *scanner.FieldType {
	if t == nil {
		return nil
	}
	if t.IsPointer {
		return getUnderlyingStructType(t.Elem)
	}
	return t
}

func getFullTypeNameFromFieldType(ft *scanner.FieldType) string {
	if ft == nil {
		return ""
	}
	if ft.Definition != nil {
		return getFullTypeNameFromTypeInfo(ft.Definition)
	}
	if ft.IsPointer {
		return "*" + getFullTypeNameFromFieldType(ft.Elem)
	}
	// This is a fallback for basic types or unresolved types.
	return ft.Name
}

func getFullTypeNameFromTypeInfo(t *scanner.TypeInfo) string {
	if t == nil {
		return ""
	}
	if t.PkgPath != "" {
		// For external packages, PkgPath is the full import path.
		// For the current package, it's also the full import path.
		return fmt.Sprintf("%s.%s", t.PkgPath, t.Name)
	}
	if t.Name != "" {
		// This handles built-in types like "string", "int", etc.
		return t.Name
	}
	if t.Underlying != nil && t.Underlying.Definition != nil {
		return getFullTypeNameFromTypeInfo(t.Underlying.Definition)
	}
	if t.Underlying != nil {
		return t.Underlying.Name
	}
	return ""
}
