# `examples/minigo` から見る `go-scan` への期待

`examples/minigo` は、`github.com/podhmo/go-scan` ライブラリの能力を実証しテストするために設計された、小規模なGoインタープリタです。この `minigo` の実装や将来的な拡張を考察する中で、`go-scan` パッケージに期待される機能や、現状の `go-scan` がどのように役立ちうるか、またどのような点が補強されるとより便利になるかが見えてきます。

## `go-scan` に期待される便利な機能（`minigo` のコンテキストより）

`minigo` のようなツールを開発する際、`go-scan` が以下のような機能を提供することで、開発が大幅に効率化されると考えられます。

1.  **ASTノードとソースコード位置情報の詳細なマッピングとリッチなAPI提供**:
    *   **現状**: `minigo` の `interpreter.go` 内 `formatErrorWithContext` 関数では、エラー発生箇所のファイル名、行番号、列番号、該当行のソースコードを取得し、ユーザーフレンドリーなエラーメッセージを生成しようとしています。これは `go/token.FileSet` を直接操作することで実現されています。
    *   **期待**: `go-scan` がASTノード（または `token.Pos`）と、それに対応するファイル名、行番号、列番号、さらには該当行や周辺のソーススニペットを簡単に取得できる高レベルAPIを提供することで、エラーレポート処理の実装が簡潔かつ堅牢になります。例えば、`scanner.NodeInfo(node ast.Node)` のような形で詳細情報オブジェクトを取得できると便利です。

2.  **型情報の高度な解決と検証支援**:
    *   **現状**: `minigo` は独自の動的型システム (`object.go` の `Object` インターフェースと各種具象型) を持ちますが、これはGo言語の型システムとは独立しています。
    *   **期待**: `minigo` が将来的にGoの型システム（特にユーザー定義型やインターフェース、パッケージ外部の型など）をより深く理解し、静的解析に近いチェックを行おうとする場合、`go-scan` の型情報抽出・解決能力が重要になります。`README.md` で言及されている `scanner.FieldType.Resolve()` や `PackageResolver` のような、パッケージを跨いだ型定義の遅延読み込みと解決メカニズムは、`minigo` が外部のGoコードや他の `minigo` モジュールで定義された「型」や「関数シグネチャ」を理解する際に非常に強力な基盤となり得ます。

3.  **シンボルテーブル構築とスコープ解析の支援**:
    *   **現状**: `minigo` の `environment.go` では、変数や（将来的には）関数のスコープを管理するための `Environment` 構造体を定義し、手動でシンボルの登録と検索を行っています。
    *   **期待**: `go-scan` がソースコードから識別子（変数名、関数名、型名など）の定義箇所 (declaration) と参照箇所 (usage) を効率的に抽出し、それらの間のスコープ関係（例: この識別子はこのブロックで定義されている、この識別子は見つからない、など）を分析する機能を提供すれば、インタープリタの変数解決ロジック、未定義変数エラーの検出、シャドーイングの警告などが容易に実装できます。

4.  **組み込み関数・外部パッケージ関数のシグネチャ分析**:
    *   **現状**: `builtin_fmt.go` や `builtin_strings.go` では、Goの標準パッケージ `fmt` や `strings` の一部関数を模倣し、`minigo` のオブジェクトシステムに手動でマッピングしています。引数の数や型のチェックも手動です。
    *   **期待**: `go-scan` を利用して、実際のGoの `fmt` や `strings` パッケージ（あるいは他の任意のGoパッケージ）の関数シグネチャ（引数の数、型、名前、可変長引数か否か、戻り値の型など）を正確に解析できると、`minigo` 側の組み込み関数の定義、呼び出し時の引数チェック、型変換ロジックなどを半自動的に生成したり、検証したりするツールを構築できます。これにより、組み込み関数の実装漏れやシグネチャの不一致といったバグを減らせます。

5.  **ASTの探索、解析、変換ユーティリティ**:
    *   **現状**: `minigo` のインタープリタは、`ast.Node` の型スイッチを多用してASTを再帰的にトラバースし、各ノードを評価しています。
    *   **期待**: `go-scan` が、ASTに対するより高度なクエリ言語や探索ユーティリティ（例: XPath for AST、CSSセレクタライクなクエリ、特定の条件を満たすノードをvisitorパターンよりも簡潔に抽出する機能）、あるいはAST変換を支援する機能（例: 特定パターンのノードを別のノードに安全に置換するヘルパー）を提供すると、インタープリタや静的解析ツールのロジック記述が大幅に簡略化され、可読性も向上します。

## `minigo` の現状から見る `go-scan` の潜在的な使用感

`minigo` は現在、`go/parser` を直接利用してASTを構築しており、`go-scan` の機能は間接的な示唆に留まっています。しかし、`minigo` の `README.md` で強調されている `go-scan` のコア機能（ASTベース解析、型情報抽出、ドキュメンテーション解析、クロスパッケージ型解決、パッケージロケータ）は、`minigo` が以下のようなより高度な機能を志向する際に、その価値を発揮するでしょう。

*   **より洗練されたエラー報告**: 現在の `formatErrorWithContext` は良い出発点ですが、`go-scan` の詳細な位置情報や型情報を活用することで、エラーメッセージをさらに具体的かつ有用なものにできます（例: 「型 'int' と 'string' の間で演算子 '+' は定義されていません (file.go:10:5)」）。
*   **限定的な静的解析機能**: 変数の未定義チェック、型チェック（可能な範囲で）、到達不能コードの検出など。
*   **モジュールシステム**: 複数の `minigo` ファイルや外部ライブラリ（に見立てたGoコード）を組み合わせて解釈実行する際の依存関係解決やシンボル管理。

## `minigo` の開発を通じて `go-scan` に求められるかもしれない機能（不足部分・強化点）

`minigo` のようなプロジェクトをさらに発展させることを考えると、`go-scan` には以下のような機能や改善があると、より強力なサポートツールとなり得ます。

1.  **トークンレベルでの精密なエラー位置特定と関連情報**:
    *   行単位だけでなく、式の中のどのトークン（またはトークン範囲）が問題の原因であるかを特定できると、エラーメッセージの質が向上します。例えば、`a + b * c` という式で型エラーがある場合、`+` なのか `*` なのか、あるいは特定の変数なのかを指し示せると理想的です。

2.  **スコープ解決とシンボル解決の高度なユーティリティ**:
    *   識別子がどのスコープで定義され、どこから可視であるか、シャドーイングが発生しているかなどの情報を、AST（またはファイルセット）から直接解決してくれるユーティリティ。これにより、`minigo` の `Environment` のような機構のロジックを一部肩代わりできます。

3.  **制御フローグラフ (CFG) / データフロー分析 (DFA) の基礎情報提供**:
    *   より高度な静的解析（未使用変数、到達不能コードなど）や最適化を行うためには、基本的なCFGやDFAの情報が必要になります。`go-scan` がこれらを構築するための部品や情報を提供できると、応用範囲が広がります。

4.  **インクリメンタルスキャン / パーシャルスキャンへの対応**:
    *   特にREPL環境や大規模プロジェクトでの利用を考えると、変更があったファイルや部分だけを効率的に再スキャンし、既存のスキャン結果とマージする機能は非常に価値があります。これにより、フィードバックループを高速化できます。

5.  **GoDocコメントの構造化された解析**:
    *   型定義、関数定義、フィールド定義などに付随するGoDocコメントを、単なる文字列としてだけでなく、構造化された情報（例: `@param`, `@return` タグの解析、説明文本体の抽出）としてアクセスできるAPIがあると、ドキュメント生成ツールや、コメントベースのメタプログラミング支援に役立ちます。

6.  **`go:generate` やビルドタグのようなディレクティブの認識**:
    *   Goのソースコードに含まれる特別なコメントディレクティブ（`//go:generate ...` や `// +build ...`）を認識し、それらの情報をスキャン結果に含めることで、コード生成プロセスや条件付きコンパイルのシミュレーションに利用できる可能性があります。

`minigo` は `go-scan` の可能性を示す一例に過ぎませんが、このような具体的なアプリケーションの視点から `go-scan` の機能セットを拡充していくことで、より多くの開発者にとって価値のあるライブラリへと成長していくことが期待されます。
